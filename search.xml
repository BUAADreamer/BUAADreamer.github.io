<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2022软工出发-阅读和调研-构建之法与CICD与版本管理</title>
      <link href="2022/03/05/SE%E9%9B%86%E7%BB%93%E5%8F%B7-%E9%98%85%E8%AF%BB%E5%92%8C%E8%B0%83%E7%A0%94/"/>
      <url>2022/03/05/SE%E9%9B%86%E7%BB%93%E5%8F%B7-%E9%98%85%E8%AF%BB%E5%92%8C%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<div class="table-container"><table><thead><tr><th>项目</th><th>内容</th></tr></thead><tbody><tr><td>这个作业属于哪个课程</td><td><a href="https://bbs.csdn.net/forums/BH-SE" target="_blank" rel="noopener">2022春季软件工程（罗杰 任健）</a></td></tr><tr><td>这个作业的要求在哪里</td><td><a href="https://bbs.csdn.net/topics/605073900" target="_blank" rel="noopener">个人阅读作业</a></td></tr><tr><td>我在这个课程的目标是</td><td>学习软工的项目合作管理知识，提升软件开发技术</td></tr><tr><td>这个作业在哪个具体方面帮助我实现目标</td><td>通过《构建之法》理解软工，动手实践各种平台比较CI/CD</td></tr></tbody></table></div><h1><span id="begin-of-se">Begin of SE</span></h1><p>作为一个在北航计算机学院摸爬滚打的普通学生，由于6系丰富的资源，笔者接触了一些软件项目，包括OO课程网站维护，学者数据爬取平台，航送app，数据库的电商平台等等，还有一些网站小程序等等，然而做了这些项目之后，自己的实际项目管理和软件素养并没有得到完全显著的提升，原因一个是要么网站过于复杂仅仅是维护和更新部分代码，要么就是课程或者项目用完即扔。这也是我最终选择敏捷开发课程的原因，希望能够在大三下这个最后的黄金学习时间，向老师和助教以及同学们学习到尽可能多的具体技术和软件开发、项目管理的思想方法，让自己的开发和团队协作能力都上一个档次，软工，我来了！！！</p><h1><span id="构建之法阅读提问">《构建之法》阅读提问</span></h1><h2><span id="阅读中记录的琐碎疑问">阅读中记录的琐碎疑问</span></h2><p>看的过程随手记录了一些不成形的问题，选择了几个进行深究，其他的就留存于此作为记录</p><ul><li>没有银弹未来是否可有实现？现在有低代码平台等等</li><li>P47 团队对个人期望，专业人士不需要灵感与激情？</li><li>P80 结对编程的要求，似乎有点过于拘束死板？</li><li>P85-86 的中间层和最内层的例子中的表述似乎都相当负面且情绪化，为什么这两个就不能有一些柔和的处理以及表达呢？</li><li>P116 scrum对团队人员的要求 PM vs Scrum leader ? ?</li><li>敏捷开发不了AI算法软件或者技术背景强的软件？？ P121</li><li>P159 人类学调查 走到真实世界会不会太泛泛而谈了，实际的生活我们到底应该以什么样的方式和频率介入哪些生活？</li><li>P184 有没有可能借鉴去中心化网络架构ring AllReduce，即两个人之间进行交流，并将他们组成环？</li><li>P357 赢者通吃 如何看待如今的天猫京东拼多多 以及美团外卖和饿了吗？</li><li>P371 当下的低代码平台或者云速建站服务也只需要很少的代码 似乎与只能手工相悖？</li></ul><h2><span id="1专业软件开发师仅需要按照流程理性地工作">1.专业软件开发师仅需要按照流程理性地工作？</span></h2><h3><span id="原文">原文</span></h3><p>内容参见原书第3章 P47-48</p><blockquote><p>理性地工作∶软件开发有很多个人的、感情驱动的因素，但是一个成熟的团队成员必 须从事实和数据出发，按照流程，理性地工作。很多人认为自己需要灵感和激情，才能为宏大的目标奋斗，才能成为专业人士。著名的艺术家 Chuck Close 说∶“ 我总觉得 灵感是属于业余爱好者的。我们职业人士只是每天持续工作。今天你继续昨天的工作，明天你继续今天的工作，最终你会有所成就 ”</p></blockquote><h3><span id="问题">问题</span></h3><ul><li>仅仅按部就班地理性工作，真的能保证大部分工程师有所成就吗？</li></ul><h3><span id="解释">解释</span></h3><ul><li>个人认为对于著名的艺术家或者成功人士来说，他们本身就已经具有了很高的天赋或者很高的热情，因此对他们来说，也许只要按部就班进行工作就已经可以完成很高质量的代码，但是对于一般的工程师来说，每天重复差不多低质量的工作，没有任何激情和推动，可能最后只能带来较低质量的产品。而且对于一些重大复杂的算法问题或者架构问题，很多时候依赖于突发奇想或者灵机一动，如果单纯仅仅是机械做一样的工作，能解决这样的问题吗？同时这样的工作模式也很难催生新的问题发现和技术创新</li><li>因此这一点我个人认为更适合的是大多时候理性，但该有激情的时候需要热情投入。</li></ul><h2><span id="2结对编程能更加灵活吗">2.结对编程能更加灵活吗？</span></h2><h3><span id="原文">原文</span></h3><p>内容参见原书第3章 P81</p><blockquote><p>4.5.4 如何结对编程</p><p> 1. 驾驶员∶写设计文档，进行编码和单元测试等 XP开发流程。<br> 2.  领航员∶审阅驾驶员的文档;监督驾驶员对编码等开发流程的执行;考虑单元测试的覆盖 率;思考是否需要和如何重构;帮助驾驶员解决具体的技术问题。领航员也可以设计TDD中的测试用例。<br> 3. 驾驶员和领航员不断轮换角色，不要连续工作超过一小时，每工作一小时休息 15分钟。 领航员要控制时间。 <br> 4. 主动参与。任何一个任务都首先是两个人的责任，也是所有人的责任。 <br> 5. 只有水平上的差距，没有级别上的差异。两人结对，尽管可能大家的级别资历不同，但不 管在分析、设计或编码上，双方都拥有平等的决策权利。 <br> 6. 设置好结对编程的环境，座位、显示器、桌面等都要能允许两个人舒适地讨论和工作。如 果是通过远程结对编程，那么网络、语音通讯和屏幕共享程序要设置好。</p></blockquote><h3><span id="问题">问题</span></h3><ul><li>能否有两个人先讨论好然后再一起写不同模块或者同一个文件中不同代码，之后再互相测试？</li><li>形式能否更加灵活？</li></ul><h3><span id="解释">解释</span></h3><ul><li>原文中的结对编程描述貌似必须有一个人是领航，一个人是驾驶，但是事实上对于太复杂的需求，驾驶员在写代码的时候被监视就好比是面试中做算法题一样难受，甚至发挥失常（虽然这个和人的心理素质和代码能力密不可分）。而面对过于简单的需求，大部分时候不太需要领航员一直检查和review或者帮助理解文档，这个时候领航员似乎就无所事事了</li><li>结对编程能不能采用两个人先一起研究需求，并行编程，写微小的模块，之后一起检查测试代码的模式？这样似乎也可以提高效率，而且每个人负责的微小部分代码更精细，同时两个人互相测试也能测试效率更高。</li></ul><h2><span id="3团队的强弱与scrum">3.团队的强弱与scrum</span></h2><h3><span id="原文">原文</span></h3><p>内容参见原书第6章P116页</p><blockquote><p>如果你的团队很弱，那么强行把敏捷（或者其他高级方法）套在上面也没有用，也许还会适得其反，往往需要经历多次失败/总结/改进的过程才能让 Scrum 走上正轨。换句话说，如果你的团队已经有这么厉害（自主管理、自我组织、多功能型）的一帮人，那么用不用 Scrum 都能写好软件!</p></blockquote><h3><span id="问题">问题</span></h3><ul><li>如何衡量一个团队的强弱？从技术角度还是从努力角度还是综合起来？如果是参差不齐的队伍呢？</li><li>强大的个人组合成的队伍就不需要scrum来开发软件了吗？</li></ul><h3><span id="解释">解释</span></h3><ul><li>首先这里的团队的强弱本身是一个很主观而且很难给出答案的定义。比如一个队伍可能每个人技术上都很强，甚至每个人都做过全栈开发。但是他们的团队合作能力和意识不一定好，以及可能有些人在这次开发中与团队愿景不一致，那又如何定义这样的队伍的强弱呢？同时一个队伍可能技术比较平均甚至平庸，但每个人的学习能力较强，愿景类似，而且能投入的精力都很多，那这个团队是强还是弱呢。同时参差不齐的队伍又该如何计算？个人认为大多数队伍都可以实现scrum，只是可能对于不同队伍，目标和具体细节做出相应改动罢了。</li><li>假设已经满足了作者关于强的team的定义，那这个scrum流程就不需要了，那大家敏捷开发就一锅乱炖，看心情来完成代码吗？显然不太合理吧，所以要么有相应的简化处理，要么就换一种方法论，但显然似乎也不是完全不需要scrum了</li></ul><h2><span id="4敏捷仅仅适用于简单的应用">4.敏捷仅仅适用于简单的应用？</span></h2><h3><span id="原文">原文</span></h3><p>内容参见原书第6章P121页表6-3</p><blockquote><p><img src="/2022/03/05/SE%E9%9B%86%E7%BB%93%E5%8F%B7-%E9%98%85%E8%AF%BB%E5%92%8C%E8%B0%83%E7%A0%94/8.png" style="zoom: 50%;"></p></blockquote><h3><span id="问题">问题</span></h3><ul><li>只有简单的变化多的网站适合敏捷，而复杂且稳定软件就不适合甚至不需要吗？</li></ul><h3><span id="解释">解释</span></h3><ul><li>当下的很多项目都需要开发者在短时间内开发集成了众多AI算法且质量很高的软件，这时候如果不使用敏捷思想的话难道需要磨洋工吗，显然也不太可能。这个时候如果单纯用本书提到的scrum不行的话，能不能采用相似的或者以本书的敏捷方法为内核的稍加修改后的方法呢？笔者认为可以分配更多的角色，比如算法工程师，模型部署测试等角色来扩充现有的模型。</li><li>像开发底层正则表达式解析模块其实也需要不断做测试以及迅速交付，如果恰恰有项目需要做一个底层的库而用户还需要定期检查呢？那似乎这个时候敏捷也没什么不好。而且很多bug都必须在真实的大量场景测试才能找到问题</li></ul><h2><span id="5人类学调查的具体方式">5.人类学调查的具体方式？</span></h2><h3><span id="原文">原文</span></h3><p>内容参见原书P158-159</p><blockquote><p>大学生们如果能暂时放下自己所学的许多高端技术，走到真实的世界中去，也许会看到并理解来自普通用户的真实需求</p></blockquote><h3><span id="问题">问题</span></h3><ul><li>真实世界这么大，我们该走到哪，走多深呢？</li></ul><h3><span id="解释">解释</span></h3><ul><li>很多时候我们进入生活就迷茫了，这么大的世界，随便走走就眼花缭乱了，具体的真实需求可能就找不到了。具体操作时似乎不能泛泛的撒网了解真实世界，而是寻找其中的若干个有意思的点深入挖掘探索才会更有效率一些。而具体应该探索哪些行业，做哪些具体的事情呢？我个人认为最好的方式是和真实世界中的用户或者客户直接对话或者体验他们的应用场景，这样似乎比出去走走要更加具体实在一些。</li></ul><h2><span id="6赢者真的能通吃吗">6.赢者真的能通吃吗？</span></h2><h3><span id="原文">原文</span></h3><p>内容参见原书P357</p><blockquote><p>赢者通吃 这个游戏规定第一名得到全部的分数，第二名（不管多接近）到倒数第二名都是0分，最后一名还要倒扣分。软件行业就是一个赢者通吃的环境，最后一名还要把自己的身家倒贴进去。</p></blockquote><h3><span id="问题">问题</span></h3><ul><li>软件行业赢家真的可以通吃吗？</li></ul><h3><span id="解释">解释</span></h3><ul><li>比如：360vs电脑管家vs鲁大师，饿了吗vs美团外卖，腾讯视频vs爱奇艺vs优酷，至今都没有分出胜负，而最近的统计似乎也显示这些公司互有胜负，所以赢者通吃这种说法似乎有待商榷，这个游戏的合理性似乎也需要讨论。似乎很多时候并不能做到作者说的赢家通吃。</li></ul><h2><span id="7手工写代码和银弹">7.手工写代码和银弹</span></h2><h3><span id="原文">原文</span></h3><p>内容参见原书P371</p><blockquote><p>一些人士批评”很多企业还处于手工式的开发生产阶段”，我不知道软件除了用手工，还可以用什么别的来写。也许有人说，是不是那些CASE（Computer Aided Software Engineering》工具，或者是代码向导（Code Wizard），用右键一点，然后继续点【下一步】、【下一步】就可以产生出很多很多代码?这些固然好，但是你可以点一下产生很多代码，另一个公司也可以点一下产生很多同样的代码。你的核心技术在哪里呢? 本文之后提到的各种编程牛人做的有价值的软件，都是自己动手写代码，而不是用什么代码生成器搞出来的。</p></blockquote><h3><span id="问题">问题</span></h3><ul><li>自动代码平台与软工似乎越来越普及，如何看待？</li><li>随着AI发展，未来自动写软工的机器人和低代码甚至0代码平台会成为银弹吗？</li></ul><h3><span id="解释">解释</span></h3><ul><li>似乎在当下2022年和未来非手工写代码或者自动软件工程渐渐成为现实，包括腾讯和华为在内的很多公司的云服务都提供了低代码甚至自动部署的云建站服务，这些服务很多时候已经可以满足用户的需求了，那么这是不是认为就可以取代手工写代码了呢？</li><li>最近 <code>Alphacode</code> 在很多算法平台获得了突破，以后的AI是否也可以在软工领域取得突破呢，包括甚至有机器人模拟scrum的过程，完整地进行高效编码，那这会不会成为软工领域的银弹呢？</li></ul><h1><span id="调研源代码版本管理软件">调研源代码版本管理软件</span></h1><h2><span id="版本控制系统分类">版本控制系统分类</span></h2><p>一般来说，版本控制系统有三种主要类型，即：</p><ul><li>本地：所有开发人员都在同一个文件系统中</li><li>集中式：团队在中央服务器上是最新的项目版本，成员需要先从中央服务器拉取最新版本，然后开始自己的修改开发，之后再传到中央服务器上</li><li>分布式：开发人员每个人都有一个自己的代码存储库，需要更改时在存储库之间推送共享</li></ul><p>一般来说，最有效率的是Git Repos，也就是目前最成功的分布式版本控制系统，本次调研也主要针对Git的几个软件<strong>GitHub</strong>、<strong>GitLab</strong>与<strong>BitBucket</strong></p><h2><span id="git-版本控制管理软件的共同特点">Git 版本控制管理软件的共同特点</span></h2><ul><li>拉取请求 Pull Request</li><li>代码审查 作为拉取请求的后续机制，可以在Pull Request中夹带针对指定代码行的注释，或者要求他人对拉取的请求做修改</li><li>内联编辑 </li><li>问题跟踪</li><li>Markdown支持</li><li>双向认证</li><li>高级权限管理</li><li>托管的静态网页 github pages 等等</li><li>功能丰富的API </li><li>Fork / Clone Repositories 克隆和复制</li><li>代码段 </li><li>第三方集成 </li></ul><h2><span id="github-gitlab-bitbucket-coding">GitHub、Gitlab、Bitbucket、Coding</span></h2><div class="table-container"><table><thead><tr><th style="text-align:center">比较内容</th><th style="text-align:center">GitHub</th><th style="text-align:center">Gitlab</th><th style="text-align:center">Bitbucket</th><th style="text-align:center">Coding</th></tr></thead><tbody><tr><td style="text-align:center">开源性</td><td style="text-align:center">存储的代码内容开源，软件本身不开源</td><td style="text-align:center">社区版软件开源</td><td style="text-align:center">不开源，购买【托管服务】中含有<strong>产品定制</strong>功能</td><td style="text-align:center">WebIDE开源</td></tr><tr><td style="text-align:center">协作性</td><td style="text-align:center">find+follow+大牛和科技巨头聚集地</td><td style="text-align:center">find</td><td style="text-align:center">find+follow</td><td style="text-align:center">find+follow+允许开发者自定义兴趣标签</td></tr><tr><td style="text-align:center">导入代码仓库类型</td><td style="text-align:center">Git SVN HG TFS</td><td style="text-align:center">Git</td><td style="text-align:center">Git SVN HG</td><td style="text-align:center">Git CodePlex Google Code HG SourceForge SVN</td></tr><tr><td style="text-align:center">免费计划</td><td style="text-align:center">Free Plans：允许托管无限的public仓库，随时进行clone fork contribute 磁盘无限制但项目不能超1G 单个文件不能超100MB</td><td style="text-align:center">Small teams plan：允许5个成员加入，公私有仓库免费但不能大于1GB</td><td style="text-align:center">cloud-hosted plan：无限用户使用无限数量的项目，单个仓库10GB限制</td><td style="text-align:center">免费计划：允许 10 个成员使用不限量公共存储库，总容量小于等于1GB</td></tr><tr><td style="text-align:center">错误追踪</td><td style="text-align:center">提供错误跟踪系统，用于提高编码质量</td><td style="text-align:center">提供了错误跟踪系统以及基于Web的代码编辑选项，用于提高编码质量</td><td style="text-align:center">使用语义搜索来分析编码语法，以提高编码质量</td><td style="text-align:center">提供错误跟踪系统</td></tr><tr><td style="text-align:center">API服务</td><td style="text-align:center">提供了API用于应用程序开发</td><td style="text-align:center">提供了API用于应用程序开发</td><td style="text-align:center">集成了多个API和服务</td><td style="text-align:center">提供了API用于应用程序开发</td></tr></tbody></table></div><h1><span id="调研持续集成部署工具">调研持续集成/部署工具</span></h1><h2><span id="gitlab-ci">Gitlab CI</span></h2><h3><span id="说明">说明</span></h3><p>本次Gitlab使用了OO的gitlab的CI进行测试，由于相关服务器刚刚迁移到校内，因此需要重新配置runner，这部分除了CI部分顺便记录一下创建个人项目和配置runner的过程</p><h3><span id="创建group与project">创建Group与Project</span></h3><p>首先gitlab是基于group进行操作的，因此第一步首先需要建立group才能在内部进行项目创建，为了方便组员的CI测试，我单独创建了一个setest group并拉进了所有的软工小组成员，截止目前有两个项目，其中Setest是我的项目，里面有一个python文件实现了快速排序</p><p><img src="/2022/03/05/SE%E9%9B%86%E7%BB%93%E5%8F%B7-%E9%98%85%E8%AF%BB%E5%92%8C%E8%B0%83%E7%A0%94/1.png" alt></p><p><img src="/2022/03/05/SE%E9%9B%86%E7%BB%93%E5%8F%B7-%E9%98%85%E8%AF%BB%E5%92%8C%E8%B0%83%E7%A0%94/2.png" alt></p><h3><span id="配置runner">配置runner</span></h3><p>网上很多博客内容太杂了，其实就简单的几行命令和一个服务器就可以</p><p>先在左侧栏的Settings里找到CI/CD，进入之后将Runners旁边的Expand点开，之后点击里面的安装指导，按照里面的命令在任意的服务器上装好服务并完成register就好了</p><p>笔者使用的是linux amd64服务器，命令参考如下：</p><h4><span id="download-and-install-binary">Download and install binary</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Download the binary for your system</span><br><span class="line">sudo curl -L --output &#x2F;usr&#x2F;local&#x2F;bin&#x2F;gitlab-runner https:&#x2F;&#x2F;gitlab-runner-downloads.s3.amazonaws.com&#x2F;latest&#x2F;binaries&#x2F;gitlab-runner-linux-amd64</span><br><span class="line"></span><br><span class="line"># Give it permissions to execute</span><br><span class="line">sudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;gitlab-runner</span><br><span class="line"></span><br><span class="line"># Create a GitLab CI user</span><br><span class="line">sudo useradd --comment &#39;GitLab Runner&#39; --create-home gitlab-runner --shell &#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line"># Install and run as service</span><br><span class="line">sudo gitlab-runner install --user&#x3D;gitlab-runner --working-directory&#x3D;&#x2F;home&#x2F;gitlab-runner</span><br><span class="line">sudo gitlab-runner start</span><br></pre></td></tr></table></figure><h4><span id="command-to-register-runner">Command to register runner</span></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-runner register --url $URL --registration-token $REGISTRATION_TOKEN</span><br></pre></td></tr></table></figure><p>注意这里的$URL和$REGISTRATION_TOKEN替换成相应的url和token就好了。同时可以参考选择 <code>ruby2.7</code> 的 <code>docker</code> 进行部署</p><p>这样操作完之后，Runners展开的左侧就会有runners列表，这时需要点进你的服务器的编辑按钮，将内部的 <code>Indicates whether this runner can pick jobs without tags</code> 勾上就可以使用了</p><h3><span id="ci测试">CI测试</span></h3><ol><li>主要是对一份快速排序的代码进行了评测，代码如下，正确的输出是 <code>[1,2,3,4,5]</code>，仓库链接：<a href="http://gitlab.oo.buaa.edu.cn/setest/setest" target="_blank" rel="noopener">http://gitlab.oo.buaa.edu.cn/setest/setest</a></li></ol><p><img src="/2022/03/05/SE%E9%9B%86%E7%BB%93%E5%8F%B7-%E9%98%85%E8%AF%BB%E5%92%8C%E8%B0%83%E7%A0%94/3.png" alt></p><ol><li>编写 <code>.gitlab-ci.yml</code> 上传并进行CI测试</li></ol><p><img src="/2022/03/05/SE%E9%9B%86%E7%BB%93%E5%8F%B7-%E9%98%85%E8%AF%BB%E5%92%8C%E8%B0%83%E7%A0%94/4.png" alt></p><h2><span id="github-action">Github Action</span></h2><ol><li>同样的代码上传至 <code>github</code> 上进行相同的代码测试 链接：<a href="https://github.com/BUAADreamer/Setest" target="_blank" rel="noopener">https://github.com/BUAADreamer/Setest</a></li></ol><p><img src="/2022/03/05/SE%E9%9B%86%E7%BB%93%E5%8F%B7-%E9%98%85%E8%AF%BB%E5%92%8C%E8%B0%83%E7%A0%94/6.png" alt></p><ol><li>编写 <code>.yaml</code> 文件使用 <code>action</code> 的 <code>overflow</code> 进行测试结果</li></ol><p><img src="/2022/03/05/SE%E9%9B%86%E7%BB%93%E5%8F%B7-%E9%98%85%E8%AF%BB%E5%92%8C%E8%B0%83%E7%A0%94/5.png" alt></p><h2><span id="cicd-相关">CI/CD 相关</span></h2><h3><span id="1cicd工具定义">1.CI/CD工具定义</span></h3><p><strong>CI</strong>持续集成，<strong>CD</strong>持续部署，这是一种通过在应用开发阶段引入<strong>自动化</strong>来频繁向客户交付应用的方法。CI/CD 的核心概念是<strong>持续集成、持续交付和持续部署</strong>。作为一个面向开发和运营团队的解决方案，CI/CD 主要针对在<strong>集成新代码</strong>时所引发的问题</p><h3><span id="2gitlab-ci特点特性">2.Gitlab CI特点，特性</span></h3><p>Gitlab CI/CD内置于GitLab，是Gitlab一个简洁好用的的持续集成/持续交付/持续部署的框架</p><ul><li>多平台： Unix，Windows，macOS和任何其他支持Go的平台上执行构建。</li><li>多语言： 构建脚本是命令行驱动的，并且可以与Java，PHP，Ruby，C和任何其他语言一起使用。</li><li>稳定构建： 构建在与GitLab不同的机器上运行。</li><li>并行构建： GitLab CI / CD在多台机器上拆分构建，以实现快速执行。</li><li>实时日志记录： 合并请求中的链接将您带到动态更新的当前构建日志。</li><li>灵活的管道： 可以在每个阶段定义多个并行作业，并且可以触发其他构建。</li><li>版本管道： 一个 .gitlab-ci.yml文件 包含测试和整个过程的步骤，使每个人都能贡献更改，并确保每个分支获得所需的管道。</li><li>自动缩放： 可以自动缩放构建机器，以确保立即处理您的构建并将成本降至最低。</li><li>构建工件： 可以将二进制文件和其他构建工件上载到 GitLab并浏览和下载它们。</li><li>Docker支持： 可以使用自定义Docker映像， 作为测试的一部分启动服务， 构建新的Docker映像，甚至可以在Kubernetes上运行。</li><li>容器注册表： 内置的容器注册表， 用于存储，共享和使用容器映像。</li><li>受保护的变量： 在部署期间使用受每个环境保护的变量安全地存储和使用机密。</li><li>环境： 定义多个环境。</li></ul><h3><span id="3github-actions特点特性">3.Github Actions特点，特性</span></h3><p>actions可以用来作为CI/CD使用，但是它不只是CI/CD，因为它其实是<strong>一组docker容器</strong>所组成的<strong>Workflow</strong>，Workflow的触发条件，公共仓库目前仅支持push，私有仓库则支持check_run、create、delete、issue comment， commit comment, pull request等许多事件, 通过这些事件，可以完成包含CI/CD在内的许多自动化操作，例如接收到issue comment之后使用telegram bot发送通知等等</p><h3><span id="4cicd工具作用分析">4.CI/CD工具作用分析</span></h3><ul><li>CI/CD主要运用了jenkins进行对后端的开发代码的拉取，经过自动编译，打包，测试后，自动发布到tomcat服务器上，实现自动化的产品上线。</li><li>持续集成注重将各个开发者的工作集合到一个代码仓库中，通常每天会进行几次， 主要目的是尽早发现集成错误，使团队更加紧密结合，更好地协作。 通过持续集成，开发人员能够频繁地将其代码集成到公共代码仓库的主分支中。 开发人员能够在任何时候多次向仓库提交作品，而不是独立地开发每个功能模块并在开发周期结束时一一提交。</li><li>持续部署的目的是最小化部署或发布过程中团队固有的摩擦， 它的实现通常能够将构建部署的每个步骤自动化，以便任何时刻能够安全地完成代码发布。 持续部署扩展了持续交付，以便软件构建在通过所有测试时自动部署。在这样的流程中， 不需要人为决定何时及如何投入生产环境。CI/CD 系统的最后一步将在构建后的组件/包退出流水线时自动部署。 此类自动部署可以配置为快速向客户分发组件、功能模块或修复补丁，并准确说明当前提供的内容。</li></ul><h3><span id="5cicd工具对比">5.CI/CD工具对比</span></h3><p>Gitlab CI与Github Actions的系统对比在 <a href="https://about.gitlab.com/devops-tools/github-vs-gitlab/ci-missing-github-capabilities/" target="_blank" rel="noopener">https://about.gitlab.com/devops-tools/github-vs-gitlab/ci-missing-github-capabilities/</a> 非常详尽的展示了，其中CICD的对比大致用以下图来总结</p><p><img src="/2022/03/05/SE%E9%9B%86%E7%BB%93%E5%8F%B7-%E9%98%85%E8%AF%BB%E5%92%8C%E8%B0%83%E7%A0%94/7.png" alt></p><p>可以看到，对于CD部署的第三方性，以及CICD的部署容器和底层配置架构，gitlab做的更加细致一些，而github的市场化和开源性更好。</p><p>总的来说，使用体验来看由于github过于庞大，对于CICD的关注度显然没有gitlab到位，但是actions的丰富功能确实也很吸引人，然而出于种种原因最后可能软工还是会选用gitlab或者coding平台。coding对于中国用户当然是更加友好，不过具体功能还有待调研。</p>]]></content>
      
      
      <categories>
          
          <category> BUAA-SE-2022 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-SE-2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2_BigData_Tools</title>
      <link href="2021/08/30/2-BigData-Tools/"/>
      <url>2021/08/30/2-BigData-Tools/</url>
      
        <content type="html"><![CDATA[<h2><span id="milvus">milvus</span></h2><p><a href="https://milvus.io/docs/v2.0.0/home" target="_blank" rel="noopener">https://milvus.io/docs/v2.0.0/home</a></p><h2><span id="elasticsearch">elasticsearch</span></h2><p><a href="https://github.com/elastic/elasticsearch" target="_blank" rel="noopener">https://github.com/elastic/elasticsearch</a></p><p><a href="https://www.elastic.co/guide/cn/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/cn/index.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法导论笔记</title>
      <link href="2021/08/09/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%94%E8%AE%B0/"/>
      <url>2021/08/09/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1><span id="第一部分-基础知识">第一部分 基础知识</span></h1><h3><span id="循环不变式">循环不变式</span></h3><p><strong>初始化</strong>：循环的第一次迭代之前为真</p><p><strong>保持</strong>：循环的某次迭代之前为真，则在下次迭代之前也为真</p><p><strong>终止</strong>：循环终止时，不变式提供有用性质，有助于证明算法成立</p><h2><span id="第四章-分治策略">第四章 分治策略</span></h2><h3><span id="归并排序">归并排序</span></h3><h3><span id="最大子数组问题">最大子数组问题</span></h3><p>将数组切成左右两部分，则最大子数组要么出现在[l,mid]中，要么跨越了mid，要么就在[mid+1,r]中</p><h3><span id="矩阵乘法的strassen算法">矩阵乘法的Strassen算法</span></h3><p><a href="https://zhuanlan.zhihu.com/p/78657463" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/78657463</a></p><p>思想：矩阵乘法算法复杂度高，用矩阵加减法代替部分的矩阵乘法运算</p><p>从$O(n^3)$降到了$O(n^{lg7})$，但由于涉及多次浮点数加减乘除，算法稳定性精确度较低。对于n&gt;300时才适用</p><h3><span id="求解递归式">求解递归式</span></h3><p>递归树，归纳法，主方法</p><h3><span id="主方法">主方法</span></h3><p>$T(n)=aT(n/b)+f(n)$  $a\ge1,b&gt;1,\epsilon&gt;0$ </p><ol><li><p>$f(n)=O(n^{log_b^{a-\epsilon}})\rightarrow T(n)=\Theta(n^{log_b^a})$ </p></li><li><p>$f(n)=\Theta(n^{log_b^{a}})\rightarrow T(n)=\Theta(n^{log_b^a}lgn)$ </p></li><li><p>$f(n)=\Omega(n^{log_b^{a+\epsilon}})且\exists c\lt1,s.t.\forall n, af(n/b)\leq cf(n)(正则条件)\rightarrow T(n)=\Theta(f(n))$ </p></li></ol><p>主定理理解：情况1和3的小于和大于必须是<strong>多项式意义</strong>的大小关系，即如果没有相差$n^\epsilon$因子，则进入了1和2或者2和3的缝隙</p><h2><span id="第五章-概率分析与随机算法">第五章 概率分析与随机算法</span></h2><h3><span id="雇用问题">雇用问题</span></h3><p>随机化输入之后复杂度为$O(\ln n)$</p><h3><span id="随机化序列方法">随机化序列方法</span></h3><p>PERMUTE-BY-SORTING方法随机化优先级，根据优先级对数组排列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">permutes=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    permutes.append((A[i],random.randint(<span class="number">0</span>,n*n*n)))</span><br><span class="line">permutes.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line">A=[permutes[i][<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br></pre></td></tr></table></figure><p>RANDOMIZE-IN-PLACE方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">j=random.randint(i,n<span class="number">-1</span>)</span><br><span class="line">    A[i],A[j]=A[j],A[i]</span><br></pre></td></tr></table></figure><h1><span id="第二部分-排序与顺序统计量">第二部分 排序与顺序统计量</span></h1><h2><span id="第6章-堆排序">第6章 堆排序</span></h2><p>与插入排序一样是原址排序，复杂度与归并排序相当。</p><p>堆可以看成一个<strong>完全二叉树</strong></p><p><strong>最大堆</strong>—进行堆排序</p><p><strong>最小堆</strong>—构造优先队列</p><p><strong>MAX-HEAPIFY</strong>(A, i)：维护i节点为根的子树的最大堆性质</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n=len(A)</span><br><span class="line">l=i*<span class="number">2</span></span><br><span class="line">maxi=i</span><br><span class="line"><span class="keyword">if</span> l&lt;n <span class="keyword">and</span> A[maxi]&lt;A[l]:</span><br><span class="line">    maxi=l</span><br><span class="line">r=i*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> r&lt;n <span class="keyword">and</span> A[maxi]&lt;A[r]:</span><br><span class="line">    maxi=r</span><br><span class="line"><span class="keyword">if</span> i!=maxi:</span><br><span class="line">    A[i],A[maxi]=A[maxi],A[i]</span><br><span class="line">    MAX-HEAPIFY(A, maxi)</span><br></pre></td></tr></table></figure><p><strong>BUILD-MAX-HEAP</strong>(A)：遍历[length/2,1]调用MAX-HEAPIFY</p><p><strong>HEAPSORT</strong>(A)：堆排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BUILD-MAX-HEAP(A)</span><br><span class="line">sz=len(A)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(A),<span class="number">1</span>):</span><br><span class="line">A[<span class="number">0</span>],A[i]=A[i],A[<span class="number">0</span>]</span><br><span class="line">sz-=<span class="number">1</span></span><br><span class="line">HEAPIFY(A,i)</span><br></pre></td></tr></table></figure><h3><span id="优先队列">优先队列</span></h3><p>共享计算机系统的作业调度</p><p><strong>MAXIMUM</strong>(S):return S[0]</p><p><strong>EXTRACT-MAX</strong>(x)：删去最大的并维护最大堆</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">max=S[<span class="number">0</span>]</span><br><span class="line">S[<span class="number">0</span>]=S[len(S)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">del</span> S[len(S)<span class="number">-1</span>]</span><br><span class="line">MAX-HEAPIFY(S,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> max</span><br></pre></td></tr></table></figure><p><strong>INCREASE-KEY</strong>(S,i,k)：增加i位置的元素值到k</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> k&lt;S[i]:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">S[i]=k</span><br><span class="line"><span class="keyword">while</span> i&gt;=<span class="number">1</span> <span class="keyword">and</span> S[i//<span class="number">2</span>]&lt;S[i]:</span><br><span class="line">    S[i],S[i//<span class="number">2</span>]=S[i//<span class="number">2</span>],S[i]</span><br><span class="line">    i=i//<span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>INSERT</strong>(S,x)：新增一个元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">MAX_INT=sys.maxsize</span><br><span class="line">S.append(-MAX_INT)</span><br><span class="line">INCREASE-KEY(S,len(S)<span class="number">-1</span>,x)</span><br></pre></td></tr></table></figure><h2><span id="第7章-快速排序">第7章 快速排序</span></h2><h3><span id="quicksort">QUICKSORT</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(a,l,r)</span>:</span></span><br><span class="line">    <span class="comment">#随机化抽样使划分更平衡</span></span><br><span class="line">    tmp=random.randint(l,r)</span><br><span class="line">    a[tmp],a[r]=a[r],a[tmp]</span><br><span class="line">    <span class="comment">#初始化</span></span><br><span class="line">    x=a[r]</span><br><span class="line">    i=l<span class="number">-1</span> <span class="comment">#i表示左边的区域的最右端</span></span><br><span class="line">    j=l <span class="comment">#j表示右边的区域的最右端</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(l,r):</span><br><span class="line">        <span class="keyword">if</span> a[j]&lt;=x:</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">            a[i],a[j]=a[j],a[i]</span><br><span class="line">    a[i+<span class="number">1</span>],a[r]=a[r],a[i+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(a,l,r)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> l&lt;r: <span class="comment">#l&gt;=r时直接返回，否则会爆栈</span></span><br><span class="line">        sep=partition(a,l,r)</span><br><span class="line">        quicksort(a,l,sep<span class="number">-1</span>)</span><br><span class="line">        quicksort(a,sep+<span class="number">1</span>,r)</span><br><span class="line">quicksort(a,<span class="number">0</span>,len(a)<span class="number">-1</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>只要是常数划分，时间复杂度都是$O(n\lg n)$</p><p>随机化划分则算法复杂度为$O(n\lg n)$</p><h2><span id="第8章-线性时间排序">第8章 线性时间排序</span></h2><h3><span id="决策树模型">决策树模型</span></h3><p><img src="/2021/08/09/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%94%E8%AE%B0/决策树模型演示.jpg" style="zoom: 15%;"></p><p>每一层表示不同层级条件分支，叶子节点表示排序后的标号序列</p><p>决策树的叶节点数量为l</p><p>则对于一个长度为n的排列</p><p>$n!\leq l \lt 2^h$</p><p>$h&gt;\lg (n!)=\Omega(n\lg n)$​</p><p>因此任何排序算法的下界为$O(n\lg n)$</p><p><strong>不采用比较方式</strong>的排序需要更多空间，但时间复杂度突破了这个瓶颈，以下几个都为$\Theta(n)$</p><h3><span id="计数排序">计数排序</span></h3><p>稳定排序：相同数值的两个数排序前后相对次序不变</p><p>空间消耗大</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">12</span>]</span><br><span class="line">m=max(a)</span><br><span class="line">dic=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(m+<span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> a:</span><br><span class="line">    dic[x]+=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(dic)):</span><br><span class="line">    dic[i]+=dic[i<span class="number">-1</span>]</span><br><span class="line">outLs=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)+<span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">    outLs[dic[a[i]]]=a[i]</span><br><span class="line">    dic[a[i]]-=<span class="number">1</span></span><br><span class="line"><span class="keyword">del</span> outLs[<span class="number">0</span>]</span><br><span class="line">print(outLs)</span><br></pre></td></tr></table></figure><h3><span id="基数排序">基数排序</span></h3><p>早期卡片编程用到</p><p>n次循环(i from 1 to n)，每次序列对第i位数按照从小到大排序，最后的顺序就是从小到大</p><p>要求对一位数的排序为稳定排序</p><h3><span id="桶排序">桶排序</span></h3><p>将[0,1]划分为[0,1/n],[1/n,2/n]…[(n-1)/n,1]区间</p><p>每个数都属于一个小区间中，对每个区间内的数建立链表，使用插入排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">12</span>]</span><br><span class="line">m=max(a)+<span class="number">1</span></span><br><span class="line">n=len(a)</span><br><span class="line">buckets=[[] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertB</span><span class="params">(suba,x)</span>:</span></span><br><span class="line">    i=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i&lt;len(suba) <span class="keyword">and</span> suba[i]&lt;x:</span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i==len(suba):</span><br><span class="line">        suba.append(x)</span><br><span class="line">    <span class="keyword">elif</span> i==<span class="number">0</span>:</span><br><span class="line">        suba.insert(<span class="number">0</span>,x)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        suba.insert(i,x)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> a:</span><br><span class="line">    pos=int(x*n/m)</span><br><span class="line">    insertB(buckets[pos],x)</span><br><span class="line">outLs=[]</span><br><span class="line"><span class="keyword">for</span> b <span class="keyword">in</span> buckets:</span><br><span class="line">    outLs+=b</span><br><span class="line">print(outLs)</span><br></pre></td></tr></table></figure><h2><span id="第9章-中位数与顺序统计量">第9章 中位数与顺序统计量</span></h2><p>第i个<strong>顺序统计量</strong>：一个序列中第i小的元素</p><h3><span id="选择问题">选择问题</span></h3><p>输入：一个集合A和一个数i</p><p>输出：第i个顺序统计量</p><p>利用快速排序中的随机划分函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">randomselect</span><span class="params">(a,l,r,i)</span>:</span></span><br><span class="line">    q=partition(a,l,r)</span><br><span class="line">    k=q-l+<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> k==i:</span><br><span class="line">        <span class="keyword">return</span> q</span><br><span class="line">    <span class="keyword">elif</span> i&lt;k:</span><br><span class="line">        <span class="keyword">return</span> randomselect(a,l,q<span class="number">-1</span>,i)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> randomselect(a,q+<span class="number">1</span>,r,i-k)</span><br></pre></td></tr></table></figure><h4><span id="select算法">select算法</span></h4><p><a href="https://blog.csdn.net/luoshixian099/article/details/45286303" target="_blank" rel="noopener">https://blog.csdn.net/luoshixian099/article/details/45286303</a></p><h1><span id="第三部分-数据结构">第三部分 数据结构</span></h1><h2><span id="第10章-基本数据结构">第10章 基本数据结构</span></h2><h3><span id="栈后进先出">栈：后进先出</span></h3><h3><span id="队列先进先出">队列：先进先出</span></h3><h3><span id="链表">链表</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,val,prev,next)</span>:</span></span><br><span class="line">        self.value = val</span><br><span class="line">        self.prev = prev</span><br><span class="line">        self.next = next</span><br></pre></td></tr></table></figure><p>哨兵用一个哨兵对象nil表示NULL</p><p>哨兵可以降低常数因子，但占用额外空间比较浪费，一般不用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">L.nil.prev=L.tail</span><br><span class="line">L.nil.next=L.head</span><br></pre></td></tr></table></figure><h3><span id="有根树的表示">有根树的表示</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">treenode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,val,p,leftChild,rightChild)</span>:</span></span><br><span class="line">        self.val=val</span><br><span class="line">        self.p=p</span><br><span class="line">        self.leftChild=leftChild</span><br><span class="line">        self.rightChild=rightChild <span class="comment">#多叉树用self.childs=childs childs为节点列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#另一种表示</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">treenode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,val,p,leftChild,rightSibling)</span>:</span></span><br><span class="line">        self.val=val</span><br><span class="line">        self.p=p</span><br><span class="line">        self.leftChild=leftChild</span><br><span class="line">        self.rightSibling=rightSibling </span><br><span class="line">        <span class="comment">#leftChild--&gt;最左边的孩子</span></span><br><span class="line">        <span class="comment">#rightSibling--&gt;每个节点的靠右的第一个兄弟</span></span><br></pre></td></tr></table></figure><h2><span id="第11章-散列表">第11章 散列表</span></h2><h3><span id="直接寻址表">直接寻址表</span></h3><p>即数组，根据关键字k直接索引元素</p><h3><span id="散列表">散列表</span></h3><p>根据函数h(k)的值索引元素</p><p>冲突解决办法：链接法 开放寻址法</p><h4><span id="链接法">链接法</span></h4><p>假设任何一个给定元素等可能散列到m个槽中任何一个，与其他元素被散列到哪无关，这个假设为<strong>简单均匀散列</strong></p><p>每个槽对应一个链表，冲突则放在链表中</p><h3><span id="散列函数">散列函数</span></h3><p>多数散列函数都假定<strong>关键字全域</strong>为<strong>自然数集N</strong>，如果不是自然数集则一般要通过某种方式转换为自然数，比如<strong>字符串和Ascii码</strong></p><h4><span id="除法散列法">除法散列法</span></h4><p>$h(k)=k\ mod\ m$</p><p>m一般取不接近2的整数幂的素数</p><h4><span id="乘法散列法">乘法散列法</span></h4><p>$h(k)=\lfloor m((kA)\ mod\ 1)\rfloor$​</p><p>其中 $((kA) mod 1)$ ​为取 $kA$​​​ 的小数部分 $0\leq A \leq 1$</p><p>由于移位乘法比较简单，A一般取形如$s/2^w$​的一个小数，m一般取2的整数幂</p><p>Knuth认为$A=(\sqrt 5 -1)/2=0.6180339887…$比较合适</p><h4><span id="全域散列法">全域散列法</span></h4><p>随机选择散列函数，使之独立于关键字</p><p><img src="/2021/08/09/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%94%E8%AE%B0/全域散列定义.png" style="zoom: 80%;"></p><h4><span id="开放寻址法">开放寻址法</span></h4><p>$h:U\times{0,1…m-1}\rightarrow {0,1…m-1}$</p><p>对每一个关键字k，使用开放寻址法的探查序列 $<h(k,0),h(k,1),...,h(k,m-1)>$​ 选择空的槽位</h(k,0),h(k,1),...,h(k,m-1)></p><p>探查方式</p><ul><li>线性探查</li><li>二次探查</li><li>双重散列</li></ul><h3><span id="完全散列">完全散列</span></h3><p>二级散列表，每一级都采用全域散列</p><h2><span id="第12章-二叉搜索树">第12章 二叉搜索树</span></h2><p>在一棵高度h的二叉树上，动态集合上的操作SEARCH/MINIMUM/MAXIMUM/SUCCESSOR/PREDECESSOR/DELETE/INSERT均可以在O(h)内完成</p><h2><span id="第13章-红黑树">第13章 红黑树</span></h2><p>平衡搜索树</p><h2><span id="第14章-数据结构的扩张">第14章 数据结构的扩张</span></h2><h3><span id="扩张数据结构的步骤">扩张数据结构的步骤</span></h3><ol><li>选择一种<strong>基础数据结构</strong></li><li>确定基础数据结构中要维护的<strong>附加信息</strong></li><li>检验基础数据结构上的基本修改操作<strong>能否维护</strong>附加信息</li><li>设计一些<strong>新操作</strong></li></ol><p>顺序统计树——在红黑树基础上对每个结点增加一个表示子树大小的size变量</p><p>区间树——红黑树基础上，关键字采用区间信息和端点最大值</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flask项目部署</title>
      <link href="2021/07/29/Flask%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
      <url>2021/07/29/Flask%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h3><span id="商品信息爬取">商品信息爬取</span></h3><p><a href="https://blog.csdn.net/onlynima/article/details/103808124" target="_blank" rel="noopener">https://blog.csdn.net/onlynima/article/details/103808124</a></p><p>将某个请求自动转换为某个语言代码：<a href="https://curl.trillworks.com/（需要翻墙）" target="_blank" rel="noopener">https://curl.trillworks.com/（需要翻墙）</a></p><h3><span id="pyecharts画图并保存">pyecharts画图并保存</span></h3><p><a href="https://blog.csdn.net/u011318077/article/details/90113206" target="_blank" rel="noopener">https://blog.csdn.net/u011318077/article/details/90113206</a></p><p>pip —default-timeout=1000 install -U matplotlib</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>rubyonrails-Learning</title>
      <link href="2021/07/15/rubyonrails-Learning/"/>
      <url>2021/07/15/rubyonrails-Learning/</url>
      
        <content type="html"><![CDATA[<p>Windows 远程连接 Ubuntu16.4 桌面:<a href="https://cloud.tencent.com/developer/article/1619241" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1619241</a></p><p>先配置好环境</p><p>官网看rails不建议在win上操作，因此只好选用ubuntu云服务器试着操作一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ruby-full</span><br><span class="line">sudo apt-get install sqlite</span><br><span class="line">sudo apt-get install rails</span><br></pre></td></tr></table></figure><p>本地启动服务器调试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rails new blog</span><br><span class="line">cd blog</span><br><span class="line">bin/rails server</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Django+vue项目部署</title>
      <link href="2021/07/11/Django-vue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
      <url>2021/07/11/Django-vue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h2><span id="后端配置">后端配置</span></h2><p><a href="https://blog.csdn.net/freezingxu/article/details/77074075" target="_blank" rel="noopener">在Ubuntu/Linux环境下使用MySQL：启动和关闭MySQL服务</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service mysql start</span><br><span class="line">service mysql status</span><br><span class="line">service mysql stop</span><br></pre></td></tr></table></figure><p>修改.cnf文件的方法：直接 <code>sudo vim my.cnf</code></p><p>mysql my.cnf配置：<a href="https://blog.csdn.net/weixin_43633797/article/details/102524499" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43633797/article/details/102524499</a></p><p>查看监听端口：netstat -tln   <a href="https://www.136.la/mysql/show-80993.html" target="_blank" rel="noopener">https://www.136.la/mysql/show-80993.html</a></p><p>彻底删除并重装mysql：<a href="https://www.codenong.com/cs106182111/" target="_blank" rel="noopener">https://www.codenong.com/cs106182111/</a></p><p>sudo apt install mysql-server</p><p>sudo apt install libmysqlclient-dev</p><p>初始密码找不到进不去：<a href="https://blog.csdn.net/r527665047/article/details/107056941/" target="_blank" rel="noopener">https://blog.csdn.net/r527665047/article/details/107056941/</a></p><p>修改完密码之后要重启mysql！</p><p>进入后端根目录</p><p>python manage.py makemigrations</p><p>python manage.py runserver 8000</p><p><a href="https://www.cnblogs.com/steven_oyj/archive/2010/05/24/1742808.html" target="_blank" rel="noopener">https://www.cnblogs.com/steven_oyj/archive/2010/05/24/1742808.html</a></p><p><a href="https://blog.csdn.net/leacock1991/article/details/110406708" target="_blank" rel="noopener">https://blog.csdn.net/leacock1991/article/details/110406708</a></p><p>解决OSError: mysql_config not found问题：<a href="https://blog.csdn.net/zy_whynot/article/details/106960087" target="_blank" rel="noopener">https://blog.csdn.net/zy_whynot/article/details/106960087</a></p><p>mongo远程连接：<a href="https://www.cnblogs.com/kimkat/p/9192785.html" target="_blank" rel="noopener">https://www.cnblogs.com/kimkat/p/9192785.html</a></p><h3><span id="ngnix配置">ngnix配置</span></h3><p><a href="https://www.cnblogs.com/niehaidong111/p/11208492.html" target="_blank" rel="noopener">https://www.cnblogs.com/niehaidong111/p/11208492.html</a></p><p><a href="https://www.cnblogs.com/NAG2020/p/12920154.html" target="_blank" rel="noopener">https://www.cnblogs.com/NAG2020/p/12920154.html</a></p><p>安装ngnix：<a href="https://blog.csdn.net/qq_23832313/article/details/83578836" target="_blank" rel="noopener">https://blog.csdn.net/qq_23832313/article/details/83578836</a></p><p><a href="https://www.cnblogs.com/gede/p/11011693.html" target="_blank" rel="noopener">https://www.cnblogs.com/gede/p/11011693.html</a></p><p>sudo vim /etc/nginx/conf.d/istic.conf</p><h2><span id="前端配置">前端配置</span></h2><h3><span id="安装npm">安装npm</span></h3><p>sudo apt update</p><p>sudo apt install npm</p><p>git clone <a href="https://gitee.com/muller2020/BUAACrawler.git" target="_blank" rel="noopener">https://gitee.com/muller2020/BUAACrawler.git</a></p><p>进入前端目录</p><p>cd vue-admin-template</p><p>npm install</p><p>npm run build:prod</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -aux |grep uwsgi</span><br><span class="line">kill -9 3539 #最后这个号码是最上面那个</span><br><span class="line">uwsgi --ini mywsgi.ini #再重启uwsgi就好了</span><br></pre></td></tr></table></figure><h3><span id="前端问题解决">前端问题解决</span></h3><p><a href="http://blog.itblood.com/2455.html" target="_blank" rel="noopener">Error:Rule can only have resource source(provided resource test include exclude【解决办法】</a> 重装webpack</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm cache clean --force #清除缓存</span><br></pre></td></tr></table></figure><p>npm install一定要保证全局的存储地址有充足的空间！！！（默认在C盘）</p><h2><span id="部署完成">部署完成</span></h2><h3><span id="修改用户密码">修改用户密码</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">python3 manage.py shell</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth <span class="keyword">import</span> get_user_model</span><br><span class="line">User = get_user_model()</span><br><span class="line">user=User.objects.get(username=<span class="string">'XXX'</span>)</span><br><span class="line">user.set_password(<span class="string">'new_password'</span>)</span><br><span class="line">user.save()</span><br><span class="line">或者</span><br><span class="line">python3 manage.py changepassword username</span><br></pre></td></tr></table></figure><h3><span id="连接远程服务器">连接远程服务器</span></h3><p><a href="https://www.cnblogs.com/zhuminghui/p/10947930.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhuminghui/p/10947930.html</a></p><h3><span id="自动部署">自动部署</span></h3><h4><span id="生成公私钥">生成公私钥</span></h4><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -o</span><br></pre></td></tr></table></figure><p>将公钥放到仓库的公钥列表中，并将.git文件夹下的config文件中的url改为ssh地址</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法学习</title>
      <link href="2021/07/10/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/07/10/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>算法学习笔记，本篇主要是一些基本的知识整理</p><a id="more"></a><h1><span id="leetcode高频算法实战学习">Leetcode高频算法实战学习</span></h1><h2><span id="一-数组">一、数组</span></h2><h3><span id="数组理论">数组理论</span></h3><p>使用静态数组实现的方法：每次大小不够时将新的静态数组长度<strong>增大一倍</strong>，这样就可以将拷贝数值的复杂度降到$O(n)$</p><p>不同遍历方式差别很大，以下三种从上到下时间依次上升。</p><p>参考博客：<a href="https://blog.csdn.net/xiewuquan/article/details/50492096" target="_blank" rel="noopener">https://blog.csdn.net/xiewuquan/article/details/50492096</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="built_in">print</span>(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x:a)&#123;</span><br><span class="line">    <span class="built_in">print</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it:a.<span class="built_in">begin</span>();it!=a.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">    <span class="built_in">print</span>(it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>emplace_back</code>效果和<code>push_back</code>一致，最好使用前者，节省空间开销</p><p>如果已经确定了数组长度，就直接先使用<code>vector&lt;int&gt; ans(n);</code>初始化好再直接用下标索引直接赋值，比一个个<code>push_back</code>快</p><h3><span id="扫描数组技巧">扫描数组技巧</span></h3><p>求数组区间和，区间方差，二位数组矩阵区域和方法：记录从0到每个序号的和，然后用sum[j]-sum[i-1]的方式求出区间[i,j]的和</p><h3><span id="序列问题">序列问题</span></h3><h4><span id="下一个排列">下一个排列</span></h4><ol><li>数组长度小于2直接返回原数组</li><li>从后往前扫描找到一个序号i使得nums[i]&lt;nums[i+1]</li><li>在nums[i+1,n-1]之间找到一个大于nums[i]且最小的数的序号mini，将mini和i处的数交换</li><li>将i位置之后的数组逆序（由从大到小变为从小到大）</li></ol><h4><span id="前一个排列">前一个排列</span></h4><ol><li>数组长度小于2直接返回原数组</li><li>从后往前扫描找到一个序号i使得nums[i]&gt;nums[i+1]</li><li>在nums[i+1,n-1]之间找到一个小于nums[i]且最大的数的序号maxi，将maxi和i处的数交换</li><li>将i位置之后的数组逆序（由从小到小变为从大到小）</li></ol><p>逆序过程可以用sort函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sort(nums+i,nums+n<span class="number">-1</span>,cmp); <span class="comment">//n=nums.size()</span></span><br><span class="line">sort(nums.<span class="built_in">begin</span>()+i,nums.<span class="built_in">end</span>(),cmp); <span class="comment">//另一种写法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a,<span class="keyword">const</span> <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b; <span class="comment">//从大到小排序 a&lt;b则是从小到大</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="最大子序和">最大子序和</span></h4><h5><span id="最大连续子数组和">最大连续子数组和</span></h5><p>先求出从<code>0</code>到每个位置的和，用<code>sums</code>记录，在这个遍历过程中同时记录在每个位置之前的位置中sum最小的位置，也用另一个数组存储。</p><p>之后对每个位置<code>i</code>，计算<code>sums[i]-sums[minPos[i]]</code>的最大值</p><h5><span id="环形数组最大连续子数组和">环形数组最大连续子数组和</span></h5><p>用一个普通数组表示环形数组</p><p>分为两种情况</p><p>case1:最大的子数组在原数组中间，此时等价于之前普通的数组情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**+++**</span><br></pre></td></tr></table></figure><p>case2:最大子数组在原数组两边，此时等价于求<strong>最小连续子数组和</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++***++</span><br></pre></td></tr></table></figure><h3><span id="有序数组查找问题">有序数组查找问题</span></h3><h4><span id="两数之和">两数之和</span></h4><p>有序数组中，两个指针l,r记录。两个位置数字和与目标值比较，一样的话返回，大了就r—，小的话就l++。</p><h4><span id="三数之和">三数之和</span></h4><p>三个指针i j k(i&lt;=j&lt;=k)</p><p>定死一个位置i，看是否存在nums[j]+nums[k]=target-nums[i]</p><h4><span id="二分查找">二分查找</span></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">        l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><h4><span id="搜索旋转排序矩阵">搜索旋转排序矩阵</span></h4><p>类似二分查找的思路，加一些判定</p><p>假设左边的数位置是 L，右边位置是 R：</p><ol><li><p>如果当前数组的长度小于等于 2 的话，我们按边界条件处理。</p></li><li><p>否则，取中间的位置 M，先判断目标值和 M 位置值的关系，如果相等直接返回 M。</p></li><li><p>然后，如果 M 位置的值大于 L 位置的值:</p><ul><li><p>如果目标值在 L 到 M 之间，我们递归左边部分。</p></li><li><p>其他情况，递归右边部分。</p></li></ul></li><li><p>如果 M 位置的值小于 L 位置的值:</p><ul><li><p>如果目标值在 M 到 R 之间，递归右边部分。</p></li><li><p>其他情况，递归左边部分。</p></li></ul></li></ol><h4><span id="搜索二维矩阵">搜索二维矩阵</span></h4><p>每次从左下角的指针开始判断</p><p>对于m*n矩阵，初始化指针为x=m-1,y=0</p><p>之后<code>nums[x][y]&gt;target</code>就x—</p><p>相等就返回</p><p>小于就y++</p><h2><span id="二-栈">二、栈</span></h2><p>后进先出</p><p>需要实现top() size() pop() push(x)四个操作</p><h3><span id="括号匹配">括号匹配</span></h3><h3><span id="表达式计算">表达式计算</span></h3><h2><span id="三-队列">三、队列</span></h2><p>先进先出</p><h3><span id="滑动窗口最大值">滑动窗口最大值</span></h3><h4><span id="方法2使用单调双向队列解决问题">方法2：使用单调双向队列解决问题</span></h4><p>原理：如果在k个数中存在一个编号<code>i&lt;j</code>,<code>nums[i]&lt;=nums[j]</code>则<code>nums[i]</code>必定不可能是最大的那个数，因此将这样的数出队。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q; <span class="comment">//q为原数组的序号队列，相当于同时存储了数值和编号两个值</span></span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123; <span class="comment">//初始化先将前k个数中降序的编号存到队列中</span></span><br><span class="line">            <span class="keyword">while</span>(!q.empty()&amp;&amp;nums[q.back()]&lt;=nums[i])&#123;</span><br><span class="line">                q.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            q.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans=&#123;nums[q.front()]&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!q.empty()&amp;&amp;nums[q.back()]&lt;=nums[i])&#123;</span><br><span class="line">                q.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            q.push_back(i);</span><br><span class="line">            <span class="keyword">if</span>(q.front()&lt;i-k+<span class="number">1</span>)&#123;</span><br><span class="line">                q.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(nums[q.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方差计算：$D(x)=\sum x_i^2-((\sum x_i)/n)^2$</p><h3><span id="求岛屿最大面积">求岛屿最大面积</span></h3><p>遍历每一个土地，是1则开始广度搜索，同时将搜索到的土地标记为0，即不能再次访问，直到队列为空。</p><h2><span id="四-链表">四、链表</span></h2><h3><span id="反转链表">反转链表</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归解法</span></span><br><span class="line"><span class="function">ListNode* <span class="title">recurseWay</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head||!head-&gt;next)&#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode * newHead=recurseWay(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next=head;</span><br><span class="line">    head-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归解法</span></span><br><span class="line"><span class="function">ListNode* <span class="title">noRecurseWay</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* newHead=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        ListNode* nt=head-&gt;next;</span><br><span class="line">        head-&gt;next=newHead;</span><br><span class="line">        newHead=head;</span><br><span class="line">        head=nt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="五-树">五、树</span></h2><p>前序遍历：根节点—&gt;左子树—&gt;右子树</p><p>中序遍历：左子树—&gt;根节点—&gt;右子树</p><p>后序遍历：左子树—&gt;右子树—&gt;根节点</p><h3><span id="根据前序遍历和中序遍历结果构造二叉树">根据前序遍历和中序遍历结果构造二叉树</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">     TreeNode *left;</span><br><span class="line">     TreeNode *right;</span><br><span class="line">     TreeNode() : val(<span class="number">0</span>), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">     TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">     TreeNode(<span class="keyword">int</span> x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mySolution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rootval=preorder[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> n=inorder.<span class="built_in">size</span>();</span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> TreeNode(rootval);</span><br><span class="line">        <span class="keyword">int</span> r=<span class="built_in">find</span>(inorder.<span class="built_in">begin</span>(),inorder.<span class="built_in">end</span>(),rootval)-inorder.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorder1;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorder2;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder1;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;r;i++)&#123;</span><br><span class="line">            preorder1.push_back(preorder[<span class="number">1</span>+i]);</span><br><span class="line">            inorder1.push_back(inorder[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=r+<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            preorder2.push_back(preorder[i]);</span><br><span class="line">            inorder2.push_back(inorder[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;left=buildTree(preorder1,inorder1);</span><br><span class="line">        root-&gt;right=buildTree(preorder2,inorder2);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">officalSolution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; index;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=inorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            index[inorder[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myBuildTree(preorder,inorder,<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">myBuildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder,<span class="keyword">int</span> prel,<span class="keyword">int</span> prer,<span class="keyword">int</span> inl,<span class="keyword">int</span> inr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prel&gt;prer)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> TreeNode(preorder[prel]);</span><br><span class="line">        <span class="keyword">int</span> rooti=index[preorder[prel]];</span><br><span class="line">        <span class="keyword">int</span> leftLen=rooti-inl;</span><br><span class="line">        root-&gt;left=myBuildTree(preorder,inorder,prel+<span class="number">1</span>,prel+leftLen,inl,inl+leftLen<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right=myBuildTree(preorder,inorder,prel+leftLen+<span class="number">1</span>,prer,rooti+<span class="number">1</span>,inr);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据中序和后序遍历结果构造也是同理，只需要对上述做法微调即可。</p><h3><span id="层序遍历">层序遍历</span></h3><p>普通递归或者BFS都可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfsLevelOrder(root,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">myLevelOrder</span><span class="params">(TreeNode* root,<span class="keyword">int</span> level)</span></span>&#123; <span class="comment">//me</span></span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(level&gt;ans.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ls;</span><br><span class="line">                ls.push_back(root-&gt;val);</span><br><span class="line">                ans.push_back(ls);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans[level<span class="number">-1</span>].push_back(root-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            myLevelOrder(root-&gt;left,level+<span class="number">1</span>);</span><br><span class="line">            myLevelOrder(root-&gt;right,level+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">bfsLevelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123; <span class="comment">//Leetcode official</span></span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span> &lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> currentLevelSize = q.<span class="built_in">size</span>();</span><br><span class="line">            ret.push_back(<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; ());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= currentLevelSize; ++i) &#123; </span><br><span class="line">                <span class="comment">//这里的bfs与一般的不同，每次将当前循环中所有元素全部处理并出队，相当于处理完【一层】</span></span><br><span class="line">                <span class="keyword">auto</span> node = q.front(); q.pop();</span><br><span class="line">                ret.back().push_back(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3><span id="寻找最近公共祖先">寻找最近公共祖先</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==p||root==q)&#123; <span class="comment">//root和p或q中某个相等直接返回root</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* ansl=<span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* ansr=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ansl=lowestCommonAncestor(root-&gt;left,p,q); <span class="comment">//查询左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ansr=lowestCommonAncestor(root-&gt;right,p,q);<span class="comment">//查询右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ansl!=<span class="literal">nullptr</span>&amp;&amp;ansr!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root; <span class="comment">//都不为空，则一个在左子树，一个在右子树</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ansl!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ansl; <span class="comment">//只有一个为空则返回那个结果</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ansr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3><span id="树上最接近的两部分">树上最接近的两部分</span></h3><p>删除一条边使得分开的两部分节点之和最接近（差的绝对值最小）</p><p>思路：先求出每个子树的和并记录在对应节点的val中，再遍历每个节点找出答案</p><p><strong>最优子结构特性</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">similarTwoParts</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        getSum(root);</span><br><span class="line">        <span class="keyword">int</span> s=root-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> minsum=<span class="number">0x3fffff</span>;</span><br><span class="line">        findMax(root,minsum,s);</span><br><span class="line">        <span class="keyword">return</span> minsum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findMax</span><span class="params">(TreeNode* root,<span class="keyword">int</span> &amp;minsum,<span class="keyword">int</span> rootsum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val!=rootsum&amp;&amp;<span class="built_in">abs</span>(rootsum<span class="number">-2</span>*root-&gt;val)&lt;minsum)&#123;</span><br><span class="line">            minsum=<span class="built_in">abs</span>(rootsum<span class="number">-2</span>*root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        findMax(root-&gt;left,minsum,rootsum);</span><br><span class="line">        findMax(root-&gt;right,minsum,rootsum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;val=getSum(root-&gt;left)+getSum(root-&gt;right)+root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><span id="六-堆优先队列">六、堆（优先队列）</span></h2><p>堆：完全二叉树，且每个子树的根节点的值都是这个子树的最大值或者最小值</p><h3><span id="判断二叉树是否为堆">判断二叉树是否为堆</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; index;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLegalHeap</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否为完全二叉树</span></span><br><span class="line">        getIndex(root,<span class="number">0</span>);</span><br><span class="line">        sort(index.<span class="built_in">begin</span>(),index.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;index.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index[i]&gt;index[i<span class="number">-1</span>]+<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是否符合堆的性质</span></span><br><span class="line">        <span class="keyword">return</span> isBiggestLegalHeap(root)||isLeastLegalHeap(root); <span class="comment">//两个函数也可以增加一个变量来合并</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getIndex</span><span class="params">(TreeNode* root,<span class="keyword">int</span> i)</span></span>&#123; <span class="comment">//遍历二叉树获取每个非空元素的在堆中的序号</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        index.push_back(i);</span><br><span class="line">        getIndex(root-&gt;left,i*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        getIndex(root-&gt;right,i*<span class="number">2</span>+<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBiggestLegalHeap</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>&amp;&amp;root-&gt;left-&gt;val&gt;root-&gt;val||root-&gt;right!=<span class="literal">nullptr</span>&amp;&amp;root-&gt;right-&gt;val&gt;root-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isBiggestLegalHeap(root-&gt;left)&amp;&amp;isBiggestLegalHeap(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLeastLegalHeap</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>&amp;&amp;root-&gt;left-&gt;val&lt;root-&gt;val||root-&gt;right!=<span class="literal">nullptr</span>&amp;&amp;root-&gt;right-&gt;val&lt;root-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isLeastLegalHeap(root-&gt;left)&amp;&amp;isLeastLegalHeap(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3><span id="将二叉树转换为堆">将二叉树转换为堆</span></h3><p>改进的BFS<strong>层序遍历</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">transferHeapToList</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; heap;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> sz=q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;i++)&#123;</span><br><span class="line">                TreeNode* node=q.front();q.pop();</span><br><span class="line">                heap.push_back(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    q.push(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    q.push(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3><span id="合并k个有序链表">合并k个有序链表 ※※※</span></h3><p>维护这k个有序链表的头节点的优先队列（即最小堆）,每次从最小堆里弹出最小的节点并将他的链表后继节点加入堆中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span> <span class="comment">//LeetCode-Solution</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Status</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode *ptr;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Status &amp;rhs) <span class="keyword">const</span> &#123; <span class="comment">//重载运算符构造最小堆</span></span><br><span class="line">            <span class="keyword">return</span> val &gt; rhs.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    priority_queue &lt;Status&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> node: lists) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node) q.push(&#123;node-&gt;val, node&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode head, *tail = &amp;head; <span class="comment">//head.next指向总链表的头 tail为尾部</span></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> f = q.top(); q.pop();</span><br><span class="line">            tail-&gt;next = f.ptr; </span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (f.ptr-&gt;next) q.push(&#123;f.ptr-&gt;next-&gt;val, f.ptr-&gt;next&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3><span id="合并k个最小堆">合并k个最小堆</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Status</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Status &amp;rhs) <span class="keyword">const</span> &#123; <span class="comment">//重载运算符构造最小堆</span></span><br><span class="line">            <span class="keyword">return</span> val &gt; rhs.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    priority_queue &lt;Status&gt; q; <span class="comment">//将每个最小堆的首元素维护一个最小堆</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mergeKHeaps</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; heaps)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;heaps.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            q.push(&#123;i,heaps[i][<span class="number">0</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            ans.push_back(extractMin(heaps));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">extractMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; heaps)</span></span>&#123; <span class="comment">//返回一个堆顶的值，并做相应的各个堆的维护</span></span><br><span class="line">        <span class="comment">/* 以下写法错误，注意避免</span></span><br><span class="line"><span class="comment">        vector&lt;int&gt; heap=heaps[top.i];</span></span><br><span class="line"><span class="comment">        heap.pop_back();</span></span><br><span class="line"><span class="comment">        这样相当于新建了一个heap变量，没有对原heaps做修改</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Status</span> <span class="title">top</span>=<span class="title">q</span>.<span class="title">top</span>();</span>q.pop();</span><br><span class="line">        <span class="keyword">int</span> n=heaps[top.i].<span class="built_in">size</span>(); </span><br><span class="line">        <span class="keyword">int</span> tmp=heaps[top.i][n<span class="number">-1</span>];heaps[top.i][n<span class="number">-1</span>]=heaps[top.i][<span class="number">0</span>];heaps[top.i][<span class="number">0</span>]=tmp;</span><br><span class="line">        heaps[top.i].pop_back();</span><br><span class="line">        <span class="keyword">if</span>(!heaps[top.i].empty())&#123;</span><br><span class="line">            minHeapify(heaps[top.i],<span class="number">0</span>);</span><br><span class="line">            q.push(&#123;top.i,heaps[top.i][<span class="number">0</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> top.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">minHeapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heap,<span class="keyword">int</span> i)</span></span>&#123; <span class="comment">//维持最小堆</span></span><br><span class="line">        <span class="keyword">int</span> n=heap.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l=i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mini=i;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;n&amp;&amp;heap[l]&lt;heap[mini])&#123;</span><br><span class="line">            mini=l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> r=i*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;n&amp;&amp;heap[r]&lt;heap[mini])&#123;</span><br><span class="line">            mini=r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mini!=i)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=heap[i];heap[i]=heap[mini];heap[mini]=tmp;</span><br><span class="line">            minHeapify(heap,mini);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><span id="七-二叉查找树">七、二叉查找树</span></h2><h2><span id="八-图">八、图</span></h2><p>广度优先搜索遍历 DFS</p><p>深度优先搜索遍历 BFS</p><h2><span id="九-设计类问题">九、设计类问题</span></h2><h2><span id="十-贪心与分治">十、贪心与分治</span></h2><h3><span id="问题拆解与相应原则">问题拆解与相应原则 <font color="red">※※※</font></span></h3><p>如果子问题最优则原问题最优，贪心算法。</p><p>如果子问题需要全部求解才能求解原问题，子问题互相独立，分治算法。</p><p>如果子问题最优不能保证原问题最优，但是子问题之间不会循环（所谓循环，是指从问题 A 拆解出子问题 B，然后子问题 B 又能拆解出子问题 A），考虑动态规划算法。</p><p>更加复杂的情况，我们总是可以考虑暴力搜索解决。</p><h3><span id="分发饼干">分发饼干</span></h3><p>先将需求数组g和尺寸数组s排序，然后对于每一个孩子的需求都<strong>寻找到最小的符合需求的饼干</strong>进行满足</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; g, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        sort(g.<span class="built_in">begin</span>(),g.<span class="built_in">end</span>());</span><br><span class="line">        sort(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> n=g.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;n&amp;&amp;j&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]&lt;g[i])&#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3><span id="用最少数量的箭引爆气球">用最少数量的箭引爆气球</span></h3><p>遇到区间类的贪心问题，都先考虑排序，一般按照左端点或者右端点排序，控制复杂度为 $O(n\lg n)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">point</span>;<span class="comment">//坐标</span></span><br><span class="line">        <span class="keyword">int</span> type; <span class="comment">//0:begin 1:end</span></span><br><span class="line">        <span class="keyword">int</span> pos;  <span class="comment">//编号</span></span><br><span class="line">    &#125; Node;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node x,Node y)</span></span>&#123; <span class="comment">//将所有节点进行排序，坐标小的靠前，坐标一致将起点置于前</span></span><br><span class="line">        <span class="keyword">return</span> x.<span class="built_in">point</span>&lt;y.<span class="built_in">point</span>?<span class="literal">true</span>:</span><br><span class="line">               x.<span class="built_in">point</span>&gt;y.<span class="built_in">point</span>?<span class="literal">false</span>:</span><br><span class="line">               x.type==<span class="number">0</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node&gt; nodes;</span><br><span class="line">        <span class="keyword">int</span> n=points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">exist</span><span class="params">(n,<span class="number">0</span>)</span></span>; <span class="comment">//表示每个编号的气球是否已经被射爆</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; targets; <span class="comment">//当前可以被一次射中的全部气球编号</span></span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            nodes.push_back(&#123;points[i][<span class="number">0</span>],<span class="number">0</span>,i&#125;);</span><br><span class="line">            nodes.push_back(&#123;points[i][<span class="number">1</span>],<span class="number">1</span>,i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nodes.<span class="built_in">begin</span>(),nodes.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> node:nodes)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.type==<span class="number">0</span>)&#123;</span><br><span class="line">                targets.push(node.pos); <span class="comment">//起点，直接进队</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(!exist[node.pos])&#123;   <span class="comment">//终点且这个气球没被射爆</span></span><br><span class="line">                    ans++;</span><br><span class="line">                    <span class="keyword">while</span>(!targets.empty())&#123; <span class="comment">//全部出队并设置为已射爆</span></span><br><span class="line">                        exist[targets.front()]=<span class="number">1</span>;</span><br><span class="line">                        targets.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3><span id="快速幂">快速幂</span></h3><p>例子：$3^{15}$  $15=(1111)_2 $  $3^{15}=3^{1+2+4+8}$</p><p>分治算法的经典例子</p><p>可以延申求矩阵快速幂，用于动态规划的加速</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> N=n;</span><br><span class="line">        <span class="keyword">return</span> n&gt;=<span class="number">0</span>?quickMul_recursion(x,n):<span class="number">1</span>/quickMul_recursion(x,-N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">quickMul_recursion</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">long</span> <span class="keyword">long</span> n)</span></span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> y=quickMul_recursion(x,n/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> n%<span class="number">2</span>==<span class="number">1</span>?y*y*x:y*y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">long</span> <span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> x_exp=x;</span><br><span class="line">        <span class="keyword">double</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>) ans*=x_exp;</span><br><span class="line">            x_exp*=x_exp;</span><br><span class="line">            n/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3><span id="排序链表">排序链表</span></h3><p>$O(n\lg n)$ 时间复杂度与常数空间复杂度情况下完成链表排序</p><p>分治算法，先拆分再合并，类似归并排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* odd=<span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* even=<span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* podd=<span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* peven=<span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//先将原链表拆分成奇数位置链表和偶数位置链表两个链表</span></span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!even) even=p;</span><br><span class="line">                <span class="keyword">else</span> peven-&gt;next=p;</span><br><span class="line">                peven=p;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(!odd) odd=p;</span><br><span class="line">                <span class="keyword">else</span> podd-&gt;next=p;</span><br><span class="line">                podd=p;</span><br><span class="line">            &#125;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(podd) podd-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(peven) peven-&gt;next=<span class="literal">nullptr</span>; <span class="comment">//此处不能忘记把当前的指针的下一个设为NULL，否则会一直循环</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;=<span class="number">1</span>) <span class="keyword">return</span> head; <span class="comment">//长度小于等于1时直接返回原指针</span></span><br><span class="line">        <span class="comment">//合并sort后的奇数子表和偶数子表</span></span><br><span class="line">        <span class="keyword">return</span> mergeNode(sortList(even),sortList(odd));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeNode</span><span class="params">(ListNode* p,ListNode* q)</span></span>&#123;</span><br><span class="line">        ListNode* ans=<span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(p||q)&#123; <span class="comment">//比较两个头指针，每次将小的加入到答案链表中</span></span><br><span class="line">            <span class="keyword">if</span>(!q||(p&amp;&amp;(p-&gt;val&lt;q-&gt;val)))&#123;</span><br><span class="line">                <span class="keyword">if</span>(!ans) ans=p;</span><br><span class="line">                <span class="keyword">else</span> cur-&gt;next=p;</span><br><span class="line">                cur=p;</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(!ans) ans=q;</span><br><span class="line">                <span class="keyword">else</span> cur-&gt;next=q;</span><br><span class="line">                cur=q;</span><br><span class="line">                q=q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        cur-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3><span id="数组中出现次数超过一半的数字">数组中出现次数超过一半的数字</span></h3><p>分治：子问题为在子数组中出现次数超过一半的数，最后将左右两个子数组的结果合并</p><p>贪心：摩尔投票，利用抵消的方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//my code</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; num2cnt;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            num2cnt[nums[i]]++;</span><br><span class="line">            <span class="keyword">if</span>(num2cnt[nums[i]]&gt;n/<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//贪心 摩尔投票法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> m=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==n) cnt++;<span class="comment">//相同，次数++</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt==<span class="number">0</span>)&#123; <span class="comment">//不相同 若已经到了0，则更换答案，没到0就--</span></span><br><span class="line">                    n=nums[i];</span><br><span class="line">                    cnt=<span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><span id="十一-常用排序算法">十一、常用排序算法</span></h2><p>冒泡排序，归并排序，快速排序，桶排序，堆排序</p><h3><span id="对角线遍历-ii">对角线遍历 II</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> s;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">    &#125;Node; <span class="comment">//s=x+y </span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node x,Node y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.s&lt;y.s?<span class="literal">true</span>:</span><br><span class="line">               x.s&gt;y.s?<span class="literal">false</span>:</span><br><span class="line">               x.y&lt;y.y?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDiagonalOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node&gt; tmp;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                tmp.push_back(&#123;i+j,j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(tmp.<span class="built_in">begin</span>(),tmp.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:tmp)&#123;</span><br><span class="line">            ans.push_back(nums[x.s-x.y][x.y]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3><span id="最大间距">最大间距</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maximumGap_normal(nums);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumGap_normal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123; <span class="comment">//暴力解法</span></span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>,n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,nums[i+<span class="number">1</span>]-nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumGap_Bucketsort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123; <span class="comment">//桶排序方式 这样实现比暴力还慢，不太行</span></span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minx=*min_element(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> maxx=*max_element(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>)<span class="keyword">return</span> maxx-minx; <span class="comment">//只有两个元素，返回两者最大值</span></span><br><span class="line">        <span class="keyword">int</span> d=<span class="built_in">ceil</span>((<span class="keyword">double</span>)(maxx-minx)/(n<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">if</span>(maxx==minx)<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//考虑数组全相等的情况，防止之后d=0出现错误</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">minBuc</span><span class="params">(n<span class="number">-1</span>,maxx+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxBuc</span><span class="params">(n<span class="number">-1</span>,minx<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">ap</span><span class="params">(n<span class="number">-1</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> pos=(nums[i]-minx)/d;</span><br><span class="line">            <span class="keyword">if</span>(pos&gt;=n<span class="number">-1</span>)pos=n<span class="number">-2</span>; <span class="comment">//这里要注意最大值可能会等于minx+(n-1)d 如果不设成n-2会出错</span></span><br><span class="line">            <span class="keyword">if</span>(!ap[pos])ap[pos]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(minBuc[pos]&gt;nums[i])minBuc[pos]=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(maxBuc[pos]&lt;nums[i])maxBuc[pos]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=d;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!ap[i])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> j=i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;n<span class="number">-1</span>&amp;&amp;!ap[j])j++;</span><br><span class="line">            <span class="keyword">if</span>(j==n<span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,minBuc[j]-maxBuc[i]);</span><br><span class="line">            i=j<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3><span id="有效的字母异位词">有效的字母异位词</span></h3><p>判断两个单词的每个字母出现次数是否均一样</p><p>采用桶排序，也可以理解为使用标记数组或hash表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnts[<span class="number">26</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> cntt[<span class="number">26</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cnts[s[i]-<span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        n=t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cntt[t[i]-<span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnts[i]!=cntt[i])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2><span id="十二-trie-树和kmp-算法">十二、Trie 树和KMP 算法</span></h2><h1><span id="labuladong算法小抄笔记">《labuladong算法小抄》笔记</span></h1><h2><span id="一-语言基础">一、语言基础</span></h2><h3><span id="c">C++</span></h3><p>传参用<code>&amp;</code>表示引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;int,int&gt; p(1,2);</span><br><span class="line">cout&lt;&lt;p.first&lt;&lt;p.second;</span><br></pre></td></tr></table></figure><h4><span id="1动态数组vector">1.动态数组vector</span></h4><p><a href="https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html</a></p><p><a href="https://www.cnblogs.com/maluning/p/8570717.html" target="_blank" rel="noopener">https://www.cnblogs.com/maluning/p/8570717.html</a></p><h5><span id="初始化">初始化</span></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n=<span class="number">7</span>,m=<span class="number">8</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>; <span class="comment">//数组中全部为0</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;; <span class="comment">//初始化为1,3,5</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(n,<span class="number">2</span>)</span></span>; <span class="comment">//初始化一个长度为n且全为2的数组</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp; <span class="comment">//初始一个二维数组</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(m,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n,<span class="literal">true</span>))</span></span>; <span class="comment">//初始一个m*n的二维布尔数组 且值全为true</span></span><br></pre></td></tr></table></figure><h5><span id="成员函数">成员函数</span></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="comment">//返回是否为空</span></span></span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span></span>; <span class="comment">//返回大小</span></span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span></span>; <span class="comment">//返回最后一个值的引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>; <span class="comment">//尾部插入一个元素val</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>; <span class="comment">//删除尾部元素</span></span><br><span class="line">erase(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator);</span><br></pre></td></tr></table></figure><h4><span id="2字符串string">2.字符串string</span></h4><h5><span id="初始化">初始化</span></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s; <span class="comment">//s--&gt;""</span></span><br><span class="line"><span class="built_in">string</span> s=<span class="string">"abc"</span>;</span><br></pre></td></tr></table></figure><h5><span id="成员函数">成员函数</span></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">char</span> c)</span></span>; <span class="comment">//尾部插入一个字符c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>; <span class="comment">//删除尾部字符</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">substr</span><span class="params">(<span class="keyword">size_t</span> pos,<span class="keyword">size_t</span> len)</span></span>; <span class="comment">//获得pos开始的长度为len的子串</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s1==s2; <span class="comment">//看两字符串是否相等</span></span><br></pre></td></tr></table></figure><h4><span id="3哈希表unordered_map">3.哈希表unordered_map</span></h4><h5><span id="初始化">初始化</span></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mapping; <span class="comment">//key and value both int</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; mapping; <span class="comment">//key is string,value is int</span></span><br></pre></td></tr></table></figure><h5><span id="成员函数">成员函数</span></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span></span>; <span class="comment">//返回键值对个数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>;<span class="comment">//是否为空</span></span><br><span class="line"><span class="function">size_type <span class="title">count</span> <span class="params">(<span class="keyword">const</span> key_type&amp; key)</span></span>; <span class="comment">//返回key在map中出现次数,由于哈希表，这个值只能是0/1，因此本函数用于判断key是否在哈希表中</span></span><br><span class="line"><span class="function">size_type <span class="title">erase</span><span class="params">(<span class="keyword">const</span> key_type&amp; key)</span></span>; <span class="comment">//清除一个键值对</span></span><br></pre></td></tr></table></figure><h5><span id="常见操作">常见操作</span></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; counter;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">    counter[num]++; <span class="comment">//如果键值num本来不存在，则相当于是初始化为0后再+1:counter[num]=0;counter[num]++;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; it:counter)&#123;</span><br><span class="line">    <span class="keyword">int</span> key=it.first;</span><br><span class="line">    <span class="keyword">int</span> value=it.second;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;key&lt;&lt;<span class="string">":"</span>&lt;&lt;value&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="4哈希集合unordered_set">4.哈希集合unordered_set</span></h4><h5><span id="初始化">初始化</span></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; visited;</span><br></pre></td></tr></table></figure><h5><span id="成员函数">成员函数</span></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span></span>; <span class="comment">//返回元素的个数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>;<span class="comment">//是否为空</span></span><br><span class="line"><span class="function">size_type <span class="title">count</span> <span class="params">(<span class="keyword">const</span> key_type&amp; key)</span></span>; <span class="comment">//类似哈希表</span></span><br><span class="line">pair&lt;iterator,bool&gt; insert(const key_type&amp; key);//插入元素</span><br><span class="line"><span class="function">size_type <span class="title">erase</span><span class="params">(<span class="keyword">const</span> key_type&amp; key)</span></span>;<span class="comment">//删除元素</span></span><br></pre></td></tr></table></figure><h4><span id="5队列queue">5.队列queue</span></h4><h5><span id="初始化">初始化</span></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;</span><br></pre></td></tr></table></figure><h5><span id="成员函数">成员函数</span></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span></span>; <span class="comment">//返回队列元素的个数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>;<span class="comment">//队列是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp;val)</span></span>; <span class="comment">//加入元素到队尾</span></span><br><span class="line"><span class="function">value_type&amp; <span class="title">front</span><span class="params">()</span></span>; <span class="comment">//获得队头元素引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">//删除队头元素</span></span><br><span class="line"><span class="keyword">int</span> e=q.front();q.pop(); <span class="comment">//获得队头元素并出队,注意,pop()是直接删除,不会返回队头元素</span></span><br></pre></td></tr></table></figure><h4><span id="51双向队列deque">5.1双向队列deque</span></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> value_type&amp;val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> value_type&amp;val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">value_type&amp; <span class="title">front</span><span class="params">()</span></span>;back();</span><br></pre></td></tr></table></figure><h4><span id="6堆栈stack">6.堆栈stack</span></h4><h5><span id="初始化">初始化</span></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; stk;</span><br></pre></td></tr></table></figure><h5><span id="成员函数">成员函数</span></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span></span>; <span class="comment">//返回堆栈元素的个数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>;<span class="comment">//堆栈是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp;val)</span></span>; <span class="comment">//加入元素到栈顶</span></span><br><span class="line"><span class="function">value_type&amp; <span class="title">top</span><span class="params">()</span></span>; <span class="comment">//获得栈顶元素引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">//删除栈顶元素</span></span><br></pre></td></tr></table></figure><h3><span id="java">Java</span></h3><h4><span id="1数组">1.数组</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m=<span class="number">5</span>,n=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>[] nums=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">boolean</span>[][] visited=<span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">nums.length --&gt;获得数组长度</span><br></pre></td></tr></table></figure><h4><span id="2字符串string">2.字符串String</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="string">"Hello,world"</span>;</span><br><span class="line"><span class="keyword">char</span> c=s1.charAt(<span class="number">2</span>); <span class="comment">//返回字符串中第2个字符</span></span><br><span class="line"><span class="keyword">char</span>[] chars=s1.toCharArray();  <span class="comment">//字符串转字符数组</span></span><br><span class="line">chars[<span class="number">1</span>]=<span class="string">'a'</span>;</span><br><span class="line">String s2=<span class="keyword">new</span> String(chars); <span class="comment">//字符数组转字符串</span></span><br><span class="line">System.out.println(s2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(s1.equals(s2))&#123;</span><br><span class="line">    <span class="comment">//s1==s2</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//s1!=s2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String s3=s1+<span class="string">"!"</span>; <span class="comment">//+的效率比较低</span></span><br><span class="line">StringBuilder sb=<span class="keyword">new</span> StringBuilder(); <span class="comment">//一般用StringBuilder append方法好一点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">char</span> c=<span class="string">'a'</span>;c&lt;<span class="string">'f'</span>;c++)&#123;  </span><br><span class="line">    sb.append(c);</span><br><span class="line">&#125;</span><br><span class="line">sb.append(<span class="string">'a'</span>).append(<span class="string">"avx"</span>).append(<span class="number">1234</span>) <span class="comment">//支持拼接字符串，字符，数字</span></span><br><span class="line">    </span><br><span class="line">String s=sb.toString();<span class="comment">//转为字符串类型</span></span><br><span class="line"><span class="comment">//注:字符串比较尽量用s.equals(s1),否则可能出意想不到的问题</span></span><br></pre></td></tr></table></figure><h4><span id="3动态数组arraylist">3.动态数组ArrayList</span></h4><p>类似<code>C++</code>的<code>vector</code></p><p><code>E</code>代表元素,下同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; nums=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">ArrayList&lt;Integer&gt; strings=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>; <span class="comment">//获得数组大小</span></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>; <span class="comment">//获得index处元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>; <span class="comment">//尾部添加元素</span></span><br></pre></td></tr></table></figure><h4><span id="4双链表linkedlist">4.双链表LinkedList</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;String&gt; strings=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>; <span class="comment">//获得数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>; <span class="comment">//时间复杂度为O(n),比较慢</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addFirst</span><span class="params">(E e)</span></span>; <span class="comment">//头部添加元素</span></span><br><span class="line"><span class="function">E <span class="title">removeFirst</span><span class="params">()</span></span>;<span class="comment">//delete first element</span></span><br><span class="line"><span class="function">E <span class="title">removeLast</span><span class="params">()</span></span>;<span class="comment">//delete last element</span></span><br></pre></td></tr></table></figure><h4><span id="5哈希表hashmap">5.哈希表HashMap</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer,String&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">HashMap&lt;String,<span class="keyword">int</span>[]&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">//字符串到数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常用方法</span></span><br><span class="line"><span class="comment">//K代表键值，V代表类型</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span></span>; <span class="comment">//判断是否存在键key</span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(Object key)</span></span>;<span class="comment">//获得key对应value值</span></span><br><span class="line"><span class="function">V <span class="title">put</span><span class="params">(K key,V value)</span></span>; <span class="comment">//存入哈希表</span></span><br><span class="line"><span class="function">V <span class="title">remove</span><span class="params">(Object key)</span></span>; <span class="comment">//删除key并返回对应值</span></span><br><span class="line"><span class="function">V <span class="title">getOrDefault</span><span class="params">(Object key,defaultValue)</span> <span class="comment">//返回key对应value值，不存在则返回default值</span></span></span><br><span class="line"><span class="function">Set&lt;k&gt; <span class="title">keySet</span><span class="params">()</span> <span class="comment">//获得Hash表中所有key</span></span></span><br><span class="line"><span class="function">V <span class="title">putIfAbsent</span><span class="params">(K key,V value)</span></span>;<span class="comment">//存在则不做事,不存在就插入</span></span><br></pre></td></tr></table></figure><h4><span id="6哈希集合hashset">6.哈希集合HashSet</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">//init</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>; <span class="comment">//add an element</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>; <span class="comment">//集合是否存在元素o</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>; <span class="comment">//若o存在则删除</span></span><br></pre></td></tr></table></figure><h4><span id="7队列queue">7.队列Queue</span></h4><p><code>Queue</code>是一个接口,初始化方式相对特别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;String&gt; q=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span></span>; <span class="comment">//返回队头元素</span></span><br><span class="line"><span class="function">E <span class="title">poll</span><span class="params">()</span></span>; <span class="comment">//删除并返回队尾元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>; <span class="comment">//将元素e插入队尾</span></span><br></pre></td></tr></table></figure><h4><span id="8堆栈stack">8.堆栈Stack</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;integer&gt; s=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">push</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span></span>; <span class="comment">//返回栈顶元素</span></span><br><span class="line"><span class="function">E <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">//删除并返回栈顶元素</span></span><br></pre></td></tr></table></figure><h3><span id="python">Python</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list</span><br><span class="line">tuple</span><br><span class="line">set</span><br><span class="line">dict</span><br></pre></td></tr></table></figure><h2><span id="二-核心套路">二、核心套路</span></h2>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据科学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记</title>
      <link href="2021/07/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>2021/07/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2><span id="岛上书店">《岛上书店》</span></h2><p><img src="/2021/07/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/岛上书店.png" style="zoom:33%;"></p><p><strong>作者</strong>：加·泽文 （美）</p><p><strong>初次阅读时间</strong>：2021.7.1</p><p><strong>简述</strong>：讲述了中年鳏夫<strong>A·J费克里</strong>的故事。<strong>阿米莉娅</strong>因为到岛上书店推销书籍与他结识，初次见面两人并不投机。之后的日子里，养女<strong>玛雅</strong>的出现让本来沉浸于丧妻之痛的A·J振作起来，之后的日子里，他不仅重拾了生活的信心，还用自己的善意帮助着警察兰比亚斯找到了对阅读的兴趣，成功撮合了妻姐伊斯梅和兰比亚斯的婚姻，最终也用真诚和对书的热爱成功牵手艾米(阿米莉娅)，每个人的生活都迎来了转机。</p><h3><span id="书评摘录">书评摘录</span></h3><p>每个人的生命中，都有着无比艰难的那一年，将人生变得美好而辽阔</p><p>岛上书店是间维多利亚风格的小屋，门廊上挂着褪色的招牌，上面写着：<strong>没有谁是一座孤岛，每本书都是一个世界</strong></p><p>《岛上书店》写的是书店老板的一生，但真正讲述的，是全人类的阅读，生活和爱。</p><p>爱与被爱的能力，付出与接受的意愿，能拯救陷于孤独绝境中的我们。</p><h3><span id="语句摘录">语句摘录</span></h3><p>扉页：来吧，亲爱的，且让我们来相爱，趁你我尚在人世。——鲁米</p><p>尾页：我们不全是长篇小说，也不全是短篇故事，最后的最后，我们成为一部人生故事集</p><p>无人为孤岛；一书一世界</p><h3><span id="亮点记录">亮点记录</span></h3><p>书中的书，以书名作为章节名，一共有13章，也对应了13本书</p><p>看似书名和小说情节关系不大，实则每一章都和对应书的内容有重合之处</p><h4><span id="1一根羊腿成为了杀夫的工具待宰的羔羊-罗尔德达尔-英国作家-詹姆斯与巨桃-查理与巧克力工厂-童书创作">1.一根羊腿，成为了杀夫的工具——《待宰的羔羊》 罗尔德·达尔 英国作家 《詹姆斯与巨桃》 《查理与巧克力工厂》 童书创作</span></h4><p>主人公刚刚经历了丧气的痛苦，就像只待宰的羔羊，无情的被生活所摧残</p><h4><span id="2钻石制作的小镇里每个人的故事像里兹饭店那样大的钻石菲茨杰拉德">2.钻石制作的小镇里每个人的故事——《像里兹饭店那样大的钻石》菲茨杰拉德</span></h4><p>主要讲述了艾丽丝岛每个人的大致情况</p><h4><span id="3采矿营里收养了一个印第安人宝宝咆哮营里的幸运儿-布莱特哈特">3.采矿营里收养了一个印第安人宝宝——《咆哮营里的幸运儿》 布莱特·哈特</span></h4><p>玛雅被遗落在书店里，AJ开始了父亲之旅</p><h4><span id="4和爷爷一起生活的胖女孩参加体操训练并去表演世界的感觉理查德鲍什">4.和爷爷一起生活的胖女孩参加体操训练，并去表演——《世界的感觉》理查德·鲍什</span></h4><p>AJ与可爱女儿的亲情故事</p><h4><span id="5全家出游出了岔子好人难寻-弗兰纳里奥康纳">5.全家出游出了岔子——《好人难寻》 弗兰纳里·奥康纳</span></h4><p>AJ开始追求阿米莉娅</p><p>意趣相投是多么重要</p><p>关于政治，上帝和爱，人们都讲些无聊的谎话。想要了解一个人，你只需要问一个问题：“你最喜欢哪本书？”</p><h4><span id="6嗜赌之人与其被打败的青蛙卡拉维拉县驰名的跳蛙-马克吐温">6.嗜赌之人与其被打败的青蛙——《卡拉维拉县驰名的跳蛙》 马克吐温</span></h4><p>AJ和艾米结婚了</p><p>吐温信笔书写的文字，他自己比读者更快乐</p><h4><span id="7穿夏裙的女孩-欧文肖">7.《穿夏裙的女孩》 欧文·肖</span></h4><p>兰比亚斯开始喜欢伊斯梅，丹尼尔在车祸中去世，在自己小说中的描写里离去。这个穿夏裙的女孩，指当年的玛丽安，现在的伊斯梅，也指一切正在追求美好爱情的姑娘们。</p><p>要是有谁觉得你在一屋子人中是独一无二的，就选那个人吧！</p><h4><span id="8垂死的父亲和女儿争论何为讲故事的最佳方式与父亲的对话-格雷斯佩利">8.垂死的父亲和女儿争论何为讲故事的最佳方式——《与父亲的对话》  格雷斯·佩利</span></h4><p>玛雅的创意写作过程</p><h4><span id="9逮香蕉鱼的最佳日子-jd塞林格">9.《逮香蕉鱼的最佳日子》—— J·D塞林格</span></h4><p>《海滩一日》还原了玛雅母亲玛丽安的遭遇，平淡温和的笔触中，蕴含着巨大的悲怆感</p><h4><span id="10泄密的心埃德加爱伦坡">10.《泄密的心》——埃德加·爱伦·坡</span></h4><p>兰比亚斯知道了当年那本《帖木尔》在伊斯梅这。</p><h4><span id="11铁头艾梅本德">11.《铁头》——艾梅·本德</span></h4><p>AJ看病发现了自己的肿瘤</p><h4><span id="12当我们在谈论爱情时我们在谈论什么雷蒙德卡佛">12.《当我们在谈论爱情时我们在谈论什么》——雷蒙德·卡佛</span></h4><p>作家无法真正描写一间病房，尤其是当你所爱之人住在里面。</p><p>我们写我们不喜爱、讨厌、承认有缺点的事物，要比写我们喜爱的事物容易的多。</p><h4><span id="13书店老板罗尔德达尔">13.《书店老板》——罗尔德·达尔</span></h4><p>书店老板的意义何在呢？跟人沟通</p><h2><span id="杀死一只知更鸟">《杀死一只知更鸟》</span></h2><p><img src="/2021/07/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/杀死一只知更鸟.jpeg" style="zoom:50%;"></p><p>作者：哈珀·李 （美）</p><h3><span id="语句摘录">语句摘录</span></h3><p>第一部</p><p>“这并不恶劣啊，只是刺激它一下罢了——又不是把它扔到火堆里。”杰姆愤愤不平地咕哝道。“你怎么知道火柴不会伤着它？”“傻瓜，乌龟感觉不到疼。”“哈！你当过乌龟？”</p><p>那座老房子丝毫未变，还是一副没精打采的样子，但是当我们隔着街道凝望着它，似乎看到里面的百叶窗动了一下。飞快的一闪。那么轻微，几乎让人察觉不到，然后整座房子又归于死寂。</p><p>第二章</p><p>九月初，迪尔离开我们，回默里迪恩去了。我们送他上了五点钟的长途汽车。没有了他，我有些闷闷不乐，幸好想起再过一个星期我就要上学了。我还从来没有这么急切地盼望过什么。冬天，我经常在树屋里一待就是好几个钟头，往学校操场张望，用杰姆给我的双倍望远镜悄悄观察那一大群孩子，偷学他们正在玩的游戏；有时候他们围成一个个圆圈玩“摸人”游戏，我就在那扭来扭去的一个个圆圈里追踪杰姆的红夹克，暗自分享他们的坏运气和小小的胜利。我渴望加入到他们中间。 开学第一天，杰姆屈尊带我去学校——一般来说，这是父母亲的职责，可是阿迪克斯说，杰姆很乐意把我送到教室里。我猜想，在这桩交易中，肯定有钱在他们两人之间秘密转手，因为当我们小跑着经过拉德利家附近的拐角时，我听见杰姆的口袋里发出一种奇怪的叮当声。快到校园的时候，我们慢下了脚步，杰姆不厌其烦地向我做交代：在学校期间，我不能去打扰他，不能找他一起扮演一段《人猿泰山与蚁人》，不能提起他的私生活让他感到尴尬，也不能在课间和中午休息的时候像尾巴一样跟在他身后；我必须和一年级学生待在一起，而他必须和五年级学生待在一起。总而言之，我绝对不能去找他。 “你的意思是，我们俩再也不能一起玩了吗？”我问。 “在家里我们还照常一起玩，”他说，“可学校完全是另一回事儿——你会明白的。” 果不其然。第一天上午还没结束，我们的老师卡罗琳·费希尔小姐就把我揪到教室前面，用一把尺子打了我的手掌心，还让我站在墙角，一直到中午。 卡罗琳小姐顶多才二十一岁。她长着一头光滑的红褐色头发，脸颊白里透红，指甲涂成了深红色。她脚踩高跟鞋，身穿一条红白条纹的裙子，不论是看上去还是闻起来都像一颗薄荷糖。她寄宿在我们家斜对面的莫迪·阿特金森小姐家，住的是楼上的正房。莫迪小姐第一次把我们介绍给她的时候，杰姆一连好几天都像是在云里雾里。 卡罗琳小姐用印刷体把自己的名字写在黑板上，说：“这是我的名字：卡罗琳·费希尔。我来自北亚拉巴马州的温斯顿县。”教室里立刻响起了一阵不安的嘀嘀咕咕声，因为大家担心她将来会暴露出与生俱来的地域特征。（亚拉巴马州于一八六一年一月十一日宣布脱离联邦政府的时候，温斯顿县也从亚拉巴马州脱离了出去——这在梅科姆是每个孩子都知道的事实。）</p><p>第三章</p><p>你永远也不可能真正了解一个人，除非你站在他的角度考虑问题……”</p><p>第七章</p><p>去掉那些形容词，剩下的就是事实了。</p><p>第十章</p><p>我本以为疯狗都是口吐白沫，上蹿下跳，见人就扑上去撕咬喉咙，而且还以为只有在八月份疯狗才会发作。如果蒂姆·约翰逊也是那样的话，我可能就不会这么害怕了。</p><p>空荡荡的街道上，人们心惊胆战地等待危险来临——没有什么比这更要命的了。树木纹丝不动，知更鸟静默无声，给莫迪小姐盖房子的木工也都四散而去。我听见泰特先生吸了几下鼻子，又擤了擤鼻子。我看见他把枪换了个位置，夹在臂弯里。我看见斯蒂芬妮小姐把脸贴在她家前门的玻璃上，莫迪小姐也冒了出来，站在她身旁。阿迪克斯把一只脚踏在椅子的横档上，手放在大腿外侧，慢慢向下摩挲。</p><p>第十一章</p><p>空气中已经有了一丝夏天的气息——背阴的地方还有些凉意，但是太阳已经暖洋洋的了，这意味着好时光即将到来：暑假，还有迪尔。</p><p>我在接受他人之前，首先要接受自己。有一种东西不能遵循从众原则，那就是人的良心。</p><p>勇敢就是，在你还没开始的时候就知道自己注定会输，但依然义无反顾地去做，并且不管发生什么都坚持到底。一个人很少能赢，但也总会有赢的时候。杜博斯太太赢了，全凭她那九十八磅重的身躯。用她的话来说，她死得无牵无挂，不亏欠任何人，也不依赖任何东西。她是我见过的最勇敢的人。”</p><p>第二部</p><p>“一个人没必要把自己懂的东西都展现出来。这不是淑女的做派——再说了，人们不喜欢他们身边有什么人比他们懂得多。这会让他们气不打一处来。你使用的语言再标准，也改变不了他们。除非他们自己想学，否则一点儿办法也没有。你要么闭上嘴巴，要么跟他们说一样的话。”</p><p>第十三章</p><p>我说自己非常高兴，其实这是个谎言，可是在特定情况下，还有在无能为力的时候，人不得不撒谎。</p><p>我不明白她为什么对遗传这么痴迷。我也不知道自己从哪儿得来这样一个印象：“优秀的人”就是凭自己的心智尽力而为的人，而姑姑半遮半掩地表达过她的观点，那就是——一个家族守在一块土地上的时间越长，这个家族就越优秀。“照这么来说，尤厄尔家算是优秀人等啰。”杰姆说道。</p><p>第十五章</p><p>“你真是这么认为的吗？”这是一句杀伤力极强的问话。</p><p>阿迪克斯开着这辆车出差，跑过不少路，不过他每天上下班，来回四趟，加起来差不多有两英里，都是走路往返。他说走路是他唯一的运动。在梅科姆，要是某个人毫无目的地在路上行走，那么就可以准确无误地断定这个人的脑子不是很清楚。</p><p>阿迪克斯说过，与人交谈的礼貌做法是谈论对方感兴趣的事情，而不是大谈特谈自己的兴趣点。</p><p>第十六章</p><p>那场面真像是过节。公共拴马栏里已经挤得满满当当，每棵树下都拴着骡子和大车。县政府大楼所在的广场上到处都是坐在报纸上就餐的人。有的正就着罐头瓶里装的热牛奶吞下糖浆饼，还有的在大啃冷鸡肉和炸猪排。手头宽裕一点儿的人从杂货店里买来装在大肚饮料瓶里的可口可乐，边吃边喝。满脸油渍的孩子们在人群里窜来窜去，玩“抽鞭子”游戏，婴儿们在母亲怀里吃他们的午饭。在广场远处的一个角落里，黑人们静静地坐在太阳底下，嚼着沙丁鱼和饼干，喝着味道更冲的“尼海”可乐[插图]。多尔夫斯·雷蒙德先生也和他们坐在一起。</p><p>他当然不是，河对岸的所有土地都是属于他的，还有一点我要告诉你，他出身于一个真正的世家。”</p><p>哇，当然愿意。”杰姆答道。我们兴高采烈地跑在塞克斯牧师前面冲进了法庭，又上了一段后楼梯，然后停在门口等着。塞克斯牧师气喘吁吁地赶了上来，小心地引导我们穿过看台上的黑人观众。有四个黑人主动站起来，把他们的前排座位让给了我们。</p><p>地方检察官面前的桌子上摆放着一本褐色的书，还有几本黄色笔记簿；阿迪克斯的桌上空空如也。 </p><p>第十七章</p><p>他是个秃顶，脸颊光溜溜的，年龄呢，可以是四十到六十之间的任何一个数字。虽然他此时背对着我们，我们也知道他有一只眼睛略微有点儿斜视，不过他把这个缺陷转化成了自己的优势：有时候他似乎在盯着某个人，但实际上全无此意，就因为这个，陪审员和证人都畏惧他三分。陪审员们以为自己正处在密切监视之下，会更加专心致志；证人们也一样，因为他们也有同样的错觉。</p><p>第十八章</p><p>“阿迪克斯，我们继续吧，法庭记录上要写明证人没有受到无礼对待，她的想法和事实恰恰相反。”</p><p>我心里暗想，她长这么大，有人用“女士”或者“马耶拉小姐”称呼过她吗？估计从来没有过，因为她把日常礼仪都当成了一种冒犯。她究竟过着什么样的生活呢？这个问题很快就有了答案。</p><p>慢慢地，阿迪克斯问这些问题的意图越来越清晰地显现在我头脑中：通过问一些不会让吉尔莫先生认为与本案无关或者微不足道而提出反对的问题，阿迪克斯不露声色地在陪审团面前勾勒出一幅尤厄尔家家庭生活的图景。陪审团了解到如下情况</p><p>马耶拉的敌对情绪本来已经平息了许多，变成了默默的怨恨，这下子又爆发了。“芬奇先生，你又在取笑我吗？”</p><p>第十九章</p><p>“我才不管呢。反正那样做不对，不应该用那种态度对待他们。谁也没有权利用那种口气对人说话——简直让人恶心透了。”</p><p>第二十章</p><p>我们又朝楼下望去。阿迪克斯正讲得如行云流水一般，带着一种超然物外的态度，跟他口授信件的时候一样。他在陪审团面前慢慢地来回踱步，而那些陪审团成员似乎在全神贯注地倾听：他们仰着头，目光始终追随着阿迪克斯，眼睛里仿佛流露出欣赏的神情。我猜，这是因为阿迪克斯从不慷慨激昂地大吼大叫。阿迪克斯</p><p>托马斯·杰斐逊曾经说过，人人生而平等</p><p>我能想到的最可笑的例子，是那些公共教育管理者，他们让愚笨懒惰的学生和聪明勤奋的学生一样升学，因为‘人人生而平等’，教育者们还会郑重其事地告诉你，留级的孩子会产生强烈的自卑感。我们都知道，某些人灌输给我们的‘人人生而平等’，实际上是个谬论——事实上，有些人就是比别人聪明睿智，有些人就是比别人享有更多的机会，因为他们生来如此，有些男人比别的男人挣钱多，有些女士做的蛋糕比别的女士更胜一筹——总而言之，有些人天生就比大多数普通人具有更高的天赋和才华。</p><p>第二十三章</p><p>在我们生活的这个世界上，总有什么东西让人丧失理智——即使他们努力想做到公平，结果还是事与愿违。</p><p>一个白人只要对黑人做了这种伤天害理的事情，不管他是什么人，不管他多么富有，也不管他出身多么高贵，这个白人就是人渣。</p><p>这个世界上最让我厌恶的事情，莫过于下等白人利用黑人的单纯无知欺骗他们。休要自欺欺人——这些行为一天一天积累起来，我们早晚要为此付出代价。我希望不是你们这一代去偿还。</p><p>你可以把沃尔特·坎宁安从头到脚洗得一尘不染，你可以给他穿上鞋子和新衣服，但他举手投足永远也不会跟杰姆一样。</p><p>芬奇家的女孩子对那种人没有半点儿兴趣。”“姑——姑，”杰姆说，“她还不到九岁呢。”</p><p>我脑子里充满了好奇和兴趣，想到她家去做客，瞧瞧她是怎么生活的，有些什么样的朋友。要说起来，我还想看看月亮的背面是什么样子呢！</p><p>兴许她当初来和我们住在一起的原因，就是为了帮助我们拣选朋友。</p><p>我并没有说你不能向他表示友好啊。你应该友好、礼貌地对待他。亲爱的，你应该对所有人都彬彬有礼。但是，你没必要请他到家里来。</p><p>阿迪克斯说过，你可以选择自己的朋友，但你不能选择自己的家人，所以不管你是否承认，他们都和你有血缘关系，而且不承认事实会让你显得很愚蠢。”</p><p>因——为——他——是——渣——滓</p><p>一种是像我们和街坊邻居这样的普通人，一种是跟坎宁安家一样住在林子里的人，一种是像尤厄尔家一样生活在垃圾场旁边的人，还有一种是黑人。”</p><p>第二十四章 </p><p>我还是在父亲的世界里感觉更自在</p><p>在一个律师家庭里，你学到的第一点就是，凡事无定论。芬奇先生在没有十分把握之前，不能那样随便乱说。”</p><p>第二十五章</p><p>阿迪克斯拿出一个自由人所能采取的一切手段来拯救汤姆·鲁宾逊，但在人们内心深处的秘密法庭里，根本就没有什么诉讼可言。从马耶拉·尤厄尔开口叫嚷的那一刻起，汤姆就是死路一条。</p><p>第二十六章</p><p>我们每周有一节时事讲评课，要求每个孩子从报纸上剪下一则新闻，把内容记得烂熟于心，然后讲给全班同学听。据说这个做法能帮助孩子们克服种种缺点：站在自己的同学面前发言，可以促使一个孩子做到身姿挺拔，镇定自若；做一个简短的演讲能培养孩子有意识地遣词造句；记诵时事新闻能提高孩子的记忆力；被单独拉出来完成一件事儿还会让孩子更渴望回到集体中去。</p><p>第二十八章</p><p>“不想，我要穿着。”我说。这身行头起码能掩盖我的满面羞愧。“你们想搭车回家吗？”有人问道。“不用了，谢谢您，先生。”杰姆说，“我们只有一小段路。”“当心鬼魂啊，”那个声音戏谑道，“更要紧的是，要警告那些鬼魂当心斯库特。”</p><p>杰姆说，“过来，斯库特，让我扶着你这个——大火腿。你可别失去平衡一头栽倒。”“我能看清路。”“好吧，不过你有可能会失去平衡啊。”我感到头上微微有点儿发紧，猜想杰姆大概已经抓住了火腿的顶端。“你抓住我了？”“哦，嗯。”</p><p>夜静得出奇。我都能清清楚楚地听见身边传来杰姆的呼吸声。偶尔会有一阵小风倏地掠过，吹在我的光腿上，不过这只是预报中所说的大风夜甩下的小尾巴。这是暴风雨来临之前的沉寂。我们屏息凝神。</p><p>我说这话更多的是为了让自己安心，而不是为了说服杰姆，因为我们刚一迈开步子往前走，我也听到了他所说的沙沙声。那分明不是我的演出服发出来的。</p><p>亚历山德拉姑姑把紧箍在我身上的布片和铁丝网一点点拉开，我发现她的手指都在哆嗦。“亲爱的，你没事儿吧？”她一边费劲儿地把我解脱出来，一边问了一遍又一遍。</p><p>第二十九章</p><p>如果我们一直被感觉牵着鼻子走，就会像猫一样追着自己的尾巴转圈子。</p><p>第三十章</p><p>“如果我们掩盖了事情的真相，那就等于完全违背了我一直以来教育杰姆如何做人的原则。有时候，我觉得自己作为一个父亲很失败，简直一无是处，可我就是他们所拥有的全部。在这个世界上，杰姆最先看的人是我，然后才去看别人，我一直努力让自己活得堂堂正正，能够直视他的目光……如果我默许这种事情发生，坦率地说，我从此以后再也无法坦然面对他的眼睛，如果是这样的话，我就知道自己已经永远失去了他。我不想失去他和斯库特，因为他们是我的一切。”</p><p>第三十一章</p><p>你永远也不可能真正了解一个人，除非你穿上他的鞋子走来走去，站在他的角度考虑问题。</p><p>“斯库特，大多数人都是善良的，等你最终了解他们之后就会发现</p>]]></content>
      
      
      <categories>
          
          <category> Life Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OO-Unit4小结及课程总结</title>
      <link href="2021/06/26/OO-Unit4%E5%B0%8F%E7%BB%93%E5%8F%8A%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
      <url>2021/06/26/OO-Unit4%E5%B0%8F%E7%BB%93%E5%8F%8A%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1><span id="oo-unit4小结amp课程总结">OO-Unit4小结&amp;课程总结</span></h1><p>终于迎来了OO的终章——UML解析器编写。今天还刚好是考完航概的烤漆最后一天，在这样的日子里来写这篇博客自然要放松点啦，这篇就把这学期的一些体会感悟都好好记录一下，算是对艰苦奋战“<strong>昆仑课程</strong>”一学期的完美留念。</p><h2><span id="本单元作业架构设计">本单元作业架构设计</span></h2><p>本单元需要对各个<code>UML</code>类进行解析建模。官方包已经提供了对于特定的<code>json</code>数据的输出处理以及相应的官方<code>Uml</code>的一些基本类，但是这些考虑到基本类只包含了<code>id name</code>等基本属性，而缺少某些<code>Uml</code>类的重要数据属性，因此需要对每次作业中一些涉及到评测的类进行单独的<strong>自定义类建模</strong>，与此同时在初始化中也需要加入的中间变量或容器对这些自定义类进行初始化。这一单元的架构大体上是将初始化过程，主类的各个评测函数，以及各个需要用到的自定义类进行分块包装，最终组合起来形成<code>Uml</code>解析器。</p><p>本单元经历了充分的测试，终于是第一次AK了，虽然很大程度上还是要感谢ch大佬的数据支持，感觉应该给他专门颁发一个特殊的奖才能感谢他帮我们找出的这么多bug！</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit4/hw13.png" style="zoom:50%;"></p><p>第一次作业的要求相对简单，是对类图的解析。于是大体上在主类里实现了<code>init</code>函数，各个具体的返回值函数，以及建立了有必要的<code>MyClass</code>、<code>MyInterface</code>、<code>MyOperation</code>三个类，这三个自定义类里包含了有用的各种内部属性和方法。其中<code>MyClass</code>引用了其他两个类，而这三个类在<code>MyUmlInteraction</code>都有相应的引用。</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit4/hw14.png" alt="hw14" style="zoom: 25%;"></p><p>第二次作业在第一次作业基础上实现了对时序图和状态转移图的解析。在第一次基础上新增了<code>MyInteraction</code>和<code>MyStateMachine</code>两个自定义类对新增的两种图的数据和方法进行实现。</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit4/hw15.png" alt="hw15" style="zoom: 25%;"></p><p>第三次作业新增了一个<code>init</code>类对开始的初始化操作和初始化变量进行操作从而减少主功能类的行数，代码架构更合理，每个类的功能更独立。</p><h2><span id="四个单元中架构设计及oo方法理解的演进">四个单元中架构设计及OO方法理解的演进</span></h2><p>四次作业中唯一的一次重构就发生在第一单元的求导计算的1-2次作业中，由于没有想到之后的第二三次作业的改动力度之大且刚开始面向对象，没有那么好的封装思路。之后的三个单元均是在之前架构基础上微调或者增量开发。</p><p>第一次作业中对于对于三角函数，多项式，项等各个部分进行单独的封装，同时对各个求导规则和方法进行单独的封装，体现了层次化结构化的思想。</p><p>第二次作业中对于多线程的原理和应用进行了学习和实践，学习了生产者消费者模式和worker-threads模式。采用了集中式调度，调度器和输入线程为一对生产者消费者，调度器和各个电梯间也形成了生产者消费者关系。</p><p>第三单元了解了JML规格编写和阅读方法，知道了如何用形式化的语言来描述和检查代码。这一单元的代码架构固定，只建立了个别必要的图管理类。</p><p>第四单元了解了UML可视化代码规格方式，知道了如何形象的对代码从类图，代码时序动态图，状态图等方面进行描述。建立了抽象分离初始化，具体功能类，返回函数主类三个层次的体系。</p><h2><span id="四个单元中测试理解与实践的演进">四个单元中测试理解与实践的演进</span></h2><p>四个单元的学习过程中，评测机不断扩充完善。造数据和<code>debug</code>能力也不断增强。总的来说的方法还是三个，形式验证（比对指导书需求，看代码），黑盒测试（与他人或标答对拍），白盒测试。</p><p>第一单元主要采用了<code>xeger</code>根据正则表达式生成一定强度的数据，以及递归下降构造数据的方式。然后利用<code>sympy</code>库计算结果或化简表达式进行对拍和评测的方式。</p><p>第二单元由于事情繁多，只完成了基本的导出结果的功能。投放数据采用<code>subprocess</code>库来完成。这一单元主要是合理利用强测数据，多尝试，多跑点，就能找出很多bug。</p><p>第三单元采用<code>Junit</code>白盒单元测试和黑盒测试相结合，针对每次作业的核心耗时算法构造出相应的数据点进行性能测试，构造长随机指令覆盖用例对正确性进行测试。</p><p>第四单元和第三单元类似，也是单元测试+黑盒测试结合的方式，而针对这次作业的特点，我采用了手动<code>Uml</code>图并实现<code>利用官方包的命令自动导出相应的json数据-&gt;解析json数据-&gt;自动构造这个图能够出现的所有指令-&gt;组合成一个数据</code>，总的来说就是物尽其用的思想，由于没有精力实现像第三单元一样的随机生成的代码，那就只能尽可能<strong>压榨</strong>每一个<code>Uml</code>图的价值。对每一个<code>Uml</code>图都生成出所有可能出现的图模型和相应的所有指令。这样虽然不能保证图的复杂性，但是至少保证了每个数据都是这个图的最全数据。具体的效果如下图所示，对于每个图都导出了所有的模型和相应的数据，同时保存了对于每个数据点的描述方便之后<code>debug</code>。</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit4/t1.png" style="zoom:67%;"></p><p>总的来说，本学期OO的评测机我的思路就是将评测分成<code>时间评测和获取输出</code>、<code>评测正确性</code>两步走的思路。前一部分向每个不同程序投喂输入数据，检测运行时间和CPU时间是否超时，并保存相应的输出结果。后一部分将每个数据的标准输出或者多人的输出进行对拍，找少数派或者直接评价正确性。</p><p>而数据构造则也分为了对于每个数据点的构造，一组数据点的构造，和具体的构造函数。大体上实现解耦。</p><p>从刚开始到最后一次的评测机，我的<code>OO-test</code>项目一直有一些新东西，这个过程是不断完善测试体验和提高测试效率的过程。以下记录一下点自认为觉得写的较好的功能。</p><ol><li><p>让<code>Pycharm</code>里的评测输出<strong>五颜六色</strong>、花哨、完整起来，丰富的颜色让测试变得有趣。还看到有的同学写了<code>GUI</code>（太神仙了），本来也想尝试但是觉得没太大必要就作罢了。还有ch大佬的丰富多样、有趣的调试信息也是值得学习的。我的输出主要包含了时间性能评测信息，对拍评测信息。如果测试对象只有两个人会显示具体哪一行不同，1/3/4单元还会显示具体是什么指令/数据的错误，最后一单元还给出了可能错误的原因。这些贴心的输出都为debug提供了极大的便利，很多时候稍微造一造数据跑出来就可以知道错误是什么原因（不过数据还是根本，还是要感谢各位大佬的数据支援）。</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit4/t2.png" style="zoom: 80%;"></p></li><li><p>一个<code>test</code>搞定一切。实现了一个<code>test</code>函数，输入为一个<code>jar</code>名字列表，同时在外围实现了<code>beatTest</code>、<code>testWithOther</code>、<code>testSingle</code>、<code>init</code>等方法对单独测试，双人对拍，多人运动进行单独封装，根据名字列表长度调用相关函数做相应的测试。如下图所示。</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit4/t3.png" alt></p></li></ol><p>最后的评测机大概就这样了。基本每个单元都会有一个生成数据的代码和测试代码。</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit4/t4.png" alt></p><h2><span id="课程收获">课程收获</span></h2><p>本学期的OO课程从层次化，多线程，规格化，模型化四个方面进行了学习，知识上学习了层次化架构设计，线程安全与一般设计模式，JML结构化语言描述，UML模型。工具链上，对于<code>IDEA</code>内的各种代码分析插件以及调试插件，<code>Pycharm</code>内的一些插件，<code>StarUML</code>等有了一定的使用心得。了解了一般的面向对象的编写方式，以及从前期需求对接，到增量迭代开发、重构优化，到测试交付以及bug修复的软件开发全流程体验，这个过程中<code>Java</code>的面向对象编程能力和基于<code>Python</code>的测试能力也不断提升，对于基本的程序测试也有了一定的认知，不过需要改进的地方就是缺少了对于数据本身的强度评测，具体来说就是没有对每个分支的覆盖程度进行反馈，之后的评测中需要加入相应的代码进行更全面的测试。</p><p>另外，OO研讨课上我做了两次分享，第一次主要介绍了包括黑盒测试，白盒测试，灰盒测试和评测机架构在内的测试理论实践知识，最后一次介绍了代码注释，博客编写和课程体会，这两次研讨的PPT我都花了至少4个小时进行制作，虽然内容并不是非常硬核，但是这个过程中对于这些知识的理解确实也更到位了，也体会到了分享的乐趣，当知道真的有个别同学觉得我的讲解有一点用处时，内心还是很充实而欣慰的。同时，写博客，阅读他人博客和代码，听其他同学的研讨分享也学到了很多东西，可以说，OO这门课除了让我们打好了面向对象的基础，也让我增强了技术分享、表达和向他人学习的能力。同时，这种可以阅读、hack他人代码，几乎全透明的学习方式也让人感到耳目一新，体验极佳，启发了更多的学习方式。</p><p>此外对于每次作业还有一些小的碎碎念，在最后一次研讨课我也分享了一下，这里偷个懒，直接搬运过来。作为补充总结。</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit4/4.png" style="zoom: 33%;"></p><h2><span id="对于课程的具体改进建议">对于课程的具体改进建议</span></h2><ol><li>博客环节可以适当改善。可以鼓励大家多阅读他人博客，并积极写评论进行交流。感觉一学期下来虽然写了四篇博客，但并不是所有同学都非常清楚一篇好的博客到底是什么样的以及写这个的意义和目的。可以尝试让同学进行互评，适当公开评价细则，设置自定义任务模块（比如可以让同学们写某个方面技术分享博客，根据质量给相应奖励之类，不过感觉这样又和评论区重复了）等鼓励同学们写更多的优质博客。</li><li>研讨课可以安排更多的活动，比如没有人讲的时候可以组织包括辩论赛（针对某个热点信息科技话题进行辩论），圆桌会议（讨论技术热点和未来的研究方向，头脑风暴，对于OO课内的一些技术的创新点进行讨论），甚至是翻转课堂的形式（让同学们代替老师讲授某一部分内容，减轻老师的教学压力），或者如果可爱的助教大大们愿意讲点啥课程组也不能拒绝对吧😀。</li><li>课外可以安排一些其他的任务，比如类似软院软工项目图书管理系统，飞机订票系统之类的小软件项目，可以考虑提供前后端框架代码让大家进行补全，也可以自定义题目让大家自行从0开发。让有兴趣的同学自行组队完成并进行一定的展示和加分。通过一些有实际功能的实际系统可以让大家更好地掌握面向对象知识在实际开发中的使用方式。</li><li>每次互测可以让大家评选出本房间内彼此的代码进行打分和评价，鼓励互测房内同学更好地学习彼此代码。官方也可以分享和总结一些好的代码思路，比如提供几份公认较好的架构思路供大家参考。可以让同学们写一写自己在互测中读到的好代码好在哪，学到和借鉴到了什么东西。</li><li>可以从第一次作业开始鼓励同学们写好注释，按照<code>javadoc</code>规范来写，每个单元结束时生成一份<code>javadoc</code>。而且好的注释可以帮助他人阅读自己代码，节省大家宝贵的互测时间。</li><li>完善前期的<code>java</code>先修课程，稍微增加一些对于java细枝末节知识的介绍，完善现有的教程。也可以考虑在现有的部分课程基础上加一些视频讲解之类。课程内容可以增加一些对于java的目前应用内容，比如具体的Spring后端开发，hadoop大数据分析等方面的简单讲解。</li></ol><p>最后的最后，还是感谢一起在这么多个日日夜夜一起对拍的阿强和阿勇两位舍友，以及给过我很多帮助的战哥，昊哥，lyj、lkl助教，吴老师，以及各位大佬们，没有你们，可能无数次迎接我的都是：</p><p>$\color{green} {恭喜你在强测中获得0分！}$ </p><p>$\color{red} {不存在此互测成员}$ </p><p>这样的消息吧！希望未来可以把学到的面向对象的知识用于实际工程中，不断提升自己OO的能力！OO课完结撒花了！！</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-OO-2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散数学3</title>
      <link href="2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/"/>
      <url>2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/</url>
      
        <content type="html"><![CDATA[<h1><span id="第一章-导论">第一章 导论</span></h1><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/1-1.png" style="zoom:50%;"></p><h2><span id="组合数学主要学习内容">组合数学主要学习内容</span></h2><ul><li>排列与组合（基础） </li><li>鸽巢原理（存在性） </li><li>生成排列和组合（生成算法） </li><li>二项式系数 （组合数） </li><li>容斥原理（排列数） </li><li>递推关系和生成函法（ 重要） </li><li>特殊计数序列 </li><li>图匹配、互异代表系统 </li><li>Polya 计数</li></ul><h2><span id="知识图">知识图</span></h2><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/1-2.png" alt></p><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/1-3.png" alt></p><h1><span id="第二章-排列与组合">第二章 排列与组合</span></h1><h2><span id="21-基本计数原理">2.1 基本计数原理</span></h2><h3><span id="加法原理addition-principle">加法原理Addition Principle</span></h3><h3><span id="乘法原理multiplication-principle">乘法原理Multiplication Principle</span></h3><h3><span id="减法原理-subtraction-principle">减法原理 Subtraction Principle</span></h3><p>减去不符合要求的</p><h3><span id="除法原理-division-principle">除法原理 Division Principle</span></h3><h2><span id="22-集合的排列">2.2 集合的排列</span></h2><h3><span id="集合的线性排列">集合的线性排列</span></h3><p>n元素集合的r-排列——n个元素中取出r个元素有序摆放</p><p>全部r-排列数：$P(n,r)$</p><p>当$r&gt;n$时$P(n,r)=0$</p><p>$P(n,r)=n!/(n-r)!$</p><p>$0!=1$</p><h3><span id="排列pnr的递推关系">排列P(n,r)的递推关系</span></h3><ol><li>P(n, r)=n*P(n-1, r-1)<ul><li>分步递归 </li><li>选择1号盒子放一个球*从n-1个球中选r-1个放入r-1个盒子中</li></ul></li><li>P(n, r)=P(n-1,r)+rP(n-1,r-1) <ul><li>分类递推</li><li>不选第一个球+选了第一个球</li></ul></li></ol><h3><span id="组合模型">组合模型</span></h3><p>$C(n,r)=n!/((n-r)!*r!)$</p><p>$C(n,r)=C(n,n-r)$</p><p>$C(n,r)C(r,k)=C(n,k)C(n-k, r-k)$</p><ul><li>先选出r个班委，再选出k个常委</li><li>等价于先选出k个常委，再选出r-k个其他班委</li></ul><h3><span id="集合的多种类型排列">集合的多种类型排列</span></h3><h4><span id="循环排列">循环排列</span></h4><p>n个元素集合的循环r排列个数为</p><p>$\frac {P(n,r)}r = \frac {n!}{r(n-r)!}$</p><p>n元素循环排列个数：(n-1)!</p><h4><span id="项链排列">项链排列</span></h4><p>即循环排列的一半即可</p><p>$\frac {P(n,r)}{2r} = \frac {n!}{2r(n-r)!}$</p><h2><span id="23-集合的组合">2.3 集合的组合</span></h2><p>普通集合r-组合：$C(n,r)$ </p><p>$\sum_{i=1}^nC_n^i=2^n$</p><h2><span id="24-多重集的排列">2.4 多重集的排列</span></h2><h4><span id="无限重复数">无限重复数</span></h4><p>S有k种不同元素，每种元素都可以重复无限次，则S的r-排列个数为$k^r$</p><p>无限次可以放到每种元素个数都大于等于r</p><h4><span id="有限重复数">有限重复数</span></h4><h5><span id="多重集排列">多重集排列</span></h5><p>S＝{n1*a1, n2*a2,…, nk*ak}​</p><p>$n_1+n_2+..+n_k=n$</p><p>S排列数为 $\frac {n!} {n_1!n_2!…n_k!}$</p><h5><span id="多重集排列的另一种解释">多重集排列的另一种解释</span></h5><p>对n个元素集合划分为指定大小的多个部分(n个小球放入不同标号的若干个盒子中)</p><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/5.png" style="zoom: 50%;"></p><h2><span id="25-多重集组合">2.5 多重集组合</span></h2><p>集合S有k种不同的元素，每种元素数量无限，r-组合数量</p><h3><span id="隔板法">隔板法</span></h3><ul><li>相当于将r个元素分成k个不同区域</li><li>r个相同元素间插入k-1个隔板，分成k份</li><li>C(k+r-1，k-1) = C(k+r-1，r)  </li><li>(k-1)+r个位置取出r个位置</li></ul><h3><span id="两个整数解问题">两个整数解问题</span></h3><ul><li>$n_1+n_2+…+n_k=r$ 的非负整数解个数C(k+r-1, r) </li><li>$n_1+n_2+…+n_k=r$ 的正整数解个数 C(r-1, k-1)</li></ul><h1><span id="第三章-鸽巢原理">第三章 鸽巢原理</span></h1><p>又称为抽屉原理，狄里克雷原理</p><h2><span id="31-鸽巢原理的简单形式">3.1 鸽巢原理的简单形式</span></h2><p>n+1个物体放进n个盒子中，至少有一个盒子包含两个或者更多的物体</p><h3><span id="中国剩余定理">中国剩余定理</span></h3><p>令 m, n是互素的正整数，a和b分别是小于m和n的非负整数。</p><p>那么，存在正整数 x，使得 x 除以m余数为a, 且除以n余数为b，即 x＝pm+a，x =qn+b。</p><h4><span id="中国剩余定理一般形式">中国剩余定理一般形式</span></h4><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/3-1.png" style="zoom:50%;"></p><h3><span id="连续时间型问题">连续时间型问题</span></h3><blockquote><p>某学生有37天来完成一个课外科技项目，而学生需 要不超过60小时的课外时间，他还希望每天至少安排一 小时。证明：无论如何安排工作时间（每天都是整数小时）， 都存在连续的若干天，在此期间他恰好工作了13个小时。 </p></blockquote><p>设到第n天已经工作的时间为$s_n$</p><p>则$1\leq s<em>1 \leq s_2…\leq s</em>{37} \leq 60$</p><p>且$14\leq s<em>1+13 \leq s_2+13…\leq s</em>{37}+13 \leq 73$</p><p>根据鸽巢原理，上述74个数中必有$1\leq i\leq j\leq 37$，使得$s_i+13 = s_j$</p><h2><span id="32-鸽巢原理的加强形式">3.2 鸽巢原理的加强形式</span></h2><p>令q1, q2 , …, qn为正整数。若将q1+q2+…+qn – n+1个物体被放进n个盒子内，那么，</p><ul><li>或者第1个盒子至少含有q1个物体 </li><li>或者第2个盒子至少含有q2个物体</li><li>…</li><li>或者第n个盒子至少含有qn个物体</li></ul><h2><span id="33-ramsey定理">3.3 Ramsey定理</span></h2><h3><span id="引理">引理</span></h3><p>在6个人中</p><ul><li>或者有3个人，他们中每两个人都互相认识； </li><li>或者有3个人，他们中的每两个人都彼此不认识。</li></ul><h3><span id="n阶完全图">n阶完全图</span></h3><p>上述引理可以描述为，给图K6的任意边着红、蓝色，一定存在一个红色K3或者一个蓝色K3</p><p>即K6—&gt;K3,K3</p><h3><span id="ramsey定理">Ramsey定理</span></h3><p>如果m ≥ 2及n ≥ 2是两个整数，则存在正整数p，使得$K_p\rightarrow K_m，K_n$</p><h4><span id="ramsey数">Ramsey数</span></h4><p>使$K_p\rightarrow K_m,K_n$成立的最小整数p</p><h3><span id="相关结论">相关结论</span></h3><p>$R(m,n)\leq R(m-1,n)+R(m,n-1)$</p><p>$R(n,2)=2$</p><p>$R(3,3)=6$</p><p>证明拉姆齐数 $R(3,4)=9$</p><p>知乎：<a href="https://www.zhihu.com/question/263833856" target="_blank" rel="noopener">https://www.zhihu.com/question/263833856</a></p><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/1.png" style="zoom: 67%;"></p><p>也可用分类讨论证明$r(3,4)&lt;=9$</p><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/2.jpg" style="zoom: 33%;"></p><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/3.jpg" alt="3" style="zoom:33%;"></p><p>再举反例证明不等于8</p><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/4.png" alt></p><h1><span id="第四章-生成排列和组合">第四章 生成排列和组合</span></h1><h2><span id="41-生成排列">4.1 生成排列</span></h2><h3><span id="递归生成算法">递归生成算法</span></h3><h4><span id="原理">原理</span></h4><p>先排好1~n-1的，然后再对每一种排列插入n</p><p>递归进行以上过程</p><h4><span id="例子">例子</span></h4><p>3 1 2</p><p>1 3 2</p><p>1 2 3</p><p>3 2 1</p><p>2 3 1</p><p>2 1 3</p><h3><span id="邻位对换算法">邻位对换算法</span></h3><h4><span id="原理">原理</span></h4><p>生成{1, 2, …, n}的排列算法:</p><ol><li><p>初始：<img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/4-1.png" style="zoom:40%;">；</p></li><li><p>while 存在活动整数时，do</p><p>  (1) 求出最大的活动整数m<br>  (2) 交换m和其箭头指向的相邻整数的位置<br>  (3) 改变所有满足p&gt;m的整数 p 的箭头方向。</p></li><li><p>不存在活动整数时，算法结束。</p></li></ol><h4><span id="例子">例子</span></h4><p>1 2 3</p><p>1 3 2</p><p>3 1 2</p><p>3 2 1</p><p>2 3 1</p><p>2 1 3</p><h2><span id="42-排列中的逆序">4.2 排列中的逆序</span></h2><h3><span id="排列的逆序">排列的逆序</span></h3><p>令$i_1 i_2 ,…, i_n$ 是集合$\begin{Bmatrix}{1, 2, …, n}\end{Bmatrix}$的一个排列，如果$0\leq k &lt; l \leq n$, 且$i_k &gt; i_l$ , 称数对（$i_k , i_l$）是排列的一个逆序。</p><h3><span id="逆序数">逆序数</span></h3><p>逆序数$a_j$是排列中先于整数j并大于j的整数个数，度量j的反序程度。</p><h3><span id="逆序列">逆序列</span></h3><p>$a_j$表示一个排列$i_1,i_2…i_n$中数$j$的逆序数，则$a_1,a_2…a_n$为排列$i_1,i_2…i_n$的逆序列</p><p>每个逆序列满足如下条件：</p><ul><li>$\forall 1\leq i \leq n,0\leq a_i \leq n-i$ 特殊的，$i=n$时，$a_n=0$</li></ul><p>对于任意一个满足上述条件的整数序列$b_1,b_2…b_n$都存在集合$\begin{Bmatrix}{1, 2, …, n}\end{Bmatrix}$的唯一一个排列的逆序列为$b_1b_2..b_n$</p><h3><span id="由一个逆序列构造一个排列">由一个逆序列构造一个排列</span></h3><p><strong>从最大数开始</strong>：先把最大数写上，从大到小一个个推理位置</p><p>也可以<strong>从最小数开始</strong></p><h3><span id="奇排列-偶排列">奇排列、偶排列</span></h3><p>逆序个数为奇数，逆序个数为偶数</p><p>$i_1i_2…i_n$的逆序列为$b_1b_2…b_n$，$k=b_1+b_2+..+b_n$为逆序数，可以通过k次交换相邻两个数转换为$12…n$</p><h2><span id="43-生成组合">4.3 生成组合</span></h2><p>n元集合$\begin{Bmatrix}{x_1, x_2, …, x_n}\end{Bmatrix}$的组合与长度为n的二进制数一一对应</p><p>只需要从小到大的顺序写出$0到2^n-1$所有数的二进制形式即可</p><p>算法2：反射Gray码序生成算法</p><h2><span id="44-生成r-组合算法">4.4 生成r-组合算法</span></h2><h3><span id="基于字典序的算法">基于字典序的算法</span></h3><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/4-2.png" style="zoom: 67%;"></p><h1><span id="第五章-二项式系数">第五章 二项式系数</span></h1><h2><span id="51-帕斯卡三角形">5.1 帕斯卡三角形</span></h2><p>别称：杨辉三角、贾宪三角</p><p>Pascal公式：$C<em>n^k=C</em>{n-1}^k+C_{n-1}^{k-1}$</p><p>证明：即不包含1的k子集个数和包含1的k子集个数之和</p><h2><span id="52-二项式定理">5.2 二项式定理</span></h2><p>$(x+y)^n=\sum_{k=0}^nC_n^kx^{n-k}y^k$</p><h3><span id="二项式系数其他等式">二项式系数其他等式</span></h3><p>$kC<em>n^k=n*C^{k-1}</em>{n-1}$</p><p>n个人中选k人组成球队，且其中一人为队长</p><p>$2^n=\sum_{k=0}^nC_n^k$</p><p>$\sum<em>{k=0}^n(C_n^k)^2=C</em>{2n}^n$</p><p>$\sum_{k=0}^n(-1)^kC_n^k=0$</p><p>$C_n^0+C_n^2+…=C_n^1+C_n^3+…=2^{n-1}$</p><h2><span id="53-二项式系数的单峰性">5.3 二项式系数的单峰性</span></h2><p>n为<strong>偶数</strong></p><ul><li>$C_n^0<c_n^1<...<c_n^{\frac n 2},c_n^{\frac 2}>…&gt;C_n^{n-1}&gt;C^n_n$</c_n^1<...<c_n^{\frac></li></ul><p>n为<strong>奇数</strong></p><ul><li>$C_n^0<c_n^1<...<c_n^{\frac {n-1} 2},c_n^{\frac {n+1} 2}>…&gt;C_n^{n-1}&gt;C^n_n$</c_n^1<...<c_n^{\frac></li></ul><h3><span id="sperner定理">Sperner定理</span></h3><p>令S是n个元素的集合, C 是S的子集的集合</p><ul><li>若C中任意两个不同的子集都存在包含关系,则称C是S的一个<strong>链</strong>。 </li><li>若C中任意一个子集都不包含在其他子集内， 即任意两个不同的子集都不存在包含关系，则 称C是S的一个<strong>反链</strong>。</li></ul><p>反链个数最多为$C_n^{\lfloor \frac n 2 \rfloor}$</p><h4><span id="最大链">最大链</span></h4><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/5-2.png" style="zoom:50%;"></p><h4><span id="链与反链的关系">链与反链的关系</span></h4><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/5-3.png" style="zoom:50%;"></p><h2><span id="54-多项式定理">5.4 多项式定理</span></h2><p>$(x_1+x_2+…+x_t)^n$</p><h4><span id="多项式系数">多项式系数</span></h4><p>$n_1+n_2+…+n_t=n$</p><p> <img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/5-4.png" style="zoom:67%;"></p><p> 重数分别为$n_1,n_2,…,n_t$的t种不同类型物品多重集的排列数</p><h2><span id="55-牛顿二项式定理">5.5 牛顿二项式定理</span></h2><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/5-1.png" style="zoom: 50%;"></p><h1><span id="第六章-容斥原理及应用">第六章 容斥原理及应用</span></h1><h2><span id="61-容斥原理">6.1 容斥原理</span></h2><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/6-1.png" style="zoom:50%;"></p><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/6-2.png" style="zoom:50%;"></p><h2><span id="62-带重复的组合">6.2 带重复的组合</span></h2><h3><span id="容斥原理在多重集组合中的作用">容斥原理在多重集组合中的作用</span></h3><h3><span id="典型例题">典型例题</span></h3><h4><span id="例1">例1</span></h4><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/6-3.png" style="zoom:50%;"></p><h4><span id="例2">例2</span></h4><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/6-4.png" style="zoom:50%;"></p><h2><span id="63-错位排列">6.3 错位排列</span></h2><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/6-5.png" style="zoom:50%;"></p><p>即<strong>每个位置i</strong>上的数字<strong>都不是i</strong>。</p><p>利用容斥原理，设i位置上数字是i为事件$A_i$</p><p>则$D_n=|\overline {A_1\cup A_2\cup…\cup A_n}|=|\overline {A_1}\cap \overline {A_2} \cap … \cap \overline {A_n}|=n!-C_n^1<em>(n-1)!+…+(-1)^nC^n_n</em>0!$</p><p>$=n!(1-\frac 1 {1!}+\frac 1 {2!}+…+(-1)^n*\frac 1 {n!})$</p><h3><span id="递推关系">递推关系</span></h3><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/6-6.png" style="zoom:50%;"></p><h2><span id="64-带有禁止位置的排列">6.4 带有禁止位置的排列</span></h2><p>利用容斥原理即可</p><h2><span id="65-另一个禁止位置问题">6.5 另一个禁止位置问题</span></h2><h2><span id="66-莫比乌斯反演">6.6 莫比乌斯反演</span></h2><h1><span id="第七章-递推关系和生成函数">第七章 递推关系和生成函数</span></h1><h2><span id="71-若干数列">7.1 若干数列</span></h2><p>等差、等比、斐波那契数列</p><h2><span id="72-生成函数">7.2 生成函数</span></h2><p>计算多重集组合数时使用</p><h3><span id="几个常见展开式">几个常见展开式</span></h3><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/7-3.png" style="zoom:50%;"></p><h3><span id="定义">定义</span></h3><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/7-1.png" style="zoom:50%;"></p><p>一个数列确定了一个生成函数，反之，一个生成函数也可以确定一个数列</p><h3><span id="利用生成函数求解带有约束的多重集的组合个数">利用生成函数求解带有约束的多重集的组合个数</span></h3><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/7-2.png" style="zoom:50%;"></p><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/7-4.png" style="zoom:50%;"></p><h2><span id="73-指数生成函数">7.3 指数生成函数</span></h2><p>计算多重集排列数时使用</p><h3><span id="展开式">展开式</span></h3><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/7-5.png" style="zoom:50%;"></p><h3><span id="定义">定义</span></h3><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/7-6.png" style="zoom:50%;"></p><h3><span id="例题">例题</span></h3><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/7-7.png" style="zoom:50%;"></p><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/7-8.png" style="zoom:50%;"></p><h2><span id="74-求解线性齐次递推关系">7.4 求解线性齐次递推关系</span></h2><h3><span id="定义">定义</span></h3><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/7-9.png" style="zoom:50%;"></p><h3><span id="特征方程法">特征方程法</span></h3><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/7-10.png" style="zoom:50%;"></p><h2><span id="75-非齐次递推关系">7.5 非齐次递推关系</span></h2><h3><span id="一般非齐次递推关系的通解">一般非齐次递推关系的通解</span></h3><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/7-11.png" style="zoom:50%;"></p><p>即先将$b_n$抹去，算出<strong>齐次通解</strong></p><p>再用齐次通解加上<strong>非齐次特解</strong>得到通解</p><p>一般非齐次特解需要猜测一个带参数的形式并代入原表达式计算各个参数值</p><p>最后根据初始条件确定齐次通解的常系数</p><h1><span id="第8章-特殊计数序列">第8章 特殊计数序列</span></h1><h2><span id="81-catalan数">8.1 Catalan数</span></h2><h3><span id="catalan数列">Catalan数列</span></h3><p>把凸n+1多边形区域分成三角形区域的方法数</p><p>$C<em>n=\frac 1 {n+1} C</em>{2n}^n(n=0,1,2…)$</p><p>$\frac {C<em>n} {C</em>{n-1}}=\frac {4n-2} {n+1}$</p><p>$C<em>n=C_0C</em>{n-1}+C<em>1C</em>{n-2}+…+C_{n-1}C_0$</p><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/8-1.png" style="zoom:50%;"></p><h2><span id="82-差分序列和stirling数">8.2 差分序列和Stirling数</span></h2><h3><span id="问题引入">问题引入</span></h3><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/8-2.png" style="zoom:50%;"></p><h3><span id="差分递归定义">差分递归定义</span></h3><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/8-3.png" style="zoom:50%;"></p><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/8-4.png" style="zoom:50%;"></p><p>上述结论可用于求前n项和</p><p>$\sum<em>{k=0}^n C_k^p=C</em>{n+1}^{p+1}$</p><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/8-5.png" style="zoom: 50%;"></p><h3><span id="stirling数">Stirling数</span></h3><h4><span id="第一类斯特林数">第一类斯特林数</span></h4><p>$s(p,k)$</p><p>将p个物品排成<strong>k个非空</strong>的<strong>循环排列</strong>方法数</p><p>$s(n,1)=(n-1)!(n\ge 1)$</p><p>$s(n,n-1)=C_n^2(n\ge 1)$</p><p>$若1\leq k \leq p-1,则:s(p,k)=(p-1)s(p-1,k)+s(p-1,k-1)$</p><h4><span id="第二类斯特林数">第二类斯特林数</span></h4><p>$S(p,k)$</p><p>把 p个元素的集合划分到 <strong>k个不可区分</strong>的盒子且<strong>没有空盒子</strong>的划分的个数</p><p>$若1\leq k \leq p-1,则:S(p,k)=kS(p-1,k)+S(p-1,k-1)$</p><h4><span id="spk">$S^#(p,k)$</span></h4><p>把p元素划分到k个<strong>非空</strong>、<strong>可区分</strong>的盒子 的划分数</p><h3><span id="bell数">Bell数</span></h3><p>Bell数是将 p个元素的集合分成非空、不可区分的盒子的划分数(至少一个盒子，至多p个盒子)</p><h2><span id="83-分拆数">8.3 分拆数</span></h2><h3><span id="整数拆分的组合含义">整数拆分的组合含义</span></h3><p>把 $n$个无区别的球放入无区别的盒子的放法（各盒子中可放入$t$ 个球, $1≤t≤n$）</p><h3><span id="分拆的表示">分拆的表示</span></h3><p>$n=na<em>n+(n-1)a</em>{n-1}+…+2a_2+1a_1$</p><p>上述n的一个拆分记为: $\lambda=n^{a_n}…2^{a_2}1^{a_1}$</p><h3><span id="分拆的几何表示-ferrers图">分拆的几何表示: Ferrers图</span></h3><p>如10的拆分3+3+2+2   $3^22^2$记为：</p><p>● ● ●</p><p>● ● ●</p><p>● ●</p><p>● ●</p><h4><span id="共轭分拆">共轭分拆</span></h4><p>分拆的矩阵的转置称为共轭分拆</p><p>上述矩阵的共轭分拆为4+4+2 即$4^22^1$</p><p>● ● ● ●</p><p>● ● ● ●</p><p>● ●</p><h4><span id="自共轭分拆">自共轭分拆</span></h4><p>和共轭分拆完全相同的分拆</p><h3><span id="例题">例题</span></h3><p>有3个1克砝码，2个2克砝码，2个4克砝码，问能称出几种重量？有几种方法？</p><p>$G(x)=(1+x+x^2+x^3)(1+x^2+x^4)(1+x^4+x^8)$</p><ul><li>将每个括号内的x换成对应的$x_1,x_2,x_4$再展开就可以得到具体的每个重量的称重方法</li><li>计算出来后每一项的指数就是能称出的重量</li><li>系数就是对应方法数</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Combinatorics </tag>
            
            <tag> Discrete Mathematics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS理论课笔记-IO/磁盘管理/文件系统/安全/分布式OS</title>
      <link href="2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-2/"/>
      <url>2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-2/</url>
      
        <content type="html"><![CDATA[<h1 id="第五章-输入输出系统"><a href="#第五章-输入输出系统" class="headerlink" title="第五章 输入输出系统"></a>第五章 输入输出系统</h1><h2 id="5-1-I-O硬件基本原理"><a href="#5-1-I-O硬件基本原理" class="headerlink" title="5.1 I/O硬件基本原理"></a>5.1 I/O硬件基本原理</h2><h3 id="I-O设备分类"><a href="#I-O设备分类" class="headerlink" title="I/O设备分类"></a>I/O设备分类</h3><p><strong>传输速度</strong>：低速中速高速</p><p><strong>信息交换单位</strong>：块设备和字符设备</p><p><strong>共享属性</strong>：独占设备，共享设备，虚拟设备</p><h2 id="5-2-I-O软件基本原理"><a href="#5-2-I-O软件基本原理" class="headerlink" title="5.2 I/O软件基本原理"></a>5.2 I/O软件基本原理</h2><h3 id="I-O控制技术"><a href="#I-O控制技术" class="headerlink" title="I/O控制技术"></a>I/O控制技术</h3><h4 id="程序控制I-O-PIO-Programmed-I-O"><a href="#程序控制I-O-PIO-Programmed-I-O" class="headerlink" title="程序控制I/O(PIO,Programmed I/O)"></a>程序控制I/O(PIO,Programmed I/O)</h4><p>轮询或查询方式IO</p><p>CPU代进程向IO模块发出指令，之后忙等，直到操作完成进程继续执行</p><h4 id="中断驱动方式-Interrupt-driven-I-O"><a href="#中断驱动方式-Interrupt-driven-I-O" class="headerlink" title="中断驱动方式(Interrupt-driven I/O)"></a>中断驱动方式(Interrupt-driven I/O)</h4><p>I/O操作结束后由设备控制器主动通知程序结束信息，不用轮询</p><p>外设数据处理时CPU不需等待，但是每输入输出一个数据CPU都要中断，浪费CPU时间</p><h4 id="直接存储访问方式-DMA-Direct-Memory-Access"><a href="#直接存储访问方式-DMA-Direct-Memory-Access" class="headerlink" title="直接存储访问方式(DMA, Direct Memory Access)"></a>直接存储访问方式(DMA, Direct Memory Access)</h4><p><strong>直接存储器访问</strong>方式</p><p>由一个<strong>专门的控制器</strong>完成数据从<strong>内存到设备</strong>或者<strong>设备到内存</strong>的传输工作，是数据块的传输</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>CPU只干预I/O操作的<strong>开始</strong>和<strong>结束</strong>， 而当中的数据读写过程无需CPU控制，适于<strong>高速设备</strong></li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>数据<strong>传送的方向、存放数据的内存地址及传送数据的长度</strong>等都由CPU控制，占 用了CPU时间。</li><li><strong>每个设备</strong>占用<strong>一个</strong>DMA 控制器，当设备增加时，需要增加新的DMA 控制器</li></ul><h4 id="通道技术（Channel）"><a href="#通道技术（Channel）" class="headerlink" title="通道技术（Channel）"></a>通道技术（Channel）</h4><p>与DMA几乎一样</p><p>通道是一个<strong>特殊功能的处理器</strong>，有自己的指令体系，专门负责数据输入输出的传输控制，与CPU分别使用内存，实现运算与IO的并行</p><p>执行一个通道程序可完成几组IO操作，减少了CPU干预，但费用较高</p><p>可<strong>同时控制多种设备</strong>，区别于DMA只能控制一台或少数几台同类设备</p><h3 id="缓冲技术"><a href="#缓冲技术" class="headerlink" title="缓冲技术"></a>缓冲技术</h3><p>匹配CPU和外设不同处理速度，减少CPU中断次数，提高并行性</p><ul><li><strong>单缓冲</strong>： 1个缓冲区，CPU外设轮流使用</li><li><strong>双缓冲</strong>： 2个缓冲区，CPU和外设可以连续处理，但要求速度相近</li><li><strong>环形缓冲</strong>：<strong>生产者—消费者</strong>问题</li></ul><h4 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h4><p>缓冲区队列：</p><ul><li>空闲缓冲区</li><li>输入缓冲区</li><li>输出缓冲区</li></ul><h3 id="设备分配"><a href="#设备分配" class="headerlink" title="设备分配"></a>设备分配</h3><p>对进程使用外设过程的管理。</p><p><strong>两个做法</strong>：</p><ol><li>在进程间切换使用外设，如<strong>键盘</strong>和<strong>鼠标</strong>；</li><li>通过一个虚拟设备把<strong>外设与应用进程隔开</strong>，只由<strong>虚拟设备</strong>来使用设备。</li></ol><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ol><li>设备控制表  DCT 每个设备一张</li><li>控制器控制表  I/O控制器的配置和状态</li><li>通道控制表  每个通道一张</li><li>系统设备表 系统内一张 记录所有设备状态和对应的控制表入口</li></ol><h4 id="单通道IO设备系统分配"><a href="#单通道IO设备系统分配" class="headerlink" title="单通道IO设备系统分配"></a>单通道IO设备系统分配</h4><p>一个设备对应一个控制器，一个控制器对应一个通道 </p><h4 id="多通道IO系统设备分配"><a href="#多通道IO系统设备分配" class="headerlink" title="多通道IO系统设备分配"></a>多通道IO系统设备分配</h4><p><strong>一个设备</strong>与<strong>几个控制器</strong>相连，<strong>一个控制器</strong>与<strong>几个通道</strong>相连 </p><h4 id="假脱机技术SPOOLing"><a href="#假脱机技术SPOOLing" class="headerlink" title="假脱机技术SPOOLing"></a>假脱机技术SPOOLing</h4><p>把<strong>独享设备</strong>转变成具有<strong>共享特征的虚拟设备</strong>，从而提高设备利用率</p><h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><ul><li>关中断 </li><li>保存现场 </li><li>转入设备中断处理程序 </li><li>进行中断处理 </li><li>恢复被中断进程的现场 </li><li>开中断 </li><li>设置MMU以执行下一个进程</li></ul><h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><ul><li>将抽象I/O请求转换为对物理设备的请求 </li><li>检查I/O请求的合法性 </li><li>初始化设备 </li><li>启动设备 </li><li>发出I/O命令 </li><li>响应中断请求 </li><li>构造通道程序</li></ul><h2 id="5-3-OS设备管理实例"><a href="#5-3-OS设备管理实例" class="headerlink" title="5.3 OS设备管理实例"></a>5.3 OS设备管理实例</h2><h1 id="第六章-磁盘存储管理"><a href="#第六章-磁盘存储管理" class="headerlink" title="第六章 磁盘存储管理"></a>第六章 磁盘存储管理</h1><h2 id="6-1-磁盘存储的工作原理"><a href="#6-1-磁盘存储的工作原理" class="headerlink" title="6.1 磁盘存储的工作原理"></a>6.1 磁盘存储的工作原理</h2><p>温切斯特盘</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><strong>扇区</strong>（sector） 盘片被分成许多<strong>扇形的区域</strong></li><li><strong>磁道</strong>（track） 盘片上以盘片中心为圆心，不同半径的<strong>同心圆</strong>。</li><li><strong>柱面</strong>（cylinder) 硬盘中，不同盘片相同半径的磁道所组成的<strong>圆柱</strong>。</li><li>每个<strong>磁盘有两个面</strong>，每个面都有一个<strong>磁头</strong>(head)。</li></ul><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-2/6-1.png" style="zoom:50%;"></p><h3 id="磁盘的组织"><a href="#磁盘的组织" class="headerlink" title="磁盘的组织"></a>磁盘的组织</h3><p>读一个扇区需要<strong>柱面/磁头/扇区</strong>。</p><p>一维逻辑块数组按照顺序映射到磁盘扇区</p><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-2/6-2.png" style="zoom: 33%;"></p><h3 id="磁盘访问时间"><a href="#磁盘访问时间" class="headerlink" title="磁盘访问时间"></a>磁盘访问时间</h3><p>磁盘延迟=软件的Queue处理+Disk Service Time(寻道+旋转+传输)</p><h4 id="寻道时间"><a href="#寻道时间" class="headerlink" title="寻道时间"></a>寻道时间</h4><p>磁头从当前位置移到指定磁道上所经历时间</p><p>$s:启动磁盘时间$</p><p>$m:磁头移动一条磁道所花时间$</p><p>$T_s=m*n+s$</p><h4 id="旋转延迟时间"><a href="#旋转延迟时间" class="headerlink" title="旋转延迟时间"></a>旋转延迟时间</h4><p>平均$T_r$为$50到100ms$</p><p>$T_r=1/(2r)$</p><h4 id="传输时间"><a href="#传输时间" class="headerlink" title="传输时间"></a>传输时间</h4><p>$T_t$为与磁盘进行数据交换（读出或写入）的时间</p><p>$T_t$的大小与每次所<strong>读／写的字节数</strong>b，<strong>旋转速度r</strong>以及磁道上的<strong>字节数N</strong>有关</p><p>$T_t = b/(rN)$</p><p>$b/N—需要多少转$</p><p>$r—多少转/s$</p><p>传输数据的大小 (通常是1个扇区): 512B</p><p>旋转速度：3600 RPM ~ 15000 RPM</p><p>典型的传输速度：2MB~50 MB/秒</p><h4 id="总访问时间"><a href="#总访问时间" class="headerlink" title="总访问时间"></a>总访问时间</h4><p>$T_a=T_s+1/(2r)+b/(rN)$</p><h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><h4 id="先来先服务-FCFS"><a href="#先来先服务-FCFS" class="headerlink" title="先来先服务 FCFS"></a>先来先服务 FCFS</h4><p>按访问请求先后次序服务</p><h4 id="最短寻道时间优先-SSTF"><a href="#最短寻道时间优先-SSTF" class="headerlink" title="最短寻道时间优先 SSTF"></a>最短寻道时间优先 SSTF</h4><p>优先选择<strong>距当前磁头最近的访问请求</strong>进行服务，主要考虑<strong>寻道优先</strong>。</p><p>可能导致饥饿，即一些请求长时间得不到服务</p><h4 id="扫描算法-SCAN-电梯调度"><a href="#扫描算法-SCAN-电梯调度" class="headerlink" title="扫描算法 SCAN 电梯调度"></a>扫描算法 SCAN 电梯调度</h4><p>磁盘臂沿特定方向移动到最后一层, 满足路径中的所有请求。</p><p>然后转回并反向移动至最低层, 满足路径中的所有请求。</p><h4 id="循环扫描算法-CSCAN"><a href="#循环扫描算法-CSCAN" class="headerlink" title="循环扫描算法 CSCAN"></a>循环扫描算法 CSCAN</h4><ul><li>按照所要访问的柱面位置的次序去选择访问者。</li><li>移动臂到达最后一个柱面后，<strong>立即</strong>带动读写磁头快速<strong>返回到0号柱面</strong>。</li><li>返回时<strong>不为任何的等待</strong>访问者<strong>服务</strong>。</li><li>返回后可再次进行扫描。</li></ul><p>SCAN算法偏向于处理最里或最外的磁道访问请求，CSCAN可以避免</p><h4 id="LOOK算法"><a href="#LOOK算法" class="headerlink" title="LOOK算法"></a>LOOK算法</h4><p>SCAN算法改进</p><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-2/6-4.png" style="zoom:80%;"></p><h4 id="CLOOK算法"><a href="#CLOOK算法" class="headerlink" title="CLOOK算法"></a>CLOOK算法</h4><p>CSCAN算法改进</p><p>每次向一个方向移动到最高请求柱面，之后返回最低请求柱面，不理会返回路径上的请求</p><h2 id="6-2-保证磁盘可靠性"><a href="#6-2-保证磁盘可靠性" class="headerlink" title="6.2 保证磁盘可靠性"></a>6.2 保证磁盘可靠性</h2><h3 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h3><p><strong>廉价冗余磁盘阵列</strong>,Redundant arrays of inexpensive disks</p><ul><li>冗余技术提高可靠性</li><li>并行提高性能</li></ul><p>数据分段并行交叉存取</p><p>组成磁盘阵列的不同方式称为RAID级别，分为0-6 7个级别，还有一个RAID10</p><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-2/6-3.png" style="zoom:67%;"></p><h2 id="6-3-提高I-O访问速度"><a href="#6-3-提高I-O访问速度" class="headerlink" title="6.3 提高I/O访问速度"></a>6.3 提高I/O访问速度</h2><h3 id="主要途径"><a href="#主要途径" class="headerlink" title="主要途径"></a>主要途径</h3><ul><li>选择性能好的磁盘</li><li>并行化</li><li>采用适当的调度算法</li><li>设置磁盘高速缓冲区</li></ul><h3 id="提高磁盘I-O速度——缓存"><a href="#提高磁盘I-O速度——缓存" class="headerlink" title="提高磁盘I/O速度——缓存"></a>提高磁盘I/O速度——缓存</h3><ul><li>独立缓存/以虚拟内存为缓存</li><li>置换算法 LRU</li><li>周期性写回</li></ul><h3 id="优化数据布局"><a href="#优化数据布局" class="headerlink" title="优化数据布局"></a>优化数据布局</h3><ul><li>优化物理块的分布</li><li>优化索引节点的分布</li></ul><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><ul><li>提前读</li><li>延迟写</li><li>虚拟盘</li></ul><h2 id="6-4-磁盘管理的实例"><a href="#6-4-磁盘管理的实例" class="headerlink" title="6.4 磁盘管理的实例"></a>6.4 磁盘管理的实例</h2><h1 id="第七章-文件系统"><a href="#第七章-文件系统" class="headerlink" title="第七章 文件系统"></a>第七章 文件系统</h1><h2 id="7-1-文件系统基本概念"><a href="#7-1-文件系统基本概念" class="headerlink" title="7.1 文件系统基本概念"></a>7.1 文件系统基本概念</h2><p>文件作为数据的存储和访问单位</p><p>文件包括：</p><ul><li>文件体：文件本身内容 （data）</li><li>文件说明：文件存储和管理的相关信息，如：文件名、文件内部标识、文件存储地址、访问权限、访问时间等；（meta-data）</li></ul><p>文件可以视为与进程地址空间无关的一段单独连续的逻辑地址空间</p><p>现代OS：一切皆文件</p><h2 id="7-2-文件系统实现方法"><a href="#7-2-文件系统实现方法" class="headerlink" title="7.2 文件系统实现方法"></a>7.2 文件系统实现方法</h2><p>文件系统管理对象：</p><ul><li>文件</li><li>目录</li><li>磁盘存储空间</li></ul><h3 id="文件控制块-FCB"><a href="#文件控制块-FCB" class="headerlink" title="文件控制块 FCB"></a>文件控制块 FCB</h3><h4 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h4><ul><li>文件名</li><li>物理位置 </li><li>文件逻辑结构 有无结构</li><li>文件物理结构 （顺序、索引）</li></ul><h4 id="访问控制信息"><a href="#访问控制信息" class="headerlink" title="访问控制信息"></a>访问控制信息</h4><ul><li>文件所有者 创建的用户</li><li>访问权限 读、写、执行、删除</li></ul><h4 id="使用信息"><a href="#使用信息" class="headerlink" title="使用信息"></a>使用信息</h4><ul><li>创建时间，上一次修改时间，当前使用信息等等</li></ul><h3 id="文件逻辑结构和物理结构"><a href="#文件逻辑结构和物理结构" class="headerlink" title="文件逻辑结构和物理结构"></a>文件逻辑结构和物理结构</h3><h4 id="文件逻辑结构（文件组织）"><a href="#文件逻辑结构（文件组织）" class="headerlink" title="文件逻辑结构（文件组织）"></a>文件逻辑结构（文件组织）</h4><h4 id="文件物理结构"><a href="#文件物理结构" class="headerlink" title="文件物理结构"></a>文件物理结构</h4><p>文件存放方式，在存储介质上的位置、链接和编目方法</p><p>主要结构：连续结构（顺序存取，适用于变化不大的顺序访问文件）、索引结构、串联结构（随机存取，采用链接指针，动态性好，易于扩充）</p><h3 id="索引结构-※※※"><a href="#索引结构-※※※" class="headerlink" title="索引结构 ※※※"></a>索引结构 ※※※</h3><p>为每个文件建立<strong>逻辑块号与物理块号的对照表</strong>：<strong>索引表</strong>。</p><p>文件由<strong>数据文件</strong>和<strong>索引表</strong>构成，这种文件称为：<strong>索引文件</strong>。</p><p>索引表位置：文件目录中，文件开头</p><p>索引表大小：固定/非固定大小</p><p>索引文件在存储区占两个区，<strong>索引区—放索引表</strong>，<strong>数据区—放数据文件本身</strong>。</p><h4 id="访问索引文件"><a href="#访问索引文件" class="headerlink" title="访问索引文件"></a>访问索引文件</h4><ul><li>先查文件索引号，由<strong>逻辑块号查得物理块号</strong></li><li>由此<strong>物理块号</strong>获得所要求的信息</li></ul><h4 id="索引表的组织"><a href="#索引表的组织" class="headerlink" title="索引表的组织"></a>索引表的组织</h4><ul><li>链接模式<ul><li>多个索引表链接起来</li></ul></li><li>多级索引</li><li>综合模式<ul><li>直接索引与间接索引结合</li></ul></li></ul><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id="目录的实现"><a href="#目录的实现" class="headerlink" title="目录的实现"></a>目录的实现</h4><p>直接法：目录项=文件名+FCB</p><p>间接法：目录项=文件名+FCB地址</p><h4 id="符号文件目录的查询"><a href="#符号文件目录的查询" class="headerlink" title="符号文件目录的查询"></a>符号文件目录的查询</h4><h5 id="顺序查寻法"><a href="#顺序查寻法" class="headerlink" title="顺序查寻法"></a>顺序查寻法</h5><p>依次比对名字</p><h5 id="Hash方法"><a href="#Hash方法" class="headerlink" title="Hash方法"></a>Hash方法</h5><p>将符号名唯一的变换为符号表中的表目索引</p><h3 id="磁盘空间管理"><a href="#磁盘空间管理" class="headerlink" title="磁盘空间管理"></a>磁盘空间管理</h3><h4 id="空闲表法"><a href="#空闲表法" class="headerlink" title="空闲表法"></a>空闲表法</h4><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">第一空闲盘块号</th><th style="text-align:center">空闲盘块数</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">3</td></tr></tbody></table></div><h4 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h4><p>分为<strong>空闲盘区链</strong>和<strong>空闲盘块链</strong></p><h4 id="位示图（位图法）"><a href="#位示图（位图法）" class="headerlink" title="位示图（位图法）"></a>位示图（位图法）</h4><h4 id="成组链表法"><a href="#成组链表法" class="headerlink" title="成组链表法"></a>成组链表法</h4><p>每组的<strong>第一个空闲块</strong>记录下一组空闲块的<strong>物理盘块号</strong>和<strong>空闲块总数</strong>。</p><h3 id="保护文件的方法"><a href="#保护文件的方法" class="headerlink" title="保护文件的方法"></a>保护文件的方法</h3><ul><li>建立副本</li><li>定时转储</li><li>规定文件的权限</li></ul><h2 id="7-3-文件系统实例分析"><a href="#7-3-文件系统实例分析" class="headerlink" title="7.3 文件系统实例分析"></a>7.3 文件系统实例分析</h2><h3 id="FAT"><a href="#FAT" class="headerlink" title="FAT"></a>FAT</h3><h3 id="EXT2"><a href="#EXT2" class="headerlink" title="EXT2"></a>EXT2</h3><h3 id="Linux-VFS"><a href="#Linux-VFS" class="headerlink" title="Linux VFS"></a>Linux VFS</h3><h3 id="LFS"><a href="#LFS" class="headerlink" title="LFS"></a>LFS</h3><h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>一个Unix文件系统采用2KB大小的数据块和4字节的数据块地址。每个i节点包括10个直接索引，1个一级间接索引和1个二级间接索引。<br>（1）该文件系统中文件最大为多少KB？（本小题5分）<br>（2）假设磁盘上一半的文件大小恰好为2KB，另一半文件的大小恰好为1.5KB，那么磁盘空间的利用率是多少？如果数据块大小改为1KB，磁盘空间利用率是多少？（只考虑存储文件数据的磁盘块）（本小题6分）<br>（3）小明编写了一个读取文件的程序，可以从不同大小的文件中随机读取一定量数据，结果发现读取大文件时的平均性能有明显下降。请分析主要原因，并尝试给出解决该问题的思路。（本小题4分）</p><p>(1)</p><p>2KB/4=512个磁盘块</p><p>(10+1*512+1*512*512)*2KB=</p><p>(2)</p><p>(2/2+1.5/2)/2=0.875</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-OS-2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS理论课笔记-系统引导/内存管理/进程与并发程序设计</title>
      <link href="2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/"/>
      <url>2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/</url>
      
        <content type="html"><![CDATA[<h1 id="第1章-引论"><a href="#第1章-引论" class="headerlink" title="第1章 引论"></a>第1章 引论</h1><p>操作系统是一个程序，是一组管理计算机硬件资源的软件集合，向计算机程序提供共性服务。</p><ol><li>控制计算机资源；</li><li>给用户提供<strong>接口</strong>或<strong>虚拟机</strong>。</li></ol><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/1-1.png" style="zoom:67%;"></p><h2 id="OS的历史沿革"><a href="#OS的历史沿革" class="headerlink" title="OS的历史沿革"></a>OS的历史沿革</h2><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/1-2.png" style="zoom: 50%;"></p><p><strong>批处理</strong>：用户提交作业成批送入计算机，由作业调度程序自动选择作业运行。涉及到<strong>Mainframe基本功能，排队论、统筹学</strong>。</p><p><strong>批处理系统</strong>，分为<strong>联机批处理系统</strong>（作业的输入/输出由CPU来处理）和<strong>脱机批处理系统</strong>（输入/输出脱离主机控制）。 两者均有CPU空闲，均为<strong>单道程序系统</strong></p><p><strong>多道程序系统</strong>：多个程序同时进入内存，交替使用I/O设备和CPU。</p><p>多道程序系统的出现，标志着操作系统<strong>渐趋成熟</strong>的阶段，先后出现了<strong>作业调度管理</strong>、<strong>处理机管理</strong>、<strong>存储器管理</strong>、<strong>外部设备管理</strong>、<strong>文件系统管理</strong>等功能。</p><p><strong>分时系统</strong>：多个用户分享使用同一台计算机。多个程序分时共享硬件和软件资源</p><p>两种典型分时系统：</p><ol><li><p>Multics/Unix (1968/1970)</p></li><li><p>IBM VM 360/370 (1966/1972)</p></li></ol><p>Unix、DOS、Windows、Linux（使用GNU）</p><p><strong>分布式网络化</strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/1-3.png" style="zoom: 60%;"></p><h2 id="操作系统基本实现机制"><a href="#操作系统基本实现机制" class="headerlink" title="操作系统基本实现机制"></a>操作系统基本实现机制</h2><h3 id="异常-exception-陷阱-trap-和中断-interrupt"><a href="#异常-exception-陷阱-trap-和中断-interrupt" class="headerlink" title="异常(exception): 陷阱(trap)和中断(interrupt)"></a>异常(exception): 陷阱(trap)和中断(interrupt)</h3><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/1-4.png" style="zoom:50%;"></p><h2 id="操作系统的基本类型"><a href="#操作系统的基本类型" class="headerlink" title="操作系统的基本类型"></a>操作系统的基本类型</h2><ul><li>批处理系统</li><li>分时系统</li><li>实时系统</li><li>混合型</li></ul><h2 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h2><h3 id="处理机管理"><a href="#处理机管理" class="headerlink" title="处理机管理"></a>处理机管理</h3><p>核心任务：分配CPU时间 ——进程、线程管理——公平分配、保证非阻塞、按优先级分配</p><p>进程管理：程序是静态实体，进程是执行中的程序。进程的调度：创建、挂起、激活。进程间通信：同步，互斥，死锁。</p><h3 id="存储器-内存-管理"><a href="#存储器-内存-管理" class="headerlink" title="存储器(内存)管理"></a>存储器(内存)管理</h3><p>管理缓存、主存、磁盘等所形成的多级存储架构，为多道程序的并发提供良好的环境。</p><p>– 内存分配和存储无关性：方便用户<br>– 内存保护：互不干扰<br>– 内存扩充：虚拟存储器</p><h3 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h3><p>管理输入/输出设备，屏蔽差异性，提供并发访问</p><p>– 设备无关性：逻辑设备-&gt;物理设备<br>– 设备分配：独享、共享和虚拟<br>– 设备的传输控制：中断、通道</p><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>将磁盘变成一个很容易使用的存储媒介提供给用户使用。<br>– 文件存储空间的管理<br>– 目录管理<br>– 文件读、写管理<br>– 文件保护<br>– 向用户提供接口</p><h3 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h3><ul><li>作业调度</li><li>作业控制。<ul><li>批量型作业</li><li>终端型作业</li></ul></li></ul><h1 id="第2章-系统引导"><a href="#第2章-系统引导" class="headerlink" title="第2章 系统引导"></a>第2章 系统引导</h1><h2 id="BootLoader"><a href="#BootLoader" class="headerlink" title="BootLoader"></a>BootLoader</h2><p>引导加载程序，是系统<strong>加电后</strong>运行的第一段软件代码，是操作系统<strong>内核运行之前</strong>运行的一段小程序</p><p><strong>BootLoader</strong>是<strong>Booter</strong>和<strong>Loader</strong>的合写，前者要<strong>初始化系统硬件</strong>使之运行起来，至少是<strong>部分运行</strong>起来；后者将<strong>操作系统映像加载到内存</strong>中，并跳转到操作系统的代码运行。</p><ul><li><strong>MIPS</strong>处理器大多用于<strong>嵌入式系统</strong>，嵌入式系统常用<strong>U-boot</strong>作为OS启动装载程序，U-Boot，全称 Universal Boot Loader；</li><li><strong>X86</strong>处理器通常采用<strong>LILO</strong>和<strong>GRUB</strong>。</li></ul><h2 id="U-Boot启动流程"><a href="#U-Boot启动流程" class="headerlink" title="U-Boot启动流程"></a>U-Boot启动流程</h2><p>大多数BootLoader都分为<strong>stage1</strong>和<strong>stage2</strong>两大部分，U-boot也不例外。</p><ul><li>依赖于cpu体系结构的代码（如设备初始化代码等）通常都放在stage1且可以用<strong>汇编语言</strong>来实现；</li><li>stage2则通常用<strong>C语言</strong>来实现，这样可以实现复杂的功能，而且有更好的可读性和移植性。</li></ul><h2 id="启动及OS引导"><a href="#启动及OS引导" class="headerlink" title="启动及OS引导"></a>启动及OS引导</h2><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/2-1.png" alt></p><h4 id="启动第一步——加载BIOS"><a href="#启动第一步——加载BIOS" class="headerlink" title="启动第一步——加载BIOS"></a>启动第一步——加载BIOS</h4><p>BIOS进行硬件自检以及读取启动顺序</p><h4 id="启动第二步——读取MBR，装载MBR到内存特定地址"><a href="#启动第二步——读取MBR，装载MBR到内存特定地址" class="headerlink" title="启动第二步——读取MBR，装载MBR到内存特定地址"></a>启动第二步——读取MBR，装载MBR到内存特定地址</h4><h4 id="启动第三步——Boot-Loader，运行主引导程序"><a href="#启动第三步——Boot-Loader，运行主引导程序" class="headerlink" title="启动第三步——Boot Loader，运行主引导程序"></a>启动第三步——Boot Loader，运行主引导程序</h4><h1 id="第3章-内存管理"><a href="#第3章-内存管理" class="headerlink" title="第3章 内存管理"></a>第3章 内存管理</h1><h2 id="3-1-多道程序的存储管理"><a href="#3-1-多道程序的存储管理" class="headerlink" title="3.1 多道程序的存储管理"></a>3.1 多道程序的存储管理</h2><p>固定（静态）式分区分配，程序适应分区。系统初始化时将存储空间分为若干个区域，之后再将这些区域分配给用户作业。</p><p>可变（动态）式分区分配，分区适应程序。动态确定分区边界。</p><p>内外碎片造成巨大空间浪费</p><p><strong>跟踪</strong>内存使用情况？<strong>位图表示法（分区表）</strong>和<strong>链表表示法（分区链表）</strong>。</p><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/2-2.png" style="zoom:40%;"><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/2-3.png" alt="2-3" style="zoom:40%;"></p><p>位图表示法空间成本固定，时间成本低，容错能力差（不知道被占用的原因）。</p><p>链表表示法时间成本高，容错能力较好。</p><h3 id="可变分区管理"><a href="#可变分区管理" class="headerlink" title="可变分区管理"></a>可变分区管理</h3><p>内存分配采用两张表：<strong>已分配分区表</strong>和<strong>未分配分区表</strong>。操作为分配、回收内存。</p><h3 id="基于顺序搜索的分配算法"><a href="#基于顺序搜索的分配算法" class="headerlink" title="基于顺序搜索的分配算法"></a>基于顺序搜索的分配算法</h3><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-1.png" style="zoom: 50%;"></p><h3 id="基于索引搜索的动态分区分配算法"><a href="#基于索引搜索的动态分区分配算法" class="headerlink" title="基于索引搜索的动态分区分配算法"></a>基于索引搜索的动态分区分配算法</h3><p>大中型系统采用</p><h4 id="快速适应算法（分类搜索法）"><a href="#快速适应算法（分类搜索法）" class="headerlink" title="快速适应算法（分类搜索法）"></a>快速适应算法（分类搜索法）</h4><p>把空闲分区<strong>按容量大小</strong>进行分类，经常用到长度的空闲区设立单独的<strong>空闲区链表</strong>。为多个空闲链表设立一张<strong>管理索引表</strong>。</p><h3 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h3><p>介于固定分区与可变分区之间的动态分区技术</p><p>在分配存储块时将一个<strong>大的存储块</strong>分裂成<strong>两个大小相等的小块</strong>。</p><p>已分配和空闲分区大小均为2的整数次幂。每次有一个新的大小请求先看有无最靠近这个大小的幂次的分区，没有就向上查找并分裂。</p><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-2.png" style="zoom:45%;"><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-3.png" style="zoom:45%;"></p><h2 id="3-2-程序从存储到执行"><a href="#3-2-程序从存储到执行" class="headerlink" title="3.2 程序从存储到执行"></a>3.2 程序从存储到执行</h2><h3 id="存储分配三种方式"><a href="#存储分配三种方式" class="headerlink" title="存储分配三种方式"></a>存储分配三种方式</h3><ul><li>直接指定。直接使用实际地址</li><li>静态分配</li><li>动态分配</li></ul><h4 id="可重定位分区分配"><a href="#可重定位分区分配" class="headerlink" title="可重定位分区分配"></a>可重定位分区分配</h4><p>定时的或在内存紧张时，移动某些已分配区中的信息，把存储空间中<strong>所有的空白区</strong>合<strong>并为</strong>一个<strong>大的连续区</strong>。</p><h3 id="程序的链接和装入"><a href="#程序的链接和装入" class="headerlink" title="程序的链接和装入"></a>程序的链接和装入</h3><ul><li><strong>编译</strong>(compile)：由编译程序将用户源程序<strong>编译</strong>成<strong>若干个目标模块</strong>。</li><li><strong>链接</strong>(linking)：由链接程序将<strong>目标模块</strong>和相应的<strong>库函数</strong>链接成<strong>可装载模块</strong>（<strong>可执行文件</strong>）。</li><li><strong>装入</strong>(loading)：由装载程序将可装载模块<strong>装入内存</strong>。一般采用动态运行时装入方式</li></ul><h4 id="链接方式"><a href="#链接方式" class="headerlink" title="链接方式"></a>链接方式</h4><ul><li><p>静态链接 直接将共享库中代码链接如程序代码中</p></li><li><p>动态链接 需要时才链接特定的模块</p></li></ul><h4 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h4><p>在装入时对目标程序中的指令和数据地址的修改，或映射过程。</p><h4 id="多重分区分配"><a href="#多重分区分配" class="headerlink" title="多重分区分配"></a>多重分区分配</h4><p>一个作业往往由相对独立的程序段和数据段组成，将这些片段分别装入到存储空间中不同的区域内的分配方式。</p><h3 id="程序段"><a href="#程序段" class="headerlink" title="程序段"></a>程序段</h3><p>一个程序本质上都是由 bss段、data段、text段三个组成的。</p><p><strong>bss段</strong>：（bss segment）用来存放程序中<strong>未初始化的全局变量</strong>的一块内存区域。bss是英文Block Started by Symbol的简称。bss段属于<strong>静态内存分配</strong>。</p><p><strong>data段</strong>：数据段（data segment）用来存放程序中<strong>已初始化的全局变量</strong>的一块内存区域。数据段属于<strong>静态内存分配</strong>。</p><p><strong>text段</strong>：代码段（code segment/text segment）用来存放<strong>程序执行代码</strong>的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于<strong>只读</strong>(某些架构也允许代码段为可写，即允许修改程序)。在代码段中，也有可能包含一些只读的常数变量，例如<strong>字符串常量</strong>等。</p><p><strong>栈(stack)</strong>：存放、交换<strong>临时数据</strong>的内存区</p><ul><li><p>用户存放<strong>程序局部变量</strong>的内存区域，（但不包括static声明的变量，<strong>static</strong>意味着在<strong>数据段中存放变量</strong>）。</p></li><li><p><strong>保存/恢复调用现场</strong>。在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。</p></li></ul><p><strong>堆（heap）</strong>：存放进程运行中<strong>动态分配</strong>的内存段</p><ul><li>它的大小并不固定，可动态扩张或缩减。当进程调用<strong>malloc等函数分配内存</strong>时，新分配的内存就被动态添加到堆上（<strong>堆被扩张</strong>）；当利用<strong>free</strong>等函数释放内存时，被释放的内存从堆中被剔除（<strong>堆被缩减</strong>）。</li></ul><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-4.png" alt></p><p>C语言各个段地址解析：</p><p><a href="https://blog.csdn.net/zhengshifeng123/article/details/79756830" target="_blank" rel="noopener">https://blog.csdn.net/zhengshifeng123/article/details/79756830</a></p><h3 id="gcc编译与链接"><a href="#gcc编译与链接" class="headerlink" title="gcc编译与链接"></a>gcc编译与链接</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gcc -o main main.c extra.c #-o 编译+链接</span><br><span class="line">./main #运行main</span><br><span class="line"></span><br><span class="line">gcc -c main.c</span><br><span class="line">gcc -c extra.c #只编译</span><br><span class="line"></span><br><span class="line">gcc main.o extra.o -o main</span><br><span class="line">./main #只链接</span><br></pre></td></tr></table></figure><p><strong>gcc调用</strong>包含的几个<strong>工具</strong>：</p><ul><li>cc1：预处理器和编译器</li><li>as：汇编器</li><li>collect2：链接器</li></ul><h3 id="Linux下可执行文件的格式"><a href="#Linux下可执行文件的格式" class="headerlink" title="Linux下可执行文件的格式"></a>Linux下可执行文件的格式</h3><p>ELF（Executable and Linkable Format）文件</p><ol><li><strong>可重定位（relocatable）文件</strong>，保存着代码和适当的数据，用来和其他的object文件一起来创建一个可执行文件或者是一个共享文件。</li><li><strong>可执行（executable）文件</strong>，保存着一个用来执行的程序，该文件指出了exec（BA_OS）如何来创建程序进程映像</li><li><strong>共享object文件</strong>，保存着代码和合适的数据，用来被下面的两个链接器链接。第一个是链接编辑器（静态链接），可以和其他的可重定位和共享object文件一起来创建object文件；第二个是动态链接器，联合一个可执行文件和其他的共享object文件来创建一个进程映象。</li></ol><p><strong>编译，链接，重定位，装载，运行</strong>。五个步骤完成程序的执行全流程。</p><h2 id="3-3-页式内存管理"><a href="#3-3-页式内存管理" class="headerlink" title="3.3 页式内存管理"></a>3.3 页式内存管理</h2><h3 id="程序、进程和作业"><a href="#程序、进程和作业" class="headerlink" title="程序、进程和作业"></a>程序、进程和作业</h3><p><strong>程序</strong>—<strong>静止</strong>的，是存放在磁盘上的可执行文件</p><p><strong>进程</strong>—<strong>动态</strong>的，包括程序和程序处理对象，是分配资源的基本单位。</p><ul><li><p>完成操作系统功能的进程是<strong>系统进程</strong>。</p></li><li><p>完成用户功能的进程称为<strong>用户进程</strong>。</p></li></ul><p><strong>作业</strong>—是用户需要计算机完成的<strong>某项任务</strong>，是要求计算机<strong>所做工作的集合</strong>。</p><p>一个<strong>作业</strong>划分为<strong>多个进程</strong>来完成，一个进程又由其<strong>实体</strong>—<strong>程序和数据集合</strong>来组成。</p><h3 id="分页式存储管理"><a href="#分页式存储管理" class="headerlink" title="分页式存储管理"></a>分页式存储管理</h3><p><strong>纯分页系统</strong>：没有页面置换功能。所有页<strong>一次性全部装入主存</strong>。</p><p><strong>页</strong>：每个作业的<strong>地址空间</strong>分成一些<strong>大小相等的片</strong>，称之为<strong>页面</strong>或<strong>页</strong>。</p><p><strong>存储块</strong>：主存的<strong>存储空间</strong>也分成和<strong>页面相同大小的片</strong>，称为<strong>存储块</strong>，或<strong>页框</strong>。</p><p><strong>分页地址结构</strong>：</p><h5 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a>逻辑地址</h5><div class="table-container"><table><thead><tr><th style="text-align:center">31-12</th><th style="text-align:center">11-0</th></tr></thead><tbody><tr><td style="text-align:center">页号p</td><td style="text-align:center">页内偏移w</td></tr></tbody></table></div><h5 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h5><div class="table-container"><table><thead><tr><th style="text-align:center">21-12</th><th style="text-align:center">11-0</th></tr></thead><tbody><tr><td style="text-align:center">块号</td><td style="text-align:center">块内偏移d</td></tr></tbody></table></div><p>现代操作系统中最常用的页面大小为4KB</p><h4 id="内存分配基本思想"><a href="#内存分配基本思想" class="headerlink" title="内存分配基本思想"></a>内存分配基本思想</h4><ul><li>以<strong>页</strong>为单位进行分配，并按程序（作业）的<strong>长度（页数）</strong>进行分配；</li><li><strong>逻辑上相邻</strong>的页，<strong>物理上不一定相邻</strong>。</li></ul><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>每个进程有一个<strong>进程页表</strong>，描述该进程<strong>占用的物理页面</strong>及<strong>逻辑排列顺序</strong>。</p><p>整个系统有一个<strong>物理页面表</strong>，描述物理内存空间<strong>分配使用</strong>情况。</p><p>整个系统有一个<strong>请求表</strong>，描述系统内各个<strong>进程页表的位置</strong>和<strong>大小</strong>，用于<strong>地址转换</strong>，也可以结合到各进程的PCB里。</p><h4 id="地址变换—页表查找"><a href="#地址变换—页表查找" class="headerlink" title="地址变换—页表查找"></a>地址变换—页表查找</h4><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-5.png" style="zoom: 80%;"></p><h4 id="关于页表"><a href="#关于页表" class="headerlink" title="关于页表"></a>关于页表</h4><ul><li>页表<strong>放置在内存中</strong>，记录了进程的<strong>现场信息</strong>。记录进程的<strong>内存分配情况</strong>以及实现进程运行时的<strong>动态重定位</strong>。</li><li>访问一个数据需要访问内存<strong>两次</strong>（页表一次，内存一次）。</li><li>页表的<strong>基址</strong>及<strong>长度</strong>由<strong>页表寄存器</strong>给出。</li></ul><h4 id="地址转换机构"><a href="#地址转换机构" class="headerlink" title="地址转换机构"></a>地址转换机构</h4><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-6.png" style="zoom:80%;"></p><p>逻辑地址分为页号和页内地址两部分。先进行越界保护。之后进行页表定位：页表始址+页号*页表项长度</p><p>查询页表，读出块号。物理地址=块号+块内地址（块内地址=页内地址）</p><h3 id="提高分页效率"><a href="#提高分页效率" class="headerlink" title="提高分页效率"></a>提高分页效率</h3><ul><li>减少页表大小</li><li>提高地址映射速度</li></ul><h4 id="解决问题方法"><a href="#解决问题方法" class="headerlink" title="解决问题方法"></a>解决问题方法</h4><ul><li>动态调入页表：只将需用的部分页表项调入内存</li><li>多级页表</li></ul><p><strong>二级页表</strong>：</p><ul><li>一级目录：页目录表</li><li>二级目录：页表</li></ul><p>参考博客：<a href="https://www.jianshu.com/p/51c2286a6268" target="_blank" rel="noopener">https://www.jianshu.com/p/51c2286a6268</a></p><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-7.jpg" style="zoom: 67%;"></p><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-8.png" style="zoom:67%;"></p><blockquote><p>如果是64位操作系统，内存也是4G，每个页面大小也为4KB，采用三级页表，需要字对齐，则虚拟地址应该为多少位？</p></blockquote><p>首先每一级页表的所占空间大小应该都是一个页面的大小。即4KB（因为自映射机制）</p><p>又由于64位操作系统需要字对齐，所以实际上每一级目录只占用12-3=9位。</p><p>因此三级目录就需要9*3+12=39位</p><p>多级页表带来访存效率低下问题</p><h3 id="页表快速访问机制——MMU"><a href="#页表快速访问机制——MMU" class="headerlink" title="页表快速访问机制——MMU"></a>页表快速访问机制——MMU</h3><p>CPU内部增加了一个硬件单元，称为<strong>存储管理单元MMU</strong>（Memory Management Unit）</p><ul><li><strong>页表Cache</strong>：又称为<strong>TLB</strong>，用于存放<strong>虚拟地址</strong>与<strong>相应</strong>的<strong>物理地址</strong>；</li><li><strong>TLB控制单元</strong>：TLB内容<strong>填充、刷新、覆盖，以及越界检查</strong>。</li><li><strong>页表（遍历）查找单元</strong>：若TLB未命中，自动查找多级页表，将找到的物理地址<strong>送与TLB控制单元</strong>。（可用软件实现）</li></ul><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-21.png" alt></p><h3 id="反向页表、哈希页表"><a href="#反向页表、哈希页表" class="headerlink" title="反向页表、哈希页表"></a>反向页表、哈希页表</h3><h3 id="页的保护"><a href="#页的保护" class="headerlink" title="页的保护"></a>页的保护</h3><ul><li>地址<strong>越界</strong>保护</li><li>页表中设置<strong>保护位</strong>（只读，读写，执行）</li></ul><h3 id="页面大小习题"><a href="#页面大小习题" class="headerlink" title="页面大小习题"></a>页面大小习题</h3><p>假设进程的平均大小是1MB(s=1MB)，每个页表项需要8个字节(e=8B)。页面大小设置为多少字节比较好？</p><p>答：$f(p)=s*e/p+p/2，求minf(p)$ $为4kB$</p><h3 id="多级页表再理解"><a href="#多级页表再理解" class="headerlink" title="多级页表再理解"></a>多级页表再理解</h3><p>指令给出的地址除<strong>偏移地址之外</strong>的<strong>各部分</strong>全是各级页表的<strong>页表号</strong>或<strong>页号</strong>，且都是<strong>物理页号</strong></p><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-9.png" style="zoom: 67%;"></p><h2 id="3-4-分段存储管理"><a href="#3-4-分段存储管理" class="headerlink" title="3.4 分段存储管理"></a>3.4 分段存储管理</h2><p>逻辑地址结构为：<strong>段号S+位移量W</strong></p><p><strong>段表</strong>记录了段与内存位置对应关系，保存在内存中。</p><p>段表<strong>基地址</strong>和<strong>长度</strong>由段表寄存器给出。访问一个字节数据/指令需要<strong>访问内存两次</strong>（段表1次，内存1次）。</p><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-10.png" style="zoom:80%;"></p><p>先比较段号S和段表长度TL，不越界则检查段内地址d是否超过段长。</p><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-11.png" style="zoom:80%;"></p><p><strong>信息共享</strong>——<strong>可重入代码</strong>（<strong>纯代码Pure Code</strong>），允许多个进程<strong>同时访问</strong>，但<strong>不允许</strong>任何进程对其进行<strong>修改</strong>。</p><p>可采用<strong>分段共享</strong>，</p><h3 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h3><p><strong>分段方法</strong>——分配和管理<strong>虚拟存储器</strong></p><p><strong>分页方法</strong>——分配和管理<strong>实存储器</strong></p><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-12.png" style="zoom:80%;"></p><h2 id="3-5-虚拟存储管理（※）"><a href="#3-5-虚拟存储管理（※）" class="headerlink" title="3.5 虚拟存储管理（※）"></a>3.5 虚拟存储管理（※）</h2><p><strong>虚拟地址空间</strong>：并不真实存在，格式按<strong>字节从0开始编址</strong>所形成的空间</p><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-13.png" style="zoom: 67%;"></p><h3 id="虚拟存储的基本原理"><a href="#虚拟存储的基本原理" class="headerlink" title="虚拟存储的基本原理"></a>虚拟存储的基本原理</h3><ul><li>按需装载</li><li>缺页调入</li><li>不用调出</li></ul><h3 id="缺页错误（-Page-Fault）处理机制"><a href="#缺页错误（-Page-Fault）处理机制" class="headerlink" title="缺页错误（ Page Fault）处理机制"></a>缺页错误（ Page Fault）处理机制</h3><p>当进程执行过程中需访问的页面不在物理存储器中时，会引发发生缺页中断，进行所需页面换入，步骤如下：</p><ol><li>陷入内核态，保存必要的信息（OS及用户进程状态相关的信息）。（现场保护）</li><li>查找出来发生页面中断的虚拟页面（进程地址空间中的页面）。这个虚拟页面的信息通常会保存在一个硬<br>件寄存器中，如果没有的话，操作系统必须检索程序计数器，取出这条指令，用软件分析该指令，通过分析找出发生页面中断的虚拟页面。（页面定位）</li><li>检查虚拟地址的有效性及安全保护位。如果发生保护错误，则杀死该进程。（权限检查）</li><li>查找一个空闲的页框(物理内存中的页面)，如果没有空闲页框则需要通过页面置换算法找到一个需要换出的页框。（新页面调入（1））</li><li>如果找的页框中的内容被修改了，则需要将修改的内容保存到磁盘上。（注：此时需要将页框置为忙状态，以防页框被其它进程抢占掉）（旧页面写回）</li><li>页框“干净”后，操作系统将保存在磁盘上的页面内容复制到该页框中。（新页面调入（2））此时会引起一个磁盘读写调用，发生上下文切换（在等待磁盘读写的过程中让其它进程运行）。</li><li>当磁盘中的页面内容全部装入页框后，向操作系统发送一个中断。操作系统更新内存中的页表项，将虚拟页面映射的页框号更新为写入的页框，并将页框标记为正常状态。（更新页表）</li><li>恢复缺页中断发生前的状态，将程序指针重新指向引起缺页中断的指令。（恢复现场）</li><li>程序重新执行引发缺页中断的指令，进行存储访问。（继续执行）缺页处理过程涉及了用户态和内核态之间的切换，虚拟地址和物理地址之间的转换（这个转换过程需要使用MMU和TLB）</li></ol><h2 id="3-6-页面置换"><a href="#3-6-页面置换" class="headerlink" title="3.6 页面置换"></a>3.6 页面置换</h2><h3 id="1-最优置换-OPT"><a href="#1-最优置换-OPT" class="headerlink" title="1.最优置换 OPT"></a>1.最优置换 OPT</h3><ul><li><p>需要用<strong>先验知识</strong>，无法实现，作为<strong>基准</strong>衡量其他算法效果。</p></li><li><p>置换掉<strong>未来最久不被使用</strong>的页</p></li></ul><h3 id="2-FIFO类算法"><a href="#2-FIFO类算法" class="headerlink" title="2.FIFO类算法"></a>2.FIFO类算法</h3><h4 id="先进先出-FIFO"><a href="#先进先出-FIFO" class="headerlink" title="先进先出 FIFO"></a>先进先出 FIFO</h4><p>用一个<strong>队列</strong>维护</p><p><strong>性能较差</strong>，因为<strong>较早调入</strong>的页往往<strong>访问频率高</strong></p><h4 id="Belady-现象"><a href="#Belady-现象" class="headerlink" title="Belady 现象"></a>Belady 现象</h4><p>FIFO容易出现</p><p>分配页面增多，<strong>缺页率</strong>反而<strong>增高</strong></p><h4 id="改进FIFO—Second-Chance"><a href="#改进FIFO—Second-Chance" class="headerlink" title="改进FIFO—Second Chance"></a>改进FIFO—Second Chance</h4><p>每个页面增加一个<strong>访问标志位</strong>，标识进入<strong>缓存队列</strong>后是否再次被访问过</p><p>如果一个页面进入后被访问，则设置标识位为1。在将要淘汰A时，将A标识位设成0，并将A移动到<strong>队列头（视为新加入的）</strong></p><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-15.png" style="zoom: 80%;"></p><h4 id="改进FIFO—Clock"><a href="#改进FIFO—Clock" class="headerlink" title="改进FIFO—Clock"></a>改进FIFO—Clock</h4><p>Second Chance的改进版，也叫最近未使用算法</p><p>使用<strong>环形队列</strong>，缺页时当前指针指向的P如果访问标记为1，则清零并移动指针到P的下一个</p><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-14.png" style="zoom:67%;"></p><p>FIFO类算法命中率较低，<strong>实际应用</strong>较少。</p><h4 id="FIFO算法性能比较"><a href="#FIFO算法性能比较" class="headerlink" title="FIFO算法性能比较"></a>FIFO算法性能比较</h4><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-16.png" style="zoom: 50%;"></p><h3 id="3-最近最少使用-LRU算法"><a href="#3-最近最少使用-LRU算法" class="headerlink" title="3.最近最少使用 LRU算法"></a>3.最近最少使用 LRU算法</h3><p><strong>核心思想</strong>：最近被访问过，将来被访问概率增高</p><p>淘汰掉<strong>最先进入队列</strong>里且被<strong>访问次数最少</strong>的页面，可采用链表实现</p><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-17.png" style="zoom: 50%;"></p><h3 id="4-其他替换算法"><a href="#4-其他替换算法" class="headerlink" title="4.其他替换算法"></a>4.其他替换算法</h3><ul><li><p>LRU类：LRU2， Two queues（2Q）， Multi Queue（MQ）</p></li><li><p>LFU类： LFU（Least Frequently Used）， LFU-Aging， LFU*-Aging， Window-LFU； </p></li><li>其它： Most Recently Used（MRU），Adaptive Replacement Cache（ARC），Working Set（WS），Working Set Clock（WSclock）</li></ul><h3 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h3><ul><li><strong>两个进程共享</strong>同一块物理内存，每个页面都被标志成了<strong>写时复制</strong>。共享的物理内存中每个页面都是只读的。</li><li>如果某个进程想改变某个页面时，就会与<strong>只读标记</strong>冲突，而系统在检测出页面是<strong>写时复制</strong>的，则会在内存中复制一个页面，然后进行写操作。</li><li>新复制的页面对执行写操作的进程是私有的，对其他共享写时复制页面的进程是不可见的。</li></ul><h2 id="3-7-页目录自映射"><a href="#3-7-页目录自映射" class="headerlink" title="3.7 页目录自映射"></a>3.7 页目录自映射</h2><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-18.png" style="zoom: 40%;"><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-19.png" style="zoom:40%;"><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-20.png" style="zoom:40%;"></p><h1 id="第4章-进程与并发程序设计"><a href="#第4章-进程与并发程序设计" class="headerlink" title="第4章 进程与并发程序设计"></a>第4章 进程与并发程序设计</h1><h2 id="4-1-进程与线程"><a href="#4-1-进程与线程" class="headerlink" title="4.1 进程与线程"></a>4.1 进程与线程</h2><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><p>并发：两个活动都处在各自的<strong>起点到终点间的某一处</strong>。</p><p>并行：<strong>同一时间度量</strong>下<strong>同时运行</strong>在<strong>不同的处理机</strong>上</p><p>并发不一定是并行</p><h4 id="并行性的确定—Bernstein条件"><a href="#并行性的确定—Bernstein条件" class="headerlink" title="并行性的确定—Bernstein条件"></a>并行性的确定—Bernstein条件</h4><p>程序并发执行出现<strong>竞争</strong></p><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/4-1.png" style="zoom:50%;"></p><p>归结为：<strong>不存在一个数据集</strong>两个进程<strong>同时需要写</strong></p><h3 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h3><p><strong>结构特征</strong>：包含<strong>程序段，数据段，进程控制块（PCB）</strong></p><p>一个进程应该包括：</p><ul><li>程序的代码；</li><li>程序的数据；</li><li>PC中的值，用来指示下一条将运行的指令；</li><li>一组通用的寄存器的当前值，堆、栈；</li><li>一组系统资源（如打开的文件）</li></ul><h3 id="进程状态与控制"><a href="#进程状态与控制" class="headerlink" title="进程状态与控制"></a>进程状态与控制</h3><p>进程控制实现：<strong>原语</strong>——常驻内存，只在内核态下执行，指令序列连续不可分割</p><p>创建原语(fork exec)</p><p>撤销原语(kill)</p><h4 id="进程三种基本状态"><a href="#进程三种基本状态" class="headerlink" title="进程三种基本状态"></a>进程三种基本状态</h4><p>就绪(Ready)：已获得处理机外所需资源，等待CPU的分配</p><p>执行(Running)：<strong>占用处理机</strong>资源。无进程可执行时，自动执行系统idle进程（相当于空操作）</p><p>阻塞(Blocked)：正在执行的进程，因等待某事件，<strong>暂时无法</strong>继续执行，放弃处理机处于<strong>暂停</strong>状态</p><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/4-2.png" style="zoom: 67%;"></p><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/4-3.png" style="zoom: 80%;"></p><h4 id="挂起进程模型"><a href="#挂起进程模型" class="headerlink" title="挂起进程模型"></a>挂起进程模型</h4><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/4-4.png" style="zoom: 67%;"></p><h4 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h4><ul><li><strong>进程标识符</strong> （进程ID）</li><li><strong>程序、数据地址</strong></li><li><strong>当前状态</strong> 系统会把相同状态的进程组成队列</li><li><strong>现场保护区</strong> 需要等待时保存CPU各种状态信息</li><li><strong>同步与同步机制</strong> 实现进程间互斥同步、通信所需的信号量</li><li><strong>优先级</strong> </li><li><strong>资源清单</strong> 拥有的除CPU外的资源记录</li><li><strong>链接字</strong> 该进程所在队列中下一个进程PCB首地址</li></ul><h3 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h3><p>进程 (process task) 包含了两个概念：<strong>资源拥有者</strong>和<strong>可执行单元</strong></p><p>可执行单元——线程(thread)  将<strong>资源与计算</strong>分离，提高并发效率</p><p><strong>进程</strong>是<strong>资源分配</strong>的基本单位，<strong>线程</strong>是<strong>处理机调度</strong>的基本单位</p><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/4-5.png" style="zoom:50%;"></p><h3 id="线程的实现方式-※※"><a href="#线程的实现方式-※※" class="headerlink" title="线程的实现方式 ※※"></a>线程的实现方式 ※※</h3><h4 id="用户级线程：User-level-threads-ULT"><a href="#用户级线程：User-level-threads-ULT" class="headerlink" title="用户级线程：User level threads(ULT)"></a>用户级线程：User level threads(ULT)</h4><p>线程在用户空间,通过library模拟的thread</p><h4 id="内核级线程：Kernel-level-threads-KLT"><a href="#内核级线程：Kernel-level-threads-KLT" class="headerlink" title="内核级线程：Kernel level threads (KLT)"></a>内核级线程：Kernel level threads (KLT)</h4><p>kernel有好几个分身 多线程内核</p><h4 id="混合实现方式"><a href="#混合实现方式" class="headerlink" title="混合实现方式"></a>混合实现方式</h4><p>使用内核级线程，将<strong>用户级线程</strong>与<strong>某些</strong>或者<strong>全部</strong>内核线程<strong>多路复用</strong>起来，形成混合的线程实现方式。</p><h4 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h4><ul><li><strong>Many-to-One Model</strong> 多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。<ul><li>优点：线程管理在用户空间进行，<strong>效率高</strong></li><li>缺点：一个线程被阻塞，整个进程被阻塞；<strong>多个线程不能并行</strong>运行在多处理机上</li></ul></li><li><strong>One-to-one Model</strong>  将每个用户级线程映射到一个内核级线程<ul><li>优点：一个进程阻塞可以让另一线程继续，<strong>并发能力强</strong></li><li>缺点：每创1个用户级线程都需要创1个内核级线程，<strong>开销大</strong></li></ul></li><li><strong>Many-to-Many Model</strong>  将 n 个用户级线程映射到m 个内核级线程上，要求m &lt;= n。<ul><li>特点：集前2者之长</li></ul></li></ul><h2 id="4-2-同步与互斥"><a href="#4-2-同步与互斥" class="headerlink" title="4.2 同步与互斥"></a>4.2 同步与互斥</h2><p>互斥-间接制约：多个进程不能同时进入<strong>同一组共享变量临界区域</strong></p><p>同步-直接制约：有效地共享资源、相互合作</p><h3 id="基于忙等的方式"><a href="#基于忙等的方式" class="headerlink" title="基于忙等的方式"></a>基于忙等的方式</h3><p>软硬件方法都不可取 </p><p>Lamport面包店算法、Eisenberg算法</p><h3 id="基于信号量的方法"><a href="#基于信号量的方法" class="headerlink" title="基于信号量的方法"></a>基于信号量的方法</h3><h4 id="经典信号量机制"><a href="#经典信号量机制" class="headerlink" title="经典信号量机制"></a>经典信号量机制</h4><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单表述</span></span><br><span class="line">P(S): <span class="keyword">while</span> S&lt;=<span class="number">0</span> <span class="keyword">do</span> skip</span><br><span class="line">  S:=S-<span class="number">1</span>;</span><br><span class="line">V(S): S:=S+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//详细表述</span></span><br><span class="line"><span class="keyword">Type</span> semaphore = <span class="keyword">record</span></span><br><span class="line">    value : integer;</span><br><span class="line">    L : list <span class="keyword">of</span> process;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">Procedure</span> <span class="title">P</span><span class="params">(S)</span></span></span><br><span class="line"><span class="function">    <span class="title">var</span> <span class="title">S</span> :</span> semaphore;</span><br><span class="line">    <span class="keyword">begin</span> </span><br><span class="line">        S.value := S.value -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> S.value&lt;<span class="number">0</span> <span class="keyword">then</span> block(S.L);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">V</span><span class="params">(S)</span></span></span><br><span class="line"><span class="function">    <span class="title">var</span> <span class="title">S</span> :</span> semaphore;</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        S.value := S.value + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> S.value&lt;=<span class="number">0</span> <span class="keyword">then</span> wakeup(S.L);</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>信号量必须且只能置一次初值，且只能由P/V操作来改变</p><h4 id="物理意义"><a href="#物理意义" class="headerlink" title="物理意义"></a>物理意义</h4><ul><li>S.value为正时表示<strong>资源的个数</strong></li><li>S.value为负时表示<strong>等待进程</strong>的<strong>个数</strong></li><li>P操作<strong>分配</strong>资源</li><li>V操作<strong>释放</strong>资源</li></ul><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#互斥 初始化S=1</span></span><br><span class="line"><span class="comment">#有限n并发可以把S初始值设为n</span></span><br><span class="line">P(S)   P(S)</span><br><span class="line">临界区  临界区</span><br><span class="line">V(S)   V(S)</span><br><span class="line"></span><br><span class="line"><span class="comment">#同步 初始化S=0 先运行code1 再运行code2</span></span><br><span class="line">P(S)   code1</span><br><span class="line">code2  V(S)</span><br></pre></td></tr></table></figure><h3 id="基于管程的同步与互斥"><a href="#基于管程的同步与互斥" class="headerlink" title="基于管程的同步与互斥"></a>基于管程的同步与互斥</h3><p>管程：高级同步原语</p><p>把<strong>分散的临界区集中</strong>起来，为每个可共享资源设计一个<strong>专门机构</strong>来<strong>统一管理</strong>各进程对该资源的访问，这个<strong>专门机构</strong>称为管程。</p><p>管程互斥进入，由编译器进行实现、</p><h3 id="进程间通信-Inter-Process-Comm"><a href="#进程间通信-Inter-Process-Comm" class="headerlink" title="进程间通信(Inter-Process-Comm)"></a>进程间通信(Inter-Process-Comm)</h3><ul><li>管道（Pipe）及命名管道（Named pipe或FIFO） </li><li>消息队列（Message） 两个通信原语<ul><li>send(destination, &amp;message)</li><li>receive(source, &amp;message)</li></ul></li><li>共享内存（Shared memory） <ul><li>最有用,最快</li><li>同一块物理内存被映射到进程A、B各自的进程地址空间</li><li>共享内存可以同时读但不能同时写，则需要<strong>同步机制</strong>约束</li></ul></li><li>信号量（Semaphore） </li><li>套接字（Socket） </li><li>信号（Signal）</li></ul><h2 id="4-3-经典进程同步问题"><a href="#4-3-经典进程同步问题" class="headerlink" title="4.3 经典进程同步问题"></a>4.3 经典进程同步问题</h2><h3 id="生产者－消费者问题-the-producer-consumer-problem"><a href="#生产者－消费者问题-the-producer-consumer-problem" class="headerlink" title="生产者－消费者问题(the producer consumer problem)"></a>生产者－消费者问题(the producer consumer problem)</h3><blockquote><p>若干进程通过有限的共享缓冲区交换数据。其中，“生产者”进程不断写入，而 “消费者”进程不断读出；共享缓冲区共有 N个；任何时刻只能有一个进程可对共享缓冲区进行操作。</p></blockquote><h4 id="信号量写法"><a href="#信号量写法" class="headerlink" title="信号量写法"></a>信号量写法</h4><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/4-6.png" style="zoom:50%;"></p><h4 id="管程写法"><a href="#管程写法" class="headerlink" title="管程写法"></a>管程写法</h4><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/4-7.png" style="zoom: 67%;"></p><h3 id="读者－写者问题-the-readers-writers-problem"><a href="#读者－写者问题-the-readers-writers-problem" class="headerlink" title="读者－写者问题(the readers-writers problem)"></a>读者－写者问题(the readers-writers problem)</h3><blockquote><p>问题描述：对共享资源的读写操作，任一时刻 “写者”最多只允许一个，而 “读者”则允许多个，即 “读－写”互斥，“写－写”互斥，“读－读”允许</p></blockquote><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.读者占优势算法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//wmutex表示“允许写”，初值是1。 </span></span><br><span class="line"><span class="comment">//公共变量readcount表示“正在读”的进程数，初值是0； </span></span><br><span class="line"><span class="comment">//mutex表示对readcount的互斥操作，初值是1。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Writer</span></span><br><span class="line">P(wmutex);</span><br><span class="line"><span class="keyword">write</span></span><br><span class="line">V(wmutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Reader</span></span><br><span class="line">P(mutex);</span><br><span class="line">    <span class="keyword">if</span> readcount=<span class="number">0</span> <span class="keyword">then</span> P(wmutex);</span><br><span class="line">    readcount := readcount +<span class="number">1</span>;</span><br><span class="line">V(mutex);</span><br><span class="line"><span class="keyword">read</span></span><br><span class="line">P(mutex);</span><br><span class="line">    readcount := readcount -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> readcount=<span class="number">0</span> <span class="keyword">then</span> V(wmutex);</span><br><span class="line">V(mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.读写公平算法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//新增读写互斥变量rwmutex=1</span></span><br><span class="line"><span class="comment">//相当于读完1个之后不能继续下一个人读</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Writer</span></span><br><span class="line">P(rwmutex);</span><br><span class="line">P(wmutex);</span><br><span class="line"><span class="keyword">write</span></span><br><span class="line">V(wmutex);</span><br><span class="line">V(rwmutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Reader</span></span><br><span class="line">P(rwmutex);</span><br><span class="line">P(mutex);</span><br><span class="line">    <span class="keyword">if</span> readcount=<span class="number">0</span> <span class="keyword">then</span> P(wmutex);</span><br><span class="line">    readcount := readcount +<span class="number">1</span>;</span><br><span class="line">V(mutex);</span><br><span class="line">V(rwmutex);  <span class="comment">//释放rwmutex从而让写者先写</span></span><br><span class="line"><span class="keyword">read</span></span><br><span class="line">P(mutex);</span><br><span class="line">    readcount := readcount -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> readcount=<span class="number">0</span> <span class="keyword">then</span> V(wmutex);</span><br><span class="line">V(mutex);</span><br></pre></td></tr></table></figure><h3 id="哲学家进餐问题-the-dining-philosophers-problem"><a href="#哲学家进餐问题-the-dining-philosophers-problem" class="headerlink" title="哲学家进餐问题(the dining philosophers problem)"></a>哲学家进餐问题(the dining philosophers problem)</h3><blockquote><p>问题描述：（由Dijkstra首先提出并解决）5个哲学家围绕一张圆桌而坐，桌子上放着5支筷子，每两个哲学家之间放一支；</p><p>哲学家的动作包括思考和进餐，进餐时需要同时拿起他左边和右边的两支筷子，思考时则同时将两支筷子放回原处。</p><p>如何保证哲学家们的动作有序进行？如：不出现相邻者同时进餐；不出现有人永远拿不到筷子。</p></blockquote><h3 id="理发师问题"><a href="#理发师问题" class="headerlink" title="理发师问题"></a>理发师问题</h3><blockquote><p>理发店里有一位理发师、一把理发椅和n把供等候理发的顾客坐的椅子；</p><p>如果没有顾客，理发师便在理发椅上睡觉，当一个顾客到来时，叫醒理发师；</p><p>如果理发师正在理发时，又有顾客来到，则如果有空椅子可坐，就坐下来等待，否则就离开。</p></blockquote><h3 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h3><blockquote><p>三个吸烟者在一间房间内，还有一个香烟供应者。为了制造并抽掉香烟，每个吸烟者需要三样东西：烟草、纸和火柴。供应者有丰富的货物提供。</p><p>三个吸烟者中，第一个有自己的烟草，第二个有自己的纸，第三个有自己的火柴。</p><p>供应者将两样东西放在桌子上，允许一个吸烟者吸烟。当吸烟者完成吸烟后唤醒供应者，供应者再放两样东西（随机地）在桌面上，然后唤醒另一个吸烟者。</p><p>试为吸烟者和供应者编写程序解决问题。</p></blockquote><h2 id="4-4调度"><a href="#4-4调度" class="headerlink" title="4.4调度"></a>4.4调度</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>控制协调多个进程对CPU的竞争</p><h4 id="调度类型"><a href="#调度类型" class="headerlink" title="调度类型"></a>调度类型</h4><ul><li>高级调度：接纳多少个作业，接纳哪些作业</li><li>中级调度：内外存交换</li><li>低级调度：CPU资源角度，非抢占式和抢占式（时间片原则，优先权原则，短作业（进程）优先</li></ul><h3 id="设计调度算法要考虑的问题（设计要点）"><a href="#设计调度算法要考虑的问题（设计要点）" class="headerlink" title="设计调度算法要考虑的问题（设计要点）"></a>设计调度算法要考虑的问题（设计要点）</h3><h4 id="进程优先级（数）"><a href="#进程优先级（数）" class="headerlink" title="进程优先级（数）"></a>进程优先级（数）</h4><p>优先数反映了某个优先级</p><p>静态优先级、动态优先级</p><h4 id="进程就绪队列组织"><a href="#进程就绪队列组织" class="headerlink" title="进程就绪队列组织"></a>进程就绪队列组织</h4><p>按优先级排队方式</p><h4 id="占用CPU的方式"><a href="#占用CPU的方式" class="headerlink" title="占用CPU的方式"></a>占用CPU的方式</h4><ul><li><strong>不可抢占式方式</strong>。一直占用处理器，直到该进程自己因调用原语操作，或等待I/O等原因进入阻塞状态，或时间片用完时才让出处理器，重新进行。</li><li><strong>抢占式方式</strong>。就绪队列中一旦有优先级高于当前运行进程优先级的进程存在时，便立即进行进程调度，把处理器转给优先级高的进程</li></ul><h4 id="进程的分类"><a href="#进程的分类" class="headerlink" title="进程的分类"></a>进程的分类</h4><h4 id="分类1"><a href="#分类1" class="headerlink" title="分类1"></a>分类1</h4><ul><li>I/O Bound（I/O密集型）</li><li>CPU bound（CPU密集型）</li></ul><h4 id="分类2"><a href="#分类2" class="headerlink" title="分类2"></a>分类2</h4><ul><li>批处理进程（Batch Process) 编译器，科学计算</li><li>交互式进程（Interactive Process) Word 触控性GUI</li><li>实时进程（Real-time Process) 视频、音频</li></ul><h3 id="批处理系统的调度算法"><a href="#批处理系统的调度算法" class="headerlink" title="批处理系统的调度算法"></a>批处理系统的调度算法</h3><h4 id="吞吐量、平均等待时间和平均周转时间"><a href="#吞吐量、平均等待时间和平均周转时间" class="headerlink" title="吞吐量、平均等待时间和平均周转时间"></a>吞吐量、平均等待时间和平均周转时间</h4><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/4-8.png" style="zoom: 67%;"></p><h4 id="批处理常用调度算法"><a href="#批处理常用调度算法" class="headerlink" title="批处理常用调度算法"></a>批处理常用调度算法</h4><ul><li><strong>先来先服务</strong>（FCFS：First Come First Serve)。<ul><li>按先后次序分派CPU，当前进程或作业直到执行完或阻塞才让出CPU。唤醒进程后等到当前作业或进程让出CPU。</li><li>利于长作业，不利于短作业</li><li>利于CPU密集型，不利于IO密集型</li></ul></li><li><strong>最短作业优先</strong>（SJF：Shortest Job First)<ul><li>对长作业不利</li></ul></li><li><strong>最短剩余时间优先</strong>（SRTF：Shortest Remaining Time First） <ul><li><strong>短作业改进</strong>为<strong>抢占式</strong>。新就绪进程比当前进程完成时间更短，则抢占。</li></ul></li><li><strong>最高响应比优先</strong>（HRRF：Highest Response Ratio First）<ul><li>响应比：$RP=1+\frac {已等待时间} {要求运行时间}$</li><li>既照顾了短作业，又不让长作业等太久</li></ul></li></ul><h3 id="交互式系统"><a href="#交互式系统" class="headerlink" title="交互式系统"></a>交互式系统</h3><ul><li><p><strong>时间片轮转</strong>(RR：Round Robin) </p><ul><li>排队(FCFS原则)—轮转(每次就绪队列队首进程执行一个时间片)—中断(时间片结束发生中断)—抢占（暂停当前进程并移到就绪队列末尾)—出让(可以未使用完时间片就出让)</li><li>静态动态优先级</li></ul></li><li><p><strong>多级队列</strong>(MQ：Multi-level Queue)</p><ul><li>引入多个就绪队列，并区别对待各个队列</li></ul></li><li><p><strong>多级反馈队列</strong>(MFQ： Multi-level Feedback Queue)</p></li></ul><h3 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h3><ul><li>静态表调度Static table-driven scheduling</li><li>单调速率调度RMS：Rate Monotonic Scheduling</li><li>最早截止时间优先算法EDF：Earliest Deadline First</li></ul><h3 id="多处理机调度"><a href="#多处理机调度" class="headerlink" title="多处理机调度"></a>多处理机调度</h3><ul><li>自调度</li><li>成组调度</li><li>专用处理机调度</li></ul><h2 id="4-5-死锁"><a href="#4-5-死锁" class="headerlink" title="4.5 死锁"></a>4.5 死锁</h2><blockquote><p><strong>死锁定义</strong>：一组进程中，每个进程都<strong>无限等待</strong>被该组进程中其它进程所占有的资源，在无外力介入的条件下，将因<strong>永远分配不到资源</strong>而<strong>无法运行</strong>的现象。</p></blockquote><p><strong>发生原因</strong></p><ul><li>资源<strong>竞争</strong></li><li>并行<strong>执行顺序</strong>不当</li></ul><h3 id="死锁发生的四个必要条件"><a href="#死锁发生的四个必要条件" class="headerlink" title="死锁发生的四个必要条件"></a>死锁发生的四个必要条件</h3><ul><li>互斥条件</li><li>请求和占有条件</li><li>不可剥夺条件</li><li>环路等待条件</li></ul><h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><ul><li>打破互斥条件</li><li>打破占有且申请条件</li><li>打破不可剥夺条件</li><li>打破循环等待条件</li></ul><h3 id="资源分配图（RAG）算法"><a href="#资源分配图（RAG）算法" class="headerlink" title="资源分配图（RAG）算法"></a>资源分配图（RAG）算法</h3><p>有向图G的顶点为资源或进程，从<strong>资源R到进程P</strong>的边表示<strong>R已分配给P</strong>，从<strong>进程P到资源R</strong>的边表示<strong>P正因请求R</strong>而处于<strong>等待</strong>状态。</p><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/4-10.png" style="zoom:80%;"></p><h4 id="封锁进程"><a href="#封锁进程" class="headerlink" title="封锁进程"></a>封锁进程</h4><p>是指某个进程由于请求了超过了系统中现有的未分配资源数目的资源，而被系统封锁的进程。</p><h4 id="非封锁进程"><a href="#非封锁进程" class="headerlink" title="非封锁进程"></a>非封锁进程</h4><p>即没有被系统封锁的进程</p><h4 id="资源分配图的化简方法"><a href="#资源分配图的化简方法" class="headerlink" title="资源分配图的化简方法"></a>资源分配图的化简方法</h4><p>假设某个RAG中存在一个进程Pi，此刻Pi是非封锁进程，那么可以进行如下化简：</p><p>当Pi有请求边时，首先将其请求边变成分配边(即满足Pi的资源请求)，而一旦Pi的所有资源请求都得到满足，Pi就能在有限的时间内运行结束，并释放其所占用的全部资源，此时Pi只有分配边，删去这些分配边（实际上相当于消去了Pi的所有请求边和分配边），使Pi成为孤立结点。（反复进行）</p><h4 id="死锁定理"><a href="#死锁定理" class="headerlink" title="死锁定理"></a>死锁定理</h4><p>系统中某个时刻<strong>t为死锁状态</strong>的充要条件是t时刻系统的<strong>资源分配图是不可完全化简</strong>的。</p><p>在经过<strong>一系列的简化</strong>后，若<strong>能消去图中的所有边</strong>，使所有的进程都成为孤立结点，则称该图是<strong>可完全化简</strong>的；反之的是不可完全化简的</p><h3 id="安全序列与安全状态"><a href="#安全序列与安全状态" class="headerlink" title="安全序列与安全状态"></a>安全序列与安全状态</h3><p><strong>安全状态</strong>：系统存在一个进程执行序列<p1,p2,...pn>可顺利完成（里面有一个进程需要的附加资源可以被当前系统中可用资源加上上所有进程Pj（j &lt; i）当前占有资源之和所满足</p1,p2,...pn></p><p>不安全状态不一定死锁，但死锁一定不安全</p><h4 id="安全与不安全示例"><a href="#安全与不安全示例" class="headerlink" title="安全与不安全示例"></a>安全与不安全示例</h4><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/4-9.png" style="zoom:67%;"></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-OS-2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OO-Unit3-总结</title>
      <link href="2021/05/31/OO-Unit3-%E5%B0%8F%E7%BB%93/"/>
      <url>2021/05/31/OO-Unit3-%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>OO第三单元JML规格设计学习总结与分析</p><h1 id="OO-Unit3-总结"><a href="#OO-Unit3-总结" class="headerlink" title="OO-Unit3-总结"></a>OO-Unit3-总结</h1><h2 id="1-JML规格设计策略"><a href="#1-JML规格设计策略" class="headerlink" title="1.JML规格设计策略"></a>1.JML规格设计策略</h2><p>由于JML的规格描述较复杂，本单元的JML规格设计我往往采用<strong>由简入难</strong>的<strong>迭代开发</strong>策略。</p><p>即一开始不着急开发出最为复杂，性能最好的代码，先<strong>严格按照JML</strong>描述写一遍代码，<strong>实现基本功能</strong>。比如类似<code>public instance model non_null Person[] acquaintance;</code>这样的规格，第9次作业开始时先直接按照<code>ArrayList</code>处理，这样各个函数中实际的代码和JML描述近乎一致，<strong>方便检查</strong>。之后在完成了基本功能后，在已经理解了基本功能描述后，对各个容器和方法算法性能进行<strong>优化设计迭代</strong>。</p><p>同时，一般简单的方法和容器设计虽然性能较差，但正确性一般较好，因此个人认为也可以作为之后的迭代优化版本的<strong>正确性测试参考的标程</strong>（不过实际开发过程中也不可能先开发一版低性能保证正确性，所以还是直接全盘考虑好再写高效一点）。</p><p>对于每个方法而言。先确定<code>normal_behavior</code>和<code>exceptional_behavior</code>。确定进入函数后不同参数对应的<strong>分支条件</strong>。并把<strong>条件判断语句</strong>写好，搭好基本框架。之后再看<code>assignable</code>会涉及到的变量。再根据<code>ensures</code>确定<strong>结果返回值</strong>和应该如何<strong>改动变量</strong>。对于异常处理里的分支逻辑也是类似的编写方式。此外，每个方法编写时也可以通过函数名字推敲涵义，从而提高正确性。</p><p>同时对于迭代增量开发，每次都要重新阅读<strong>之前实现过的方法内的JML规格</strong>，因为可能会发生变化，比如第二次到第三次作业中的<code>sendMessage</code>方法。此外要特别注意<strong>JML没写出</strong>，但是你<strong>需要实现</strong>的代码，比如<code>MyGroup内的delPerson方法</code>，如果输入的<code>person</code>是个<code>null</code>需要直接返回；<code>MyPerson</code>类内需要加一个<code>addAcquaitance</code>方法以及<code>getAcquaitance</code>方法等。</p><h2 id="2-JML测试方法和策略"><a href="#2-JML测试方法和策略" class="headerlink" title="2.JML测试方法和策略"></a>2.JML测试方法和策略</h2><p>本单元的JML规格设计由于JML细节较多，很难保证某一份代码是完全正确的，因此测试上最方便最简单的当然就是<strong>多人对拍找少数派</strong>（即<del>多人运动</del>）的方式了。这个方法在<strong>第一单元</strong>中也用到过，总结来说，对于这种<strong>输入一样</strong>，<strong>输出结果</strong>就应该一样的代码，这种方式测试效率还是很高的。此外，还有Junit单元测试，以及openJML等其他JML工具。</p><h3 id="Junit单元测试"><a href="#Junit单元测试" class="headerlink" title="Junit单元测试"></a>Junit单元测试</h3><p>Junit测试简单，可以进行对类内每个方法编写自己的测试逻辑。IDEA里最简单的使用方式就是<code>右键点击代码里的类名--&gt;点击Go to--&gt;点击Test</code>，选择<strong>需要测试的函数</strong>和<strong>选项</strong>，就生成了<strong>测试文件</strong>。</p><p>本单元中主要针对一些比较容易出现错误的方法比如<code>isCircle</code>和<code>queryBlockSum</code>进行了测试，以这两个函数为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.oocourse.spec3.exceptions.PersonIdNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.assertEquals;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.assertFalse;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.assertTrue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNetworkTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyPerson pa = <span class="keyword">new</span> MyPerson(<span class="number">1</span>, <span class="string">"a"</span>, <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyPerson pb = <span class="keyword">new</span> MyPerson(<span class="number">2</span>, <span class="string">"b"</span>, <span class="number">13</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyPerson pc = <span class="keyword">new</span> MyPerson(<span class="number">3</span>, <span class="string">"c"</span>, <span class="number">14</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyPerson pd = <span class="keyword">new</span> MyPerson(<span class="number">4</span>, <span class="string">"d"</span>, <span class="number">15</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyPerson pe = <span class="keyword">new</span> MyPerson(<span class="number">5</span>, <span class="string">"e"</span>, <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyPerson pf = <span class="keyword">new</span> MyPerson(<span class="number">6</span>, <span class="string">"f"</span>, <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">private</span> MyNetwork net = <span class="keyword">new</span> MyNetwork();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        net.addPerson(pa);</span><br><span class="line">        net.addPerson(pb);</span><br><span class="line">        net.addPerson(pc);</span><br><span class="line">        net.addPerson(pd);</span><br><span class="line">        net.addPerson(pe);</span><br><span class="line">        net.addPerson(pf);</span><br><span class="line">        net.addRelation(<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">        net.addRelation(<span class="number">1</span>, <span class="number">3</span>, <span class="number">20</span>);</span><br><span class="line">        net.addRelation(<span class="number">3</span>, <span class="number">4</span>, <span class="number">10</span>);</span><br><span class="line">        net.addRelation(<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">        net.addRelation(<span class="number">3</span>, <span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">isCircle</span><span class="params">()</span> <span class="keyword">throws</span> PersonIdNotFoundException </span>&#123;</span><br><span class="line">        assertTrue(net.isCircle(<span class="number">1</span>, <span class="number">4</span>));</span><br><span class="line">        assertFalse(net.isCircle(<span class="number">1</span>, <span class="number">6</span>));</span><br><span class="line">        assertTrue(net.isCircle(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">queryBlockSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(<span class="number">2</span>, net.queryBlockSum());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后就会出现<strong>令人舒适</strong>的评测信息，这样的单元测试，怎能不爱😍。</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit3/8.png" style="zoom:80%;"></p><p>一般来说就在<code>BeforeEach</code>和<code>AfterEach</code>里分别编写数据构造和初始化以及其他的评测信息。但是注意到这样的测试方式是对于每个<code>@Test</code>处的函数都分别调用了一次测试，即每个这样的函数对应一个点。这样有时体现不出一个类整体连续性，比如某几个方法之间的联系。参考官网写出了连续的测试方式，相当于所有方法在一次程序执行内跑完。</p><p>同时，Junit实在太强大，几乎可以测试所有的情况，比如空指针，异常抛出等，用以下代码举例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nested</span></span><br><span class="line">  <span class="meta">@DisplayName</span>(<span class="string">"when new"</span>)</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">WhenNew</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> MyPerson pa = <span class="keyword">new</span> MyPerson(<span class="number">1</span>, <span class="string">"a"</span>, <span class="number">12</span>);</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> MyPerson pb = <span class="keyword">new</span> MyPerson(<span class="number">2</span>, <span class="string">"b"</span>, <span class="number">13</span>);</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> MyPerson pc = <span class="keyword">new</span> MyPerson(<span class="number">3</span>, <span class="string">"c"</span>, <span class="number">14</span>);</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> MyPerson pd = <span class="keyword">new</span> MyPerson(<span class="number">4</span>, <span class="string">"d"</span>, <span class="number">15</span>);</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> MyPerson pe = <span class="keyword">new</span> MyPerson(<span class="number">5</span>, <span class="string">"e"</span>, <span class="number">16</span>);</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> MyPerson pf = <span class="keyword">new</span> MyPerson(<span class="number">6</span>, <span class="string">"f"</span>, <span class="number">16</span>);</span><br><span class="line">      <span class="keyword">private</span> MyNetwork net = <span class="keyword">new</span> MyNetwork();</span><br><span class="line"></span><br><span class="line">      <span class="meta">@BeforeEach</span></span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">createNewNetwork</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">          net = <span class="keyword">new</span> MyNetwork();</span><br><span class="line">          net.addPerson(pa);</span><br><span class="line">          net.addPerson(pb);</span><br><span class="line">          net.addPerson(pc);</span><br><span class="line">          net.addPerson(pd);</span><br><span class="line">          net.addPerson(pe);</span><br><span class="line">          net.addPerson(pf);</span><br><span class="line">          net.addRelation(<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">          net.addRelation(<span class="number">1</span>, <span class="number">3</span>, <span class="number">20</span>);</span><br><span class="line">          net.addRelation(<span class="number">3</span>, <span class="number">4</span>, <span class="number">10</span>);</span><br><span class="line">          net.addRelation(<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">          net.addRelation(<span class="number">3</span>, <span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Test</span></span><br><span class="line">      <span class="meta">@DisplayName</span>(<span class="string">"throws MyPersonIdNotFoundException when query a unexist id"</span>)</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">throwsMyPersonIdNotFoundException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          assertThrows(MyPersonIdNotFoundException<span class="class">.<span class="keyword">class</span>, () -&gt; <span class="title">net</span>.<span class="title">addRelation</span>(1, 7, 10))</span>; <span class="comment">//这里的()-&gt;是个啥实在没理解，但是加上就可以这么测试了</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Nested</span></span><br><span class="line">      <span class="meta">@DisplayName</span>(<span class="string">"after init"</span>)</span><br><span class="line">      <span class="class"><span class="keyword">class</span> <span class="title">AfterInit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Test</span></span><br><span class="line">          <span class="meta">@DisplayName</span>(<span class="string">"contains"</span>)</span><br><span class="line">          <span class="function"><span class="keyword">void</span> <span class="title">containsTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              assertTrue(net.contains(<span class="number">4</span>));</span><br><span class="line">              assertFalse(net.contains(<span class="number">10</span>));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Test</span></span><br><span class="line">          <span class="meta">@DisplayName</span>(<span class="string">"qps test"</span>)</span><br><span class="line">          <span class="function"><span class="keyword">void</span> <span class="title">queryPeopleSumTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              assertEquals(<span class="number">6</span>, net.queryPeopleSum());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="Python对拍评测"><a href="#Python对拍评测" class="headerlink" title="Python对拍评测"></a>Python对拍评测</h3><p>与第一单元类似，主要分为<strong>双人对拍</strong>和<strong>多人运动</strong>。本次作业单独写了两个文件。<code>relation_testdata</code>产生测试数据。<code>relationTest</code>进行对拍测试。</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit3/2.png" alt></p><p>测试数据产生主要分为<strong>随机生成用例</strong>和生成复杂的<strong>卡时间的用例</strong>。具体的生成的方式都封装在<code>getOneTestPoint()</code>方法中。根据<strong>作业次数</strong>和<strong>数据特点变量</strong>生成相应用例。其中随机生成用例要保证一定的强度，比如每个测试点都是5000条指令，保证每个测试点覆盖了所有的指令（对每个指令的个数进行计数）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">datas_src = <span class="string">"test_data/"</span></span><br><span class="line">n = <span class="number">100</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        src = datas_src + <span class="string">"%d.txt"</span> % (i + <span class="number">1</span>)</span><br><span class="line">        writeToFile(getOneTestPoint(), src)</span><br></pre></td></tr></table></figure><p>对拍测试中先进行<strong>多人团建</strong>。挨个检查所有每个文件对测试点的CPU使用时间测试性能。之后再通过比对所有人的答案检验正确性。如果大家答案均一样且没有人超时，则认为所有人正确。这里使用的是<code>test</code>函数，对输入的一个<code>jar</code>文件名字列表进行处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    nameList = [<span class="string">'Archer.jar'</span>, <span class="string">'Saber.jar'</span>, <span class="string">'Rider.jar'</span>, <span class="string">'Caster.jar'</span>, <span class="string">'Berserker.jar'</span>, <span class="string">'Assassin.jar'</span>]</span><br><span class="line">    test(nameList)</span><br></pre></td></tr></table></figure><p>效果如下</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit3/3.png" style="zoom:80%;"></p><p>在一波多人运动后，一般会发现团队中有个别成员（比如自己的代码）存在一定的问题，这时就可以选择<code>1-2</code>个优秀的成员作为<strong>标程</strong>和其他代码进行对拍。使用<code>beatTest</code>函数进行<strong>重点爆破</strong>，提高寻找<code>bug</code>的效率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beatTest(<span class="string">'homework11.jar'</span>, <span class="string">'Berserker.jar'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit3/6.png" style="zoom:80%;"></p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit3/7.png" style="zoom:80%;"></p><p>总的来说，1、3单元对多人的代码进行测试的方式比较可取的就是每个人单独跑数据看时间，使用多人对拍评价正确性。</p><h3 id="openJML工具使用"><a href="#openJML工具使用" class="headerlink" title="openJML工具使用"></a>openJML工具使用</h3><p>代码静态检查命令如下，感觉输出好奇怪，调了半天也没调好，只好放弃了。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java <span class="literal">-jar</span> .\openjml.jar <span class="literal">-exec</span> (SMT Solvers的路径) .\Solvers<span class="literal">-windows</span>\z3<span class="literal">-4</span>.<span class="number">7.1</span>.exe <span class="literal">-esc</span> <span class="literal">-dir</span> (项目目录)</span><br><span class="line">java <span class="literal">-jar</span> .\openjml.jar <span class="literal">-exec</span> .\Solvers<span class="literal">-windows</span>\z3<span class="literal">-4</span>.<span class="number">7.1</span>.exe <span class="literal">-esc</span> <span class="literal">-dir</span> ..\test_src\Archer\src\</span><br><span class="line">java <span class="literal">-jar</span> openjml.jar <span class="literal">-esc</span> <span class="literal">-progress</span> MyPerson.java</span><br></pre></td></tr></table></figure><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit3/9.png" alt></p><h3 id="JMLUnitNG"><a href="#JMLUnitNG" class="headerlink" title="JMLUnitNG"></a>JMLUnitNG</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -jar jmlunitng.jar test/MyGroup.java</span><br><span class="line">javac -cp jmlunitng.jar test/MyGroup.java</span><br><span class="line">java -cp jmlunitng.jar test.MyGroup_JML_Test</span><br></pre></td></tr></table></figure><p>这种方式只检查了边界数据，因此只是简单了解了一下，没有怎么使用。</p><h2 id="3-容器选择与使用"><a href="#3-容器选择与使用" class="headerlink" title="3.容器选择与使用"></a>3.容器选择与使用</h2><p>由于本单元作业需要对容器内元素进行高频率增删改查的操作，选用普通数组实现JML效率非常低下，因此大部分容器都采用<code>HashMap</code>进行设计。</p><h3 id="homework9"><a href="#homework9" class="headerlink" title="homework9"></a>homework9</h3><p>本次作业由于性能要求较低，除了为了<code>isCircle</code>函数的广度优先搜索算法编写的<code>visit</code>数组使用了<code>HashMap&lt;MyPerson,Boolean&gt;</code>外其余的容器均使用<code>ArrayList</code>，即<code>acquaintance/value/people</code>。使用时基本和<code>JML</code>描述写法一致。</p><h3 id="homework10-homework11"><a href="#homework10-homework11" class="headerlink" title="homework10/homework11"></a>homework10/homework11</h3><p>在这两次作业中由于指令数量增多，性能要求提升，将第9次作业中所有的<code>ArrayList</code>全部替换成了<code>HashMap</code>。包括<code>MyNetwork</code>类中的<code>people/id2group/id2message/id2bossid</code>以及<code>MyPerson</code>中的<code>acquaintance</code>。同时新增的方法和变量也尽量使用了<code>HashMap</code>保证性能要求。</p><h2 id="4-bug分析"><a href="#4-bug分析" class="headerlink" title="4.bug分析"></a>4.bug分析</h2><p>本单元的bug主要集中在两方面，即：</p><ul><li>因为JML阅读不细致导致的程序<strong>正确性</strong>问题。</li><li>因为算法/容器设计不合理导致的<strong>CPU时间</strong>问题。</li></ul><h3 id="homework9-1"><a href="#homework9-1" class="headerlink" title="homework9"></a>homework9</h3><h4 id="自己的bug"><a href="#自己的bug" class="headerlink" title="自己的bug"></a>自己的bug</h4><p>这一次作业性能要求不高，但由于没有仔细思考，采用了<code>dfs</code>算法进行<code>isCircle</code>函数设计，同时在<code>qbs</code>函数中直接采用二层循环进行遍历查找，导致非常慢，出现了性能问题。强测被hack一个点，互测被hack7个点，全部是<code>CTLE</code>。修复<code>bug</code>时将<code>isCircle</code>采用<code>bfs</code>实现<code>qbs</code>和<code>isCircle</code>函数。</p><h4 id="他人的bug"><a href="#他人的bug" class="headerlink" title="他人的bug"></a>他人的bug</h4><p>测试时由于这一单元正确性较简单，主要针对多人的复杂网络进行了数据构造，至少增加200人以及200条关系之后在最后的几百条指令全部用<code>qbs</code>和<code>qci</code>进行轰炸。效果还可，很快就刀到了两个同样使用<code>dfs</code>的难兄难弟，之后基本就收手了，看了房间里被hack的代码都是这两个的性能问题导致。</p><h3 id="homework10"><a href="#homework10" class="headerlink" title="homework10"></a>homework10</h3><p>本次作业个人测试时主要注重性能，没有很关注正确性，导致代码里有大量正确性问题，导致第一次没进互测，心态崩溃的同时，也对各个写错的地方认真进行了审视。</p><h4 id="自己的bug-1"><a href="#自己的bug-1" class="headerlink" title="自己的bug"></a>自己的bug</h4><ul><li><code>MyGroup</code>类内删除人的时候没有把总年龄和减去删除的人的年龄导致错误。</li><li><code>MyNetwork</code>类<code>addToGroup</code>方法内不存在新加的人且<code>group</code>内人数大于等于1111时没有直接返回而是进入了异常。异常里存在这个人时。<code>addMessage</code>内当加入的邮件里两个人id相同时抛出异常使用的id是<code>messageId</code>。</li><li><code>sendMeesage</code>方法内当类型为0时没有把<code>person1</code>加入<code>person2</code>的关系数组里。</li><li><code>getReceivedMessages</code>方法内误以为只返回一个小于等于3的<code>Message</code>数组，实际上是返回一个小于等于4的<code>Message</code>数组。</li></ul><p>这次作业的bug主要都是因为在阅读JML代码时过于草率，很多地方都是漏看了一句话导致了问题的出现，且测试不够充分。这启发我在以后的JML规格编写时要认真细致地阅读每一行说明，编写后要进行充分细致的单元测试和黑箱测试。此外，本次作业在自己构造数据时往往关注时间，构造了和第一次差不多的数据，对第二次作业涉及的指令覆盖很有限，这也导致了问题的出现。同时之后也发现自己的测试脚本中也是有问题的，很多时候可能测试数据里只有第一次的指令，因此问题也很难找出来。所以以后对自己的测试数据生成脚本不能过于自信，要仔细审查。</p><p>正确性虽然被<code>hack</code>惨了，但是时间性能上由于使用了<strong>并查集</strong>进行搜索，没有出现问题。并查集对每个新进入的人先设置他的<code>bossid</code>为他自己的<code>id</code>，之后新增的关系中，如果他们的bossid不一样，则把一个人的最高级的<code>bossid</code>（<code>p.bossid==p.id</code>)设置为另一个人的最高级<code>bossid</code>即可。</p><h3 id="homework11"><a href="#homework11" class="headerlink" title="homework11"></a>homework11</h3><h4 id="自己的bug-2"><a href="#自己的bug-2" class="headerlink" title="自己的bug"></a>自己的bug</h4><p>本次强测互测均未被hack。</p><p>有了上一次的惨痛教训，本次在测试时非常细致，结合了ch大佬的数据和自己的数据进行了多轮校验。这次自测时仍然找出来了与上次作业中类似的正确性的错误，对于各个类中的方法进行了多次修改，值得一提的是很多错误都是由于想当然以为上次的方法这次不变导致的，这一点以后也需要注意。同时重点设计了最短路径查找算法，使用了堆优化的<code>Dijistra</code>算法，新增一个Node节点类保存了距离和id，使用优先队列模拟堆，避免了每一轮循环都进行全部的遍历查找，保证了时间性能。此外在<code>MyGroup</code>类中加入了<code>valueSum</code>变量，每次有人员变动时就修改<code>valueSum</code>。从而保证了<code>qgvs</code>指令的性能。</p><h4 id="他人的bug-1"><a href="#他人的bug-1" class="headerlink" title="他人的bug"></a>他人的bug</h4><p>本次由于限制了5000条指令，且上限为6s，从时间上hack是极难，尝试构造了很多复杂的数据都未成功。最后通过大量随机生成用例hack了一人。阅读代码发现是经典的问题：<code>isCircle</code>函数输入相同的<code>id</code>时没有返回<code>true</code></p><h2 id="5-作业架构设计"><a href="#5-作业架构设计" class="headerlink" title="5.作业架构设计"></a>5.作业架构设计</h2><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit3/Top-Level Package.png" style="zoom:80%;"></p><p>本单元作业架构相对固定且是官方给出的，每个基本类相对固定，活动空间主要是对于图模型的管理维护。由于代码量并不大，本单元我直接将全部的图相关算法和主要数据、方法都写在了<code>MyNetwork</code>类内，同时将具体算法函数与功能函数分开。在<code>isCircle</code>内调用不同的<code>find</code>方法从而方便优化性能，有过<code>dfsFind(id1,id2)  bfsFind(id1,id2)  unionFind(id1,id2)</code>共三个查找的算法函数。同时在<code>sendIndirectMessage</code>函数中也是调用<code>Dijistra</code>函数进行操作，且调动了一个外部类<code>Node</code>进行堆优化操作。同时，使用一个<code>HashMap</code>保存每个PersonId对应的<code>bossId</code>进行并查集数据管理。</p><p>同时，各个类内最终都基本使用了<code>HashMap</code>作为数组的实现容器，且这些都采用<code>id</code>作为<code>key</code>值进行查找。</p><p>本次的异常类采用<code>static</code>类<code>count</code>对异常数据进行管理，确定了统一接口进行查询和存储异常次数。每次新增时只需要新增新的<code>HashMap</code>的<code>key</code>值即可。</p><h2 id="6-感想与体会"><a href="#6-感想与体会" class="headerlink" title="6.感想与体会"></a>6.感想与体会</h2><ul><li>本单元是圣杯战争最后一战了，回想参加的8次互测，整体来说体验还是很好的，在这个过程中学到了不少和测试相关的知识，也加深了对java和python这两门语言的理解。非常感谢课程组给我们设置的这种课程体制，让我们对测试这门艺术有所理解和掌握</li><li>JML对代码的限制还是很强的，之后在开发之前不妨先写上JML再进行后续的开发，这样正确性能够有大幅提升。同时，JML也确实太复杂了，感谢为我们的作业献出那么多力量的助教和老师们，真的辛苦你们了！</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-OO-2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OO-Unit2-总结</title>
      <link href="2021/04/24/OO-Unit2-%E5%B0%8F%E7%BB%93/"/>
      <url>2021/04/24/OO-Unit2-%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>OO第二单元电梯调度总结与分析。</p><h1 id="OO-Unit2-总结"><a href="#OO-Unit2-总结" class="headerlink" title="OO-Unit2-总结"></a>OO-Unit2-总结</h1><h2 id="一、程序结构分析"><a href="#一、程序结构分析" class="headerlink" title="一、程序结构分析"></a>一、程序结构分析</h2><h3 id="第五次作业"><a href="#第五次作业" class="headerlink" title="第五次作业"></a>第五次作业</h3><h4 id="代码可视化与数据统计"><a href="#代码可视化与数据统计" class="headerlink" title="代码可视化与数据统计"></a>代码可视化与数据统计</h4><h5 id="程序类图"><a href="#程序类图" class="headerlink" title="程序类图"></a>程序类图</h5><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit2/hw5.png" style="zoom:80%;" /></p><p>由于本次只有一台电梯，因此没有使用调度器，而是只设计了一个策略类<code>Scheduler</code>类来实现每到一个楼层根据当前等待的乘客和电梯中的乘客请求来确定目标楼层的功能。而电梯类和输入线程类则是本次作业的两个线程类，分别对应消费者和生产者。</p><h5 id="程序复杂度分析"><a href="#程序复杂度分析" class="headerlink" title="程序复杂度分析"></a>程序复杂度分析</h5><ul><li>类复杂度</li></ul><div class="table-container"><table><thead><tr><th>Class</th><th>OCavg</th><th>OCmax</th><th>WMC</th></tr></thead><tbody><tr><td>Elevator</td><td>4.5</td><td>7</td><td>18</td></tr><tr><td>InitQueue</td><td>1</td><td>1</td><td>7</td></tr><tr><td>InputThread</td><td>2</td><td>3</td><td>4</td></tr><tr><td>Main</td><td>2</td><td>2</td><td>2</td></tr><tr><td>Scheduler</td><td>8</td><td>16</td><td>40</td></tr><tr><td>WaitQueue</td><td>1</td><td>1</td><td>7</td></tr></tbody></table></div><p>可以看出，在<code>Elevator</code>类和<code>Scheduler</code>类中代码复杂度较高。两者构成了电梯的核心逻辑，包含较多分支。</p><ul><li>方法复杂度</li></ul><div class="table-container"><table><thead><tr><th>Method</th><th>CogC</th><th>ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>Elevator.Elevator(WaitQueue,InitQueue,String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.move(int)</td><td>6</td><td>3</td><td>3</td><td>5</td></tr><tr><td>Elevator.personFlow()</td><td>11</td><td>1</td><td>8</td><td>8</td></tr><tr><td>Elevator.run()</td><td>25</td><td>4</td><td>11</td><td>11</td></tr><tr><td>InitQueue.InitQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.addRequest(PersonRequest)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.clearQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.close()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.getRequests()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.isEnd()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.noWaiting()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InputThread.InputThread(WaitQueue,ElevatorInput)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InputThread.run()</td><td>7</td><td>3</td><td>4</td><td>4</td></tr><tr><td>Main.main(String[])</td><td>5</td><td>1</td><td>5</td><td>5</td></tr><tr><td>Scheduler.Scheduler(WaitQueue,InitQueue,String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Scheduler.getDesFloor(int)</td><td>49</td><td>13</td><td>15</td><td>21</td></tr><tr><td>Scheduler.getFloor(int,int)</td><td>26</td><td>7</td><td>3</td><td>15</td></tr><tr><td>Scheduler.getMorningFloor(int,int)</td><td>13</td><td>4</td><td>2</td><td>8</td></tr><tr><td>Scheduler.getNightFloor(int,int)</td><td>13</td><td>4</td><td>2</td><td>8</td></tr><tr><td>WaitQueue.WaitQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.addRequest(PersonRequest)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.clearQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.close()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.getRequests()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.isEnd()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.noWaiting()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr></tbody></table></div><p>可以看到，<code>getDesFloor、getFloor</code>方法和电梯类中的<code>run</code>方法由于需要处理电梯的运行，调用了很多其他方法和变量，复杂度较高。</p><h5 id="程序行数统计"><a href="#程序行数统计" class="headerlink" title="程序行数统计"></a>程序行数统计</h5><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit2/hw5line.png" alt=""></p><p>与之前代码复杂度分析保持一致，仍然是<code>Elevator</code>类和<code>Scheduler</code>类的行数最多。总有效代码函数为423行。</p><h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><h5 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h5><p>本次作业定义了一个<code>waitqueue</code>作为生产者消费者之间的托盘，在各个类之间进行共享。当<code>Main</code>类开始后，先读入这份数据的到达模式，之后启动输入线程和电梯线程，输入线程不断读入新的请求，将请求加入到等待队列中，同时<code>Elevator</code>类不断处理等待队列中的请求，处理时每到一个新的楼层就会询问<code>Scheduler</code>类获得新的目标楼层。当输入到EOF时，输入线程结束。电梯内外的全部请求都处理结束时，电梯线程也结束，之后<code>Main</code>类主线程就会结束。</p><p>具体对于三种到达模式。<code>Random</code>直接使用了<code>ALS</code>进行调度。而<code>Morning</code>模式下则是先等待2s再开始接送乘客，且当电梯内没有乘客时自动返回1楼。<code>Night</code>模式下则是对当前的等待队列进行从大到小的排序，先接高楼层的乘客，接满后直接返回1层，反复如此进行下去。</p><h5 id="同步块的设置和锁的选择"><a href="#同步块的设置和锁的选择" class="headerlink" title="同步块的设置和锁的选择"></a>同步块的设置和锁的选择</h5><p>本次的共享变量主要有<code>waitqueue</code>和<code>initqueue</code>。前者被电梯类，策略类和输入类三者共享，后者只被电梯类和策略类两者共享（此处忽略了同样共享的主类）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Elevator.run</span></span><br><span class="line"><span class="keyword">if</span> (initQueue.noWaiting() &amp;&amp; waitQueue.noWaiting()) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (waitQueue) &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            waitQueue.wait(); <span class="comment">//等待队列为空，需要先等输入线程接受新的输入</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pattern.equals(<span class="string">"Night"</span>)) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (waitQueue.getRequests()) &#123; <span class="comment">//Night模式下需要排序，给waitQueue类里的请求列表加锁</span></span><br><span class="line">        waitQueue.getRequests()</span><br><span class="line">            .sort(Comparator.comparingInt(PersonRequest::getFromFloor)); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//InputThread.run</span></span><br><span class="line"><span class="keyword">synchronized</span> (waitQueue) &#123; <span class="comment">//给waitQueue加锁保证线程安全</span></span><br><span class="line">    <span class="keyword">if</span> (request == <span class="keyword">null</span>) &#123;</span><br><span class="line">        waitQueue.close();</span><br><span class="line">        waitQueue.notifyAll(); <span class="comment">//输入结束时唤醒等待队列，让Elevator类继续处理请求</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            elevatorInput.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        waitQueue.addRequest(request);</span><br><span class="line">        waitQueue.notifyAll(); <span class="comment">//有新的输入时唤醒等待队列，让Elevator类继续处理请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Main.main </span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    inputThread.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    elevator.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="comment">//等两个线程均结束，主线程才结束</span></span><br></pre></td></tr></table></figure><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>架构较为清晰，每个类的功能都比较独立，且将策略类和电梯类分开，易于更换策略。对一个电梯的建模比较完整，便于第六次作业中增加电梯。</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p><code>Random</code>模式下只采用了标准的ALS调度方式，导致性能较差。</p><h3 id="第六次作业"><a href="#第六次作业" class="headerlink" title="第六次作业"></a>第六次作业</h3><h4 id="代码可视化与数据统计-1"><a href="#代码可视化与数据统计-1" class="headerlink" title="代码可视化与数据统计"></a>代码可视化与数据统计</h4><h5 id="程序类图-1"><a href="#程序类图-1" class="headerlink" title="程序类图"></a>程序类图</h5><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit2/hw6.png" alt=""></p><p>本次作业和上次作业相比改动幅度不大，只增加了一个调度器类。</p><h5 id="程序复杂度分析-1"><a href="#程序复杂度分析-1" class="headerlink" title="程序复杂度分析"></a>程序复杂度分析</h5><ul><li>类复杂度</li></ul><div class="table-container"><table><thead><tr><th>Class</th><th>OCavg</th><th>OCmax</th><th>WMC</th></tr></thead><tbody><tr><td>Dispatcher</td><td>3.5</td><td>10</td><td>21</td></tr><tr><td>Elevator</td><td>2.5</td><td>8</td><td>25</td></tr><tr><td>InitQueue</td><td>1</td><td>1</td><td>7</td></tr><tr><td>InputThread</td><td>3</td><td>5</td><td>6</td></tr><tr><td>Main</td><td>4</td><td>4</td><td>4</td></tr><tr><td>Scheduler</td><td>8</td><td>16</td><td>40</td></tr><tr><td>WaitQueue</td><td>1</td><td>1</td><td>7</td></tr></tbody></table></div><p>可以看出<code>Dispatcher</code>和<code>Elevator、Scheduler</code>类的复杂度较高。这三个类也是本次作业的核心类。</p><ul><li>方法复杂度</li></ul><div class="table-container"><table><thead><tr><th>Method</th><th>CogC</th><th>ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>Dispatcher.Dispatcher(WaitQueue,ArrayList<Elevator>,String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Dispatcher.dispatch()</td><td>39</td><td>3</td><td>12</td><td>12</td></tr><tr><td>Dispatcher.getMinElevatori()</td><td>3</td><td>1</td><td>2</td><td>3</td></tr><tr><td>Dispatcher.getMorningMinElevatori()</td><td>3</td><td>1</td><td>2</td><td>3</td></tr><tr><td>Dispatcher.getNightMinElevatori()</td><td>3</td><td>1</td><td>2</td><td>3</td></tr><tr><td>Dispatcher.run()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.Elevator(WaitQueue,InitQueue,String,String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.addRequest(PersonRequest)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.close()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.getInitReqNum()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.getReqNum()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.getWaitQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.getWaitReqNum()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.move(int)</td><td>6</td><td>3</td><td>3</td><td>5</td></tr><tr><td>Elevator.personFlow()</td><td>11</td><td>1</td><td>8</td><td>8</td></tr><tr><td>Elevator.run()</td><td>26</td><td>4</td><td>12</td><td>12</td></tr><tr><td>InitQueue.InitQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.addRequest(PersonRequest)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.clearQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.close()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.getRequests()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.isEnd()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.noWaiting()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InputThread.InputThread(WaitQueue,ElevatorInput,ArrayList<Elevator>,String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InputThread.run()</td><td>11</td><td>3</td><td>6</td><td>6</td></tr><tr><td>Main.main(String[])</td><td>6</td><td>1</td><td>6</td><td>6</td></tr><tr><td>Scheduler.Scheduler(WaitQueue,InitQueue,String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Scheduler.getDesFloor(int)</td><td>49</td><td>13</td><td>16</td><td>22</td></tr><tr><td>Scheduler.getFloor(int,int)</td><td>26</td><td>7</td><td>3</td><td>15</td></tr><tr><td>Scheduler.getMorningFloor(int,int)</td><td>13</td><td>4</td><td>2</td><td>8</td></tr><tr><td>Scheduler.getNightFloor(int,int)</td><td>13</td><td>4</td><td>2</td><td>8</td></tr><tr><td>WaitQueue.WaitQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.addRequest(PersonRequest)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.clearQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.close()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.getRequests()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.isEnd()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.noWaiting()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr></tbody></table></div><p>本次复杂度较高的是调度器的<code>dispatch</code>方法，以及获得目标楼层的<code>`getDesFloor</code>方法和电梯运行的<code>run</code>方法。</p><h5 id="程序行数统计-1"><a href="#程序行数统计-1" class="headerlink" title="程序行数统计"></a>程序行数统计</h5><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit2/hw6line.png" alt=""></p><p>本次作业代码量较大，总有效行数是571行。</p><h4 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h4><h5 id="原理分析-1"><a href="#原理分析-1" class="headerlink" title="原理分析"></a>原理分析</h5><p>本次作业在上一次作业基础上主要增加了调度器类，用来实现各个电梯的负载均衡调度，采用了分布式调度，即将一个大的请求队列分配给各个电梯自己的请求队列，由各个电梯对自己的请求队列进行处理。相当于采用了两对消费者-生产者，一对是输入线程和调度器线程，一对是调度器线程和各个电梯。输入线程终止条件与上次作业相同，而调度器线程终止条件则是没有新的输入且总的请求队列为空。各个电梯自己的终止条件是自身的请求等待队列为空。具体策略上，本次作业采用了和上次作业一致的策略。</p><h5 id="同步块的设置和锁的选择-1"><a href="#同步块的设置和锁的选择-1" class="headerlink" title="同步块的设置和锁的选择"></a>同步块的设置和锁的选择</h5><p>本次作业共享的变量为总请求等待队列，各个电梯自身的请求等待队列和电梯内请求队列。<code>Elevator</code>和<code>Scheduler</code>类的同步与上次一致，不再赘述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dispatcher.dispatch</span></span><br><span class="line"><span class="keyword">if</span> (waitQueue.isEnd() &amp;&amp; waitQueue.noWaiting()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Elevator elevator : elevators) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (elevator.getWaitQueue()) &#123; <span class="comment">//遍历时给每个电梯的等待队列类加上锁保证安全</span></span><br><span class="line">            elevator.getWaitQueue().close();</span><br><span class="line">            elevator.getWaitQueue().notifyAll(); </span><br><span class="line">            <span class="comment">//输入线程结束且总等待队列为空将所有电梯的等待队列关闭，同时唤醒所有电梯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (waitQueue.noWaiting()) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (waitQueue) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                waitQueue.wait(); <span class="comment">//总等待队列为空但输入线程并未结束时，先等待</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//InputThread.run</span></span><br><span class="line"><span class="keyword">synchronized</span> (waitQueue) &#123; <span class="comment">//给总等待队列加锁，防止与调度器线程冲突</span></span><br><span class="line">    <span class="keyword">if</span> (request == <span class="keyword">null</span>) &#123;</span><br><span class="line">        waitQueue.close(); <span class="comment">//关闭总请求队列</span></span><br><span class="line">        waitQueue.notifyAll(); <span class="comment">//输入结束时唤醒调度器内的总等待队列</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            elevatorInput.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (request <span class="keyword">instanceof</span> PersonRequest) &#123;</span><br><span class="line">            waitQueue.addRequest((PersonRequest) request);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request <span class="keyword">instanceof</span> ElevatorRequest) &#123;</span><br><span class="line">            Elevator elevator = <span class="keyword">new</span> Elevator(<span class="keyword">new</span> WaitQueue(), <span class="keyword">new</span> InitQueue(),</span><br><span class="line">                                             pattern, ((ElevatorRequest) request).getElevatorId());</span><br><span class="line">            <span class="keyword">synchronized</span> (elevators) &#123; <span class="comment">//给电梯数组加锁，保证线程安全</span></span><br><span class="line">                elevators.add(elevator);</span><br><span class="line">                elevator.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        waitQueue.notifyAll(); <span class="comment">//在新的请求进入等待队列中或者加入了新电梯后唤醒所有的等待队列。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><p>在没有非必要的对第五次作业的修改基础上，只通过新增一个调度器线程类对请求进行处理，复用了电梯类和策略类，层次架构较清晰，是一次比较好的增量开发。同时，调度器每次分配请求时对现有的每个电梯内的请求人数进行比较，较好的考虑了负载均衡。</p><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><p>因为写代码不谨慎，出现了一处潜在的死循环发生区。</p><h3 id="第七次作业"><a href="#第七次作业" class="headerlink" title="第七次作业"></a>第七次作业</h3><h4 id="代码可视化与数据统计-2"><a href="#代码可视化与数据统计-2" class="headerlink" title="代码可视化与数据统计"></a>代码可视化与数据统计</h4><h5 id="程序类图-2"><a href="#程序类图-2" class="headerlink" title="程序类图"></a>程序类图</h5><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit2/hw7.png" alt=""></p><p>本次作业的架构与上次一致。</p><h5 id="程序复杂度分析-2"><a href="#程序复杂度分析-2" class="headerlink" title="程序复杂度分析"></a>程序复杂度分析</h5><ul><li>类复杂度</li></ul><div class="table-container"><table><thead><tr><th>Class</th><th>OCavg</th><th>OCmax</th><th>WMC</th></tr></thead><tbody><tr><td>Dispatcher</td><td>3.75</td><td>9</td><td>15</td></tr><tr><td>Elevator</td><td>2.93</td><td>8</td><td>41</td></tr><tr><td>InitQueue</td><td>1</td><td>1</td><td>7</td></tr><tr><td>InputThread</td><td>3</td><td>5</td><td>6</td></tr><tr><td>Main</td><td>3</td><td>3</td><td>3</td></tr><tr><td>Scheduler</td><td>6.6</td><td>14</td><td>33</td></tr><tr><td>WaitQueue</td><td>1</td><td>1</td><td>7</td></tr></tbody></table></div><ul><li>方法复杂度</li></ul><div class="table-container"><table><thead><tr><th>Method</th><th>CogC</th><th>ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>Dispatcher.Dispatcher(WaitQueue,ArrayList<Elevator>,HashSet<Integer>)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Dispatcher.dispatch()</td><td>34</td><td>4</td><td>11</td><td>12</td></tr><tr><td>Dispatcher.getMinElevatori(PersonRequest)</td><td>6</td><td>1</td><td>2</td><td>4</td></tr><tr><td>Dispatcher.run()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.Elevator(WaitQueue,InitQueue,String,String,String,WaitQueue,HashSet<Integer>)</td><td>3</td><td>1</td><td>2</td><td>3</td></tr><tr><td>Elevator.addRequest(PersonRequest)</td><td>5</td><td>1</td><td>5</td><td>6</td></tr><tr><td>Elevator.canArrive(PersonRequest)</td><td>10</td><td>3</td><td>1</td><td>12</td></tr><tr><td>Elevator.canBOut(PersonRequest)</td><td>4</td><td>1</td><td>1</td><td>5</td></tr><tr><td>Elevator.canCOut(PersonRequest)</td><td>7</td><td>2</td><td>1</td><td>8</td></tr><tr><td>Elevator.close()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.getInitReqNum()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.getReqNum()</td><td>3</td><td>1</td><td>2</td><td>3</td></tr><tr><td>Elevator.getType()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.getWaitQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.getWaitReqNum()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.move(int)</td><td>8</td><td>3</td><td>3</td><td>6</td></tr><tr><td>Elevator.personFlow()</td><td>17</td><td>4</td><td>11</td><td>12</td></tr><tr><td>Elevator.run()</td><td>25</td><td>4</td><td>11</td><td>11</td></tr><tr><td>InitQueue.InitQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.addRequest(PersonRequest)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.clearQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.close()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.getRequests()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.isEnd()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.noWaiting()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InputThread.InputThread(WaitQueue,ElevatorInput,ArrayList<Elevator>,String,HashSet<Integer>)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InputThread.run()</td><td>11</td><td>3</td><td>6</td><td>6</td></tr><tr><td>Main.main(String[])</td><td>5</td><td>1</td><td>5</td><td>5</td></tr><tr><td>Scheduler.Scheduler(WaitQueue,InitQueue,String,int)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Scheduler.getBFloor(int,int)</td><td>4</td><td>2</td><td>1</td><td>3</td></tr><tr><td>Scheduler.getCFloor(int,int)</td><td>7</td><td>2</td><td>1</td><td>6</td></tr><tr><td>Scheduler.getDesFloor(int)</td><td>38</td><td>10</td><td>14</td><td>17</td></tr><tr><td>Scheduler.getTakeFloor(int,int)</td><td>28</td><td>7</td><td>4</td><td>16</td></tr><tr><td>WaitQueue.WaitQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.addRequest(PersonRequest)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.clearQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.close()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.getRequests()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.isEnd()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.noWaiting()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr></tbody></table></div><h5 id="程序行数统计-2"><a href="#程序行数统计-2" class="headerlink" title="程序行数统计"></a>程序行数统计</h5><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit2/hw7line.png" alt=""></p><p>本次代码量较上次增加了60行，主要增加了与电梯性质和换乘相关的代码。</p><h4 id="代码分析-2"><a href="#代码分析-2" class="headerlink" title="代码分析"></a>代码分析</h4><h5 id="原理分析-2"><a href="#原理分析-2" class="headerlink" title="原理分析"></a>原理分析</h5><p>本次作业架构与上次一致。对调度器内部的负载均衡判定方法除了考虑电梯现有请求队列人数，加入了判断是否能停留的逻辑和优先级的逻辑（速度快的优先级高）,加入了换乘的处理逻辑。同时，改变了调度器线程的终止条件，当且仅当输入线程终止且所有换乘乘客均已到达目的地，才结束。而调度器线程的结束也才会导致若干个电梯线程的结束。具体电梯的策略类和前两次作业保持一致。</p><h5 id="同步块的设置和锁的选择-2"><a href="#同步块的设置和锁的选择-2" class="headerlink" title="同步块的设置和锁的选择"></a>同步块的设置和锁的选择</h5><p>本次作业与前两次作业比起来，由于要处理换乘的情况，加入了一个记录换乘乘客id的集合<code>checkidset</code>用来判断调度器线程的终止条件。核心的线程安全问题也主要集中在对这个集合的处理上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Elevator.run</span></span><br><span class="line"><span class="keyword">if</span> (d == <span class="number">0</span>) &#123; <span class="comment">//乘客到达目的地时</span></span><br><span class="line">    ...</span><br><span class="line">    TimableOutput.println(</span><br><span class="line">        String.format(<span class="string">"OUT-%d-%d-%s"</span>, request.getPersonId(), floor, id));</span><br><span class="line">    <span class="keyword">synchronized</span> (checkidset) &#123;</span><br><span class="line">        checkidset.remove(request.getPersonId()); <span class="comment">//将这个id从换乘id集合中移除</span></span><br><span class="line">        checkidset.notifyAll(); <span class="comment">//唤醒换乘人集合，让调度器继续作业</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((type.equals(<span class="string">"B"</span>) &amp;&amp; canBOut(request))) &#123; <span class="comment">//到达中转站</span></span><br><span class="line">  ...</span><br><span class="line">    TimableOutput.println(String.format(<span class="string">"OUT-%d-%d-%s"</span>,</span><br><span class="line">                                        request.getPersonId(), floor, id));</span><br><span class="line">    <span class="keyword">synchronized</span> (allWaitQueue) &#123;</span><br><span class="line">        PersonRequest newrequest = <span class="keyword">new</span> PersonRequest(floor,</span><br><span class="line">                                                    request.getToFloor(), request.getPersonId());</span><br><span class="line">        allWaitQueue.addRequest(newrequest); <span class="comment">//总请求等待队列新增请求</span></span><br><span class="line">        allWaitQueue.notifyAll(); <span class="comment">//唤醒总请求等待对列，让调度器继续分配请求</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (checkidset) &#123; checkidset.notifyAll(); &#125; <span class="comment">//唤醒换乘人集合，让调度器继续作业</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dispatcher.dispatch</span></span><br><span class="line"><span class="keyword">if</span> (waitQueue.isEnd() &amp;&amp; waitQueue.noWaiting()) &#123; <span class="comment">//当输入线程已经终止时</span></span><br><span class="line">    <span class="keyword">synchronized</span> (checkidset) &#123; <span class="comment">//给换乘人集合加锁</span></span><br><span class="line">        <span class="keyword">if</span> (checkidset.size() &gt; <span class="number">0</span>) &#123; <span class="comment">//当前还有换乘的乘客没有到达目的地</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                checkidset.wait(); <span class="comment">//等待乘客到达目的地或者新的换乘请求加入</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (waitQueue) &#123; <span class="comment">//处理现在的请求</span></span><br><span class="line">                ArrayList&lt;PersonRequest&gt; requests = waitQueue.getRequests();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; requests.size(); i++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> mini = getMinElevatori(requests.get(i));</span><br><span class="line">                    elevators.get(mini).addRequest(requests.get(i));</span><br><span class="line">                    <span class="keyword">synchronized</span> (elevators.get(mini).getWaitQueue()) &#123;</span><br><span class="line">                        elevators.get(mini).getWaitQueue().notifyAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                    requests.remove(i);</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (checkidset.size() &gt; <span class="number">0</span>) &#123; <span class="comment">//如果还有没到达的换乘乘客，继续下一轮循环</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Elevator elevator : elevators) &#123; <span class="comment">//所有换乘乘客均已到达，可以关闭各个线程的等待队列了</span></span><br><span class="line">        <span class="keyword">synchronized</span> (elevator.getWaitQueue()) &#123;</span><br><span class="line">            elevator.getWaitQueue().close(); </span><br><span class="line">            elevator.getWaitQueue().notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;...&#125; <span class="comment">//输入线程未终止，正常分配请求</span></span><br></pre></td></tr></table></figure><h5 id="UML时序图"><a href="#UML时序图" class="headerlink" title="UML时序图"></a>UML时序图</h5><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit2/hw7-0.png" alt=""></p><p>时序图说明：只保留了几个线程类，主要展示了整个时序流程而省略了实现细节。图中Elevator类是所有elevator的代表</p><h5 id="可扩展性分析"><a href="#可扩展性分析" class="headerlink" title="可扩展性分析"></a>可扩展性分析</h5><ol><li><strong>功能设计</strong>上。由于上次作业架构较为合理，本次作业整体改动不大，同时，在完善了对电梯类型和电梯属性的扩展后，现在的电梯的可扩展性较强，之后改动时只需要针对不同的电梯种类在电梯类做出相应的改变和扩展即可。其他地方不用改变。</li><li><strong>性能设计</strong>上。本次作业实现了换乘，但是由于各种原因没有实现对所有电梯状态的整体把握和换乘考虑，因此性能表现一般。</li></ol><h2 id="二、bug分析"><a href="#二、bug分析" class="headerlink" title="二、bug分析"></a>二、bug分析</h2><h3 id="第五次作业-1"><a href="#第五次作业-1" class="headerlink" title="第五次作业"></a>第五次作业</h3><h4 id="自己的bug"><a href="#自己的bug" class="headerlink" title="自己的bug"></a>自己的bug</h4><h5 id="bug描述"><a href="#bug描述" class="headerlink" title="bug描述"></a>bug描述</h5><p>本次作业在强测中AK，在互测中被找出一个bug</p><p>原因是线程安全没考虑周全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"Thread-1"</span> java.util.ConcurrentModificationException</span><br><span class="line">at java.util.ArrayList.sort(ArrayList.java:<span class="number">1464</span>)</span><br><span class="line">at Elevator.run(Elevator.java:<span class="number">68</span>)</span><br></pre></td></tr></table></figure><p>问题原因其实就是源于以下的代码。即是因为<code>Elevator</code>类在<code>Night</code>模式下对等待请求队列排序的处理有误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pattern.equals(<span class="string">"Night"</span>)) &#123;</span><br><span class="line">        waitQueue.getRequests()</span><br><span class="line">            .sort(Comparator.comparingInt(PersonRequest::getFromFloor));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="bug修复总结"><a href="#bug修复总结" class="headerlink" title="bug修复总结"></a>bug修复总结</h5><p>是非常明显的线程安全问题，只要给<code>waitQueue.getRequests()</code>加锁就没问题了。出现原因本质上还是自己对多线程的理解不深刻，没有养成勤加锁的好习惯。</p><h4 id="他人的bug"><a href="#他人的bug" class="headerlink" title="他人的bug"></a>他人的bug</h4><h5 id="bug描述-1"><a href="#bug描述-1" class="headerlink" title="bug描述"></a>bug描述</h5><p>本次共分别找到三个人的共计三个bug，都是由于线程安全所致，均导致了RTLE。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1 Random hack了3个同学 </span></span><br><span class="line">[1.0]Random</span><br><span class="line">[1.0]1-FROM-19-TO-1</span><br><span class="line">[1.0]2-FROM-19-TO-1</span><br><span class="line">[1.0]3-FROM-19-TO-1</span><br><span class="line">[1.0]4-FROM-19-TO-1</span><br><span class="line">[1.0]5-FROM-19-TO-1</span><br><span class="line">[1.0]133-FROM-19-TO-1</span><br><span class="line">[1.0]134-FROM-19-TO-1</span><br><span class="line">[1.0]135-FROM-19-TO-1</span><br><span class="line">[1.0]136-FROM-19-TO-1</span><br><span class="line">[1.0]137-FROM-19-TO-1</span><br><span class="line">[1.0]138-FROM-19-TO-1</span><br><span class="line">[1.0]139-FROM-19-TO-1</span><br><span class="line">[1.0]130-FROM-19-TO-1</span><br><span class="line">[1.0]6-FROM-19-TO-1</span><br><span class="line">[1.0]131-FROM-19-TO-1</span><br><span class="line">[1.0]132-FROM-19-TO-1</span><br><span class="line">[2.0]7-FROM-19-TO-1</span><br><span class="line">[2.0]8-FROM-19-TO-1</span><br><span class="line">[2.0]9-FROM-19-TO-1</span><br><span class="line">[2.0]10-FROM-19-TO-1</span><br><span class="line">[2.0]11-FROM-19-TO-1</span><br><span class="line">[2.0]12-FROM-19-TO-1</span><br><span class="line">[2.0]13-FROM-19-TO-1</span><br><span class="line">[10.0]14-FROM-19-TO-17</span><br><span class="line">[10.0]15-FROM-15-TO-19</span><br><span class="line">[10.0]16-FROM-18-TO-1</span><br><span class="line">[10.0]17-FROM-2-TO-20</span><br><span class="line">[10.0]18-FROM-20-TO-4</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">2 Night hack了1个同学</span></span><br><span class="line">[1.0]Night</span><br><span class="line">[1.0]1-FROM-19-TO-1</span><br><span class="line">[1.0]2-FROM-19-TO-1</span><br><span class="line">[1.0]3-FROM-19-TO-1</span><br><span class="line">[1.0]4-FROM-19-TO-1</span><br><span class="line">[1.0]5-FROM-19-TO-1</span><br><span class="line">[1.0]133-FROM-19-TO-1</span><br><span class="line">[1.0]134-FROM-19-TO-1</span><br><span class="line">[1.0]135-FROM-19-TO-1</span><br><span class="line">[1.0]136-FROM-19-TO-1</span><br><span class="line">[1.0]137-FROM-19-TO-1</span><br><span class="line">[1.0]138-FROM-19-TO-1</span><br><span class="line">[1.0]139-FROM-19-TO-1</span><br><span class="line">[1.0]130-FROM-19-TO-1</span><br><span class="line">[1.0]6-FROM-19-TO-1</span><br><span class="line">[1.0]131-FROM-19-TO-1</span><br><span class="line">[1.0]132-FROM-19-TO-1</span><br><span class="line">[1.0]7-FROM-19-TO-1</span><br><span class="line">[1.0]8-FROM-19-TO-1</span><br><span class="line">[1.0]9-FROM-19-TO-1</span><br><span class="line">[1.0]10-FROM-19-TO-1</span><br><span class="line">[1.0]11-FROM-19-TO-1</span><br><span class="line">[1.0]12-FROM-19-TO-1</span><br><span class="line">[1.0]13-FROM-19-TO-1</span><br><span class="line">[1.0]14-FROM-19-TO-1</span><br><span class="line">[1.0]15-FROM-19-TO-1</span><br><span class="line">[1.0]16-FROM-19-TO-1</span><br><span class="line">[1.0]17-FROM-19-TO-1</span><br><span class="line">[1.0]18-FROM-19-TO-1</span><br><span class="line">[1.0]19-FROM-19-TO-1</span><br></pre></td></tr></table></figure><h5 id="测试方式"><a href="#测试方式" class="headerlink" title="测试方式"></a>测试方式</h5><p>本单元由于与很多事情相撞，没完成评测机，所以只能一直采用阅读代码加上手动构造复杂的测试用例的方式来进行互测。基本原则就是构造请求数量和最大限制一样，且出现很多楼层跨度很大的电梯请求的测试数据。</p><h3 id="第六次作业-1"><a href="#第六次作业-1" class="headerlink" title="第六次作业"></a>第六次作业</h3><h4 id="自己的bug-1"><a href="#自己的bug-1" class="headerlink" title="自己的bug"></a>自己的bug</h4><p>本次强测中被hack1个点，互测中未被hack。</p><h5 id="bug描述-2"><a href="#bug描述-2" class="headerlink" title="bug描述"></a>bug描述</h5><p>RTLE，运行时间超过了210s</p><h5 id="bug修复总结-1"><a href="#bug修复总结-1" class="headerlink" title="bug修复总结"></a>bug修复总结</h5><p>原因如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (floor != desFloor1) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sleep(<span class="number">400</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    floor += step;</span><br><span class="line">    TimableOutput.println(</span><br><span class="line">        String.format(<span class="string">"ARRIVE-%d-%s"</span>, floor, id));</span><br><span class="line">    desFloor1 = scheduler.getDesFloor(floor);</span><br><span class="line">    <span class="comment">//缺少这行:step=floor&lt;desFloor1?:1:-1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即我每到一个楼层都会更新下一个目标楼层，而与此同时却没有更新方向。因此出现了问题。当出现新的请求与当前请求方向不一致时，会一直死循环，导致电梯通向天堂或者地狱。</p><h4 id="他人的bug-1"><a href="#他人的bug-1" class="headerlink" title="他人的bug"></a>他人的bug</h4><p>本次未发现他人bug。</p><p>尝试用上次的强测用例修改后进行hack，没有成功。</p><h3 id="第七次作业-1"><a href="#第七次作业-1" class="headerlink" title="第七次作业"></a>第七次作业</h3><h4 id="自己的bug-2"><a href="#自己的bug-2" class="headerlink" title="自己的bug"></a>自己的bug</h4><p>本次强测被hack四个点，互测被hack四个点。主要原因是因为换乘导致的唤醒遗漏问题以及两处代码逻辑问题。</p><p><strong>唤醒遗漏</strong>主要发生在B电梯的换乘处理上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">TimableOutput.println(String.format(<span class="string">"OUT-%d-%d-%s"</span>,request.getPersonId(), floor, id));</span><br><span class="line"><span class="keyword">synchronized</span> (allWaitQueue) &#123;</span><br><span class="line">    PersonRequest newrequest = <span class="keyword">new</span> PersonRequest(floor,request.getToFloor(), request.getPersonId());</span><br><span class="line">    allWaitQueue.addRequest(newrequest);</span><br><span class="line">    allWaitQueue.notifyAll();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>代码中，显然只对总的等待请求队列做了唤醒处理，却没有对checkidset也就是换乘乘客id的集合做唤醒处理，导致了在Dispatcher类中一直卡死，无法结束线程。</p><p><strong>处理逻辑</strong>主要是对B电梯的处理上有问题。一处是当B电梯中有偶数层目的地的乘客时，在到达偶数层会一直循环卡死在这一层。通过设置B电梯且为偶数层跳过的逻辑就解决了。即：<code>if (type.equals(&quot;B&quot;) &amp;&amp; floor % 2 == 0) { continue; }</code>。另一处如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lenInit == maxnum || (!initReqs.contains(mainRequest) &amp;&amp; lenInit == maxnum - <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> mainDesFloor;</span><br><span class="line">&#125;</span><br><span class="line">mainDesFloor = maxnum == <span class="number">6</span> ? getBFloor(floor, mainDesFloor) : mainDesFloor;</span><br></pre></td></tr></table></figure><p>当B电梯进行换乘时，我的代码逻辑在某些情况直接返回了主请求的目的地，而不是经过<code>getBFloor</code>函数转换后再做将进一步处理。于是导致了问题。只需要将转换的代码放在前面即可</p><p>如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mainDesFloor &#x3D; maxnum &#x3D;&#x3D; 6 ? getBFloor(floor, mainDesFloor) : mainDesFloor;</span><br><span class="line">if (lenInit &#x3D;&#x3D; maxnum || (!initReqs.contains(mainRequest) &amp;&amp; lenInit &#x3D;&#x3D; maxnum - 1)) &#123;</span><br><span class="line">    return mainDesFloor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="他人的bug-2"><a href="#他人的bug-2" class="headerlink" title="他人的bug"></a>他人的bug</h4><p>本次未发现他人bug。</p><h2 id="三、心得体会"><a href="#三、心得体会" class="headerlink" title="三、心得体会"></a>三、心得体会</h2><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><ul><li>一定要勤给变量加锁，同时也要注意锁的先后顺序避免出现死锁。</li><li>加锁后如果进行了<code>wait</code>操作一定要注意在合适的地方进行唤醒，否则就会一直卡死。这个时候最好枚举出所有需要唤醒的情况。</li><li>共享变量的维护很重要，尽量减少共享变量，同时对于共享变量一定要加锁进行操作。</li><li>一定要注意每个线程的终止条件，要考虑到尽可能全面的情况，比如第七次作业的输入结束后又产生新的换乘请求的情况。一般需要加一个新的变量来处理。</li></ul><h4 id="层次化设计"><a href="#层次化设计" class="headerlink" title="层次化设计"></a>层次化设计</h4><ul><li>在进行系统设计时，往往需要多线程模式。而这就往往需要对一些对象进行精细的不依赖于上层的建模，比如本次的单台电梯。只要写好一个电梯线程，就可以加无数个电梯，便于之后的扩展。建模过程中要注意不同模块之间的解耦，比如本单元作业就可以将电梯类和策略类分开，便于之后更换策略。</li><li>写之前要理清不同线程、不同类之间的交互关系和共享变量，并尽可能使得关系更加简洁，共享变量尽可能少。关系清晰了，才不容易出线程安全错误。</li></ul><h4 id="经验教训"><a href="#经验教训" class="headerlink" title="经验教训"></a>经验教训</h4><ul><li><p>对一个版本底气不足时不如老老实实交把握大的版本。第7次作业最后一次交的时候自知换乘的版本有很多问题，但是时间原因没法进一步debug了，就交上去了。但其实选择更稳妥的没换乘的方式至少正确性可能会好很多。</p></li><li><p>评测机很重要！！上一单元因为有较完善的评测机互测自测都很顺利。本单元没有实现评测机导致很多时候比较被动。</p></li><li>修复bug的时候最重要的是通过，所以修改的时候可以不考虑性能，纯考虑正确性来进行修改。另外<del>修复bug的时候不要按<code>Alt+Ctrl+L</code></del>，原因懂得都懂。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-OO-2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++面向对象</title>
      <link href="2021/04/22/C_C++/"/>
      <url>2021/04/22/C_C++/</url>
      
        <content type="html"><![CDATA[<p>C++的部分知识复习，为了准备考试</p><a id="more"></a><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="C-面向对象"><a href="#C-面向对象" class="headerlink" title="C++面向对象"></a>C++面向对象</h2><h3 id="1-类-amp-对象"><a href="#1-类-amp-对象" class="headerlink" title="1.类&amp;对象"></a>1.类&amp;对象</h3><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">#类定义</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> &#123;</span></span><br><span class="line">    <span class="comment">//范围修饰符: 开头定义变量与函数</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//变量定义</span></span><br><span class="line">    <span class="keyword">double</span> weight;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//函数定义</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getWeight</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age2set)</span></span>;</span><br><span class="line">    People(); <span class="comment">//构造函数</span></span><br><span class="line">    People(<span class="keyword">int</span> age2set,weight2set);</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在类定义外定义函数 在返回值类型和函数名之间加上 类名+范围解析运算符 :: </span></span><br><span class="line">People::People()&#123;</span><br><span class="line">    weight=<span class="number">70</span>;</span><br><span class="line">    age=<span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">People::People(<span class="keyword">int</span> age2set,<span class="keyword">double</span> weight2set)&#123;</span><br><span class="line">age=age2set;</span><br><span class="line">    weight=weight2set;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造函数另一种写法:初始化列表来初始化字段 与上一种写法等价</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">People::People( double age2set, double weight2set): age(age2set),weight(weight2set)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  ...</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">People::getWeight</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">People::set</span><span class="params">(<span class="keyword">int</span> age2set)</span></span>&#123;</span><br><span class="line">    age=age2set;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建People类变量</span></span><br><span class="line">People jack;</span><br><span class="line"><span class="function">People <span class="title">xiaoming</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>; <span class="comment">//创建时自动调用了构造函数</span></span><br></pre></td></tr></table></figure><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><p>在每次<strong>删除</strong>创建的对象时执行。<strong>类似构造</strong>函数，函数名与类名相同。只是函数名前要加一个<code>~</code>。</p><p>这个函数<strong>不能有返回值和参数</strong>。有助于在跳出程序前<strong>释放资源</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ~Obj();</span><br><span class="line">&#125;;</span><br><span class="line">Obj::~Obj()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Obj is being deleted"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h4><p><strong>特殊</strong>的构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形式</span></span><br><span class="line">classname (<span class="keyword">const</span> classname &amp;obj) &#123;</span><br><span class="line">   <span class="comment">// 构造函数的主体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Obj(<span class="keyword">int</span> len);</span><br><span class="line">   Obj(<span class="keyword">const</span> Obj &amp;obj);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line">Obj::Obj(<span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    p=<span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    *p=len; <span class="comment">//构造函数</span></span><br><span class="line">&#125;</span><br><span class="line">Obj::Obj(<span class="keyword">const</span> Obj &amp;obj)</span><br><span class="line">&#123;</span><br><span class="line">    p=<span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    *p=*obj.p; <span class="comment">//拷贝</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Obj <span class="title">obja</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">Obj objb = obja; <span class="comment">//调用了拷贝构造函数</span></span><br></pre></td></tr></table></figure><h4 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h4><p><code>friend</code> 关键字对函数进行声明即可，友元函数可以访问这个类的所有成员。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">printa</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassB</span>;</span> <span class="comment">//ClassB中所有函数都成为了Obj对象的友元函数</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><p>加上<code>inline</code> 关键字即可。一种用<strong>空间换时间</strong>的方式，在编译时会在每个调用这个函数的位置放置这个函数副本，所以<strong>空间开销大</strong>。</p><p>一般要使用最好行数较短，<strong>1-5行</strong>为宜，不要出现分支。</p><p>比如<code>Max</code>,<code>Min</code>等。</p><h4 id="对象指针"><a href="#对象指针" class="headerlink" title="对象指针"></a>对象指针</h4><h5 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h5><p>是一个指向自身的指针，用<code>this-&gt;变量/方法名</code>来使用。</p><p><strong>普通对象指针</strong>用法与this一样。</p><h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><p><code>static</code> 关键词来定义。</p><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><p>创建第一个类对象时若<strong>无其他初始化语句</strong>，所有的静态数据会<strong>清0</strong>。之后所有<strong>新创建的同类</strong>都<strong>共享</strong>这个数据。</p><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><p>不能使用<strong>this</strong>指针。必须使用<code>classname::fun()</code>的形式来调用。</p><h3 id="2-C-继承"><a href="#2-C-继承" class="headerlink" title="2.C++继承"></a>2.C++继承</h3><p><strong>基本形式</strong>是<code>class A:access-specifier B;</code></p><p>同时，也可以<strong>多继承</strong>。如下代码所示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;派生类名&gt;:</span>&lt;继承方式<span class="number">1</span>&gt;&lt;基类名<span class="number">1</span>&gt;,&lt;继承方式<span class="number">2</span>&gt;&lt;基类名<span class="number">2</span>&gt;,…</span><br><span class="line">&#123;</span><br><span class="line">&lt;派生类类体&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>修饰符</strong>是<code>public/protected/private</code>，一般用<code>public</code>，即父类的<code>public/protected</code>成员都作为相同的权限被定义在子类中。其他两种则是将父类的<code>public/protected</code>成员作为相应的权限被定义。同时，三种定义皆不能访问到父类的<code>private</code>成员。</p><p>C++<strong>继承函数</strong>比较麻烦。</p><p>以下三种是不会继承的。其他符合权限限制的都可以访问。</p><ul><li>基类的<strong>构造函数</strong>、<strong>析构函数</strong>和<strong>拷贝构造函数</strong>。</li><li>基类的<strong>重载运算符</strong>。</li><li>基类的<strong>友元函数</strong>。</li></ul><p>这里实在太复杂，先简单罗列一下最常用的<strong>构造函数的继承使用说明</strong>。</p><p>构造原则如下（这里参考了这篇博客 <a href="https://blog.csdn.net/lzbzclz/article/details/105062566" target="_blank" rel="noopener">https://blog.csdn.net/lzbzclz/article/details/105062566</a>)：</p><ol><li>在类的继承的过程中，如果子类<strong>没有定义构造函数</strong>，程序就会<strong>自动调用父类</strong>的<strong>构造函数</strong>。</li><li>如果子类<strong>定义了构造函数</strong>且父类是<strong>无参</strong>的构造函数，那么创建类的时候会自动<strong>先调用父类的构造函数</strong>，再调用子类的构造函数。</li><li>如果子类<strong>定义了构造函数</strong>且没有显示调用父类中<strong>唯一的带参构造函数</strong>，程序会报错。</li><li>调用父类构造函数的时候得用<strong>初始化父类成员对象</strong>的方式。</li></ol><p>举例如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//报错的代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> a);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line">A::A(<span class="keyword">int</span> a)&#123;</span><br><span class="line">    <span class="keyword">this</span>.a=a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    B(<span class="keyword">int</span> b);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line">B::B(<span class="keyword">int</span> b)&#123;</span><br><span class="line">    <span class="keyword">this</span>.b=b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">B <span class="title">b</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> a);</span><br><span class="line">    <span class="comment">//在这里加一个不带参数的构造函数也可</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line">A::A(<span class="keyword">int</span> a)&#123;</span><br><span class="line">    <span class="keyword">this</span>.a=a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    B(<span class="keyword">int</span> b);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line">B::B(<span class="keyword">int</span> b):A(<span class="number">10</span>)&#123;</span><br><span class="line">    <span class="keyword">this</span>.b=b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">B <span class="title">b</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-重载运算符和重载函数"><a href="#3-重载运算符和重载函数" class="headerlink" title="3.重载运算符和重载函数"></a>3.重载运算符和重载函数</h3><p><strong>函数</strong>和<strong>运算符</strong>都可以进行重载</p><p>调用时编译器通过<strong>使用的参数类型</strong>与<strong>定义</strong>中的进行比较，选择合适的，称为<strong>重载决策</strong>。</p><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"No Parameter!"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">string</span> a)</span> </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt; <span class="string">"p1:"</span> &lt;&lt; a;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">A a;</span><br><span class="line">A.<span class="built_in">print</span>();</span><br><span class="line">A.print1(<span class="string">"a"</span>);</span><br></pre></td></tr></table></figure><h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><p>关键字 <code>operator</code> 和其后要<strong>重载的运算符符号</strong>构成的，可以视为一个函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//如果在类内只需要传入一个Box参数</span></span><br><span class="line">        Box <span class="keyword">operator</span>+(<span class="keyword">const</span> Box&amp; b) &#123;</span><br><span class="line">            Box box;</span><br><span class="line">            box.a = <span class="keyword">this</span>-&gt;a+b-&gt;a;</span><br><span class="line">            box.b = <span class="keyword">this</span>-&gt;b+b-&gt;b;</span><br><span class="line">            <span class="keyword">return</span> box;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果在类外传入两个Box参数</span></span><br><span class="line">Box <span class="keyword">operator</span>+(<span class="keyword">const</span> Box&amp; b1,<span class="keyword">const</span> Box&amp; b2) &#123;</span><br><span class="line">    Box box;</span><br><span class="line">    box.a = b1-&gt;a+b2-&gt;a;</span><br><span class="line">    box.b = b1-&gt;b+b2-&gt;b;</span><br><span class="line">    <span class="keyword">return</span> box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-C-多态"><a href="#4-C-多态" class="headerlink" title="4.C++多态"></a>4.C++多态</h3><p><strong>继承关联</strong>时会用到<strong>多态</strong></p><p><strong>调用成员函数</strong>时<strong>根据对象类型</strong>执行不同函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> <span class="built_in">width</span>, <span class="built_in">height</span>;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      Shape( <span class="keyword">int</span> a=<span class="number">0</span>, <span class="keyword">int</span> b=<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">width</span> = a;</span><br><span class="line">         <span class="built_in">height</span> = b;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">"Parent class area :"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      Rectangle( <span class="keyword">int</span> a=<span class="number">0</span>, <span class="keyword">int</span> b=<span class="number">0</span>):Shape(a, b) &#123; &#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">area</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">"Rectangle class area :"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">         <span class="keyword">return</span> (<span class="built_in">width</span> * <span class="built_in">height</span>); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span>:</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      Triangle( <span class="keyword">int</span> a=<span class="number">0</span>, <span class="keyword">int</span> b=<span class="number">0</span>):Shape(a, b) &#123; &#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">area</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">"Triangle class area :"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">         <span class="keyword">return</span> (<span class="built_in">width</span> * <span class="built_in">height</span> / <span class="number">2</span>); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Shape *shape;</span><br><span class="line">   <span class="function">Rectangle <span class="title">rec</span><span class="params">(<span class="number">10</span>,<span class="number">7</span>)</span></span>;</span><br><span class="line">   <span class="function">Triangle  <span class="title">tri</span><span class="params">(<span class="number">10</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 存储矩形的地址</span></span><br><span class="line">   shape = &amp;rec;</span><br><span class="line">   <span class="comment">// 调用矩形的求面积函数 area</span></span><br><span class="line">   shape-&gt;area();</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 存储三角形的地址</span></span><br><span class="line">   shape = &amp;tri;</span><br><span class="line">   <span class="comment">// 调用三角形的求面积函数 area</span></span><br><span class="line">   shape-&gt;area(); </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，由于基类中实定义了函数，后面两处都输出 <code>Parent class area:</code>  </p><ul><li>这里也被称为 <strong>静态多态/静态链接</strong>，在程序执行前就已经将<code>area</code>函数定死了。</li></ul><p>只需要在基类的函数定义前加关键字<code>virtual</code>，进行<strong>虚定义</strong>，后面输出的就是正常的各自的输出。</p><p>这时就是根据不同的指针地址的位置的 <code>area</code> 函数来执行了。</p><h5 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带实现的虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">area</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//纯虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">area</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="5-C-数据抽象与封装"><a href="#5-C-数据抽象与封装" class="headerlink" title="5.C++数据抽象与封装"></a>5.C++数据抽象与封装</h3><ul><li>数据抽象：仅向用户<strong>暴露接口</strong>而<strong>隐藏具体实现细节</strong>的机制。</li><li><p>数据封装：把数据和操作数据的函数捆绑在一起的机制。</p></li><li><p>数据成员和外界不需要的类内方法函数用<code>private</code>，外部接口方法用<code>public</code></p></li></ul><h3 id="6-C-接口（抽象类）"><a href="#6-C-接口（抽象类）" class="headerlink" title="6.C++ 接口（抽象类）"></a>6.C++ 接口（抽象类）</h3><p>接口：类中<strong>至少有一个函数</strong>被声明为<strong>纯虚函数</strong>，则这个类就是<strong>抽象类</strong></p><p>这个和<code>Java</code>中的<strong>接口</strong>是一样的，直接用接口去定义一个实例会报错，需要具体实现</p><p>比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="comment">// 纯虚函数</span></span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getVolume</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setLength</span><span class="params">(<span class="keyword">double</span> length)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>-&gt;length = length;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> length;      <span class="comment">// 长度</span></span><br><span class="line">      <span class="keyword">double</span> breadth;     <span class="comment">// 宽度</span></span><br><span class="line">      <span class="keyword">double</span> <span class="built_in">height</span>;      <span class="comment">// 高度</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoxChild</span>:</span><span class="keyword">public</span> Box</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getVolume</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;length;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="课程思维导图"><a href="#课程思维导图" class="headerlink" title="课程思维导图"></a>课程思维导图</h3><p><img src="/.top//微信图片_20210527063529.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    
    
    <entry>
      <title>OS-C语言基础</title>
      <link href="2021/03/30/OS-C-Basic/"/>
      <url>2021/03/30/OS-C-Basic/</url>
      
        <content type="html"><![CDATA[<p>近期操作系统课上测试因为C语言的薄弱基础接连受到暴击，笔者痛下决心一定要开始一篇C语言基础总结的博客，时间有限，本次先将OS两次课上的坑总结一下，以后再补充其他的。</p><a id="more"></a><h2 id="数据类型与移位运算"><a href="#数据类型与移位运算" class="headerlink" title="数据类型与移位运算"></a>数据类型与移位运算</h2><p><code>unsigned int</code> 是无符号整数</p><p><code>int</code>有符号整数</p><p>对上述两者赋值时，都是将右边的数字的补码存入相应地址中。</p><p>比如：<code>int a = -1;unsigned a = -1;</code>其实这两个<code>a</code>存的变量内容一样，都是<code>FFFFFFFF</code>（负数的首位为1不变，其他位取反然后整体+1.）</p><p>上述两者如果用<code>%d</code>输出，都会输出一个<code>-1</code>，但是如果输出一个<code>%u</code>则会输出32位无符号整数。另外,<code>%o</code>是8进制，<code>%x</code>是输出十六进制</p><p>同理对于其他的<code>char/unsigned char</code> <code>long/unsigned long</code>等。</p><p>同时，在C语言中默认为十进制数字，可以直接用0x开头表示十六进制，0开头表示8进制，0b开头表示二进制数字。如：<code>0x1af 0176 0b101</code></p><p>同时建立起一个意识就是OS课中C语言中的最小单位可以认为是char，即一个字节</p><h2 id="大小端转换"><a href="#大小端转换" class="headerlink" title="大小端转换"></a>大小端转换</h2><p>那么再有了移位的运算符知识我们就可以实现lab1-1课上的Extra的大小端转换问题了。</p><p>大小端是针对字节来说的，对于一个数字0x12345678来说下图是一个<strong>小端存储</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">           -------------------------------------</span><br><span class="line">首地址0x4000|00010010|00110100|01010110|01111000|末尾地址0x4004</span><br><span class="line">           -------------------------------------</span><br></pre></td></tr></table></figure><p>而这张是一个<strong>大端存储</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">           -------------------------------------</span><br><span class="line">首地址0x4000|01111000|01010110|00110100|00010010|末尾地址0x4004</span><br><span class="line">           -------------------------------------</span><br></pre></td></tr></table></figure><p>即每个字节内其实都是按照所谓的”小端存储”，而大端存储相当于是把小端存储的字节序列倒序排列了。</p><p>一般的x86/ARM架构其实都是小端存储为主，但是也时常有解析大端存储数据的需求。</p><p>有了这些就可以进行转换了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1 = <span class="number">0xff</span>&lt;&lt;<span class="number">24</span>;</span><br><span class="line"><span class="keyword">int</span> a2 = <span class="number">0xff</span>&lt;&lt;<span class="number">16</span>;</span><br><span class="line"><span class="keyword">int</span> a3 = <span class="number">0xff</span>&lt;&lt;<span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> a4 = <span class="number">0xff</span>; <span class="comment">//本来以为必须要定义成unsigned，结果其实不用也可以</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0x12345678</span>;</span><br><span class="line"><span class="comment">//注意优先级，可以输出一下这个看看 a = (a &lt;&lt; 24) &amp; a1 + (a &lt;&lt; 8) &amp; a2 + (a &gt;&gt; 8) &amp; a3 + (a &gt;&gt; 24) &amp; a4; 结果为0</span></span><br><span class="line">a = ((a&lt;&lt;<span class="number">24</span>)&amp;a1) + ((a&lt;&lt;<span class="number">8</span>)&amp;a2) + ((a&gt;&gt;<span class="number">8</span>)&amp;a3) + ((a&gt;&gt;<span class="number">24</span>)&amp;a4); </span><br><span class="line"><span class="comment">// a = 0x78563412</span></span><br></pre></td></tr></table></figure><p>一旦遇到移位运算符，逻辑运算符，多加括号是个好习惯。</p><h2 id="指针与结构体"><a href="#指针与结构体" class="headerlink" title="指针与结构体"></a>指针与结构体</h2><p><code>sizeof(type)</code> 返回该变量所占字节数</p><p>指针本质上可以理解为一个<code>int</code>型变量，存着一个32位的地址数据，因为有内存里其他数据的辅助，可以解析相应地址的变量。</p><p>而数组和指针没有本质区别，即如下面所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *b=a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,a[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,b[<span class="number">1</span>]);<span class="comment">//b[1]和*(b+1)一样</span></span><br></pre></td></tr></table></figure><p>结构体的基本使用方式回顾</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s1</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s1</span> <span class="title">t1</span>;</span></span><br><span class="line">t1.a=<span class="number">12</span>;t1.b=<span class="string">'a'</span>;t1.c=<span class="string">'b'</span>;t1.d=<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s1</span> * <span class="title">t1p</span> = <span class="title">t1</span>;</span></span><br><span class="line">t1-&gt;a=<span class="number">13</span>; <span class="comment">//指针需要使用箭头的引用方式</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s1</span> * <span class="title">tp</span> = (<span class="title">struct</span> <span class="title">s1</span> *) <span class="title">addr</span>;</span><span class="comment">//将一个地址转换成结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s1</span> <span class="title">t</span> = *((<span class="title">struct</span> <span class="title">s1</span> *) <span class="title">addr</span>);</span><span class="comment">//将一个地址转换成结构体变量</span></span><br></pre></td></tr></table></figure><p>值得注意的是结构体内会很<strong>贴心</strong>的（一个哥们直接被这个坑了，挂了一次课上）将第二个b/c这两个char变量放在a变量后的连续两个字节里,然后空两个字节之后继续存d变量。即是下图这样的（一个*代表一个字节）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aaaabc  dddd</span><br><span class="line">************</span><br></pre></td></tr></table></figure><p>所以第二次课上如果想直接使用寻找四个变量的地址的方式，就应该先加一个<code>sizeof(int)</code>得到b，再加一个<code>sizeof(char)</code>得到c，再加两个<code>sizeof(char)</code>得到d</p><p>而笔者则是采用了直接将得到的变量利用结构体指针强制转换成结构体变量再进行使用的方式，但是课上测试时，在输出结构体变量内的数字时没有对符号进行清零导致了错误。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-OS-2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OO-Unit1-总结</title>
      <link href="2021/03/25/OO-Unit1-%E5%B0%8F%E7%BB%93/"/>
      <url>2021/03/25/OO-Unit1-%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>2021年北航OO课程的第一单元—表达式求导作业项目总结。</p><p>本单元中，有过因为疏忽大意出现重大错误导致被hack惨的痛苦经历，也有未被hack成功的喜悦体验，下面就来对这一单元的内容做一下梳理和回顾。</p><a id="more"></a><h1 id="OO-Unit1-总结"><a href="#OO-Unit1-总结" class="headerlink" title="OO-Unit1-总结"></a>OO-Unit1-总结</h1><h2 id="一、程序结构分析"><a href="#一、程序结构分析" class="headerlink" title="一、程序结构分析"></a>一、程序结构分析</h2><h3 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h3><h4 id="代码可视化与数据统计"><a href="#代码可视化与数据统计" class="headerlink" title="代码可视化与数据统计"></a>代码可视化与数据统计</h4><h5 id="程序类图"><a href="#程序类图" class="headerlink" title="程序类图"></a>程序类图</h5><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit1/hw1.png" style="zoom:80%;" /></p><p>可以看出，本次作业<code>Item</code>类中含有两个多余的方法，而整体架构上并没有严格遵循高内聚低耦合的原则，需要对各个类进行化简。</p><h5 id="程序复杂度分析"><a href="#程序复杂度分析" class="headerlink" title="程序复杂度分析"></a>程序复杂度分析</h5><div class="table-container"><table><thead><tr><th>Class</th><th>OCavg</th><th>OCmax</th><th>WMC</th></tr></thead><tbody><tr><td>Item</td><td>3.33</td><td>12</td><td>20</td></tr><tr><td>Main</td><td>2</td><td>2</td><td>4</td></tr><tr><td>Poly</td><td>4</td><td>12</td><td>20</td></tr></tbody></table></div><p>可以看出，在<code>Item</code>类和<code>Poly</code>类中代码复杂度较高，含有过多的判断语句。</p><h5 id="程序行数统计"><a href="#程序行数统计" class="headerlink" title="程序行数统计"></a>程序行数统计</h5><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit1/hw1_sta.png" style="zoom:80%;" /></p><p>本次的<code>Main</code>类中的有效行数达到了31行，过多。</p><h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><h5 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h5><p><code>Main</code>类中含有对字符串的预处理<code>process</code>方法，包含去除空白字符和对加减号的替换。</p><p><code>Item</code>类中记录了一个项的系数和幂指数。</p><p><code>Poly</code>类中记录了一个多项式的系数和幂指数的幂指数到系数的<code>HashMap</code>，以及相应的求导化简方法。</p><p>具体运行时，先对输入的字符串做好预处理，同时产生一个<code>Item</code>类的列表，之后将这个列表存入<code>Poly</code>类中利用<code>initMap</code>方法转换成<code>HashMap</code>，转换同时进行了化简，之后再完成求导方法。</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>针对本次任务，字符串处理后根据符号分割的速度快，操作简便。之后将表达式每一项先进行化简再进行求导操作，类之间耦合程度较低，同时化简效果较好。</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>可扩展性较弱，字符串处理的方法仅仅适用于本次作业，之后两次作业均不适用。</p><h3 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h3><h4 id="代码可视化与数据统计-1"><a href="#代码可视化与数据统计-1" class="headerlink" title="代码可视化与数据统计"></a>代码可视化与数据统计</h4><h5 id="程序类图-1"><a href="#程序类图-1" class="headerlink" title="程序类图"></a>程序类图</h5><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit1/hw2.png" style="zoom: 50%;" /></p><p>本次作业基本达到了高内聚低耦合的目的，每个类的功能相对独立，除了<code>Expression</code>类外没有特别臃肿的类。</p><h5 id="程序复杂度分析-1"><a href="#程序复杂度分析-1" class="headerlink" title="程序复杂度分析"></a>程序复杂度分析</h5><div class="table-container"><table><thead><tr><th>Class</th><th>OCavg</th><th>OCmax</th><th>WMC</th></tr></thead><tbody><tr><td>Constant</td><td>1</td><td>1</td><td>5</td></tr><tr><td>ExprFactor</td><td>1</td><td>1</td><td>6</td></tr><tr><td>ExprNode</td><td>2.62</td><td>7</td><td>21</td></tr><tr><td>Expression</td><td>3.33</td><td>8</td><td>40</td></tr><tr><td>FactorFather</td><td>1</td><td>1</td><td>9</td></tr><tr><td>Item</td><td>5.5</td><td>14</td><td>55</td></tr><tr><td>Main</td><td>1</td><td>1</td><td>1</td></tr><tr><td>PowerFun</td><td>3.43</td><td>13</td><td>24</td></tr><tr><td>TriFun</td><td>4.33</td><td>20</td><td>39</td></tr></tbody></table></div><p>可以看出<code>Expression</code>和<code>Item</code>类的复杂度较高。</p><h5 id="程序行数统计-1"><a href="#程序行数统计-1" class="headerlink" title="程序行数统计"></a>程序行数统计</h5><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit1/hw2_sta.png" style="zoom:80%;" /></p><p>本次作业代码量较大，总有效行数是751行，其中代码行数最长地就是<code>Expression</code>类</p><h4 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h4><h5 id="原理分析-1"><a href="#原理分析-1" class="headerlink" title="原理分析"></a>原理分析</h5><p>本次作业使用了多叉树作为数据结构建立表达式树。采用了递归下降的方式对输入的表达式进行解析。</p><p>表达式树分为三个层次，如下图所示。</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit1/pic.png" style="zoom:80%;" /></p><p>其中表达式层可以看成是若干个项的对象组成的列表，项层可以看成是若干个因子对象组成的列表，而因子里的表达式因子里的表达式也符合这里的表达式定义。</p><p>对最小层次因子，本次作业我建立了<code>Factor</code>抽象类，同时使用一个父类<code>FactorFather</code>类对<code>Factor</code>类的各个方法进行实现，并让各个具体的因子类继承这个父类，达到了使用<code>Factor</code>对象就可以对所有的因子类进行无差别调用和管理的目的。<code>Factor</code>类主要的重写方法有<code>toString</code>输出原因子方法，<code>diff</code>求导方法，返回值都是字符串。</p><p><code>Item</code>类中主要有<code>diff</code>、<code>simplify</code>方法。分别对应求导，化简。求导具体是用递归的方式计算第一个因子的导数乘以后面所有因子的乘积加第一个因子乘以后面所有因子的乘积的导数。化简方法将项转换成$a<em>x^k</em>sin(x)^m<em>cos(x)^n</em>若干个表达式因子相乘$的形方便合并同类项。</p><p><code>ExprNode</code>类定义了表达式树的根节点。里面也含有<code>diff</code>、<code>simplify</code>方法。求导方法拼接每个项的求导输出，化简方法则是将相同的项进行合并。</p><p><code>Expression</code>类包含了一个<code>ExprNode</code>对象，具体的求导输出也是调用了相关接口。同时<code>Expression</code>类也包含了对输入字符串的递归下降的解析过程和相关方法。包含了<code>getExpression、getItem、getFactor、getExprFactor、getTriFun、getPowFun、getNumber、getConstant</code>等方法。最后调用<code>getExpression</code>方法对输入进行解析并将结果存入<code>exprNode</code>对象中。</p><p>求导之后，将导数的字符串重新进行解析化简，得到较为简单的结果。</p><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><p>利用递归下降和表达式树对输入字符串进行了快速准确的解析，同时对同类项进行了一定程度的合并，可以达到较好的化简效果。</p><p>求导方法自下而上，各层之间关系清晰，且可以简便的使用同一种方式遍历所有的项和因子进行操作。</p><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><p>对于表达式的深合并和化简没有完成，同时没有定义清晰的复合求导，嵌套求导接口，对于比第三次作业更复杂的合并方式（比如增加各种嵌套）本次作业代码可扩展性一般。</p><h3 id="第三次作业"><a href="#第三次作业" class="headerlink" title="第三次作业"></a>第三次作业</h3><h4 id="代码可视化与数据统计-2"><a href="#代码可视化与数据统计-2" class="headerlink" title="代码可视化与数据统计"></a>代码可视化与数据统计</h4><h5 id="程序类图-2"><a href="#程序类图-2" class="headerlink" title="程序类图"></a>程序类图</h5><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit1/hw3.png" style="zoom: 33%;" /></p><h5 id="程序复杂度分析-2"><a href="#程序复杂度分析-2" class="headerlink" title="程序复杂度分析"></a>程序复杂度分析</h5><div class="table-container"><table><thead><tr><th>Class</th><th>OCavg</th><th>OCmax</th><th>WMC</th></tr></thead><tbody><tr><td>Constant</td><td>1</td><td>1</td><td>5</td></tr><tr><td>ExprFactor</td><td>1</td><td>1</td><td>6</td></tr><tr><td>ExprNode</td><td>2.62</td><td>7</td><td>21</td></tr><tr><td>Expression</td><td>5.31</td><td>11</td><td>69</td></tr><tr><td>FactorFather</td><td>1</td><td>1</td><td>9</td></tr><tr><td>Item</td><td>4.7</td><td>13</td><td>47</td></tr><tr><td>Main</td><td>2</td><td>2</td><td>2</td></tr><tr><td>PowerFun</td><td>3.43</td><td>13</td><td>24</td></tr><tr><td>TriFun</td><td>3.73</td><td>12</td><td>41</td></tr><tr><td>WFexception</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WFjudge</td><td>1.67</td><td>3</td><td>5</td></tr></tbody></table></div><h5 id="程序行数统计-2"><a href="#程序行数统计-2" class="headerlink" title="程序行数统计"></a>程序行数统计</h5><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit1/hw3_sta.png" style="zoom:80%;" /></p><p>本次代码量较上次增加了150行，主要是增加了格式正确性判断的逻辑以及修改了部分解析表达式的代码。</p><h4 id="代码分析-2"><a href="#代码分析-2" class="headerlink" title="代码分析"></a>代码分析</h4><h5 id="原理分析-2"><a href="#原理分析-2" class="headerlink" title="原理分析"></a>原理分析</h5><p>本次代码在上次的代码基础上修改了对三角函数的解析函数以及增加了嵌套求导、正确格式检查（包含了对空白字符，非法字符的解析），改动量较小。具体原理与上次作业类似。</p><p>具体方法上，增加了<code>getWhite</code>方法读入空白字符而没有做预处理，同时如果代码中遇到了不符合格式规范的输入序列，直接抛出异常，在<code>Main</code>类中进行接受和处理。</p><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><p>格式检查正确性较好，检查的比较完整。较上次作业改动不大，可以认为是比较符合设计模式中的开放-封闭原则。</p><h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><p>为了求稳，化简效果较差，仅完成了和上次程度一样的化简。</p><h2 id="二、bug分析"><a href="#二、bug分析" class="headerlink" title="二、bug分析"></a>二、bug分析</h2><h3 id="第一次作业-1"><a href="#第一次作业-1" class="headerlink" title="第一次作业"></a>第一次作业</h3><h4 id="自己的bug"><a href="#自己的bug" class="headerlink" title="自己的bug"></a>自己的bug</h4><h5 id="bug描述"><a href="#bug描述" class="headerlink" title="bug描述"></a>bug描述</h5><p>本次作业在强测中AK，在互测中被找出一个bug</p><p>被一些比较长且负号很多的用例测的时候有可能会产生下述bug：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.IllegalArgumentException: Comparison method violates its general contract!</span><br><span class="line">at java.util.TimSort.mergeLo(TimSort.java:<span class="number">777</span>)</span><br><span class="line">at java.util.TimSort.mergeAt(TimSort.java:<span class="number">514</span>)</span><br><span class="line">at java.util.TimSort.mergeCollapse(TimSort.java:<span class="number">441</span>)</span><br><span class="line">at java.util.TimSort.sort(TimSort.java:<span class="number">245</span>)</span><br><span class="line">at java.util.Arrays.sort(Arrays.java:<span class="number">1512</span>)</span><br><span class="line">at java.util.ArrayList.sort(ArrayList.java:<span class="number">1462</span>)</span><br><span class="line">at java.util.Collections.sort(Collections.java:<span class="number">175</span>)</span><br><span class="line">at Poly.getOutput(Poly.java:<span class="number">51</span>)</span><br><span class="line">at Poly.diff(Poly.java:<span class="number">42</span>)</span><br><span class="line">at Main.main(Main.java:<span class="number">17</span>)</span><br></pre></td></tr></table></figure><p>问题原因其实就是源于以下的代码。以下代码位于<code>Poly.java</code>的输出函数中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(ls, (Comparator) (o1, o2) -&gt; &#123;</span><br><span class="line">    BigInteger i1 = (BigInteger) o1;</span><br><span class="line">    BigInteger i2 = (BigInteger) o2;</span><br><span class="line">    <span class="keyword">if</span> (miXiMap.get(i1).compareTo(BigInteger.valueOf(<span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (miXiMap.get(i2).compareTo(BigInteger.valueOf(<span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i2.compareTo(i1);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>简单来说就是对一个容器进行排序时（首先本次作业排序就没必要，但笔者非常脑残地进行了降幂排序），比较函数里不能出现两个相互矛盾返回值逻辑，或者至少不要调用除了这个对象外部的变量。比如我的上述代码例子里，其实就是想降幂排序的同时将负号的移到后面去以此来简化长度，这个过程调用了外部的<code>HashMap</code>中对应幂指数的系数，这就会和JDK的底层实现相矛盾，于是造成了错误。</p><h5 id="bug修复总结"><a href="#bug修复总结" class="headerlink" title="bug修复总结"></a>bug修复总结</h5><p>和找出我这个bug的同学交流了一下，其实该大佬根本没看出我这个代码有啥问题，单纯用大规模的随机数据把我刀了，所以建议大家如果遇到没有必要的需求千万不要一时兴起随意加入，即使要加入也要好好翻翻文档看看能不能这么用。</p><p>那么我是怎么修改的呢，其实非常简单，我只需要查找整个序列找到一个系数为负的把他和第一个交换一下就好了。</p><p>这次bug修复也让我意识到了，简单的功能用更少的代码不一定能实现更好的效果，有时候偷懒其实会害了自己。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (miXiMap.get(ls.get(<span class="number">0</span>)).compareTo(BigInteger.ZERO) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> j = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ls.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (miXiMap.get(ls.get(i)).compareTo(BigInteger.ZERO) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            j = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j != -<span class="number">1</span>) &#123;</span><br><span class="line">        BigInteger x = ls.get(j);</span><br><span class="line">        ls.remove(j);</span><br><span class="line">        ls.add(<span class="number">0</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="他人的bug"><a href="#他人的bug" class="headerlink" title="他人的bug"></a>他人的bug</h4><h5 id="bug描述-1"><a href="#bug描述-1" class="headerlink" title="bug描述"></a>bug描述</h5><p>本次共分别找到两个人的共计三个bug，由于不太了解OO玩法，第一次多交了一些错误类型差不多的数据（第二次作业我交的少多了），这里向两位同学抱歉了，以后我保证不交那么多同质用例了，纯属浪费时间。</p><p>具体hack用例和结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1 符号parse有问题 hack 2人</span></span><br><span class="line">input:+++8*x*x**+78+x**6504-+-3313147-++69209*x**-7375*x+--837214</span><br><span class="line">output:510347166*x**-7375-6504*x**-6505+632*x**78</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">2 对于没有指数的数字parse有误 抛出了异常 hack 1人</span></span><br><span class="line">input:-+-2048*52*x++9-++6*-6*x**+138-x*x+x*+406*x**36+1-+-7320*+01+x**266*-530*4---458-+-622+x*5872*+51+-1343+x**13*x**0*x**465+x*x*579713++x**-8029*x*353*9463-+79*x**+239*x-+-681--x*-8200+++9223*x+x**867*851*1*-5--x**0*-4</span><br><span class="line">output:</span><br><span class="line">Exception in thread "main" java.lang.NumberFormatException: Zero length BigInteger</span><br><span class="line">at java.math.BigInteger.&lt;init&gt;(BigInteger.java:420)</span><br><span class="line">at java.math.BigInteger.&lt;init&gt;(BigInteger.java:606)</span><br><span class="line">at Term.&lt;init&gt;(Term.java:53)</span><br><span class="line">at Box.&lt;init&gt;(Box.java:26)</span><br><span class="line">at Main.main(Main.java:14)</span><br></pre></td></tr></table></figure><p>第一个bug主要是这两位同学都采用了字符串预处理的方式，但是并没有涵盖所有的情况，比如<code>---</code>、<code>-+-</code>这样的三符号情况导致出错。</p><p>第二个bug因为一位同学在解析数字时将空串传给了<code>BigInteger</code>对象。</p><h5 id="测试方式"><a href="#测试方式" class="headerlink" title="测试方式"></a>测试方式</h5><p>本次采用了<strong>大规模随机数据生成和评测</strong>寻找不同类型bug，遇到有错误的再<strong>查看代码进行定点爆破</strong>的方式。</p><p>由于第一次的表达式较简单，直接采用了<code>sympy</code>库的<code>sympify</code>方法转换每个<code>jar</code>文件的输出和<code>sympy</code>库的输出进行比对进行测试。</p><p>同时由于这种方式有时候会parse错误，我还采用了比对房内7个人地结果找少数派的方式，加大了找到bug的概率。</p><p>笔者对生成输入数据的正则表达式加以控制，让每个可以重复的地方次数不超过4次以此控制复杂度。共生成了6组数据，每组有1000个表达式。这样的测试方式就找到了上述的bug。</p><h3 id="第二次作业-1"><a href="#第二次作业-1" class="headerlink" title="第二次作业"></a>第二次作业</h3><h4 id="自己的bug-1"><a href="#自己的bug-1" class="headerlink" title="自己的bug"></a>自己的bug</h4><h5 id="bug描述-2"><a href="#bug描述-2" class="headerlink" title="bug描述"></a>bug描述</h5><p>本次作业在强测中<code>WA</code>了五个点，互测被刀了12下，全是一个同质bug。</p><p>在遇到以下用例时会出现问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(x)</span><br><span class="line">错误输出:(<span class="number">1</span>)</span><br><span class="line">-(-(x))</span><br><span class="line">错误输出:((<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>简单来说就是一个负号与一个表达式因子相连时，求导会无视负号的存在。</p><h5 id="bug修复总结-1"><a href="#bug修复总结-1" class="headerlink" title="bug修复总结"></a>bug修复总结</h5><p>这个bug根植于设计的不够合理。我的设计是先parse输入获得一个简单的表达式树，再对每一项进行化简，而化简时将项内的每个因子的符号进行连乘（代码中是符号因子的异或运算）得到项的符号，而最后将项的符号设置到这一项的系数因子上。而实际写代码时对于表达式因子的符号，不小心写出了如下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fact.setNeg(flag != fact.getNeg());</span><br></pre></td></tr></table></figure><p><code>flag</code>即是项的符号，这里本应将<code>flag</code>的值更新，然后将<code>fact</code>的<code>neg</code>符号设置为<code>false</code>，但是却手残写成了这样。</p><p>只要改为以下代码即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flag &#x3D; flag !&#x3D; fact.getNeg();</span><br><span class="line">fact.setNeg(false);</span><br></pre></td></tr></table></figure><p>同时，我的这种方法必须要化简后才能对表达式因子做出正确输出，而表达式因子类中并没有调用化简方法，导致了表达式因子中的表达式因子输出有误。</p><p>只需要在<code>ExprFactor</code>类中增加两行代码即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exprNode.simplify();</span><br><span class="line">exprNode.mergeItems();</span><br></pre></td></tr></table></figure><h4 id="他人的bug-1"><a href="#他人的bug-1" class="headerlink" title="他人的bug"></a>他人的bug</h4><h5 id="bug描述-3"><a href="#bug描述-3" class="headerlink" title="bug描述"></a>bug描述</h5><p>本次一共找出两个人共3个bug</p><p>用例和结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1 对常数求导处理有误 hack了1人</span></span><br><span class="line">in:--1837*-4816</span><br><span class="line">out:</span><br><span class="line"></span><br><span class="line">in:-6489+--595*x**8245*7592*-7893</span><br><span class="line">out:595*(+8245*x**8244*(7592*-7893)+x**8245*())</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">2 对表达式因子符号处理有误 hack了1人</span></span><br><span class="line">in:-(-x**-2-(-x**-2-(-x-(-x-(-x-sin(x))))))</span><br><span class="line">out:((0*(x)+1*(-1))+(0+((0*(x)+1*(-1))+(0+((0*(x)+1*(-1))+(0*(sin(x))+cos(x)*(-1)))))))</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">3 表达式因子求导错误 hack了1人</span></span><br><span class="line">in:--(+cos(x)**+4219*+7970+3497*-8451*x**8072*x)-+(+6179)</span><br><span class="line">out:(0+0)</span><br></pre></td></tr></table></figure><p>本次作业较上次作业主要增加的难度就在于表达式因子。需要格外注意表达式因子的<code>parse</code>和求导的符号输出。</p><h5 id="测试方式-1"><a href="#测试方式-1" class="headerlink" title="测试方式"></a>测试方式</h5><p>本次代码量太大且复杂，仍然采用了一定规模数据集测试+有针对性阅读代码的方式进行测试，仍然使用<code>python</code>评测机。</p><p>测试时将用例进行了分类，分为了多层表达式因子嵌套类，三角函数类，常数类，杂类。测试数据构造也采用递归下降的方式，简单来说也是<code>get a Expression--&gt;get many Items--&gt;get many Factors</code>这样的形式，对于每个因子采用正则表达式生成字母加上<code>python</code>随机数生成指数的方式。同时使用全局变量来记录调用<code>getExprFactor</code>方法的次数，以及在<code>getExpression</code>方法内通过判断当前字符串长度来决定是否直接返回当前字符串还是继续获得随机生成的项，同时生成数据时如果大于了长度限制就继续生成，直到长度小于等于50。用这两个方法就可以构造出符合第二次作业互测数据要求的数据点了。</p><p>对拍数据采用了官方给出的评测方式即在$[-10,10]$上随机生成$1000$个点将这些结果和<code>sympy</code>求导结果进行比对的方式，必须要全对才算这个点通过。</p><p>同时由于本次作业表达式较复杂，求导时间长，采用了多个点复用一组1000个点的数据的方式加快评测进度。同时每一组表达式的用例个数从之前的1000个降到了100个。</p><h3 id="第三次作业-1"><a href="#第三次作业-1" class="headerlink" title="第三次作业"></a>第三次作业</h3><h4 id="自己的bug-2"><a href="#自己的bug-2" class="headerlink" title="自己的bug"></a>自己的bug</h4><p>本次作业强测和互测中均未发现bug</p><h4 id="他人的bug-2"><a href="#他人的bug-2" class="headerlink" title="他人的bug"></a>他人的bug</h4><h5 id="bug描述-4"><a href="#bug描述-4" class="headerlink" title="bug描述"></a>bug描述</h5><p>找出了一个同学的一个bug</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1 输出的字符串中右括号未输出导致错误</span></span><br><span class="line">in:-((-cos((-sin(x)))*x+cos(85)**48*x*-25))</span><br><span class="line">out:(-x*sin((-sin(x)))*cos(x)-cos((-sin(x)))-25*cos(85)**48</span><br></pre></td></tr></table></figure><h5 id="测试方式-2"><a href="#测试方式-2" class="headerlink" title="测试方式"></a>测试方式</h5><p>本次测试方式与上次类似，只是修改了测试数据生成的程序，加入了对空白字符的生成以及三角嵌套的生成，同时针对这次作业与上次作业的主要不同点三角嵌套进行了重点生成，获得了三角多层嵌套数据，然而有些数据因为长度过长，实在无法缩减，最后没有成功hack到人。</p><h2 id="三、重构经历总结"><a href="#三、重构经历总结" class="headerlink" title="三、重构经历总结"></a>三、重构经历总结</h2><h3 id="第二次作业重构"><a href="#第二次作业重构" class="headerlink" title="第二次作业重构"></a>第二次作业重构</h3><h4 id="重构过程"><a href="#重构过程" class="headerlink" title="重构过程"></a>重构过程</h4><p>本单元主要在第二次作业开发时被迫重构了<strong>输入的解析方式</strong>和整个<strong>求导的数据结构和方法</strong>。</p><p>第一次作业时，由于表达式结构简单，笔者并没有考虑递归下降，表达式树这些方法，而是直接采用了字符串预处理和简单的项求导合并的方式。然而到了第二次作业，引入了表达式因子和三角函数，简单的正负号替换等预处理方式已经解决不了问题，而且对于表达式因子这样的嵌套求导规则并不能用简单的每项直接求导这样简单的方式了。</p><p>于是进行了重构，基本是整个项目<strong>推倒重来</strong>。</p><p>定义了因子的抽象类，以及各个具体的因子类。同时在<code>Expression</code>类中用递归下降的方式对表达式的输入进行了解析。</p><p>重构时曾经纠结过表达式树的结构问题，曾经在一个晚上想了很久二叉树应该如何建立，最终也没有想的很完善，考虑到二叉树建树和<strong>化简求导操作比较麻烦</strong>，在时间紧急的情况下，抛弃了二叉树，转而采用了<strong>多叉树</strong>的方式。而多叉树开始建立时已经到了周六上午，时间所剩无几，决定边做边思考，最终参考助教在讨论区的帖子，解析出了表达式，并利用多叉树进行了求导，效果还可以，1个上午就通过了中测。</p><h4 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h4><ul><li>一开始就要将之后的几次作业内容大概了解，知道最终需要做成什么样子，不要在一开始就随心所欲地设计一个简单的只符合该次要求的结构。</li><li>如果一开始并不明确之后会做成什么样子，那么应该对程序的各个部分进行解耦，比如本单元作业的字符串解析，求导，化简其实可以分属为三个部分，如果将每一部分都解开，之后重构或者增量开发时思路也会更清晰，效率也会更高。</li><li>对于一个需求，尽可能不要钻这个需求的空子寻求捷径去完成，而要寻求本质的一般性解决办法，比如本单元作业中的表达式解析，指导书中明确给出了符号形式化表达，目的就是在于提示我们使用一般化的方法对输入进行处理。</li><li>同时，重构时也不能要求过高，如果时间紧迫时，拿出一种现阶段最可行最好实现的方式进行实现就好。同时，最好边实践边思考，不要空想，有时候，做出来比做完美更重要，一定要把思路落实到纸上或者电脑上。</li></ul><h2 id="四、心得体会"><a href="#四、心得体会" class="headerlink" title="四、心得体会"></a>四、心得体会</h2><ul><li><p>本单元的作业着眼于表达式求导这个基本问题，从第一次的简单的幂函数求导延申到最后的幂函数和三角嵌套的求导，增量开发的过程中，涉及了一个软件从开发到测试到交付的各个环节，体验了重构，测试代码，bug修复等多个以后会经常遇到的环节，对于软件设计开发的流程有了一定的认识。</p></li><li><p>巩固了面向对象的基本知识，了解了常用的工厂模式，接口实现，层次化设计的方法，进一步加深了对于<code>java</code>语言的了解和掌握。同时，代码风格也由于<code>checkstyle</code>的介入越来越好。</p></li><li>增强了测试程序的编写能力，掌握了<code>multiprocessing/sympy/xeger/os</code>等常用库的使用方法和<code>java</code>文件的打包方式，了解了如何修改终端输出的颜色改善评测体验，已经可以熟练的使用<code>Python</code>搭建功能优良完善，架构清晰的评测机。</li><li>加深了对正则表达式的理解，学习到了如何使用递归下降来解析和生成输入数据。</li><li>增强了心理抗压能力，在面对ddl的压力时正确应对并解决困难后，心理更强大了。</li><li>磨炼了意志力，知道了不到最后一刻不放弃，多次OO互测在要放弃的时候用一个新的用例hack成功，只有不放弃，多尝试才有可能不断进步，不断收获新的惊喜和成果。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-OO-2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS-Lab0笔记</title>
      <link href="2021/03/10/OS-Lab0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/03/10/OS-Lab0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>OS课程Lab0学习笔记</p><a id="more"></a><h1 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h1><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><p>命令格式：<code>命令名 [选项] [参数]</code></p><p>Linux命令在系统中有两种类型：<code>内置Shell（外壳）命令</code>和<code>Linux命令</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf #删除所有文件</span><br></pre></td></tr></table></figure><h3 id="OS常用命令"><a href="#OS常用命令" class="headerlink" title="OS常用命令"></a>OS常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find ./ test.md #查找文件</span><br><span class="line">grep -r printf ./ #查找函数变量。。</span><br></pre></td></tr></table></figure><h3 id="vim常用命令"><a href="#vim常用命令" class="headerlink" title="vim常用命令"></a>vim常用命令</h3><p><img src="2021-03-10-OS-Lab0笔记/vim常用操作.jpg" style="zoom: 80%;" /></p><p>撤销重做：<code>u</code> <code>Ctrl+r</code></p><p>复制粘贴：<code>y</code> <code>p</code></p><p>剪切：<code>d</code></p><p>查找某个单词：<code>/word</code> 有多个则按n/N移到上一个或者下一个</p><p>查看某一行代码：<code>:n</code></p><p><strong>永久配置</strong>vim：在<code>~/.vimrc</code>文件中进行配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set nu</span><br><span class="line">set mouse=a</span><br><span class="line">set tabstop=2</span><br><span class="line">set tags=~/19373573-lab/tags</span><br></pre></td></tr></table></figure><h4 id="Ctags使用"><a href="#Ctags使用" class="headerlink" title="Ctags使用"></a>Ctags使用</h4><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><ol><li>首先，在项目根目录（例如 <code>19373573-lab</code>）下面建立索引，即在根目录下敲：<code>ctags -R *</code></li><li>在 vim 配置文件 <code>.vimrc</code> 里面加上这句话，告诉 vim 我们 tags 文件的位置：<code>set tags=~/19373573-lab/tags</code></li></ol><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><ul><li><p>光标放在某函数/变量上，<code>Ctrl+N</code>或者<code>Ctrl+P</code>进行代码补全。<code>Ctrl+]</code>进入代码的定义位置，<code>Ctrl+T</code>返回。</p></li><li><p>同时，<code>Ctrl+W+]</code>可以在新窗口打开其他代码。<code>Ctrl+W K</code>/<code>Ctrl+W J</code>在窗口间移动 <code>:q</code>退出窗口</p></li></ul><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">回退版本时常用</span></span><br><span class="line">git reset hashid --hard</span><br><span class="line">git checkout .</span><br><span class="line">git add . &amp;&amp; git commit -m "1" &amp;&amp; git push --force</span><br></pre></td></tr></table></figure><h2 id="运行小操作系统"><a href="#运行小操作系统" class="headerlink" title="运行小操作系统"></a>运行小操作系统</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/OSLAB/gxemul -E testmips -C R3000 -M 64 gxemul/vmlinux #直接运行</span><br><span class="line">/OSLAB/gxemul -E testmips -C R3000 -M 64 -V gxemul/vmlinux #调试</span><br></pre></td></tr></table></figure><p>由于OS实验经常需要使用<code>gexmul</code>模拟器，所以我直接写了一个<code>test</code>脚本封装这个指令，如下所示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash </span></span><br><span class="line">if [$1 = ''];then</span><br><span class="line">/OSLAB/gxemul -E testmips -C R3000 -M 64 gxemul/vmlinux</span><br><span class="line">else</span><br><span class="line">/OSLAB/gxemul -E testmips -C R3000 -M 64 -V gxemul/vmlinux</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="bash">breakpoint add addr (addr--&gt;usually <span class="keyword">function</span> name)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">continue</span> (<span class="built_in">continue</span> execute to next breakpoint)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">step n   (execute n steps asm code)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">lookup name|addr</span></span><br><span class="line"><span class="meta">#</span><span class="bash">dump addr</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">help</span> (get cmd <span class="built_in">help</span>)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">quit</span></span><br></pre></td></tr></table></figure><p>再给它加上权限<code>chmod +x test</code></p><p>就可以使用<code>./test</code> 直接运行操作系统</p><p>加一个任意的参数比如<code>./test 1</code>则进入调试模式</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-OS-2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OO-评测机搭建学习</title>
      <link href="2021/03/09/OO-%E8%AF%84%E6%B5%8B%E6%9C%BA%E6%90%AD%E5%BB%BA%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/03/09/OO-%E8%AF%84%E6%B5%8B%E6%9C%BA%E6%90%AD%E5%BB%BA%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>关于OO作业评测机搭建的探索</p><a id="more"></a><h3 id="将java项目打包成jar文件并运行"><a href="#将java项目打包成jar文件并运行" class="headerlink" title="将java项目打包成jar文件并运行"></a>将java项目打包成jar文件并运行</h3><h4 id="在IDEA中打包"><a href="#在IDEA中打包" class="headerlink" title="在IDEA中打包"></a>在IDEA中打包</h4><p><code>File-&gt;project structure</code></p><p>在弹窗最左侧选中 <code>Artifacts-&gt;&quot;+&quot;</code> ,选 <code>jar</code>，选择 <code>from modules with dependencies</code></p><p>此处需要注意两点：</p><ul><li>需要选择jar包默认运行的入口类</li><li>需要设置MANIFEST.MF的位置</li></ul><p>之后点<code>Build-&gt;Build Artifacts-&gt;在选项中点击build即可</code></p><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p><code>java -jar hello.jar</code></p><h3 id="生成数据—xeger"><a href="#生成数据—xeger" class="headerlink" title="生成数据—xeger"></a>生成数据—xeger</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xeger <span class="keyword">import</span> Xeger</span><br><span class="line">str=<span class="string">"你的正则表达式"</span></span><br><span class="line">x=Xeger(limit=<span class="number">10</span>) <span class="comment">#初始化，设置最大长度</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">x.xeger(str) <span class="comment">#循环生成字符串</span></span><br></pre></td></tr></table></figure><h3 id="驱动文件获得输出—subprocess"><a href="#驱动文件获得输出—subprocess" class="headerlink" title="驱动文件获得输出—subprocess"></a>驱动文件获得输出—subprocess</h3><p>最简单的就用<code>os.system(&quot;java 1.jar &lt;&lt; 1.txt &gt;&gt; out.txt&quot;)</code>的方式即可</p><h3 id="正确性判定—sympy"><a href="#正确性判定—sympy" class="headerlink" title="正确性判定—sympy"></a>正确性判定—sympy</h3><p>用到的<code>sympy</code>库函数有 <code>Symbol、diff、sympify</code></p><p>此外可能需要<code>eval</code>来去掉字符串的外围双引号</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-OO-2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OO-Pre-学习笔记</title>
      <link href="2021/03/08/OO-PRE-%E7%AC%94%E8%AE%B0/"/>
      <url>2021/03/08/OO-PRE-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>2021年OO的Pre部分学习笔记</p><a id="more"></a><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="gitlab维护代码"><a href="#gitlab维护代码" class="headerlink" title="gitlab维护代码"></a>gitlab维护代码</h3><h4 id="Command-line-instructions"><a href="#Command-line-instructions" class="headerlink" title="Command line instructions"></a>Command line instructions</h4><h5 id="Git-global-setup"><a href="#Git-global-setup" class="headerlink" title="Git global setup"></a>Git global setup</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name "冯张驰"</span><br><span class="line">git config --global user.email "19373573@buaa.edu.cn"</span><br></pre></td></tr></table></figure><h5 id="Create-a-new-repository"><a href="#Create-a-new-repository" class="headerlink" title="Create a new repository"></a>Create a new repository</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitlab.buaaoo.top/oo_homeworks_2021/仓库名.git</span><br><span class="line">cd oo_2021_pre2_19373573_pre2_task2</span><br><span class="line">touch README.md</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m "add README"</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h5 id="Existing-folder"><a href="#Existing-folder" class="headerlink" title="Existing folder"></a>Existing folder</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd existing_folder</span><br><span class="line">git init</span><br><span class="line">git remote add origin https://gitlab.buaaoo.top/oo_homeworks_2021/仓库名.git</span><br><span class="line">git add .</span><br><span class="line">git commit -m "Initial commit"</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h5 id="Existing-Git-repository"><a href="#Existing-Git-repository" class="headerlink" title="Existing Git repository"></a>Existing Git repository</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd existing_repo</span><br><span class="line">git remote rename origin old-origin</span><br><span class="line">git remote add origin https://gitlab.buaaoo.top/oo_homeworks_2021/仓库名.git</span><br><span class="line">git push -u origin --all</span><br><span class="line">git push -u origin --tags</span><br></pre></td></tr></table></figure><h4 id="补充-实验1git学习"><a href="#补充-实验1git学习" class="headerlink" title="补充-实验1git学习"></a>补充-实验1git学习</h4><h5 id="step-1-新建仓库"><a href="#step-1-新建仓库" class="headerlink" title="step 1 新建仓库"></a>step 1 新建仓库</h5><p>在本地新建一个空文件夹，在此目录下打开终端（bash/git bash/power shell/…）</p><p>输入</p><blockquote><p>git init</p></blockquote><p>从而得到一个新的<code>git</code>仓库</p><h5 id="step-2-关联远程仓库"><a href="#step-2-关联远程仓库" class="headerlink" title="step 2 关联远程仓库"></a>step 2 关联远程仓库</h5><p>目前为止，<code>step 1</code>建立的文件夹还是一个空文件夹，需要关联两个远程仓库，首先考虑第一个远程仓库</p><p>第一个远程仓库是课程组提供的远程公共仓库<code>share</code></p><blockquote><p>git remote add share git@gitlab.buaaoo.top:oo_2021_public/experiment/exp1_public.git</p></blockquote><h5 id="step-3-从远程仓库拉取文件"><a href="#step-3-从远程仓库拉取文件" class="headerlink" title="step 3 从远程仓库拉取文件"></a>step 3 从远程仓库拉取文件</h5><p>关联后可以从远程仓库拉取文件</p><p>执行命令</p><blockquote><p>git pull share master</p></blockquote><p>从<code>share</code>仓库的<code>master</code>分支下得到两个文件夹</p><h5 id="step-4-忽略不必要的文件"><a href="#step-4-忽略不必要的文件" class="headerlink" title="step 4 忽略不必要的文件"></a>step 4 忽略不必要的文件</h5><p>文件夹<code>share</code>中的内容是实现了<code>Comparable</code>接口并按序输出的例程，可以尝试跑通</p><p>文件夹<code>poly</code>中的内容是任务二中需要完善的程序，是需要提交的，而且实验要求，提交时<strong>忽略</strong><code>share</code>文件夹下的所有内容，故需要使用<code>.gitignore</code></p><p>在当前工作的<strong>根目录</strong>下新建文件<code>.gitignore</code></p><p>在其中写入</p><blockquote><p>share/*</p></blockquote><p>表示<code>push</code>时忽略子目录<code>share</code>下的所有文件</p><h5 id="step-5-删除暂存区文件"><a href="#step-5-删除暂存区文件" class="headerlink" title="step 5 删除暂存区文件"></a>step 5 删除暂存区文件</h5><p>为了保证<code>.gitignore</code>正常工作，需要删除暂存区的文件</p><blockquote><p>git rm —cached . -r</p></blockquote><h5 id="step-6-删除与远程仓库的关联"><a href="#step-6-删除与远程仓库的关联" class="headerlink" title="step 6 删除与远程仓库的关联"></a>step 6 删除与远程仓库的关联</h5><p>为了避免不必要的干扰，需要删除与远程仓库<code>share</code>的关联</p><blockquote><p>git remote remove share</p></blockquote><h5 id="step-7-关联个人实验1仓库，并尝试一次提交"><a href="#step-7-关联个人实验1仓库，并尝试一次提交" class="headerlink" title="step 7 关联个人实验1仓库，并尝试一次提交"></a>step 7 关联个人实验1仓库，并尝试一次提交</h5><blockquote><p>git remote add origin 你的个人实验1的远程仓库链接</p><p>git add .</p><p>git commit -m “anything you want to write”</p><p>git push -u origin master</p></blockquote><p>关联到远程仓库<code>origin</code>，并尝试提交</p><p>至此，任务一的内容已全部介绍完毕，如果按照上述步骤操作后得到预期结果（例如可以正常<code>pull</code>和<code>push</code> ，且<code>.gitignore</code>文件生效等），即可开始进行任务二，课程组会对你的<code>git</code>操作进行评判</p><h4 id="平时常用操作"><a href="#平时常用操作" class="headerlink" title="平时常用操作"></a>平时常用操作</h4><h5 id="在IDEA里使用git"><a href="#在IDEA里使用git" class="headerlink" title="在IDEA里使用git"></a>在IDEA里使用git</h5><p>点击工具栏的<code>VCS</code>，选择 <code>Import into Vision Control</code> 里的 <code>Create Git Repository</code></p><p>之后就可以在IDEA里完成 <code>commit</code> <code>push</code> 的操作了（右上角的对钩和绿色箭头），第一次 <code>push</code> 时可以设置远程仓库关联。还有<code>rollback</code>等操作</p><h5 id="一行shell代码完成更新提交"><a href="#一行shell代码完成更新提交" class="headerlink" title="一行shell代码完成更新提交"></a>一行shell代码完成更新提交</h5><h6 id="初次提交"><a href="#初次提交" class="headerlink" title="初次提交"></a>初次提交</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add . &amp;&amp; git commit -m "Initial commit" &amp;&amp; git push -u origin master</span><br></pre></td></tr></table></figure><h6 id="之后提交"><a href="#之后提交" class="headerlink" title="之后提交"></a>之后提交</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add . &amp;&amp; git commit -m &quot;Initial commit&quot; &amp;&amp; git push</span><br></pre></td></tr></table></figure><h5 id="代码回退"><a href="#代码回退" class="headerlink" title="代码回退"></a>代码回退</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git log #查看历史版本</span><br><span class="line">git reset --hard xxx #xxx为对应版本的hashcode </span><br><span class="line">git push origin HEAD --force #远程也更新为当前版本</span><br></pre></td></tr></table></figure><h5 id="一个项目配置多个远程源"><a href="#一个项目配置多个远程源" class="headerlink" title="一个项目配置多个远程源"></a>一个项目配置多个远程源</h5><p>更改源的名字</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rename origin task1</span><br></pre></td></tr></table></figure><p>一次性添加好所有 task 的 remote：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">projectName=<span class="string">"pre3"</span></span><br><span class="line">ID=19XXXXXX</span><br><span class="line">taskNum=6</span><br><span class="line"><span class="keyword">for</span> ((i=1;i&lt;=<span class="variable">$taskNum</span>;++i))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    git remote add task<span class="variable">$&#123;i&#125;</span> git@gitlab.buaaoo.top:oo_homeworks_2021/oo_2021_<span class="variable">$&#123;projectName&#125;</span>_<span class="variable">$&#123;ID&#125;</span>_<span class="variable">$&#123;projectName&#125;</span>_task<span class="variable">$&#123;i&#125;</span>.git</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>然后 push 的时候 specify 一下 push 到哪个 remote，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push task3 master</span><br></pre></td></tr></table></figure><p>如果某个 task 反复 push，可以将其设置为当前 branch 的 upstream：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u task3 master</span><br></pre></td></tr></table></figure><p>之后直接使用 <code>git push</code> 即可。</p><p>也可以在 IDEA 内直接进行 push 操作。选择 Git &gt; Push…，出现操作框。左侧显示你的 branch 和 commit，上面显示你要 push 的 remote 和 branch，点击可以选择具体要 push 的内容 / 具体要 push 到哪个 remote。</p><h3 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h3><h4 id="使用checkstyle"><a href="#使用checkstyle" class="headerlink" title="使用checkstyle"></a>使用checkstyle</h4><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>最简单的配置方式是直接在<code>Settings -&gt; Plugins</code> 里安装好</p><p>然后在 <code>New Projects Settings -&gt; Settings for New Projects</code>里导入<code>config.xml</code>文件或者选择自带的两种代码风格检查方式。（这个default的设置仅适用于2020版，<strong>IDEA 2018</strong> :  <code>File -&gt; Other Settings -&gt; Default Settings</code>  <strong>IDEA 2019</strong> :  <code>File -&gt; Other Settings -&gt; Settings for New Projects</code> ）</p><h5 id="平时使用"><a href="#平时使用" class="headerlink" title="平时使用"></a>平时使用</h5><p><code>鼠标右键 -&gt; Check Current File</code></p><p>或者点击左下角窗口里的<code>checkstyle</code>的按钮也可</p><h4 id="配置符合课程要求"><a href="#配置符合课程要求" class="headerlink" title="配置符合课程要求"></a>配置符合课程要求</h4><h5 id="设置不自动-import-xx"><a href="#设置不自动-import-xx" class="headerlink" title="设置不自动 import xx.*"></a>设置不自动 <code>import xx.*</code></h5><p><code>File -&gt; setting -&gt; Editor -&gt; Code Style -&gt; Java -&gt; Imports</code>设置两个count为大于100的数字</p><h3 id="评论区规范"><a href="#评论区规范" class="headerlink" title="评论区规范"></a>评论区规范</h3><h4 id="提问方式"><a href="#提问方式" class="headerlink" title="提问方式"></a>提问方式</h4><p>针对作业内容答疑区</p><ul><li>作业内容，请使用“【作业内容】”</li><li>评测要求，请使用“【评测要求】”</li></ul><p>针对公共讨论区</p><ul><li>课程规则，请使用“【课程规则】“</li><li>系统使用，请使用”【系统使用】“</li><li>技术交流，请使用”【技术交流】“</li></ul><h2 id="Pre2"><a href="#Pre2" class="headerlink" title="Pre2"></a>Pre2</h2><h3 id="task1"><a href="#task1" class="headerlink" title="task1"></a>task1</h3><p><strong>封装</strong>：是指隐藏对象的属性和实现细节（属性变量和内部方法用<code>private</code>修饰），仅对外提供公共访问⽅法 （访问方法使用<code>public</code>）。</p><h3 id="task2"><a href="#task2" class="headerlink" title="task2"></a>task2</h3><p>java<strong>常用容器</strong>：HashSet，HashMap，ArrayList</p><p>容器<strong>常用方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建</span></span><br><span class="line">ArrayList&lt;Bookset&gt; booksArrayList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">Bookset book = <span class="keyword">new</span> Bookset(name, price, num);</span><br><span class="line"><span class="comment">// 添加新元素</span></span><br><span class="line">booksArrayList.add(book);</span><br><span class="line"><span class="comment">// 判断是否存在</span></span><br><span class="line"><span class="keyword">if</span> (booksArrayList.contains(book)) &#123;</span><br><span class="line">    System.out.println(<span class="string">"We have it!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历所有元素</span></span><br><span class="line"><span class="keyword">for</span> (Bookset item : booksArrayList) &#123;</span><br><span class="line">    System.out.println(item.getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出容器规模</span></span><br><span class="line">System.out.println(booksArrayList.size());</span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">booksArrayList.remove(book);</span><br></pre></td></tr></table></figure><p>主要的坑在 <code>BigDecimal</code> <code>BigInteger</code> 类的使用上</p><p>需要用 <code>BigDecimal ans = BigDecimal.valueOf(price);</code> 这样的方式来维持精度，如果直接用 <code>BigDecimal(price)</code> 会丢失精度</p><h3 id="task3"><a href="#task3" class="headerlink" title="task3"></a>task3</h3><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>参考菜鸟教程<a href="https://www.runoob.com/design-pattern/factory-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/factory-pattern.html</a></p><p>步骤如下</p><h5 id="1-创建一个接口"><a href="#1-创建一个接口" class="headerlink" title="1.创建一个接口"></a>1.创建一个接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-创建实体类"><a href="#2-创建实体类" class="headerlink" title="2.创建实体类"></a>2.创建实体类</h5><p>注意实体类是可以使用接口的方法去<strong>调用类内的属性值</strong>的</p><p>同时可以认为这些实体类都是<strong>Shape</strong>类型的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(a);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookFace</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getType</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getNum</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getOutput</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bookset</span> <span class="keyword">implements</span> <span class="title">BookFace</span> </span>&#123;</span><br><span class="line"><span class="comment">//定义各个变量</span></span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> num;   </span><br><span class="line">    <span class="keyword">private</span> String output; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bookset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        init(); <span class="comment">//调用init函数进行初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重写各个方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookShape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bookset <span class="title">getShape</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"Other"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Bookset();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"OtherA"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> OtherA();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"Novel"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Novel();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"Poetry"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Poetry();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"OtherS"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> OtherS();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"Math"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Math1();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"Computer"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Computer();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BookFace book = BookShape.getShape(type);</span><br></pre></td></tr></table></figure><p>同时也可以对一个实体类进行继承，子类也是实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">child</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(a);</span><br><span class="line">      System.out.println(b);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-创建工厂，生成指定类型对象"><a href="#3-创建工厂，生成指定类型对象" class="headerlink" title="3.创建工厂，生成指定类型对象"></a>3.创建工厂，生成指定类型对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">   <span class="comment">//使用 getShape 方法获取形状类型的对象</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(shapeType == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;        </span><br><span class="line">      <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"RECTANGLE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"child"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> child();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-使用该工厂，通过传递类型信息来获取实体类的对象。"><a href="#4-使用该工厂，通过传递类型信息来获取实体类的对象。" class="headerlink" title="4.使用该工厂，通过传递类型信息来获取实体类的对象。"></a>4.使用该工厂，通过传递类型信息来获取实体类的对象。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ShapeFactory factory = <span class="keyword">new</span> ShapeFactory();</span><br><span class="line">Shape a = factory.getShape(<span class="string">"RECTANGLE"</span>);</span><br><span class="line">a.draw();</span><br></pre></td></tr></table></figure><h3 id="task4"><a href="#task4" class="headerlink" title="task4"></a>task4</h3><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>我写这里的时候用了比较拉跨的<code>if else</code>写法，不展示了，参考Roife的博客，记录一下怎么写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> exceptions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BooksetExistedException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BooksetExistedException</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"Oh, no! The "</span> + name + <span class="string">" exist."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> exceptions.BooksetExistedException;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    bookshelves.get(i).addNewBookset(bookset);</span><br><span class="line">&#125; <span class="keyword">catch</span> (BooksetExistedException e) &#123;</span><br><span class="line">    System.out.println(e.getMessage());</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123; <span class="comment">// 想想为啥要放在 finally 里面</span></span><br><span class="line">    scanner.nextLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="task5"><a href="#task5" class="headerlink" title="task5"></a>task5</h3><h4 id="clone和equals方法"><a href="#clone和equals方法" class="headerlink" title="clone和equals方法"></a>clone和equals方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getClass() != obj.getClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        BookFace other = (BookFace) obj;</span><br><span class="line">        <span class="comment">//其他比较逻辑</span></span><br><span class="line">        <span class="keyword">if</span>(other.a==<span class="keyword">this</span>.a) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>() &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于基本类型可以直接继承主类方法即可，String是不可变类型</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BookFace <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pre3"><a href="#Pre3" class="headerlink" title="Pre3"></a>Pre3</h2><p>正则表达式菜鸟教程：<a href="https://www.runoob.com/regexp/regexp-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/regexp/regexp-tutorial.html</a></p><p>java正则表达式用法：<a href="https://www.runoob.com/java/java-regular-expressions.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-regular-expressions.html</a></p><p>一篇补充的博客：<a href="https://blog.csdn.net/baidu_28289725/article/details/80414445" target="_blank" rel="noopener">https://blog.csdn.net/baidu_28289725/article/details/80414445</a></p><h2 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h2><p><a href="https://blog.csdn.net/asdx1020/article/details/104956074" target="_blank" rel="noopener">https://blog.csdn.net/asdx1020/article/details/104956074</a></p><p><a href="https://blog.csdn.net/asdx1020/article/details/104870918" target="_blank" rel="noopener">https://blog.csdn.net/asdx1020/article/details/104870918</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> BUAA-OO-2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端-jquery学习笔记</title>
      <link href="2021/03/03/%E5%89%8D%E7%AB%AF-jquery%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/03/03/%E5%89%8D%E7%AB%AF-jquery%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>javascript学习笔记</title>
      <link href="2021/03/02/%E5%89%8D%E7%AB%AF-javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/03/02/%E5%89%8D%E7%AB%AF-javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>前端的javascript资源整理和学习笔记</p><a id="more"></a><h2 id="资源整理"><a href="#资源整理" class="headerlink" title="资源整理"></a>资源整理</h2><h3 id="菜鸟教程"><a href="#菜鸟教程" class="headerlink" title="菜鸟教程"></a>菜鸟教程</h3><p><a href="https://www.runoob.com/js/js-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/js/js-tutorial.html</a></p><h3 id="w3school"><a href="#w3school" class="headerlink" title="w3school"></a>w3school</h3><p><a href="https://www.w3school.com.cn/js/index.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/js/index.asp</a></p><h2 id="慕课网教程笔记"><a href="#慕课网教程笔记" class="headerlink" title="慕课网教程笔记"></a>慕课网教程笔记</h2><p>教程网站：</p><p><a href="https://www.imooc.com/learn/36" target="_blank" rel="noopener">https://www.imooc.com/learn/36</a>  入门篇—对应本部分1-3</p><p><a href="https://www.imooc.com/learn/10" target="_blank" rel="noopener">https://www.imooc.com/learn/10</a>  进阶篇—对应本部分4-8</p><h3 id="1-入门"><a href="#1-入门" class="headerlink" title="1.入门"></a>1.入门</h3><h4 id="引入JS"><a href="#引入JS" class="headerlink" title="引入JS"></a>引入JS</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.插入<span class="selector-tag">JS</span></span><br><span class="line">&lt;script type="text/javascript"&gt;表示:</span><br><span class="line">在&lt;script&gt;&lt;/script&gt;之间的是文本类型(text)</span><br><span class="line"><span class="selector-tag">javascript</span>是为了告诉浏览器里面的文本是属于<span class="selector-tag">JavaScript</span>语言</span><br><span class="line"></span><br><span class="line">&lt;script type="text/javascript"&gt;</span><br><span class="line"><span class="selector-tag">document</span><span class="selector-class">.write</span>("开启<span class="selector-tag">JS</span>之旅!"); </span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">2.外部引用 使用<span class="selector-tag">src</span></span><br><span class="line">&lt;script src="script.js"&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">3.页面中位置</span><br><span class="line">一般放在<span class="selector-tag">head</span>或<span class="selector-tag">body</span>部分</span><br><span class="line">放在&lt;<span class="selector-tag">head</span>&gt;部分:</span><br><span class="line">最常用的方式是在页面中<span class="selector-tag">head</span>部分放置&lt;<span class="selector-tag">script</span>&gt;元素，浏览器解析<span class="selector-tag">head</span>部分就会执行这个代码，然后才解析页面的其余部分。</span><br><span class="line">放在&lt;<span class="selector-tag">body</span>&gt;部分:</span><br><span class="line"><span class="selector-tag">JavaScript</span>代码在网页读取到该语句的时候就会执行。</span><br></pre></td></tr></table></figure><p>注意: javascript作为一种脚本语言<strong>可以放在html页面中任何位置</strong>，但是浏览器<strong>解释html</strong>时是<strong>按先后顺序</strong>的，所以前面的script就先被执行。比如进行<strong>页面显示初始化的js必须放在head里面</strong>，因为初始化都要求提前进行（如给页面body设置css等）；而如果是通过<strong>事件调用</strong>执行的function那么<strong>对位置没什么要求</strong>的。</p><h4 id="语句和符号"><a href="#语句和符号" class="headerlink" title="语句和符号"></a>语句和符号</h4><p>基本格式：<code>语句;</code> 分号也可不加</p><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行</span></span><br><span class="line"><span class="comment">/* 多行 */</span></span><br></pre></td></tr></table></figure><h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> b,c;</span><br><span class="line">a=<span class="number">1</span>;</span><br><span class="line">b=<span class="string">"abs"</span></span><br><span class="line">c=<span class="literal">true</span>;</span><br><span class="line">c=<span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h4 id="基本语句-和java、C一样"><a href="#基本语句-和java、C一样" class="headerlink" title="基本语句 和java、C一样"></a>基本语句 和java、C一样</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件)</span><br><span class="line">&#123; 条件成立时执行的代码 &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>()</span><br><span class="line">&#123; 条件不成立时执行的代码 &#125;</span><br><span class="line"><span class="keyword">else</span>&#123; &#125;</span><br><span class="line">还有<span class="keyword">do</span>...while/<span class="keyword">while</span>/<span class="keyword">for</span>/<span class="keyword">switch</span>-<span class="keyword">case</span></span><br></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     函数代码;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以有返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add2</span>(<span class="params">x,y</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   sum = x + y;</span><br><span class="line">   <span class="keyword">return</span> sum; <span class="comment">//返回函数值,return后面的值叫做返回值。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-常用互动方法"><a href="#2-常用互动方法" class="headerlink" title="2.常用互动方法"></a>2.常用互动方法</h3><h4 id="输出内容（document-write）"><a href="#输出内容（document-write）" class="headerlink" title="输出内容（document.write）"></a>输出内容（document.write）</h4><h5 id="第一种-输出内容用””括起，直接输出””号内的内容。"><a href="#第一种-输出内容用””括起，直接输出””号内的内容。" class="headerlink" title="第一种:输出内容用””括起，直接输出””号内的内容。"></a>第一种:输出内容用””括起，直接输出””号内的内容。</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type="text/javascript"&gt;</span><br><span class="line">  document.write("I love JavaScript！"); //内容用""括起来，""里的内容直接输出。</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h5 id="第二种-通过变量，输出内容"><a href="#第二种-通过变量，输出内容" class="headerlink" title="第二种:通过变量，输出内容"></a>第二种:通过变量，输出内容</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type="text/javascript"&gt;</span><br><span class="line">  var mystr="hello world!";</span><br><span class="line">  document.write(mystr);  //直接写变量名，输出变量存储的内容。</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h5 id="第三种-输出多项内容，内容之间用-号连接。"><a href="#第三种-输出多项内容，内容之间用-号连接。" class="headerlink" title="第三种:输出多项内容，内容之间用+号连接。"></a>第三种:输出多项内容，内容之间用+号连接。</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type="text/javascript"&gt;</span><br><span class="line">  var mystr="hello";</span><br><span class="line">  document.write(mystr+"I love JavaScript"); //多项内容之间用+号连接</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h5 id="第四种-输出HTML标签，并起作用，标签使用””括起来。"><a href="#第四种-输出HTML标签，并起作用，标签使用””括起来。" class="headerlink" title="第四种:输出HTML标签，并起作用，标签使用””括起来。"></a>第四种:输出HTML标签，并起作用，标签使用””括起来。</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type="text/javascript"&gt;</span><br><span class="line">  var mystr="hello";</span><br><span class="line">document.write(mystr+"&lt;br&gt;");//输出hello后，输出一个换行符</span><br><span class="line">  <span class="selector-tag">document</span><span class="selector-class">.write</span>("<span class="selector-tag">JavaScript</span>");</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>关于JS输出空格问题，请查看wiki中” <a href="http://www.imooc.com/wiki/view?pid=167" target="_blank" rel="noopener">JS如何输出空格</a> “</p><h4 id="警告（alert-消息对话框）"><a href="#警告（alert-消息对话框）" class="headerlink" title="警告（alert 消息对话框）"></a>警告（alert 消息对话框）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(字符串或变量);</span><br></pre></td></tr></table></figure><p><strong>注意</strong>:</p><ol><li>在点击对话框”确定”按钮前，不能进行任何其它操作。</li><li>消息对话框通常可以用于调试程序。</li><li>alert输出内容，可以是字符串或变量，与document.write 相似。</li></ol><h4 id="确认（confirm-消息对话框）"><a href="#确认（confirm-消息对话框）" class="headerlink" title="确认（confirm 消息对话框）"></a>确认（confirm 消息对话框）</h4><h5 id="语法"><a href="#语法" class="headerlink" title="语法:"></a>语法:</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">confirm(str);</span><br></pre></td></tr></table></figure><h5 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明:"></a>参数说明:</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str：在消息对话框中要显示的文本</span><br><span class="line">返回值: <span class="built_in">Boolean</span>值</span><br></pre></td></tr></table></figure><h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值:"></a>返回值:</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当用户点击<span class="string">"确定"</span>按钮时，返回<span class="literal">true</span></span><br><span class="line">当用户点击<span class="string">"取消"</span>按钮时，返回<span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>注1:</strong> 通过返回值可以判断用户点击了什么按钮</p><p><strong>注2</strong>: 消息对话框是排它的，即用户在点击对话框按钮前，不能进行任何其它操作。</p><h4 id="提问（prompt-消息对话框）"><a href="#提问（prompt-消息对话框）" class="headerlink" title="提问（prompt 消息对话框）"></a>提问（prompt 消息对话框）</h4><p>弹出消息对话框（包含一个<strong>确定按钮</strong>、<strong>取消按钮</strong>与一个<strong>文本输入框</strong>）。</p><h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法:"></a>语法:</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prompt(str1, str2);</span><br></pre></td></tr></table></figure><h5 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1: 要显示在消息对话框中的文本，不可修改</span><br><span class="line">str2：文本框中的内容，可以修改</span><br></pre></td></tr></table></figure><h5 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值:"></a>返回值:</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 点击确定按钮，文本框中的内容将作为函数返回值</span><br><span class="line"><span class="number">2.</span> 点击取消按钮，将返回<span class="literal">null</span></span><br></pre></td></tr></table></figure><h4 id="打开新窗口（window-open）"><a href="#打开新窗口（window-open）" class="headerlink" title="打开新窗口（window.open）"></a>打开新窗口（window.open）</h4><p>open() 方法可以查找一个已经存在或者新建的浏览器窗口。</p><p><strong>语法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.open([URL], [窗口名称], [参数字符串])</span><br></pre></td></tr></table></figure><p><strong>参数说明:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">URL：可选参数，在窗口中要显示网页的网址或路径。如果省略这个参数，或者它的值是空字符串，那么窗口就不显示任何文档。</span><br><span class="line">窗口名称：可选参数，被打开窗口的名称。</span><br><span class="line">    <span class="number">1.</span>该名称由字母、数字和下划线字符组成。</span><br><span class="line">    <span class="number">2.</span><span class="string">"_top"</span>、<span class="string">"_blank"</span>、<span class="string">"_self"</span>具有特殊意义的名称。</span><br><span class="line">       _blank：在新窗口显示目标网页</span><br><span class="line">       _self：在当前窗口显示目标网页</span><br><span class="line">       _top：框架网页中在上部窗口中显示目标网页</span><br><span class="line">    <span class="number">3.</span>相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。</span><br><span class="line">    <span class="number">4.n</span>ame 不能包含有空格。</span><br><span class="line">参数字符串：可选参数，设置窗口参数，各参数用逗号隔开。</span><br></pre></td></tr></table></figure><p><strong>参数表:</strong></p><p><strong><a href="http://img.mukewang.com/52e3677900013d6a05020261.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/52e3677900013d6a05020261.jpg" alt="img"></a></strong></p><p>例如:打开<a href="http://www.imooc.com网站，大小为300px" target="_blank" rel="noopener">http://www.imooc.com网站，大小为300px</a> * 200px，无菜单，无工具栏，无状态栏，有滚动条窗口：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type="text/javascript"&gt; window.open('http://www.imooc.com','_blank','width=300,height=200,menubar=no,toolbar=no, status=no,scrollbars=yes')</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type="text/javascript"&gt;</span><br><span class="line">  <span class="selector-tag">function</span> <span class="selector-tag">Wopen</span>()&#123;</span><br><span class="line">    window.open("http://www.imooc.com","_blank"); </span><br><span class="line">  &#125; </span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;input name="button" type="button" onClick="Wopen()" value="点击我，打开新窗口!" /&gt;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>运行结果考虑浏览器兼容问题。</p><h4 id="关闭窗口（window-close）"><a href="#关闭窗口（window-close）" class="headerlink" title="关闭窗口（window.close）"></a>关闭窗口（window.close）</h4><p><strong>用法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.close();   <span class="comment">//关闭本窗口</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;窗口对象&gt;.close();   <span class="comment">//关闭指定的窗口</span></span><br></pre></td></tr></table></figure><h3 id="3-DOM操作"><a href="#3-DOM操作" class="headerlink" title="3.DOM操作"></a>3.DOM操作</h3><h4 id="DOM介绍"><a href="#DOM介绍" class="headerlink" title="DOM介绍"></a>DOM介绍</h4><p>文档对象模型<strong>DOM</strong>（Document Object Model）定义访问和处理HTML文档的标准方法。</p><p>DOM 将HTML文档呈现为<strong>带有元素、属性和文本</strong>的<strong>树结构</strong>（<strong>节点树</strong>）。</p><h4 id="通过ID获取元素"><a href="#通过ID获取元素" class="headerlink" title="通过ID获取元素"></a>通过ID获取元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mychar= <span class="built_in">document</span>.getElementById(<span class="string">"con"</span>);</span><br></pre></td></tr></table></figure><p>注:获取的元素是一个对象，如想对元素进行操作，我们要通过它的属性或方法。</p><h4 id="innerHTML-属性"><a href="#innerHTML-属性" class="headerlink" title="innerHTML 属性"></a>innerHTML 属性</h4><p>用于获取或替换 HTML 元素的内容</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type="text/javascript"&gt;</span><br><span class="line">  var mychar=document.getElementById("con");</span><br><span class="line">  mychar.innerHTML="hello world!"; //利用innerHTML属性修改标签内容</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="改变-HTML-样式"><a href="#改变-HTML-样式" class="headerlink" title="改变 HTML 样式"></a>改变 HTML 样式</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.style.property=new style;</span><br><span class="line">var mychar = document.getElementById("pcon");</span><br><span class="line">mychar.style.color="red";</span><br><span class="line">mychar.style.fontSize="20";</span><br></pre></td></tr></table></figure><p><strong>注意:</strong>Object是获取的元素对象，如通过document.getElementById(“id”)获取的元素。</p><p><strong>基本属性表（property）:</strong></p><p><strong><a href="http://img.mukewang.com/52e4d4240001dd6c04850229.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/52e4d4240001dd6c04850229.jpg" alt="img"></a></strong></p><p><strong>注意:</strong>该表只是一小部分CSS样式属性，其它样式也可以通过该方法设置和修改。</p><h4 id="显示和隐藏（display属性）"><a href="#显示和隐藏（display属性）" class="headerlink" title="显示和隐藏（display属性）"></a>显示和隐藏（display属性）</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.style.display = value</span><br></pre></td></tr></table></figure><h5 id="value取值"><a href="#value取值" class="headerlink" title="value取值:"></a>value取值:</h5><p><strong><a href="http://img.mukewang.com/52e4dba5000179da04110095.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/52e4dba5000179da04110095.jpg" alt="img"></a></strong></p><h4 id="控制类名（className-属性）"><a href="#控制类名（className-属性）" class="headerlink" title="控制类名（className 属性）"></a>控制类名（className 属性）</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object.className = classname</span><br></pre></td></tr></table></figure><h4 id="本章思路小结"><a href="#本章思路小结" class="headerlink" title="本章思路小结"></a>本章思路小结</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">a[document.getElementById方法通过ID获取元素-即DOM对象]--&gt;b[修改对象的属性]</span><br><span class="line">b--&gt;c[Object.innerHTML改变代码]</span><br><span class="line">b--&gt;d[Object.style.property改变样式]</span><br><span class="line">b--&gt;e[Object.display改变隐藏与否]</span><br><span class="line">b--&gt;f[Object.classname改变类名]</span><br></pre></td></tr></table></figure><h3 id="4-数组"><a href="#4-数组" class="headerlink" title="4.数组"></a>4.数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myarray=<span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">//创建 括号内可以设置个数</span></span><br><span class="line"><span class="keyword">var</span> myarray = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">66</span>,<span class="number">80</span>,<span class="number">90</span>,<span class="number">77</span>,<span class="number">59</span>);<span class="comment">//创建数组同时赋值</span></span><br><span class="line"><span class="keyword">var</span> myarray = [<span class="number">66</span>,<span class="number">80</span>,<span class="number">90</span>,<span class="number">77</span>,<span class="number">59</span>];<span class="comment">//直接输入一个数组（称 “字面量数组”）</span></span><br><span class="line"><span class="comment">//数组存储的数据可以是任何类型（数字、字符、布尔值等）</span></span><br><span class="line">myarray[<span class="number">5</span>]=<span class="number">88</span>; <span class="comment">//使用一个新索引，为数组增加一个新元素</span></span><br><span class="line">myarray.length; <span class="comment">//获得数组myarray的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二维数组的定义方法一</span></span><br><span class="line"><span class="keyword">var</span> myarr=<span class="keyword">new</span> <span class="built_in">Array</span>();  <span class="comment">//先声明一维 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;   <span class="comment">//一维长度为2</span></span><br><span class="line">   myarr[i]=<span class="keyword">new</span> <span class="built_in">Array</span>();  <span class="comment">//再声明二维 </span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;   <span class="comment">//二维长度为3</span></span><br><span class="line">   myarr[i][j]=i+j;   <span class="comment">// 赋值，每个数组元素的值为i+j</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//二维数组的定义方法二</span></span><br><span class="line"><span class="keyword">var</span> Myarr = [[<span class="number">0</span> , <span class="number">1</span> , <span class="number">2</span> ],[<span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span>]]</span><br></pre></td></tr></table></figure><h3 id="5-事件响应"><a href="#5-事件响应" class="headerlink" title="5.事件响应"></a>5.事件响应</h3><p>事件是<strong>可以被 JavaScript 侦测到的行为</strong>。 网页中的每个元素都可以产生某些可以触发 JavaScript 函数或程序的事件。</p><h5 id="主要事件表"><a href="#主要事件表" class="headerlink" title="主要事件表"></a>主要事件表</h5><p><a href="http://img.mukewang.com/53e198540001b66404860353.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/53e198540001b66404860353.jpg" alt="img"></a></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">form</span>&gt;</span><br><span class="line">&lt;input name="button" type="button" value="点击提交" onclick="add2()" /&gt;</span><br><span class="line">&lt;input name="确定" type="button" value="确定" onmouseover="add()"/&gt; </span><br><span class="line">&lt;a href="http://www.imooc.com" onmouseout="message()"&gt;点击我&lt;/a&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>onfocus和onblur是相对于一个区域的焦点说的</p><h5 id="加载事件（onload）"><a href="#加载事件（onload）" class="headerlink" title="加载事件（onload）"></a>加载事件（onload）</h5><p>事件会在页面加载完成后，立即发生，同时执行被调用的程序。</p><p>注意：加载页面时，触发onload事件，事件写在<code>&lt;body&gt;</code>标签内。</p><h5 id="卸载事件（onunload）"><a href="#卸载事件（onunload）" class="headerlink" title="卸载事件（onunload）"></a>卸载事件（onunload）</h5><p>当用户退出页面时（页面关闭、页面刷新等），触发onUnload事件，同时执行被调用的程序。</p><p>注意：不同浏览器对onunload事件支持不同。</p><h3 id="6-JS内置对象"><a href="#6-JS内置对象" class="headerlink" title="6.JS内置对象"></a>6.JS内置对象</h3><h4 id="Date日期对象"><a href="#Date日期对象" class="headerlink" title="Date日期对象"></a>Date日期对象</h4><p>定义一个时间对象 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Udate=<span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">/*使 Udate 成为日期对象，并且已有初始值：当前时间(当前电脑系统时间)。*/</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>:使用关键字new，Date()的首字母必须大写。 </p><p>如果要自定义初始值，可以用以下方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2012</span>, <span class="number">10</span>, <span class="number">1</span>);  <span class="comment">//2012年10月1日</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'Oct 1, 2012'</span>); <span class="comment">//2012年10月1日</span></span><br></pre></td></tr></table></figure><p>我们最好使用下面介绍的<strong>方法</strong>来严格定义时间。</p><p><strong>访问方法语法：</strong>“&lt;日期对象&gt;.&lt;方法&gt;”</p><p>Date对象中处理时间和日期的常用方法：</p><p><a href="http://img.mukewang.com/555c650d0001ae7b04180297.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/555c650d0001ae7b04180297.jpg" alt="img"></a></p><h4 id="String-字符串对象"><a href="#String-字符串对象" class="headerlink" title="String 字符串对象"></a>String 字符串对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"I Love Beijing"</span>;</span><br><span class="line">str=str.toUpperCase(); <span class="comment">//转换为大写字母 还有toLowerCase()</span></span><br><span class="line"><span class="keyword">var</span> len=str.length; <span class="comment">//获取长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取指定位置字符</span></span><br><span class="line">stringObject.charAt(index)</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回指定的字符串首次出现的位置</span></span><br><span class="line">stringObject.indexOf(substring, startpos)</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串分割split()</span></span><br><span class="line">stringObject.split(separator,limit) <span class="comment">//limit--&gt;分割的最大次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提取字符串substring()</span></span><br><span class="line">stringObject.substring(startPos,stopPos) </span><br><span class="line"></span><br><span class="line"><span class="comment">//提取指定数目的字符substr()</span></span><br><span class="line">stringObject.substr(startPos,length) <span class="comment">//提取从 startPos位置开始的指定数目的字符串。</span></span><br></pre></td></tr></table></figure><h4 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h4><p>Math 对象是一个<strong>固有的对象</strong>，<strong>无需创建它</strong>，<strong>直接</strong>把 Math <strong>作为对象使用</strong>就<strong>可以调用</strong>其所有属性和方法。这是它与Date,String对象的<strong>区别</strong>。</p><h5 id="常用的属性、方法"><a href="#常用的属性、方法" class="headerlink" title="常用的属性、方法"></a>常用的属性、方法</h5><p>属性：<code>Math.PI</code></p><p>方法：<code>Math.ceil()</code> (向上取整)  <code>Math.floor()</code> (向下取整) <code>Math.round()</code> (四舍五入)  <code>Math.random()</code> (随机数，返回一个$[0,1]$区间内的随机数)</p><h5 id="Math-对象属性"><a href="#Math-对象属性" class="headerlink" title="Math 对象属性"></a>Math 对象属性</h5><p><a href="http://img.mukewang.com/532fe7cf0001e7b505170269.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/532fe7cf0001e7b505170269.jpg" alt="img"></a></p><h5 id="Math-对象方法"><a href="#Math-对象方法" class="headerlink" title="Math 对象方法"></a>Math 对象方法</h5><p><a href="http://img.mukewang.com/532fe841000174db05160622.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/532fe841000174db05160622.jpg" alt="img"></a></p><h4 id="Array-数组对象"><a href="#Array-数组对象" class="headerlink" title="Array 数组对象"></a>Array 数组对象</h4><h5 id="数组定义的方法"><a href="#数组定义的方法" class="headerlink" title="数组定义的方法"></a>数组定义的方法</h5><p>1.定义了一个空数组:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组名= <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br></pre></td></tr></table></figure><p>2.定义时指定有n个空元素的数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组名 =<span class="keyword">new</span> <span class="built_in">Array</span>(n);</span><br></pre></td></tr></table></figure><p>3.定义数组的时候，直接初始化数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组名 = [&lt;元素<span class="number">1</span>&gt;, &lt;元素<span class="number">2</span>&gt;, &lt;元素<span class="number">3</span>&gt;...];</span><br></pre></td></tr></table></figure><p>我们定义myArray数组，并赋值，<strong>代码如下：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray = [<span class="number">2</span>, <span class="number">8</span>, <span class="number">6</span>];</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>定义了一个数组 myArray，里边的元素是：<code>myArray[0] = 2; myArray[1] = 8; myArray[2] = 6。</code></p><h5 id="数组元素使用"><a href="#数组元素使用" class="headerlink" title="数组元素使用"></a>数组元素使用</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名[下标] = 值;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>: 数组的下标用方括号括起来，从0开始。</p><h5 id="数组属性"><a href="#数组属性" class="headerlink" title="数组属性"></a>数组属性</h5><p>length 用法：&lt;数组对象&gt;.length；返回：数组的长度，即数组里有多少个元素。它等于数组里最后一个元素的下标加一。</p><h5 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h5><p><a href="http://img.mukewang.com/533295ab0001dead05190599.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/533295ab0001dead05190599.jpg" alt="img"></a></p><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><p><code>arrayObject.concat(array1,array2,...,arrayN)</code>  返回一个新数组，原数组不改变</p><p><code>arrayObject.join(分隔符)</code>  把数组中的<strong>所有元素放入一个字符串</strong>。元素是通过<strong>指定的分隔符</strong>进行<strong>分隔</strong>的。</p><p><code>arrayObject.reverse()</code>  颠倒数组中元素的顺序。原数组改变</p><p><code>arrayObject.slice(start,end)</code>  返回一个新的数组，包含从 start 到 end （<strong>不包括该元素</strong>）的 arrayObject 中的元素。类似<code>python</code>的切片</p><p><code>arrayObject.sort(方法函数)</code>  </p><p><strong>注意</strong>: 该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下： </p><p>  若返回值<strong>&lt;=-1</strong>，则表示 <strong>A</strong> 在排序后的序列中<strong>出现在 B 之前</strong>。<br>  若返回值<strong>&gt;-1 &amp;&amp; &lt;1</strong>，则表示 <strong>A 和 B</strong> 具有<strong>相同</strong>的排序顺序。<br>  若返回值<strong>&gt;=1</strong>，则表示 <strong>A</strong> 在排序后的序列中<strong>出现在 B 之后</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortNum</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line"> <span class="comment">//升序，如降序，把“a - b”改成“b - a”</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myarr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"80"</span>,<span class="string">"16"</span>,<span class="string">"50"</span>,<span class="string">"6"</span>,<span class="string">"100"</span>,<span class="string">"1"</span>);</span><br><span class="line"><span class="built_in">document</span>.write(myarr + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"><span class="built_in">document</span>.write(myarr.sort(sortNum));</span><br></pre></td></tr></table></figure><h3 id="7-window对象"><a href="#7-window对象" class="headerlink" title="7.window对象"></a>7.window对象</h3><p>window对象是BOM的核心，window对象指<strong>当前的浏览器窗口</strong>。</p><h4 id="window对象方法"><a href="#window对象方法" class="headerlink" title="window对象方法"></a>window对象方法</h4><p><strong><a href="http://img.mukewang.com/535483720001a54506670563.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/535483720001a54506670563.jpg" alt="img"></a></strong></p><h3 id="8-认识DOM"><a href="#8-认识DOM" class="headerlink" title="8.认识DOM"></a>8.认识DOM</h3><p>HTML文档可以说由节点构成的集合，DOM节点有:</p><p><strong>1.</strong> <strong>元素节点：</strong><code>&lt;html&gt;、&lt;body&gt;、&lt;p&gt;</code>等都是元素节点，即标签。</p><p><strong>2.</strong> <strong>文本节点:</strong>向用户展示的内容，如<code>&lt;li&gt;...&lt;/li&gt;</code>中的文本。</p><p><strong>3.</strong> <strong>属性节点:</strong>元素属性，如<code>&lt;a&gt;</code>标签的链接属性href=”<a href="http://www.imooc.com&quot;。" target="_blank" rel="noopener">http://www.imooc.com&quot;。</a></p><h5 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h5><p><a href="http://img.mukewang.com/5375c953000117ee05240129.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/5375c953000117ee05240129.jpg" alt="img"></a></p><h5 id="遍历节点树"><a href="#遍历节点树" class="headerlink" title="遍历节点树"></a>遍历节点树</h5><p><a href="http://img.mukewang.com/53f17a6400017d2905230219.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/53f17a6400017d2905230219.jpg" alt="img"></a></p><h5 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h5><p><a href="http://img.mukewang.com/538d29da000152db05360278.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/538d29da000152db05360278.jpg" alt="img"></a></p><p><strong>注意:</strong>前两个是document方法。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>薛兆丰经济学讲义笔记</title>
      <link href="2021/02/28/%E8%96%9B%E5%85%86%E4%B8%B0%E7%BB%8F%E6%B5%8E%E5%AD%A6%E8%AE%B2%E4%B9%89%E7%AC%94%E8%AE%B0/"/>
      <url>2021/02/28/%E8%96%9B%E5%85%86%E4%B8%B0%E7%BB%8F%E6%B5%8E%E5%AD%A6%E8%AE%B2%E4%B9%89%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>阅读薛兆丰的《经济学讲义》的读书笔记</p><a id="more"></a><h1 id="前言-人类的四大约束"><a href="#前言-人类的四大约束" class="headerlink" title="前言 人类的四大约束"></a>前言 人类的四大约束</h1><p>人类的四大约束：东西不够，生命有限，互相依赖，需要协调</p><h1 id="第1章-稀缺—为何商业是最大的慈善"><a href="#第1章-稀缺—为何商业是最大的慈善" class="headerlink" title="第1章 稀缺—为何商业是最大的慈善"></a>第1章 稀缺—为何商业是最大的慈善</h1><h2 id="真实世界-经济学的视角"><a href="#真实世界-经济学的视角" class="headerlink" title="真实世界|经济学的视角"></a>真实世界|经济学的视角</h2><h3 id="1-战俘营里的经济组织"><a href="#1-战俘营里的经济组织" class="headerlink" title="1.战俘营里的经济组织"></a>1.战俘营里的经济组织</h3><p>二战德国战俘营里也产生了经济组织，有交易，有货币（香烟），有价格波动，有通胀紧缩</p><h3 id="2-马粪争夺案"><a href="#2-马粪争夺案" class="headerlink" title="2.马粪争夺案"></a>2.马粪争夺案</h3><p>鼓励人们创造财富，社会才会越变越好</p><p>本案中法官将公路上的马粪所有权最终判给了搬马粪的原告，从而鼓励了该地区的人民劳动积极性</p><p><strong>公正和公平</strong>的背后是<strong>效率</strong>考量，是对整体社会<strong>长远发展的效率</strong>的考量</p><h3 id="3-看得见的和看不见的"><a href="#3-看得见的和看不见的" class="headerlink" title="3.看得见的和看不见的"></a>3.看得见的和看不见的</h3><p><strong>破窗理论</strong>——有破坏才有进步</p><p>变种1：国家发展需要大的灾难</p><p>变种2：工人就业（机器取代工人，工人没有工作做）（机器取代工人，工人也不一定能找到新工作）</p><p>变种3：少用塑料袋</p><p>做决策时不仅要考虑到看的见的损失，也要考虑隐形的净损失（另一种方案或者情况也许有更大收益）</p><h3 id="4-区分愿望和结果"><a href="#4-区分愿望和结果" class="headerlink" title="4.区分愿望和结果"></a>4.区分愿望和结果</h3><p>现代经济学研究的是<strong>事与愿违</strong>的现象。</p><p>美好愿望不一定带来理想结果，坏人干坏事的影响也相对有限，好人好心不一定干好事。</p><p>比如：</p><ul><li><strong>最低工资制度</strong>本想保护穷人，但穷人仍然穷</li><li><strong>同工同酬制度</strong>本想保护弱势群体最后却伤害了他们</li><li><strong>福利制度</strong>让没有依靠的人更惨</li><li><strong>保护动物的法律</strong>让动物减少</li><li><strong>政府立法不是问题的终点</strong>，上有法律，下有对策。</li></ul><h2 id="人性观-人是理性和自私的吗"><a href="#人性观-人是理性和自私的吗" class="headerlink" title="人性观|人是理性和自私的吗"></a>人性观|人是理性和自私的吗</h2><h3 id="5-不确定性、进化与经济理论"><a href="#5-不确定性、进化与经济理论" class="headerlink" title="5.不确定性、进化与经济理论"></a>5.不确定性、进化与经济理论</h3><p><strong>阿曼阿尔钦</strong>的论文<strong>《不确定性、进化与经济理论》</strong>认为万物存活看条件，与理性与否无关。</p><p>经济学基础不是人是理性的，而是人应该如何存活。经济学关心的是<strong>存活的条件</strong>。</p><p>随着时代和条件变化，存活条件始终在变化，物竞天择，适者生存（进化论）。</p><h3 id="6-亚当斯密的人性观"><a href="#6-亚当斯密的人性观" class="headerlink" title="6.亚当斯密的人性观"></a>6.亚当斯密的人性观</h3><p>亚当斯密的《国富论》主张人是自私的，认为人在只追求自己福利同时，也会隐形地推动社会进步。他的《道德情操论》讲的是人应该有道德。</p><p>亚当斯密的观点如下：</p><ul><li>人性自私完全不自私甚至对自己自暴自弃的人得不到他人尊重</li><li>人不仅是自私的，也具有同情心和爱心</li><li><p>人的爱心有限，随着距离拉远而减弱</p></li><li><p>仅靠爱心不够，陌生人互助需要市场协调。我们让他人帮助自己往往需要说出唤起他们的利己心话。</p></li><li>人际互动二分法：小圈子靠爱心，大世界靠市场</li></ul><h3 id="7-铅笔的故事"><a href="#7-铅笔的故事" class="headerlink" title="7.铅笔的故事"></a>7.铅笔的故事</h3><p>《我，铅笔的故事》——伦纳德.里德</p><p>市场让很多互不认识不一样的人一起参与制作了铅笔</p><h3 id="8-商业是最大的慈善"><a href="#8-商业是最大的慈善" class="headerlink" title="8.商业是最大的慈善"></a>8.商业是最大的慈善</h3><p>世界银行扶贫失败；哈利波特商业奇迹，2005年7月16日英美两国将900万册哈6送到了读者手里。</p><p>两者透露出行善和商业这两个模式存在本质区别。</p><p>行善扶贫难见成效四大原因：</p><ul><li><strong>缺乏反馈机制</strong>。行善者不能确定自己的行善行为是否是正确有效的。</li><li><strong>委托代理问题</strong>。负责行善的人花的不是自己的钱，不认真。</li><li><strong>所托非人问题</strong>。将钱交给贫困根源的地方政府。</li><li><strong>养懒汉效应</strong>。持续扶贫造成人们的依赖和懒惰，人们甚至考虑如何保住贫困的帽子。</li></ul><p>商业行为由于市场协调机制和鼓励人们分工合作，大幅持续高效的改进了人们的福利。商业是大量陌生人给予的慈善，商业是最大的慈善。</p><h2 id="区别对待-选择的标准"><a href="#区别对待-选择的标准" class="headerlink" title="区别对待|选择的标准"></a>区别对待|选择的标准</h2><h3 id="9-稀缺"><a href="#9-稀缺" class="headerlink" title="9.稀缺"></a>9.稀缺</h3><p>经济学大厦应当建立在<strong>稀缺</strong>这个基础上。</p><p>稀缺的原因</p><ol><li>我们想要的东西别人也想要</li><li>人的需求在不断变化和升级，即人的欲望是无限的。</li></ol><h3 id="10-选择和歧视"><a href="#10-选择和歧视" class="headerlink" title="10.选择和歧视"></a>10.选择和歧视</h3><p><strong>稀缺</strong>，<strong>选择</strong>，<strong>区别对待</strong>，<strong>歧视</strong>四个概念融为一体，有了一个也有了其他三个。因此歧视不可避免</p><p>因为想消除歧视，而导致了<strong>逆向歧视</strong>。美国的白人在有些方面却因为不是黑人而得不到一些福利。</p><p>真正重要的是<strong>如何歧视</strong>。</p><h3 id="11-凡歧视必得付代价"><a href="#11-凡歧视必得付代价" class="headerlink" title="11.凡歧视必得付代价"></a>11.凡歧视必得付代价</h3><p>因为歧视（以偏概全）的认识成本最低，所以人很容易先入为主。</p><p>对人歧视越多，付出代价也越大。因为市场往往需要让人放下偏见，通力合作。</p><p><strong>市场竞争</strong>让人心胸宽广。偏远小镇的歧视比繁华的大都市严重很多。</p><h3 id="12-歧视的作用和限制歧视的恶果"><a href="#12-歧视的作用和限制歧视的恶果" class="headerlink" title="12.歧视的作用和限制歧视的恶果"></a>12.歧视的作用和限制歧视的恶果</h3><p>东南亚华人把当地人按照姓氏，方言，国籍分成7等，不同距离关系的人做生意条款不一样，这样反而使人生地不熟的他们得到了很好的发展。</p><p>20世纪初美国针对买房借贷的平权运动，最终导致政府强制银行多借贷，导致次贷危机。反歧视运动导致恶果。</p><p>说明某些歧视未必有害，可能是有效率的。</p><h1 id="第2章-成本—不要只盯着钱"><a href="#第2章-成本—不要只盯着钱" class="headerlink" title="第2章 成本—不要只盯着钱"></a>第2章 成本—不要只盯着钱</h1><h2 id="选择偏好-一句话给成本下定义"><a href="#选择偏好-一句话给成本下定义" class="headerlink" title="选择偏好|一句话给成本下定义"></a>选择偏好|一句话给成本下定义</h2><h3 id="13-一句话给成本下定义"><a href="#13-一句话给成本下定义" class="headerlink" title="13.一句话给成本下定义"></a>13.一句话给成本下定义</h3><p>采石场旁边买一块空地，防止有开发商开发房地产影响采石场。实际是采石场的消费者买下了这块地。</p><p>成本是放弃了的最大代价。即被选中的选项是所有放弃的选项中价值最高的。</p><p>沉没成本：已经发生不可收回的支出。——其实不是成本，因为已经没办法收回或放弃，成本是向前看的。</p><h3 id="14-你的成本由被人来决定"><a href="#14-你的成本由被人来决定" class="headerlink" title="14.你的成本由被人来决定"></a>14.你的成本由被人来决定</h3><p>负面的感受不是成本</p><p>你的成本由他人决定</p><p>你的职业范围由社会决定</p><h3 id="15-别只盯着钱"><a href="#15-别只盯着钱" class="headerlink" title="15.别只盯着钱"></a>15.别只盯着钱</h3><p>货币成本不等于全部成本，比如假货货币成本低，但是有维权成本。</p><p>志愿兵制优于义务征兵制（义务征兵看似成本低但是使得一些科学家等也变成了士兵）</p><p>中间商赚差价，让价格更便宜。因为中间商也要竞争，同时可以免去消费者的一些麻烦。</p><h2 id="资源的价值-重新理解盈利和亏损"><a href="#资源的价值-重新理解盈利和亏损" class="headerlink" title="资源的价值|重新理解盈利和亏损"></a>资源的价值|重新理解盈利和亏损</h2><h3 id="16-从成本角度理解盈利和亏损"><a href="#16-从成本角度理解盈利和亏损" class="headerlink" title="16.从成本角度理解盈利和亏损"></a>16.从成本角度理解盈利和亏损</h3><p>盈利是意外的，提升了资源使用的成本</p><p>亏损降低了资源使用成本</p><h3 id="17-最终产品的供需决定原材料的成本"><a href="#17-最终产品的供需决定原材料的成本" class="headerlink" title="17.最终产品的供需决定原材料的成本"></a>17.最终产品的供需决定原材料的成本</h3><p>关于产品价格的形成过程，有成本决定论和供需决定论。</p><p>成本决定价格肯定是错误的</p><p>供需关系决定商品价格，商品价格决定资源成本</p><h3 id="18-“租”是对资产的付费"><a href="#18-“租”是对资产的付费" class="headerlink" title="18.“租”是对资产的付费"></a>18.“租”是对资产的付费</h3><p>租，是对资产的付费</p><p>资产—能够带来收入的资源，含义很广，包括土地，矿山，人的才能，发明创造……</p><p>猫王成为歌星前当司机的收入为10万/年，成为歌星后收入为1000万，多出的990万即为租。因为即使他的收入降低100万，900万，他还是会当歌星。</p><p>政府安排的出租车牌有价—垄断带来的收入，也是租—垄断租</p><p>租是旱涝保收的收入</p><p>租看似是白赚的，但是如果本身不努力打理，租也会下降很多。</p><h3 id="19-寻租—乞丐没有白拿施舍"><a href="#19-寻租—乞丐没有白拿施舍" class="headerlink" title="19.寻租—乞丐没有白拿施舍"></a>19.寻租—乞丐没有白拿施舍</h3><p>寻租概念起源：贼没有减少社会总财富，但是增加了人们造锁的成本，消耗了资源。</p><p>政府管制下资源消耗：企业之间为了争夺政策福利付出代价，竞争成本造成的内耗超过了政策本身的价值。</p><p>乞丐之间也是通过竞争才可以拿到施舍，没有白拿。</p><p>寻找能够带来收入的资产，分为两类：一类是努力工作提升自我，增加了社会财富。另一类是内卷竞争，消耗社会财富，即寻租。</p><p>贫穷国家制度不合理，寻租行为非常普遍，所以相对贫穷。</p><h2 id="科斯定律-从社会成本看问题"><a href="#科斯定律-从社会成本看问题" class="headerlink" title="科斯定律|从社会成本看问题"></a>科斯定律|从社会成本看问题</h2><h3 id="20-社会成本问题"><a href="#20-社会成本问题" class="headerlink" title="20.社会成本问题"></a>20.社会成本问题</h3>]]></content>
      
      
      <categories>
          
          <category> Life Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经济管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows问题和解决方案、相应网站工具</title>
      <link href="2021/02/21/windows%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3/"/>
      <url>2021/02/21/windows%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>windows遇到的系统问题和对应解决方法积累。最近遇到了Powershell异常的问题，找了微软工程师没解决，最后自己在一个论坛上找到了类似的解决了，记录一下这次排坑经历，顺便以后积累一下其他常见问题。</p><a id="more"></a><h2 id="问题1-Powershell找不到驱动器"><a href="#问题1-Powershell找不到驱动器" class="headerlink" title="问题1 Powershell找不到驱动器"></a>问题1 Powershell找不到驱动器</h2><h3 id="问题起因和描述"><a href="#问题起因和描述" class="headerlink" title="问题起因和描述"></a>问题起因和描述</h3><p>最近装了很多编辑器，配置了很多环境变量，也删除更新了很多文件，于是再打开Powershell时便遇到了以下问题。</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/windows%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98//2.png" alt=""></p><p>导致Vscode也用不了</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/windows%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98//1.png" alt=""></p><p>于是去找了微软官网找相关人员咨询，还接受了上海的工程师的电话帮助。但是都没有解决。顺便提一下，有问题的确可以和微软官方联系，不管你的windows版本，都会给你完整的咨询服务。不仅有机器自动服务，还有客服人员，技术人员的咨询支持。</p><p>工程师说这个没有通用解决办法，于是给我提供了四条基本没用看着很可怕的方法：使用系统修复命令，更新系统，重装系统，尝试卸载一些最近装的软件。</p><p>之后又找到一篇博客是关于vscode遇到这个问题的<a href="https://blog.csdn.net/yys190418/article/details/103767720" target="_blank" rel="noopener">https://blog.csdn.net/yys190418/article/details/103767720</a></p><p>然而这个只是解决vscode中powershell用不了的小问题，对我的问题并不适用。</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>最后，终于在下面这个网站上找到了问题。<a href="https://superuser.com/questions/1021310/powershell-a-drive-c-does-not-exist" target="_blank" rel="noopener">https://superuser.com/questions/1021310/powershell-a-drive-c-does-not-exist</a></p><p>原来就是环境变量的锅，只要将Path中每个变量前面的 <code>.</code> 去掉即可！根据我的实践是每个都要删，不光是开头的 <code>.</code> 以后配置环境真的要小心谨慎了，这次真的吓人</p><p>即如下图所示</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/windows%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98//3.png" style="zoom:50%;" /></p><h2 id="网站工具"><a href="#网站工具" class="headerlink" title="网站工具"></a>网站工具</h2><h3 id="社区"><a href="#社区" class="headerlink" title="社区"></a>社区</h3><p><a href="https://superuser.com/" target="_blank" rel="noopener">https://superuser.com/</a>     貌似是在stackoverflow下属的一个机构的网站</p><p><a href="https://stackoverflow.com/" target="_blank" rel="noopener">https://stackoverflow.com/</a></p><h3 id="微软网站"><a href="#微软网站" class="headerlink" title="微软网站"></a>微软网站</h3><h4 id="联系微软"><a href="#联系微软" class="headerlink" title="联系微软"></a>联系微软</h4><p><a href="https://support.microsoft.com/zh-cn/contactus" target="_blank" rel="noopener">https://support.microsoft.com/zh-cn/contactus</a> </p><p><a href="https://support.microsoft.com/zh-cn/contact/virtual-agent/?flowId=smc-contactus-entitlement&amp;partnerId=smc&amp;referrer=www.microsoft.com" target="_blank" rel="noopener">https://support.microsoft.com/zh-cn/contact/virtual-agent/?flowId=smc-contactus-entitlement&amp;partnerId=smc&amp;referrer=www.microsoft.com</a> </p><h4 id="社区-1"><a href="#社区-1" class="headerlink" title="社区"></a>社区</h4><p><a href="https://answers.microsoft.com/zh-hans" target="_blank" rel="noopener">https://answers.microsoft.com/zh-hans</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模比赛总结</title>
      <link href="2021/02/12/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AC%94%E8%AE%B0/"/>
      <url>2021/02/12/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>关于已经参加的几次数学建模比赛的参赛总结。</p><a id="more"></a><h1 id="数学建模比赛总结与回顾"><a href="#数学建模比赛总结与回顾" class="headerlink" title="数学建模比赛总结与回顾"></a>数学建模比赛总结与回顾</h1><h2 id="比赛流程梳理"><a href="#比赛流程梳理" class="headerlink" title="比赛流程梳理"></a>比赛流程梳理</h2><h3 id="美赛"><a href="#美赛" class="headerlink" title="美赛"></a>美赛</h3><h4 id="第一天-数据处理分析与模型建立"><a href="#第一天-数据处理分析与模型建立" class="headerlink" title="第一天 数据处理分析与模型建立"></a>第一天 数据处理分析与模型建立</h4><ul><li><p>6-8点。拿到题目，全队<strong>自行读题审题</strong>，按照我们队的重点读A/C/D题（数据相关），对每道题用md写一点自己的分析总结并在<strong>至少1.5小时</strong>后讨论</p></li><li><p>8-10点。基本确定题目。</p><p>每个人迅速<strong>查阅相关资料</strong>，<strong>收集文献</strong>。</p><p>如果是C/D题则全队先各自思考对数据集理解，再一起讨论确定完整的数据处理模型。如果是A题，则先找好数据再讨论。需要确定的数据处理内容有以下几个：</p><ul><li><strong>数据清洗与预处理方式</strong>（如何处理异常值，残缺值，重复值，标准化方法等）。</li><li>对于<strong>每道题</strong>都先定义<strong>单独的数据集</strong>，包含这个题需要用到的所有数据。</li><li>确立整体数据集，即<strong>体现出各题之间联系</strong>的或者<strong>多题需要用到</strong>的多用数据集。常用于开头的引入和数据处理部分以及结尾的写信部分的写作。</li></ul></li><li><p>10-12点。<strong>查文献</strong>和<strong>数据处理</strong>以及做探索性数据分析（EDA）。</p></li><li>14-15点。数据处理基本结束，全队先自行思考建模同学的思路并做出自己的补充，之后全队交流。</li><li>15-16点。和指导老师交流，明确思路和方向。</li><li>16点-晚上。<ul><li>完成数据处理和初步可视化，写作论文的问题重述、背景介绍、数据处理部分。</li><li>根据建模同学的数学原理跑出至少前两个问的模型。</li><li>建模同学至少给出<strong>前三题</strong>的<strong>大致解法</strong>。</li></ul></li></ul><h4 id="第二天-模型完善与模型计算"><a href="#第二天-模型完善与模型计算" class="headerlink" title="第二天 模型完善与模型计算"></a>第二天 模型完善与模型计算</h4><ul><li>上午：跑完至少1题并顺便做相应可视化。</li><li>下午：跑完至少1题并顺便做相应可视化。建模同学大概把所有问题的模型建立完全，并对每道题的思路用中文表述，且确立符号表。</li><li>晚上：跑完至少1题并顺便做相应可视化。</li></ul><h4 id="第三天-模型跑完与可视化"><a href="#第三天-模型跑完与可视化" class="headerlink" title="第三天 模型跑完与可视化"></a>第三天 模型跑完与可视化</h4><ul><li>所有模型的代码全部跑完，并做相应的可视化整理。</li><li>论文的中文版完善以及前几部分的英文版敲定。</li><li>模型优化与调参，模型和结果最后完善。</li></ul><h4 id="第四天-可视化与论文写作"><a href="#第四天-可视化与论文写作" class="headerlink" title="第四天 可视化与论文写作"></a>第四天 可视化与论文写作</h4><ul><li>每人分工翻译几个部分，并直接打到overleaf上（包括图片、表格、公式），同时完成对应部分时进行补充的可视化。</li><li>晚上20点前尽量完成论文的撰写，并给老师看。</li><li>20点一直到第二天8点根据老师意见进行修改，需要可视化的继续作图，并不断打磨文字。</li><li>第五天早上8点前完成论文提交。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据科学 </tag>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>missingCourseForCsers_note_stanford</title>
      <link href="2021/02/12/missingCourseForCsers-note-stanford/"/>
      <url>2021/02/12/missingCourseForCsers-note-stanford/</url>
      
        <content type="html"><![CDATA[<p>关于一些CS必备工具使用的笔记，根据斯坦福的缺失的一课课程以及一些其他网络教程整理得来。</p><a id="more"></a><p><a href="https://missing-semester-cn.github.io/" target="_blank" rel="noopener">https://missing-semester-cn.github.io/</a></p><h2 id="一、shell脚本"><a href="#一、shell脚本" class="headerlink" title="一、shell脚本"></a>一、shell脚本</h2><p><code>Bourne Again SHell</code>——Bash</p><p>终端，文字接口，Shell</p><h3 id="使用shell执行程序"><a href="#使用shell执行程序" class="headerlink" title="使用shell执行程序"></a>使用shell执行程序</h3><p>如果执行的程序不是shell编程关键字，则咨询环境变量</p><p>shell使用空格分割命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">打开后看到的:</span></span><br><span class="line">muller:~$ #$表示不是root用户 muller--&gt;用户名下面的代码略去了用户名，只保留$后的</span><br><span class="line"><span class="meta">$</span><span class="bash"> date <span class="comment">#执行程序，打印当前时间</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> hello <span class="comment">#echo--&gt;打印函数 hello为参数 特殊字符(比如空格)可以用""、''将后面的参数括起来，也可以用转义字符</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$path</span> <span class="comment">#打印环境变量所在路径</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">which</span> <span class="built_in">echo</span> <span class="comment">#打印echo的环境变量路径</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /bin/<span class="built_in">echo</span> <span class="variable">$path</span> <span class="comment">#直接使用路径名执行echo程序</span></span></span><br></pre></td></tr></table></figure><h3 id="在shell中导航"><a href="#在shell中导航" class="headerlink" title="在shell中导航"></a>在shell中导航</h3><p><code>linux</code>系统中<code>/</code>开头的都是<strong>绝对路径</strong>。</p><p>命令后带<code>-</code>接受标记和选项</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">pwd</span> <span class="comment">#获取当前目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ../a <span class="comment">#cd 切换到上级目录中的a文件夹 .表示当前目录 ..表示上一级目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls <span class="comment">#查看目录下包含的文件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -<span class="built_in">help</span> <span class="comment">#或ls -h</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mv 1.txt a.txt <span class="comment">#重命名或移动文件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp 1.txt <span class="comment">#拷贝文件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir <span class="comment">#新建文件目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> man ls <span class="comment">#man获取ls的手册 使用q退出</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> touch 1.txt <span class="comment">#创建空文件</span></span></span><br></pre></td></tr></table></figure><h3 id="在程序间创建连接"><a href="#在程序间创建连接" class="headerlink" title="在程序间创建连接"></a>在程序间创建连接</h3><p>shell中有输入输出流</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> hello &gt; hello.txt <span class="comment">#最简单的重定向输出，如果不存在hello.txt文件则生成出来一个</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat hello txt <span class="comment">#获取文件内容</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat &lt; hello.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat &lt; hello.txt &gt; hello2.txt</span></span><br></pre></td></tr></table></figure><p>使用&gt;&gt;可以进行追加输出</p><p>根用户：<code>sudo</code> 命令开头，变为<code>root</code>用户</p><h3 id="变量，控制语句"><a href="#变量，控制语句" class="headerlink" title="变量，控制语句"></a>变量，控制语句</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> a=1 <span class="comment">#变量赋值</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'$a'</span> <span class="comment">#打印出 $a</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span>"</span> <span class="comment">#打印出a变量的值，即1</span></span></span><br></pre></td></tr></table></figure><p>以<strong><code>&#39;</code>定义</strong>的字符串为<strong>原义字符串</strong>，其中的变量不会被转义，而 <strong><code>&quot;</code>定义</strong>的字符串会<strong>将变量值进行替换</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mcd () &#123;</span><br><span class="line">    mkdir -p "$1"</span><br><span class="line">    cd "$1"</span><br><span class="line">&#125;  #函数定义</span><br></pre></td></tr></table></figure><ul><li><code>$0</code> - 脚本名</li><li><code>$1</code> 到 <code>$9</code> - 脚本的参数。 <code>$1</code> 是第一个参数，依此类推。</li><li><code>$@</code> - 所有参数</li><li><code>$#</code> - 参数个数</li><li><code>$?</code> - 前一个命令的返回值</li><li>$$$$ - 当前脚本的进程识别码</li><li><code>!!</code> - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 <code>sudo !!</code>再尝试一次。</li><li><code>$_</code> - 上一条命令的最后一个参数。如果你正在使用的是交互式shell，你可以通过按下 <code>Esc</code> 之后键入 . 来获取这个值。</li></ul><p>命令通常使用 <code>STDOUT</code>来返回输出值，使用<code>STDERR</code> 来返回错误及错误码</p><p><strong>返回值0</strong>表示<strong>正常执行</strong>，其他所有<strong>非0的返回值</strong>都表示<strong>有错误发生</strong>。</p><p>可以使用<code>false</code>和<code>true</code>以及<code>&amp;&amp;</code> <code>||</code>等逻辑表达式来作为条件，例如：<code>false || echo &quot;1234&quot;</code></p><h3 id="Shell工具"><a href="#Shell工具" class="headerlink" title="Shell工具"></a>Shell工具</h3><h4 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查找所有名称为src的文件夹</span></span><br><span class="line">find . -name src -type d</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找所有文件夹路径中包含<span class="built_in">test</span>的python文件</span></span><br><span class="line">find . -path '**/test/**/*.py' -type f</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找前一天修改的所有文件</span></span><br><span class="line">find . -mtime -1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找所有大小在500k至10M的tar.gz文件</span></span><br><span class="line">find . -size +500k -size -10M -name '*.tar.gz'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">对找到文件进行操作</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Delete all files with .tmp extension</span></span><br><span class="line">find . -name '*.tmp' -exec rm &#123;&#125; \;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Find all PNG files and convert them to JPG</span></span><br><span class="line">find . -name '*.png' -exec convert &#123;&#125; &#123;&#125;.jpg \;</span><br></pre></td></tr></table></figure><p><code>fd</code> <code>locate</code> 是另外两个查找工具</p><h4 id="查找代码"><a href="#查找代码" class="headerlink" title="查找代码"></a>查找代码</h4><p><code>grep</code> <code>ack</code> <code>ag</code> <code>rg</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查找所有使用了 requests 库的文件</span></span><br><span class="line">rg -t py 'import requests'</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找所有没有写 shebang 的文件（包含隐藏文件）</span></span><br><span class="line">rg -u --files-without-match "^#!"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找所有的foo字符串，并打印其之后的5行</span></span><br><span class="line">rg foo -A 5</span><br><span class="line"><span class="meta">#</span><span class="bash"> 打印匹配的统计信息（匹配的行和文件的数量）</span></span><br><span class="line">rg --stats PATTERN</span><br></pre></td></tr></table></figure><h4 id="查找shell命令"><a href="#查找shell命令" class="headerlink" title="查找shell命令"></a>查找shell命令</h4><p><code>history</code> 命令允许您以程序员的方式来访问shell中输入的历史命令</p><p>使用 <code>Ctrl+R</code> 对命令历史记录进行回溯搜索。可以配合 <a href="https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings#ctrl-r" target="_blank" rel="noopener"><code>fzf</code></a> 使用</p><h4 id="文件夹导航"><a href="#文件夹导航" class="headerlink" title="文件夹导航"></a>文件夹导航</h4><p>Fasd 基于 <a href="https://developer.mozilla.org/en/The_Places_frecency_algorithm" target="_blank" rel="noopener"><code>frecency</code></a> 对文件和文件排序，也就是说它会同时针对频率（frequency ）和时效（ recency）进行排序。</p><p>对于常用的目录，目录名子串前加入一个命令 <code>z</code> 就可以快速切换命令到该目录</p><p>还有一些更复杂的工具可以用来概览目录结构，例如 <a href="https://linux.die.net/man/1/tree" target="_blank" rel="noopener"><code>tree</code></a>, <a href="https://github.com/Canop/broot" target="_blank" rel="noopener"><code>broot</code></a> 或更加完整的文件管理器，例如 <a href="https://github.com/jarun/nnn" target="_blank" rel="noopener"><code>nnn</code></a> 或 <a href="https://github.com/ranger/ranger" target="_blank" rel="noopener"><code>ranger</code></a>。</p><h2 id="二、Vim编辑器"><a href="#二、Vim编辑器" class="headerlink" title="二、Vim编辑器"></a>二、Vim编辑器</h2><h3 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h3><ul><li>正常模式：在文件中四处移动光标进行修改（默认的模式）</li><li>插入模式：插入文本 </li><li>替换模式：替换文本</li><li>可视化（一般，行，块）模式：选中文本块</li><li>命令模式：用于执行命令</li></ul><p>按下 <code>&lt;ESC&gt;</code> （退出键） 从任何其他模式返回正常模式。 正常模式和插入模式是最常用的两个模式</p><h4 id="正常模式与各个模式切换"><a href="#正常模式与各个模式切换" class="headerlink" title="正常模式与各个模式切换"></a>正常模式与各个模式切换</h4><p>键入 <code>i</code> 进入插入 模式， <code>R</code> 进入替换模式</p><p> <code>v</code> 进入可视（一般）模式， <code>V</code> 进入可视（行）模式， <code>&lt;C-v&gt;</code> （Ctrl-V, 有时也写作 <code>^V</code>）进入可视（块）模式，</p><p> <code>:</code> 进入命令模式。</p><ul><li><code>:q</code> 退出 （关闭窗口）</li><li><code>:w</code> 保存 （写）</li><li><code>:wq</code> 保存然后退出</li><li><code>:e {文件名}</code> 打开要编辑的文件</li><li><code>:ls</code> 显示打开的缓存</li><li><code>:help {标题}</code>打开帮助文档<ul><li><code>:help :w</code> 打开 <code>:w</code> 命令的帮助文档</li><li><code>:help w</code> 打开 <code>w</code> 移动的帮助文档</li></ul></li></ul><h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><ul><li>基本移动: <code>hjkl</code> （左， 下， 上， 右）</li><li>词： <code>w</code> （下一个词）， <code>b</code> （词初）， <code>e</code> （词尾）</li><li>行： <code>0</code> （行初）， <code>^</code> （第一个非空格字符）， <code>$</code> （行尾）</li><li>屏幕： <code>H</code> （屏幕首行）， <code>M</code> （屏幕中间）， <code>L</code> （屏幕底部）</li><li>翻页： <code>Ctrl-u</code> （上翻）， <code>Ctrl-d</code> （下翻）</li><li>文件： <code>gg</code> （文件头）， <code>G</code> （文件尾）</li><li>行数： <code>:{行数}&lt;CR&gt;</code> 或者 <code>{行数}G</code> ({行数}为行数)</li><li>杂项： <code>%</code> （找到配对，比如括号或者 /<em> </em>/ 之类的注释对）</li><li>查找：<code>f{字符}</code> <code>t{字符}</code> <code>F{字符}</code> <code>T{字符}</code><ul><li>查找/到 向前/向后 在本行的{字符}</li><li><code>,</code> / <code>;</code> 用于导航匹配</li></ul></li><li>搜索: <code>/{正则表达式}</code>, <code>n</code> / <code>N</code> 用于导航匹配</li></ul><h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><ul><li><code>i</code>进入插入模式<ul><li>但是对于操纵/编辑文本，不单想用退格键完成</li></ul></li><li><code>O</code> / <code>o</code> 在之上/之下插入行</li><li><code>d{移动命令}</code> 删除 {移动命令}<ul><li>例如， <code>dw</code> 删除词, <code>d$</code> 删除到行尾, <code>d0</code> 删除到行头。</li></ul></li><li><code>c{移动命令}</code>改变 {移动命令}<ul><li>例如， <code>cw</code> 改变词</li><li>比如 <code>d{移动命令}</code> 再 <code>i</code></li></ul></li><li><code>x</code> 删除字符 （等同于 <code>dl</code>）</li><li><code>s</code> 替换字符 （等同于 <code>xi</code>）</li><li>可视化模式 + 操作<ul><li>选中文字, <code>d</code> 删除 或者 <code>c</code> 改变</li></ul></li><li><code>u</code> 撤销, <code>&lt;C-r&gt;</code> 重做</li><li><code>y</code> 复制 / “yank” （其他一些命令比如 <code>d</code> 也会复制）</li><li><code>p</code> 粘贴</li><li>更多值得学习的: 比如 <code>~</code> 改变字符的大小写</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据分析可视化笔记</title>
      <link href="2021/02/04/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AC%94%E8%AE%B0/"/>
      <url>2021/02/04/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>关于python数据科学相关的知识笔记</p><a id="more"></a><h1 id="Python数据分析可视化笔记"><a href="#Python数据分析可视化笔记" class="headerlink" title="Python数据分析可视化笔记"></a>Python数据分析可视化笔记</h1><h4 id="jupyter-lab好东西集合"><a href="#jupyter-lab好东西集合" class="headerlink" title="jupyter lab好东西集合"></a>jupyter lab好东西集合</h4><p><a href="https://www.cnblogs.com/feffery/p/13364668.html" target="_blank" rel="noopener">https://www.cnblogs.com/feffery/p/13364668.html</a></p><h2 id="pandas基本操作和概念"><a href="#pandas基本操作和概念" class="headerlink" title="pandas基本操作和概念"></a>pandas基本操作和概念</h2><p><code>DataFrame</code>对象单独取出一行即：<code>df.loc[0]</code>和一列<code>df[&quot;a&quot;]</code>都是<code>Series</code>对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> nunpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df.columns <span class="comment">#DataFrame对象所有表头值组成的列表</span></span><br><span class="line">df.index <span class="comment">#DataFrame对象所有索引组成的列表</span></span><br></pre></td></tr></table></figure><h3 id="创建DataFrame对象"><a href="#创建DataFrame对象" class="headerlink" title="创建DataFrame对象"></a>创建DataFrame对象</h3><p>最简单也最好用：根据两个列表创建</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">index=[i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>)]</span><br><span class="line">columns=[<span class="string">"a"</span>,<span class="string">"b"</span>]</span><br><span class="line">df=pd.DataFrame(index=index,columns=columns)</span><br><span class="line">l1=[i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>)]</span><br><span class="line">l2=[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">df[<span class="string">"a"</span>]=l1 <span class="comment">#直接用列表给df一列赋值</span></span><br><span class="line">df.loc[<span class="number">0</span>]=l2 <span class="comment">##直接用列表给df一行赋值</span></span><br></pre></td></tr></table></figure><h2 id="数据分析6步"><a href="#数据分析6步" class="headerlink" title="数据分析6步"></a>数据分析6步</h2><h3 id="一、读取数据"><a href="#一、读取数据" class="headerlink" title="一、读取数据"></a>一、读取数据</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">pd.read_excel(<span class="string">"1.xlsx"</span>,)</span><br><span class="line">pd.read_csv(<span class="string">"1.csv"</span>)</span><br><span class="line"><span class="comment">#查询用法</span></span><br><span class="line">pd.read_excel?</span><br><span class="line">pd.*read*?</span><br></pre></td></tr></table></figure><h3 id="二、清洗数据"><a href="#二、清洗数据" class="headerlink" title="二、清洗数据"></a>二、清洗数据</h3><h4 id="查找异常"><a href="#查找异常" class="headerlink" title="查找异常"></a>查找异常</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置最多显示十行</span></span><br><span class="line">pd.set_option(<span class="string">'max_rows'</span>, <span class="number">10</span>) </span><br><span class="line"><span class="comment">#查找异常</span></span><br><span class="line">df[df[<span class="string">"a"</span>].isnull()]</span><br><span class="line"><span class="comment">#查找完全重复的行</span></span><br><span class="line">df[df.duplicated()]</span><br><span class="line"><span class="comment"># 查找某⼀列重复的⾏</span></span><br><span class="line">df[df.编号.duplicated()]</span><br><span class="line"><span class="comment"># 查找a属性的所有唯⼀值</span></span><br><span class="line">df.a.unique()</span><br><span class="line"><span class="comment"># 查找a包含 30 的异常值</span></span><br><span class="line">df[df.a.isin([<span class="string">'30'</span>])]</span><br><span class="line"><span class="comment">#字符换匹配</span></span><br><span class="line">df[df.a.str.contains(<span class="string">"abc"</span>,na=<span class="literal">False</span>)]</span><br><span class="line"><span class="comment"># 查找a列值在1到5之间的⾏</span></span><br><span class="line">df[df.a.between(<span class="number">1</span>, <span class="number">5</span>)]</span><br><span class="line"><span class="comment">#逻辑运算</span></span><br><span class="line">df[(df.a &gt;= <span class="number">1</span>) &amp; (df.b &lt;= <span class="number">5</span>)]</span><br></pre></td></tr></table></figure><h4 id="排除重复"><a href="#排除重复" class="headerlink" title="排除重复"></a>排除重复</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df.drop_duplicates()</span><br><span class="line">df.drop_duplicates(inplace=<span class="literal">True</span>) <span class="comment">#直接改变原数据</span></span><br><span class="line">df.drop_duplicates([<span class="string">'a'</span>]) <span class="comment"># 按某⼀列排除重复，默认保留第⼀⾏ keep='last'--&gt;删除最后一行</span></span><br></pre></td></tr></table></figure><h4 id="删除缺失值"><a href="#删除缺失值" class="headerlink" title="删除缺失值"></a>删除缺失值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">color.dropna()</span><br><span class="line">color.dropna(how=<span class="string">'all'</span>) <span class="comment"># 删除全部为空的⾏</span></span><br><span class="line">color.dropna(axis=<span class="number">1</span>) <span class="comment"># 删除包含缺失值的列</span></span><br></pre></td></tr></table></figure><h4 id="补全缺失值"><a href="#补全缺失值" class="headerlink" title="补全缺失值"></a>补全缺失值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df.fillna(<span class="string">'a'</span>) <span class="comment">#所有缺失处补上"a" 实际工作时常补上0</span></span><br><span class="line">df.fillna(method=<span class="string">'bfill'</span>) <span class="comment">#⽤后⾯的值填充</span></span><br><span class="line">df.fillna( &#123;<span class="string">'花⾊'</span>: <span class="number">0</span>, <span class="string">'牌⾯'</span>: <span class="number">1</span>&#125; ) <span class="comment">#按照字典填充</span></span><br></pre></td></tr></table></figure><h4 id="完整例子"><a href="#完整例子" class="headerlink" title="完整例子"></a>完整例子</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 设置最多显示 10 ⾏</span></span><br><span class="line">pd.set_option(<span class="string">'max_rows'</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 从 Excel ⽂件中读取原始数据</span></span><br><span class="line">df = pd.read_excel(<span class="string">'待清洗的扑克牌数据集.xlsx'</span>,sheet_name=<span class="string">"name"</span>)</span><br><span class="line"><span class="comment"># 补全缺失值</span></span><br><span class="line">df = df.fillna(<span class="string">'Joker'</span>)</span><br><span class="line"><span class="comment"># 排除重复值</span></span><br><span class="line">df = df.drop_duplicates()</span><br><span class="line"><span class="comment"># 修改异常值</span></span><br><span class="line">df.loc[<span class="number">4</span>, <span class="string">'牌⾯'</span>] = <span class="number">3</span></span><br><span class="line"><span class="comment"># 增加⼀张缺少的牌</span></span><br><span class="line">df = df.append(&#123;<span class="string">'编号'</span>: <span class="number">4</span>,<span class="string">'花⾊'</span>: <span class="string">'⿊桃♠'</span>,<span class="string">'牌⾯'</span>: <span class="number">2</span>&#125;,ignore_index=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 按编号排序</span></span><br><span class="line">df = df.sort_values(<span class="string">'编号'</span>)</span><br><span class="line"><span class="comment"># 重置索引</span></span><br><span class="line">df = df.reset_index()</span><br><span class="line"><span class="comment"># 删除多余的列</span></span><br><span class="line">df = df.drop([<span class="string">'index'</span>], axis=<span class="number">1</span> )</span><br><span class="line"><span class="comment"># 把清洗好的数据保存到 Excel ⽂件</span></span><br><span class="line">df.to_excel(<span class="string">'完成清洗的扑克牌数据.xlsx'</span>,index=<span class="literal">False</span>)</span><br><span class="line">df</span><br></pre></td></tr></table></figure><h3 id="三、操作数据"><a href="#三、操作数据" class="headerlink" title="三、操作数据"></a>三、操作数据</h3><h4 id="增加数据"><a href="#增加数据" class="headerlink" title="增加数据"></a>增加数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">"b"</span>]=[i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>)] <span class="comment">#相当于把df对象当字典用</span></span><br><span class="line">df.insert(<span class="number">1</span>, <span class="string">'a'</span>, [<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">#指定位置插入列</span></span><br><span class="line"><span class="comment">#插入一行</span></span><br><span class="line">a=pd.DataFrame(&#123;<span class="string">"a"</span>:<span class="number">1</span>,<span class="string">"b"</span>:<span class="number">2</span>&#125;)</span><br><span class="line">df2=df.append(a,ignore_index=<span class="literal">True</span>,sort=<span class="literal">False</span>)</span><br><span class="line"><span class="comment">#拼接两个数据框</span></span><br><span class="line">pd.concat([df, a],ignore_index=<span class="literal">True</span>,sort=<span class="literal">False</span>)</span><br><span class="line">还有merge()/join()函数</span><br></pre></td></tr></table></figure><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df.drop([<span class="number">0</span>,<span class="number">2</span>]) <span class="comment">#删除0/2两行数据</span></span><br><span class="line">df.drop(<span class="string">"a"</span>,axis=<span class="number">1</span>) <span class="comment">#删除"a"列的数据</span></span><br><span class="line"><span class="keyword">del</span> df2[<span class="string">"a"</span>] <span class="comment">#直接删除原数据框中的a列数据</span></span><br></pre></td></tr></table></figure><h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df.replace([<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="number">3</span>,<span class="number">4</span>],<span class="string">""</span>,regex=<span class="literal">True</span>) <span class="comment">#替换多个数据 regex--&gt;正则表达式</span></span><br><span class="line">df.loc[<span class="number">0</span>,<span class="string">"a"</span>]=<span class="string">"j"</span> <span class="comment">#修改第0行a属性的值</span></span><br><span class="line">df.columns = list(<span class="string">'AB'</span>) <span class="comment">#修改列名</span></span><br><span class="line">df.rename(&#123;<span class="string">"a"</span>:<span class="string">"b"</span>&#125;,axis=<span class="number">1</span>) <span class="comment">#修改指定列名</span></span><br><span class="line">df.rename(&#123;<span class="number">1</span>:<span class="number">3</span>,<span class="number">2</span>:<span class="number">3</span>&#125;) <span class="comment">#修改行名</span></span><br></pre></td></tr></table></figure><h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">df.head()</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">df[df.a.str.match(<span class="string">'[jk]'</span>, flags=re.IGNORECASE, na=<span class="literal">False</span>)] <span class="comment">#re.IGNORECASE--&gt;不区分大小写</span></span><br><span class="line"><span class="comment">#使用query</span></span><br><span class="line">df.query(</span><br><span class="line"> <span class="string">'1 &lt;= index &lt;= 5 \</span></span><br><span class="line"><span class="string"> and 牌⾯ not in @card '</span></span><br><span class="line">)</span><br><span class="line">df.query(</span><br><span class="line"> <span class="string">'编号 &gt; 编号.mean() \</span></span><br><span class="line"><span class="string"> and 牌⾯ == "A" '</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="四、数据转换"><a href="#四、数据转换" class="headerlink" title="四、数据转换"></a>四、数据转换</h3><h4 id="转换为时间"><a href="#转换为时间" class="headerlink" title="转换为时间"></a>转换为时间</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dateutil.parser <span class="keyword">import</span> parse</span><br><span class="line">df[<span class="string">"time"</span>]=df.Date.transform(parse).copy()</span><br><span class="line">parse(<span class="string">"10/9/2019"</span>,dayfirst=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h4 id="转换为数值"><a href="#转换为数值" class="headerlink" title="转换为数值"></a>转换为数值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pd.to_numeric(errors=<span class="string">'coerce'</span>) <span class="comment">#设置errors参数使得不能替换的值变为nan</span></span><br><span class="line">df.apply(pd.to_numeric,errors=<span class="string">'coerce'</span>) <span class="comment">#errors默认为ignore即略过不能转换的</span></span><br></pre></td></tr></table></figure><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.astype(str).dtypes</span><br><span class="line">对于时间型的数据，我们可以使⽤ strftime() 函数</span><br></pre></td></tr></table></figure><h4 id="转换为区间"><a href="#转换为区间" class="headerlink" title="转换为区间"></a>转换为区间</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pd.cut() <span class="comment">#将数值切割为指定的区间</span></span><br><span class="line">bins=[float(<span class="string">"-inf"</span>),<span class="number">280</span>,float(<span class="string">"inf"</span>)]</span><br><span class="line">pd.cut(df.a,bins=bins,right=<span class="literal">True</span>) <span class="comment">#左开右闭，默认左闭右开</span></span><br><span class="line">pd.cut(df.a,bins=<span class="number">2</span>) <span class="comment">#按照2为间隔划分</span></span><br></pre></td></tr></table></figure><h4 id="分组转换"><a href="#分组转换" class="headerlink" title="分组转换"></a>分组转换</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(<span class="string">"a"</span>)[<span class="string">"b"</span>].transform(sum) <span class="comment">#在⾏数保持不变的情况下，对某列进⾏分组求和</span></span><br><span class="line"><span class="comment">#能够⽅便地计算每个数据对应各⾃分组的占⽐</span></span><br><span class="line">df.groupby(<span class="string">"a"</span>)[<span class="string">"b"</span>].apply(sum) <span class="comment">#返回组数个结果</span></span><br><span class="line">df.groupby(<span class="string">"a"</span>)[<span class="string">"b"</span>].agg([sum,np.mean,<span class="string">"count"</span>])</span><br><span class="line">df.groupby(<span class="string">"month"</span>).agg(</span><br><span class="line">    天数=(<span class="string">"Date"</span>,count),</span><br><span class="line">平均价格=(<span class="string">"Open"</span>,np.mean)) <span class="comment">#对不同列聚合，使用不同函数</span></span><br></pre></td></tr></table></figure><h4 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#min-max标准化</span></span><br><span class="line">(df.a-df.a.min())/(df.a.max()-df.a.min())</span><br></pre></td></tr></table></figure><h3 id="五、整理数据"><a href="#五、整理数据" class="headerlink" title="五、整理数据"></a>五、整理数据</h3><h4 id="外连接-相当于并集"><a href="#外连接-相当于并集" class="headerlink" title="外连接(相当于并集)"></a>外连接(相当于并集)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.merge(df1,how=<span class="string">"outer"</span>,on=<span class="string">"用于连接的列名"</span>) <span class="comment">#缺失值用nan 得到两个表的所有⾏</span></span><br></pre></td></tr></table></figure><h4 id="内连接-相当于交集"><a href="#内连接-相当于交集" class="headerlink" title="内连接(相当于交集)"></a>内连接(相当于交集)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.merge(df1) <span class="comment">#不指定on时以两个表共同的列名为参数</span></span><br><span class="line"><span class="comment">#只返回两个表相互匹配的数据。无nan</span></span><br></pre></td></tr></table></figure><h4 id="左连接与右连接"><a href="#左连接与右连接" class="headerlink" title="左连接与右连接"></a>左连接与右连接</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.merge(df1,how=<span class="string">"left"</span>）<span class="comment">#df为左表，即使df1中某行值无也照样显示,同理右连接</span></span><br></pre></td></tr></table></figure><h4 id="交叉连接"><a href="#交叉连接" class="headerlink" title="交叉连接"></a>交叉连接</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">操作:</span><br><span class="line">（<span class="number">1</span>）⽤ assign() 函数增加 key 列；</span><br><span class="line">（<span class="number">2</span>）⽤ merge() 函数进⾏连接；</span><br><span class="line">（<span class="number">3</span>）删掉 key 列。</span><br><span class="line">df.assign(key=<span class="number">1</span>).merge(df1.assign(key=<span class="number">1</span>),on=<span class="string">"key"</span>).drop(<span class="string">"key"</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="联合拼接"><a href="#联合拼接" class="headerlink" title="联合拼接"></a>联合拼接</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.concat([df1,df2],sort=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h3 id="六、分析数据"><a href="#六、分析数据" class="headerlink" title="六、分析数据"></a>六、分析数据</h3><p>比较nb的三个数据分析库</p><p>参考文章：<a href="https://my.oschina.net/u/4581316/blog/4898542" target="_blank" rel="noopener">https://my.oschina.net/u/4581316/blog/4898542</a></p><h4 id="pandas-profiling"><a href="#pandas-profiling" class="headerlink" title="pandas_profiling"></a>pandas_profiling</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas_profiling</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.set_style(<span class="string">"whitegrid"</span>,&#123;<span class="string">"font.sans-serif"</span>:[<span class="string">"simhei"</span>,<span class="string">"Arial"</span>]&#125;)</span><br><span class="line">x=pandas_profiling.ProfileReport(df)</span><br><span class="line">x.to_file(<span class="string">"name.html"</span>)</span><br></pre></td></tr></table></figure><h4 id="Sweetviz"><a href="#Sweetviz" class="headerlink" title="Sweetviz"></a>Sweetviz</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sweetviz <span class="keyword">as</span> sv</span><br><span class="line">my_report = sv.analyze(mpg)</span><br><span class="line">my_report.show_html()</span><br></pre></td></tr></table></figure><h4 id="pandasGUI"><a href="#pandasGUI" class="headerlink" title="pandasGUI"></a>pandasGUI</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandasgui <span class="keyword">import</span> show</span><br><span class="line"><span class="comment"># 部署GUI的数据集</span></span><br><span class="line">gui = show(mpg)</span><br></pre></td></tr></table></figure><h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><h3 id="pyecharts"><a href="#pyecharts" class="headerlink" title="pyecharts"></a>pyecharts</h3><p>官网：<a href="https://pyecharts.org/#/zh-cn/intro" target="_blank" rel="noopener">https://pyecharts.org/#/zh-cn/intro</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据科学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记</title>
      <link href="2021/02/01/Java-note/"/>
      <url>2021/02/01/Java-note/</url>
      
        <content type="html"><![CDATA[<p>Java学习笔记</p><a id="more"></a><h2 id="JAVA-HOW2J教程笔记"><a href="#JAVA-HOW2J教程笔记" class="headerlink" title="JAVA-HOW2J教程笔记"></a>JAVA-HOW2J教程笔记</h2><h3 id="一、JAVA基础"><a href="#一、JAVA基础" class="headerlink" title="一、JAVA基础"></a>一、JAVA基础</h3><h4 id="1-hello-world与命令行运行"><a href="#1-hello-world与命令行运行" class="headerlink" title="1.hello world与命令行运行"></a>1.hello world与命令行运行</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//code:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Helloworld</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; <span class="comment">//main--&gt;主方法，所有代码的入口</span></span><br><span class="line">    System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//run</span></span><br><span class="line">javac hello.java <span class="comment">//编译</span></span><br><span class="line">java hello <span class="comment">//运行class文件</span></span><br></pre></td></tr></table></figure><h4 id="2-面向对象"><a href="#2-面向对象" class="headerlink" title="2.面向对象"></a>2.面向对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span></span>&#123;</span><br><span class="line">    <span class="comment">//属性定义 名字一般为驼峰命名</span></span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">float</span> hp;</span><br><span class="line">    <span class="comment">//方法定义</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span></span>&#123; </span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">num=num+n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//创建</span></span><br><span class="line">Hero a= <span class="keyword">new</span> Hero(); <span class="comment">//实例化类</span></span><br><span class="line">a.num=<span class="number">12</span>;</span><br><span class="line">a.hp=<span class="number">100.0</span>;</span><br><span class="line">a.name=<span class="string">"a"</span>;</span><br></pre></td></tr></table></figure><h4 id="3-变量"><a href="#3-变量" class="headerlink" title="3.变量"></a>3.变量</h4><h5 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">a[基本类型]--&gt; b[整型:byte short int long]</span><br><span class="line">a--&gt;c[浮点型:float double]</span><br><span class="line">a--&gt;d[布尔型:boolean--true,false]</span><br><span class="line">a--&gt;e[字符型:char]</span><br><span class="line">a--&gt;f[注:String不是基本类型,Immutable-创建不可修改]</span><br></pre></td></tr></table></figure><h5 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h5><p>变量命名只能使用字母 数字 $ _，首字母不能用数字</p><h5 id="final"><a href="#final" class="headerlink" title="final"></a>final</h5><p>一个变量被final修饰的时候，该变量只有<strong>一次赋值</strong>的机会</p><h4 id="4-操作符"><a href="#4-操作符" class="headerlink" title="4.操作符"></a>4.操作符</h4><h5 id="使用Scanner类获取输入"><a href="#使用Scanner类获取输入" class="headerlink" title="使用Scanner类获取输入"></a>使用Scanner类获取输入</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> a = s.nextInt();</span><br><span class="line">        System.out.println(<span class="string">"第一个整数："</span>+a);</span><br><span class="line">        <span class="keyword">float</span> b = s.nextFloat();</span><br><span class="line">        System.out.println(<span class="string">"第二个浮点数："</span>+b);</span><br><span class="line">        String str=s.nextLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-数组"><a href="#5-数组" class="headerlink" title="5.数组"></a>5.数组</h4><h5 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//create</span></span><br><span class="line"><span class="keyword">int</span>[] a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]; </span><br><span class="line"></span><br><span class="line"><span class="comment">//3 ways to init</span></span><br><span class="line"><span class="keyword">int</span>[] c=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">int</span>[] c=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">int</span>[] c=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增强型for循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> each:values)&#123;</span><br><span class="line">    System.out.println(each);<span class="comment">//增强型for循环只能用来取值，却不能用来修改数组里的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//copy array</span></span><br><span class="line">System.arraycopy(src, srcPos, dest, destPos, length)</span><br><span class="line">    <span class="comment">//src: 源数组</span></span><br><span class="line">    <span class="comment">//srcPos: 从源数组复制数据的起始位置</span></span><br><span class="line">    <span class="comment">//dest: 目标数组</span></span><br><span class="line">    <span class="comment">//destPos: 复制到目标数组的启始位置</span></span><br><span class="line">    <span class="comment">//length: 复制的长度  </span></span><br><span class="line"><span class="keyword">int</span>[] b;</span><br><span class="line">System.arraycopy(a, <span class="number">0</span>, b, <span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//二维数组</span></span><br><span class="line"><span class="keyword">int</span> b[][] = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">   &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">   &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,</span><br><span class="line">   &#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="常见数组函数"><a href="#常见数组函数" class="headerlink" title="常见数组函数"></a>常见数组函数</h5><p>需要引入包 <code>import java.util.Arrays;</code></p><div class="table-container"><table><thead><tr><th style="text-align:center">数组函数</th><th style="text-align:center">对应操作</th></tr></thead><tbody><tr><td style="text-align:center">Arrays.copyOfRange(int[] original, int from, int to)</td><td style="text-align:center">int[] b = Arrays.copyOfRange(a, 0, 3);复制数组</td></tr><tr><td style="text-align:center">Arrays.toString(a)</td><td style="text-align:center">转换成”[1,2,3,4]”字符串形式</td></tr><tr><td style="text-align:center">Arrays.sort(a)</td><td style="text-align:center">排序</td></tr><tr><td style="text-align:center">Arrays.binarySearch(a, 62)</td><td style="text-align:center">二分查找</td></tr><tr><td style="text-align:center">Arrays.equals(a, b)</td><td style="text-align:center">判断是否相同</td></tr><tr><td style="text-align:center">Arrays.fill(a,5)</td><td style="text-align:center">使用同一个值，填充整个数组</td></tr></tbody></table></div><h4 id="6-类和对象"><a href="#6-类和对象" class="headerlink" title="6.类和对象"></a>6.类和对象</h4><h5 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h5><p>对象不是基本类型——即是引用（即指针）</p><p><code>Hero h = new Hero();</code>  h为引用，代表了右边创建的的Hero类型对象，即h指向右侧的这个对象</p><p><code>Hero h1 = h;</code> 则h1和h指向同一个对象</p><p><code>h = new Hero()</code> h指向新的对象</p><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>extends关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Weapon</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> price;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Weapon</span> <span class="keyword">extends</span> <span class="title">Item</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> damage; <span class="comment">//攻击力 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用方法attack的时候，会根据传递的参数类型以及数量，自动调用对应的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">(Hero h1)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">(Hero h1,Hero h2)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">(Hero h1,Hero h2,Hero h3)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//采用可变数量的参数,一个函数相当于上述三个函数 使用操作数组的方式处理参数heros即可</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">(Hero... heros)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heros.length; i++) &#123;</span><br><span class="line">        System.out.println(name + <span class="string">" 攻击了 "</span> + heros[i].name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p>类里不显示写构造函数时，为隐式构造，即<code>Hero a=Hero()</code>这样的形式</p><p>写了就按照写的来，且可以重载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">(String heroname)</span></span>&#123; </span><br><span class="line">name = heroname;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="this"><a href="#this" class="headerlink" title="this"></a>this</h5><p>在对象内部表示当前这个对象</p><p>在一个构造方法中，调用另一个构造方法，可以使用this()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName3</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    <span class="comment">//name代表的是参数name</span></span><br><span class="line">    <span class="comment">//this.name代表的是属性name this相当于是引用，打印this是地址</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h5><p><strong>基本类型</strong>传参：函数块内<strong>不能改变</strong>原变量值，传入的参数为函数内局部变量</p><p><strong>引用类型</strong>传参：函数块内<strong>能改变</strong>原变量值</p><h5 id="包"><a href="#包" class="headerlink" title="包"></a>包</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> character; <span class="comment">//声明包的名字</span></span><br><span class="line"><span class="keyword">import</span> person.C <span class="comment">//引用其他包</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h5><p>用于修饰类或类里面的函数</p><div class="table-container"><table><thead><tr><th style="text-align:center">修饰符</th><th style="text-align:center">对应含义</th></tr></thead><tbody><tr><td style="text-align:center">private</td><td style="text-align:center">私有的</td></tr><tr><td style="text-align:center">package/friendly/default</td><td style="text-align:center">不写修饰符，默认状态</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">受保护的</td></tr><tr><td style="text-align:center">public</td><td style="text-align:center">公共的</td></tr></tbody></table></div><h6 id="类之间关系"><a href="#类之间关系" class="headerlink" title="类之间关系"></a>类之间关系</h6><p>自身（访问）、同包子类（<strong>同包</strong>内的类<strong>继承</strong>）、不同包子类（<strong>不同包间</strong>的类<strong>继承</strong>）、同包类（<strong>同一个包</strong>内的<strong>访问</strong>）、其他类（<strong>不同包</strong>内的<strong>访问</strong>）</p><h6 id="四种修饰符及对应的访问限制"><a href="#四种修饰符及对应的访问限制" class="headerlink" title="四种修饰符及对应的访问限制"></a>四种修饰符及对应的访问限制</h6><div class="table-container"><table><thead><tr><th style="text-align:center">修饰符</th><th style="text-align:center">自身-访问</th><th style="text-align:center">同包子类-继承</th><th style="text-align:center">不同包子类-继承</th><th style="text-align:center">同包类-访问</th><th style="text-align:center">其他类-访问</th></tr></thead><tbody><tr><td style="text-align:center">private</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">package/friendly/default</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">public</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr></tbody></table></div><p>能不露就不露出来，<strong>作用范围最小</strong>原则</p><ul><li>属性用private封装</li><li>方法一般用public</li><li>会被子类继承的方法，用protected</li><li>package用的不多</li></ul><h5 id="类属性（静态属性）"><a href="#类属性（静态属性）" class="headerlink" title="类属性（静态属性）"></a>类属性（静态属性）</h5><p>static修饰时，为类属性（<strong>静态</strong>属性），与之相对的是对象属性（<strong>实例属性</strong>，<strong>非静态</strong>属性）</p><p>类属性所有对象都<strong>共享</strong>一个相同值</p><p>访问可以用<strong><code>对象.类属性</code></strong>和<strong><code>类.类属性</code></strong>两种等价方式进行访问。</p><h5 id="类方法（静态方法）"><a href="#类方法（静态方法）" class="headerlink" title="类方法（静态方法）"></a>类方法（静态方法）</h5><p>也用<code>static</code>修饰，与类属性类似，也与对象方法（实例方法，非静态方法）相对。</p><p>方法里访问了对象属性，必须用对象方法</p><p>没有访问对象属性，可以用类方法</p><h5 id="属性初始化"><a href="#属性初始化" class="headerlink" title="属性初始化"></a>属性初始化</h5><h6 id="对象属性-三种办法初始化"><a href="#对象属性-三种办法初始化" class="headerlink" title="对象属性-三种办法初始化"></a>对象属性-三种办法初始化</h6><ol><li><p>声明该属性的时候初始化 </p></li><li><p>构造方法中初始化 </p></li><li><p>初始化块 如：<code>{ x=10 }</code></p></li></ol><h6 id="类属性-两种办法"><a href="#类属性-两种办法" class="headerlink" title="类属性-两种办法"></a>类属性-两种办法</h6><ol><li>声明该属性的时候初始化</li><li>静态初始化块</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> item=<span class="number">8</span>; <span class="comment">//声明时</span></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    item=<span class="number">6</span>; <span class="comment">//静态初始化块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><h6 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h6><ul><li>只有一个，通过私有化其构造方法，使得外部无法通过new 得到新的实例。</li><li>提供了一个public static的getInstance方法，外部调用者通过该方法获取一个对象，而且每一次都是获取同一个对象。 从而达到单例的目的。</li><li>在getInstance方法外已经创建了一个实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GiantDragon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有化构造方法使得该类无法在外部通过new 进行实例化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">GiantDragon</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//准备一个类属性，指向一个实例化对象。 因为是类属性，所以只有一个</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> GiantDragon instance = <span class="keyword">new</span> GiantDragon();</span><br><span class="line">    </span><br><span class="line"><span class="comment">//public static 方法，提供给调用者获取定义的对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GiantDragon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h6><ul><li>在getInstance方法内创建了一个实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GiantDragon</span> </span>&#123;</span><br><span class="line">    <span class="comment">//私有化构造方法使得该类无法在外部通过new 进行实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">GiantDragon</span><span class="params">()</span></span>&#123;        </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//准备一个类属性，用于指向一个实例化对象，但是暂时指向null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> GiantDragon instance;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//public static 方法，返回实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GiantDragon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//第一次访问的时候，发现instance没有指向任何对象，这时实例化一个对象</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span>==instance)&#123;</span><br><span class="line">    instance = <span class="keyword">new</span> GiantDragon();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回 instance指向的对象</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="两种方式选用"><a href="#两种方式选用" class="headerlink" title="两种方式选用"></a>两种方式选用</h6><p><strong>饿汉式</strong>，是<strong>立即加载</strong>的方式，无论是否会用到这个对象，都会加载。<br>如果在构造方法里写了<strong>性能消耗较大</strong>，<strong>占时较久</strong>的代码，比如<strong>建立与数据库的连接</strong>，那么就会在启动的时候感觉稍微有些卡顿。</p><p><strong>懒汉式</strong>，是<strong>延迟加载</strong>的方式，只有使用的时候才会加载。 并且有<strong>线程安全</strong>的考量。使用懒汉式，在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化。 但是在<strong>第一次调用</strong>的时候，会进行实例化操作，感觉上就略慢。</p><p>看业务需求，如果业务上允许有比较<strong>充分的启动和初始化时间</strong>，就使用<strong>饿汉式</strong>，<strong>否则</strong>就使用<strong>懒汉式</strong></p><h6 id="单例模式三元素"><a href="#单例模式三元素" class="headerlink" title="单例模式三元素"></a>单例模式三元素</h6><ol><li>构造方法私有化</li><li>静态属性指向实例</li><li>public static的 getInstance方法，返回第二步的静态属性</li></ol><h5 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Season &#123;</span><br><span class="line">SPRING,SUMMER,AUTUMN,WINTER <span class="comment">//分别代表1，2，3，4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Season season = Season.SPRING;</span><br><span class="line"><span class="keyword">switch</span> (season) &#123;</span><br><span class="line"><span class="keyword">case</span> SPRING:</span><br><span class="line">System.out.println(<span class="string">"春天"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SUMMER:</span><br><span class="line">System.out.println(<span class="string">"夏天"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> AUTUMN:</span><br><span class="line">System.out.println(<span class="string">"秋天"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WINTER:</span><br><span class="line">System.out.println(<span class="string">"冬天"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Season s : Season.values()) &#123;  <span class="comment">//增强型for循环遍历</span></span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-接口与继承"><a href="#7-接口与继承" class="headerlink" title="7.接口与继承"></a>7.接口与继承</h4><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AD</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">physicAttack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AP</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">magicAttack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现接口 使用implements 可以同时实现多个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ADHero</span> <span class="keyword">extends</span> <span class="title">Hero</span> <span class="keyword">implements</span> <span class="title">AD</span>,<span class="title">AP</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">physicAttack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进行物理攻击"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="对象转型"><a href="#对象转型" class="headerlink" title="对象转型"></a>对象转型</h5><p>将等号右边的类型转换为等号左边的，本质上能不能转换主要是看右边的类型能不能当成左边的来用</p><h6 id="子类转父类（向上转型）"><a href="#子类转父类（向上转型）" class="headerlink" title="子类转父类（向上转型）"></a>子类转父类（向上转型）</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hero h = <span class="keyword">new</span> Hero();</span><br><span class="line">ADHero ad = <span class="keyword">new</span> ADHero();</span><br><span class="line">h = ad; <span class="comment">//直接转换即可</span></span><br></pre></td></tr></table></figure><h6 id="父类转子类（向下转型）"><a href="#父类转子类（向下转型）" class="headerlink" title="父类转子类（向下转型）"></a>父类转子类（向下转型）</h6><p>需要强制转化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ad = (ADHero) h; <span class="comment">//强制转换</span></span><br></pre></td></tr></table></figure><h6 id="没有继承关系的两个类，互相转换会失败"><a href="#没有继承关系的两个类，互相转换会失败" class="headerlink" title="没有继承关系的两个类，互相转换会失败"></a>没有继承关系的两个类，互相转换会失败</h6><h5 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h5><p>子类和父类定义名字一样的方法，调用时调用子类的，即重写</p><h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><h6 id="操作符的多态"><a href="#操作符的多态" class="headerlink" title="操作符的多态"></a>操作符的多态</h6><p>字符串相加表示拼接，数字相加表示加法</p><h6 id="类的多态"><a href="#类的多态" class="headerlink" title="类的多态"></a>类的多态</h6><p>即不同的子类，对同一个父类方法的重写</p><h5 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h5><p>子类调用父类的静态方法（类方法）</p><h5 id="super"><a href="#super" class="headerlink" title="super"></a>super</h5><p>使用<code>super对象</code>调用父类的方法和属性</p><h5 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h5><p>声明一个类的时候，默认是继承了Object </p><p><code>toString()</code>返回当前对象的<strong>字符串表达</strong></p><p><code>finalize()</code>一个对象没有任何引用指向时，满足回收条件，这个方法被<code>JVM</code>自动调用</p><p><code>equals()</code> 判断两个对象内容是否相同</p><p><code>==</code> 判断两个引用，是否指向了同一个对象</p><p><code>hashCode()</code>返回一个对象的哈希值</p><p>Object还提供<strong>线程同步</strong>相关方法</p><ul><li><code>wait()</code></li></ul><ul><li><code>notify()</code></li><li><code>notifyAll()</code></li></ul><p><code>getClass()</code> 返回一个对象的类对象</p><h5 id="final-1"><a href="#final-1" class="headerlink" title="final"></a>final</h5><p>用final修饰的类不能被继承</p><p>修饰方法则不能被重写</p><p>修饰变量，则只有一次赋值机会</p><p>修饰引用，引用只有<strong>1</strong>次指向对象的机会</p><p>常量：<code>public static final int a = 6;</code></p><h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><p>abstract修饰符来修饰</p><p>当一个类有抽象方法的时候，该类必须被声明为抽象类</p><p>抽象类可以没有抽象方法</p><p><strong>子类必须提供</strong>不一样的attack方法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">float</span> hp;</span><br><span class="line">    <span class="keyword">float</span> armor;</span><br><span class="line">    <span class="keyword">int</span> moveSpeed;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 抽象方法attack</span></span><br><span class="line">    <span class="comment">// Hero的子类会被要求实现attack方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h6><p>区别1：</p><ul><li>子类只能继承一个抽象类，不能继承多个</li><li>子类可以实现<strong>多个</strong>接口</li></ul><p>区别2：</p><ul><li><p>抽象类可以定义</p><ul><li><p>public,protected,package,private</p></li><li><p>静态和非静态属性</p></li><li><p>final和非final属性</p></li></ul></li><li><p>但是接口中声明的属性，只能是</p><ul><li><p>public</p></li><li><p>静态</p></li><li><p>final的</p></li></ul><p>即便没有显式的声明(默认转换为<code>public static final</code>)</p></li></ul><p>注:抽象类和接口都可以有实体方法。 接口中的实体方法，叫做默认方法</p><h5 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h5><p>分为四种：</p><ul><li>非静态内部类  可以直接在一个类里面定义，实例化必须建立在一个外部类对象的基础之上，即：<strong>new 外部类().new 内部类()</strong>，可以访问外部类的属性方法</li><li>静态内部类 可以直接实例化，不能访问外部类的实例属性方法，但是可以访问静态属性方法</li><li><p>匿名类 直接实例化一个抽象类，并“<strong>当场</strong>”实现其抽象方法。</p></li><li><p>本地类 有名字的匿名类</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hero h = <span class="keyword">new</span> Hero()&#123;</span><br><span class="line">            <span class="comment">//当场实现attack方法</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"新的进攻手段"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        h.attack();</span><br><span class="line">        <span class="comment">//通过打印h，可以看到h这个对象属于Hero$1这么一个系统自动分配的类名 </span></span><br><span class="line">        System.out.println(h);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//本地类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">SomeHero</span> <span class="keyword">extends</span> <span class="title">Hero</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println( name+ <span class="string">" 新的进攻手段"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        SomeHero h  =<span class="keyword">new</span> SomeHero();</span><br><span class="line">        h.name =<span class="string">"地卜师"</span>;</span><br><span class="line">        h.attack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h5><p>默认方法是JDK8新特性，指的是接口也可以提供具体方法了</p><p><code>default public void func(){}</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mortal</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">die</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">revive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"本英雄复活了"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="UML图——类之间的关系"><a href="#UML图——类之间的关系" class="headerlink" title="UML图——类之间的关系"></a>UML图——类之间的关系</h5><p>UML-Unified Module Language<br>统一建模语言，可以很方便的用于描述类的属性，方法，以及类和类之间的关系</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置环境遇到的问题和解决办法积累</title>
      <link href="2021/01/31/%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%E7%A7%AF%E7%B4%AF/"/>
      <url>2021/01/31/%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%E7%A7%AF%E7%B4%AF/</url>
      
        <content type="html"><![CDATA[<p>笔者经常花很多的时间在配置环境上，出于不想总是这样浪费时间的考虑，写篇文章积累一下踩过的坑。</p><a id="more"></a><h3><span id="配置java环境">配置java环境</span></h3><h4><span id="命令行运行java代码时找不到或无法加载主类">命令行运行java代码时找不到或无法加载主类</span></h4><p>一般是先让你在系统变量中配<code>JAVA_HOME</code>再配<code>CLASS_PATH</code>再配<code>PATH</code>。操作完之后出现这个问题，则一般都是<strong>环境配置问题</strong>，其次可能是<strong>代码本身</strong>。</p><p>我最后是把三个环境变量配置在用户变量里也加了一遍就好了。（被坑惨了，实在不知道为什么这样就行了？？）</p><p>其他的可能解决办法还有：可以试试把所有的<code>%JAVA_HOME%</code>全部换成其本身的地址；查看一下CLASS_PATH是否设置错等。</p><h4><span id="android-studio-sync-project-with-gradle-files时卡住">Android studio Sync Project with Gradle Files时卡住</span></h4><p>主要要切换一下镜像源</p><p>参考这篇文章：<a href="https://blog.csdn.net/xiaoxiangsss/article/details/113136127" target="_blank" rel="noopener">https://blog.csdn.net/xiaoxiangsss/article/details/113136127</a></p><h3><span id="使用npm">使用npm</span></h3><p>常常需要切换代理才可以成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h3><span id="配置python环境">配置Python环境</span></h3><p><code>pip install</code>遇到 <code>Read timed out</code> 修改为 <code>pip --default-timeout=100 install package-name</code></p><p>有时<code>pip</code> 和<code>conda</code>可以都试试，如果都不行可以考虑换一下镜像或者更新一下<code>pip</code> 和<code>conda</code></p><h3><span id="设置右键菜单中打开xxx为xxx项目">设置右键菜单中<code>打开xxx为xxx项目</code></span></h3><p><a href="https://blog.csdn.net/weixin_44653409/article/details/102808839" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44653409/article/details/102808839</a></p><h3><span id="github-科学上网也clone不下来">github 科学上网也clone不下来</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/BUAADreamer/Setest.git</span><br><span class="line">Cloning into 'Setest'...</span><br><span class="line"></span><br><span class="line">fatal: unable to access 'https://github.com/BUAADreamer/Setest.git/': OpenSSL SSL_read: Connection was reset, errno 10054</span><br></pre></td></tr></table></figure><p>解决：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.sslVerify "false"</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摄影学习</title>
      <link href="2021/01/30/%E6%91%84%E5%BD%B1%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/01/30/%E6%91%84%E5%BD%B1%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Life Note </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML+CSS笔记</title>
      <link href="2021/01/30/%E5%89%8D%E7%AB%AF-html5+css3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/01/30/%E5%89%8D%E7%AB%AF-html5+css3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>前端知识整理，以备不时之需。</p><a id="more"></a><p>写在开始：本文部分内容直接搬运自一些网站，仅用作个人和他人学习用途。</p><h2 id="资源整理"><a href="#资源整理" class="headerlink" title="资源整理"></a>资源整理</h2><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p><a href="https://www.runoob.com/html/html-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a>   <a href="https://www.w3school.com.cn/html/index.asp" target="_blank" rel="noopener">w3school</a>  </p><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p><a href="https://www.runoob.com/css/css-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a>  <a href="https://www.w3school.com.cn/css/index.asp" target="_blank" rel="noopener">w3school</a>  </p><h2 id="慕课网教程笔记"><a href="#慕课网教程笔记" class="headerlink" title="慕课网教程笔记"></a>慕课网教程笔记</h2><p><a href="https://www.imooc.com/learn/9" target="_blank" rel="noopener">慕课网入门教程</a></p><h3 id="1-HTML文档结构"><a href="#1-HTML文档结构" class="headerlink" title="1.HTML文档结构"></a>1.HTML文档结构</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span> 文档类型声明，表示该文件为 HTML5文件。<span class="meta">&lt;!DOCTYPE&gt;</span> 声明必须是 HTML 文档的第一行，位于 <span class="tag">&lt;<span class="name">html</span>&gt;</span> 标签之前</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span>  --&gt;head标签表示头部标签,通常用来嵌套meta、title、style等标签。 title:网页标题</span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>认识html文件基本结构<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>在本小节中，你将学会认识html文件基本结构<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-语义化标签"><a href="#2-语义化标签" class="headerlink" title="2.语义化标签"></a>2.语义化标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>段落文本<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>自定义文本标签<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题标签 h1-h6来表示<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>块标签<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span>网页开头<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span>网页底部<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span>区域<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span>侧边栏<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-效果标签"><a href="#3-效果标签" class="headerlink" title="3.效果标签"></a>3.效果标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span> --&gt;换行标签</span><br><span class="line"><span class="symbol">&amp;nbsp;</span> --&gt;空格</span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span> --&gt;水平分割线</span><br></pre></td></tr></table></figure><h3 id="4-列表标签"><a href="#4-列表标签" class="headerlink" title="4.列表标签"></a>4.列表标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span> <span class="tag">&lt;/<span class="name">li</span>&gt;</span> --&gt;无序列表</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>abc<span class="tag">&lt;/<span class="name">li</span>&gt;</span> --&gt;有序列表</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>def<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-图片链接和表格标签"><a href="#5-图片链接和表格标签" class="headerlink" title="5.图片链接和表格标签"></a>5.图片链接和表格标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"图片地址"</span> <span class="attr">alt</span>=<span class="string">"下载失败时的替换文本"</span> <span class="attr">title</span> = <span class="string">"鼠标滑过时的提示文本"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span>  <span class="attr">href</span>=<span class="string">"目标网址"</span>  <span class="attr">title</span>=<span class="string">"鼠标滑过显示的文本"</span> <span class="attr">target</span>=<span class="string">"_self(覆盖原网页)/_blank(打开新网页)"</span>&gt;</span>链接显示的文本<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">10</span> &gt;</span> --&gt;table表格标签 border属性为边框粗细</span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> --&gt;tr表示行</span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>知识点<span class="tag">&lt;/<span class="name">th</span>&gt;</span> --&gt;th表示第一行加粗的表格表头单元格</span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>html<span class="tag">&lt;/<span class="name">td</span>&gt;</span> --&gt;td表示普通单元格</span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">thead</span>&gt;</span>标签定义表格头部,<span class="tag">&lt;<span class="name">tbody</span>&gt;</span>标签来定义表格的内容,<span class="tag">&lt;<span class="name">tfoot</span>&gt;</span>来定义表格的底部,当长的表格被打印时，表格的表头和页脚可被打印在包含表格数据的每张页面上。</span><br></pre></td></tr></table></figure><h3 id="6-表单标签"><a href="#6-表单标签" class="headerlink" title="6.表单标签"></a>6.表单标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">"save.php"</span>&gt;</span> --&gt;action:浏览者输入的数据被传送到的地方,比如一个PHP页面(save.php) </span><br><span class="line">       --&gt;method:数据传送的方式（get/post）</span><br><span class="line">    <span class="comment">&lt;!--文本输入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"username"</span>&gt;</span>用户名:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">id</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">""</span> <span class="attr">placeholder</span>=<span class="string">""</span>/&gt;</span> --&gt;普通文本输入</span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"pass"</span>&gt;</span>密码:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"pass"</span> <span class="attr">id</span>=<span class="string">"pass"</span> <span class="attr">value</span>=<span class="string">""</span> <span class="attr">placeholder</span>=<span class="string">""</span>/&gt;</span> --&gt;加密文本输入</span><br><span class="line">    --&gt;for=id完成了和input标签的联动，和相应的输入框进行绑定</span><br><span class="line">    --&gt;type="num"--只允许输入数字 type="url"--只允许输入http/https协议的网址 type="email"--&gt;邮箱</span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span>  <span class="attr">rows</span>=<span class="string">"行数"</span> <span class="attr">cols</span>=<span class="string">"列数"</span>&gt;</span>文本<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span> --&gt;大段文字输入框</span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--选择框--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio/checkbox"</span> <span class="attr">value</span>=<span class="string">"值"</span> <span class="attr">name</span>=<span class="string">"名称"</span> <span class="attr">checked</span>=<span class="string">"checked"</span>/&gt;</span></span><br><span class="line">     --&gt;当 type="radio" 时，控件为单选框</span><br><span class="line">       当 type="checkbox" 时，控件为复选框</span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--下拉菜单--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span>&gt;</span> --&gt;下拉菜单 select标签里面只能放option标签，表示下拉列表的选项。option标签放选项内容，不放置其他标签</span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"看书"</span>&gt;</span>看书<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"旅游"</span>&gt;</span>旅游<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"运动"</span> <span class="attr">selected</span>=<span class="string">"selected"</span>&gt;</span>运动<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"购物"</span>&gt;</span>购物<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--按钮--&gt;</span> --&gt;对表单其他元素做相应的操作</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"确定"</span> <span class="attr">name</span>=<span class="string">"submit"</span> /&gt;</span>  --&gt;value：按钮上显示的文字</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"reset"</span> <span class="attr">value</span>=<span class="string">"重置"</span> <span class="attr">name</span>=<span class="string">"reset"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="几个常用属性"><a href="#几个常用属性" class="headerlink" title="几个常用属性"></a>几个常用属性</h4><p>value：提交数据到服务器的值（后台程序PHP使用）</p><p>name：为控件命名，以备后台程序 ASP、PHP 使用</p><p>checked：当设置 checked=”checked” 时，该选项被默认选中</p><h3 id="7-CSS样式基本使用"><a href="#7-CSS样式基本使用" class="headerlink" title="7.CSS样式基本使用"></a>7.CSS样式基本使用</h3><p>css 样式由<strong>选择符</strong>和<strong>声明</strong>组成，而<strong>声明</strong>又由<strong>属性</strong>和<strong>值</strong>组成</p><p>注释：<code>/* */</code></p><h4 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p style="color:red;font-size:12px"&gt;这里文字是红色。&lt;/p&gt;</span><br></pre></td></tr></table></figure><h4 id="嵌入式"><a href="#嵌入式" class="headerlink" title="嵌入式"></a>嵌入式</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line">    <span class="selector-tag">span</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>:blue;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;span&gt;123&lt;/span&gt;</span><br></pre></td></tr></table></figure><h4 id="外联样式"><a href="#外联样式" class="headerlink" title="外联样式"></a>外联样式</h4><p>一般写在<code>&lt;head&gt;</code>标签内</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href="base.css" rel="stylesheet" type="text/css" /&gt;</span><br></pre></td></tr></table></figure><h4 id="三种方式优先级"><a href="#三种方式优先级" class="headerlink" title="三种方式优先级"></a>三种方式优先级</h4><p>内联式 &gt; 嵌入式 &gt; 外部式</p><p>即<strong>就近原则</strong></p><h3 id="8-CSS选择器"><a href="#8-CSS选择器" class="headerlink" title="8.CSS选择器"></a>8.CSS选择器</h3><p>声明组成：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123;</span><br><span class="line">    样式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="各种选择器"><a href="#各种选择器" class="headerlink" title="各种选择器"></a>各种选择器</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 标签选择器 */</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">font-size</span>:<span class="number">12px</span>;<span class="attribute">line-height</span>:<span class="number">1.6em</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 类选择器 .类名 */</span></span><br><span class="line">.类选器名称 &#123;css样式代码;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ID选择器 #ID */</span></span><br><span class="line">#ID名字 &#123;css样式;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*子选择器 &gt; */</span></span><br><span class="line"><span class="selector-class">.food</span>&gt;<span class="selector-tag">li</span> &#123;<span class="attribute">border</span>:<span class="number">1px</span> solid red;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*后代选择器 空格 */</span></span><br><span class="line"><span class="selector-class">.food</span> <span class="selector-tag">span</span>&#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*通用选择器 匹配html中所有标签元素*/</span></span><br><span class="line">* &#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 伪类选择器 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;<span class="attribute">color</span>:red;&#125; <span class="comment">/*给html中一个标签元素的鼠标滑过的状态来设置字体颜色*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分组选择器 */</span></span><br><span class="line"><span class="selector-tag">h1</span>,<span class="selector-tag">span</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类和ID选择器区别"><a href="#类和ID选择器区别" class="headerlink" title="类和ID选择器区别"></a>类和ID选择器区别</h4><ul><li><p><strong>ID选择器只能在文档中使用一次</strong>。与类选择器不同，在一个HTML文档中，ID选择器只能使用一次，而且仅一次。而类选择器可以使用多次。换言之，每个标签ID不能相同</p></li><li><p><strong>可以使用类选择器词列表方法为一个元素同时设置多个样式。</strong>我们可以为一个元素同时设多个样式，但只可以用类选择器的方法实现，ID选择器是不可以的（<strong>不能使用 ID 词列表</strong>）。如：</p></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.stress</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bigsize</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">25px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;p&gt;到了&lt;span class="stress bigsize"&gt;三年级&lt;/span&gt;下学期时，我们班上了一节公开课...&lt;/p&gt;</span><br></pre></td></tr></table></figure><h3 id="9-CSS继承，优先级和重要性"><a href="#9-CSS继承，优先级和重要性" class="headerlink" title="9.CSS继承，优先级和重要性"></a>9.CSS继承，优先级和重要性</h3><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>内联样式 &gt; id选择器 &gt; 类选择器 &gt; 标签选择器 &gt; 通配符选择器</p><h4 id="权值计算-特殊性"><a href="#权值计算-特殊性" class="headerlink" title="权值计算-特殊性"></a>权值计算-特殊性</h4><p>标签的权值为1，类选择符的权值为10，ID选择符的权值最高为100。继承的权值可视为0.1</p><h4 id="选择器最高层级-important"><a href="#选择器最高层级-important" class="headerlink" title="选择器最高层级!important"></a>选择器最高层级!important</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:red<span class="meta">!important</span>;&#125;</span><br></pre></td></tr></table></figure><h3 id="10-CSS字体样式"><a href="#10-CSS字体样式" class="headerlink" title="10.CSS字体样式"></a>10.CSS字体样式</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*使用font-family设置字体*/</span></span><br><span class="line"><span class="selector-tag">body</span>&#123;<span class="attribute">font-family</span>:<span class="string">"宋体"</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用font-size设置字体大小*/</span></span><br><span class="line"><span class="selector-tag">body</span>&#123;<span class="attribute">font-size</span>:<span class="number">12px</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用font-weight设置字体粗细*/</span></span><br><span class="line"><span class="selector-tag">p</span> <span class="selector-tag">span</span>&#123;<span class="attribute">font-weight</span>:bold;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用font-style设置字体样式</span></span><br><span class="line"><span class="comment">正常字体为normal,也是font-style的默认值。</span></span><br><span class="line"><span class="comment">italic为设置字体为斜体，用于字体本身就有倾斜的样式。</span></span><br><span class="line"><span class="comment">oblique为设置倾斜的字体，强制将字体倾斜。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用color设置字体颜色 三种赋值方式*/</span></span><br><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:<span class="built_in">rgb</span>(<span class="number">133</span>,<span class="number">45</span>,<span class="number">200</span>);&#125;</span><br><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:<span class="number">#00ffff</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*font样式的简写方式*/</span></span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">font-style</span>:italic;</span><br><span class="line">    <span class="attribute">font-weight</span>:bold; </span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">12px</span>; </span><br><span class="line">    <span class="attribute">line-height</span>:<span class="number">1.5em</span>; </span><br><span class="line">    <span class="attribute">font-family</span>:<span class="string">"宋体"</span>,sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">---------------</span>&gt;</span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">font</span>:italic  bold  <span class="number">12px</span>/<span class="number">1.5em</span>  <span class="string">"宋体"</span>,sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-装饰文本"><a href="#11-装饰文本" class="headerlink" title="11.装饰文本"></a>11.装饰文本</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* text-decoration添加文本修饰</span></span><br><span class="line"><span class="comment">1、text-decoration可以设置添加到文本的修饰。</span></span><br><span class="line"><span class="comment">2、text-decoration默认值为none, 定义标准的文本。</span></span><br><span class="line"><span class="comment">3、text-decoration的值为underline为定义文本下的一条线。</span></span><br><span class="line"><span class="comment">4、text-decoration的值为overline为定义文本上的一条线。</span></span><br><span class="line"><span class="comment">5、text-decoration的值为line-through为定义穿过文本下的一条线，一般用于商品折扣价。 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*text-indent为文本添加首行缩进*/</span></span><br><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">text-indent</span>:<span class="number">2em</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*line-height设置行间距*/</span></span><br><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">line-height</span>:<span class="number">1.5em</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用letter/word-spacing增加或减少字符间的空白*/</span></span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line">    <span class="attribute">letter-spacing</span>:<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用text-align设置文本对齐方式*/</span></span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line">    <span class="attribute">text-align</span>:center; <span class="comment">/*可选left right*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用到<code>px（像素）</code>、<code>em</code>、<code>% 百分比</code> 三种长度单位，这三个都是相对长度单位</p><p>1em和font-size对应</p><p>百分比也是相对于font-size设定值的比</p><h3 id="12-CSS盒模型"><a href="#12-CSS盒模型" class="headerlink" title="12.CSS盒模型"></a>12.CSS盒模型</h3><h4 id="元素分类"><a href="#元素分类" class="headerlink" title="元素分类"></a>元素分类</h4><h5 id="常用的块状元素"><a href="#常用的块状元素" class="headerlink" title="常用的块状元素"></a>常用的块状元素</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span>&gt;、&lt;<span class="selector-tag">p</span>&gt;、&lt;<span class="selector-tag">h1</span>&gt;...&lt;<span class="selector-tag">h6</span>&gt;、&lt;<span class="selector-tag">ol</span>&gt;、&lt;<span class="selector-tag">ul</span>&gt;、&lt;<span class="selector-tag">dl</span>&gt;、&lt;<span class="selector-tag">table</span>&gt;、&lt;<span class="selector-tag">address</span>&gt;、&lt;<span class="selector-tag">blockquote</span>&gt; 、&lt;<span class="selector-tag">form</span>&gt;</span><br></pre></td></tr></table></figure><h5 id="常用的内联元素"><a href="#常用的内联元素" class="headerlink" title="常用的内联元素"></a>常用的内联元素</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">a</span>&gt;、&lt;<span class="selector-tag">span</span>&gt;、&lt;<span class="selector-tag">br</span>&gt;、&lt;<span class="selector-tag">i</span>&gt;、&lt;<span class="selector-tag">em</span>&gt;、&lt;<span class="selector-tag">strong</span>&gt;、&lt;<span class="selector-tag">label</span>&gt;、&lt;<span class="selector-tag">q</span>&gt;、&lt;<span class="selector-tag">var</span>&gt;、&lt;<span class="selector-tag">cite</span>&gt;、&lt;<span class="selector-tag">code</span>&gt;</span><br></pre></td></tr></table></figure><h5 id="常用的内联块状元素"><a href="#常用的内联块状元素" class="headerlink" title="常用的内联块状元素"></a>常用的内联块状元素</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">img</span>&gt;、&lt;<span class="selector-tag">input</span>&gt;</span><br></pre></td></tr></table></figure><h5 id="几种元素转换"><a href="#几种元素转换" class="headerlink" title="几种元素转换"></a>几种元素转换</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.将<span class="selector-tag">a</span>标签转为块级标签</span><br><span class="line"><span class="selector-tag">a</span>&#123;<span class="attribute">display</span>:block;&#125;</span><br><span class="line">2.将块状元素<span class="selector-tag">div</span>转换为内联元素</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">     <span class="attribute">display</span>:inline;</span><br><span class="line">&#125;</span><br><span class="line">3.设置为内联块状</span><br><span class="line"><span class="selector-tag">display</span><span class="selector-pseudo">:inline-block</span>;</span><br><span class="line">4<span class="selector-class">.none</span>设置不显示</span><br><span class="line"><span class="selector-tag">display</span><span class="selector-pseudo">:none</span>;</span><br></pre></td></tr></table></figure><h4 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h4><p>辅助理解的视频：<a href="https://www.imooc.com/video/3225" target="_blank" rel="noopener">https://www.imooc.com/video/3225</a></p><p>内容被<code>padding</code>，<code>border</code>，<code>margin</code>三层包住，每层都有一定的宽度。</p><p>都可以设置<code>top</code>/<code>bottom</code>/<code>left</code>/<code>right</code>四个方向的属性</p><h5 id="基本设置盒子模型"><a href="#基本设置盒子模型" class="headerlink" title="基本设置盒子模型"></a>基本设置盒子模型</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">10px</span>;    </span><br><span class="line">    <span class="attribute">background-color</span>:red; <span class="comment">/*设置背景色*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/CSS3%2BHTML5/1.jpg" style="zoom:80%;" /> <img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/CSS3%2BHTML5/2.jpg" style="zoom:80%;" /></p><h4 id="设置盒子边框"><a href="#设置盒子边框" class="headerlink" title="设置盒子边框"></a>设置盒子边框</h4><p>盒子模型的边框就是围绕着内容及补白的线，这条线你可以设置它的粗细、样式和颜色(边框三个属性)。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">2px</span>  solid  red;</span><br><span class="line">&#125;</span><br><span class="line">上面是 <span class="selector-tag">border</span> 代码的缩写形式，可以分开写：</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">border-width</span>:<span class="number">2px</span>; <span class="comment">/*不常用的:thin | medium | thick*/</span></span><br><span class="line">    <span class="attribute">border-style</span>:solid; <span class="comment">/*边框样式: dashed（虚线）| dotted（点线）| solid（实线）。*/</span></span><br><span class="line">    <span class="attribute">border-color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*只加底部边框*/</span></span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">border-bottom</span>:<span class="number">2px</span> solid red; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*元素边框的圆角效果可以使用border-radius属性来设置。圆角可分为左上、右上、右下、左下。*/</span></span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">border-radius</span>: <span class="number">20px</span> <span class="number">10px</span> <span class="number">15px</span> <span class="number">30px</span>;&#125;</span><br></pre></td></tr></table></figure><h4 id="设置内边距"><a href="#设置内边距" class="headerlink" title="设置内边距"></a>设置内边距</h4><p>元素内容与边框之间是可以设置距离的，称之为“内边距（填充）”。填充也可分为上、右、下、左(顺时针)。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">padding</span>:<span class="number">20px</span> <span class="number">10px</span> <span class="number">15px</span> <span class="number">30px</span>;&#125;</span><br><span class="line"></span><br><span class="line">如果上、右、下、左的填充都为10<span class="selector-tag">px</span>;可以这么写</span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">padding</span>:<span class="number">10px</span>;&#125;</span><br><span class="line"></span><br><span class="line">如果上下填充一样为10<span class="selector-tag">px</span>，左右一样为20<span class="selector-tag">px</span>，可以这么写：</span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">padding</span>:<span class="number">10px</span> <span class="number">20px</span>;&#125;</span><br></pre></td></tr></table></figure><h4 id="设置外边距"><a href="#设置外边距" class="headerlink" title="设置外边距"></a>设置外边距</h4><p>元素与其它元素之间的距离可以使用边界（margin）来设置。边界也是可分为上、右、下、左。使用方法和内边距一样。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">margin</span>:<span class="number">20px</span> <span class="number">10px</span> <span class="number">15px</span> <span class="number">30px</span>;&#125;</span><br></pre></td></tr></table></figure><h3 id="13-CSS3布局模型"><a href="#13-CSS3布局模型" class="headerlink" title="13.CSS3布局模型"></a>13.CSS3布局模型</h3><p>在网页中，元素有三种布局模型：<br>1、流动模型（Flow）<br>2、浮动模型 (Float)<br>3、层模型（Layer）</p><h4 id="流动模型"><a href="#流动模型" class="headerlink" title="流动模型"></a>流动模型</h4><h5 id="典型特征"><a href="#典型特征" class="headerlink" title="典型特征"></a>典型特征</h5><p>第一点，<strong>块状元素</strong>都会在所处的<strong>包含元素内</strong>自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为<strong>100%</strong>。实际上，块状元素都会以行的形式占据位置。如右侧代码编辑器中三个块状元素标签(div，h1，p)宽度显示为100%。</p><p>第二点，在流动模型下，<strong>内联元素</strong>都会在所处的包含元素内从左到右水平分布显示。（内联元素可不像块状元素这么霸道独占一行）</p><h4 id="浮动模型"><a href="#浮动模型" class="headerlink" title="浮动模型"></a>浮动模型</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*让两个块状元素并排显示*/</span></span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">2px</span> red solid;</span><br><span class="line">    <span class="attribute">float</span>:left; <span class="comment">/*左对齐 right即为右对齐*/</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;div id="div1"&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id="div2"&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置div1和div2一个最左一个最右*/</span></span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">2px</span> red solid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#div1</span>&#123;<span class="attribute">float</span>:left;&#125;</span><br><span class="line"><span class="selector-id">#div2</span>&#123;<span class="attribute">float</span>:right;&#125; </span><br><span class="line"></span><br><span class="line">&lt;div id="div1"&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id="div2"&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="层模型"><a href="#层模型" class="headerlink" title="层模型"></a>层模型</h4><p>层模型有三种形式：</p><p>1、绝对定位(position: absolute)</p><p>2、相对定位(position: relative)</p><p>3、固定定位(position: fixed)</p><h5 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h5><p>如果想为元素设置层模型中的绝对定位，需要设置position:absolute(表示绝对定位)，这条语句的作用将元素<strong>从文档流中拖出来</strong>，然后使用left、right、top、bottom属性<strong>相对于</strong>其<strong>最接近的一个具有定位属性</strong>的<strong>父包含块</strong>进行绝对定位。如果不存在这样的包含块，则相对于body元素，即相对于<strong>浏览器窗口</strong>。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">实现<span class="selector-tag">div</span>元素相对于浏览器窗口向右移动100<span class="selector-tag">px</span>，向下移动50<span class="selector-tag">px</span>。</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">2px</span> red solid;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50px</span>;                                          </span><br><span class="line">&#125;</span><br><span class="line">&lt;div id="div1"&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h5 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h5><p>如果想为元素设置层模型中的相对定位，需要设置position:relative（表示相对定位），它通过left、right、top、bottom属性确定元素在<strong>正常文档流中</strong>的偏移位置。相对定位完成的过程是首先按static(float)方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于<strong>以前的位置移动，</strong>移动的方向和幅度由left、right、top、bottom属性确定，偏移前的位置保留不动。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">相对于以前位置向下移动50<span class="selector-tag">px</span>，向右移动100<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-id">#div1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">2px</span> red solid;</span><br><span class="line">    <span class="attribute">position</span>:relative;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div id="div1"&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h5 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h5><p>fixed：表示固定定位，与absolute定位类型类似，但它的相对移动的坐标是视图（屏幕内的网页窗口）本身。由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响，这与background-attachment:fixed;属性功能相同。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">实现相对于浏览器视图向右移动100<span class="selector-tag">px</span>，向下移动50<span class="selector-tag">px</span>。并且拖动滚动条时位置固定不变。</span><br><span class="line"><span class="selector-id">#div1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">2px</span> red solid;</span><br><span class="line">    <span class="attribute">position</span>:fixed;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;p&gt;文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本。&lt;/p&gt;</span><br></pre></td></tr></table></figure><h5 id="Relative与Absolute组合使用"><a href="#Relative与Absolute组合使用" class="headerlink" title="Relative与Absolute组合使用"></a>Relative与Absolute组合使用</h5><p>使用相对于某个元素的绝对定位</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1、参照定位的元素必须是相对定位元素的前辈元素：</span><br><span class="line">&lt;div id="box1"&gt;&lt;!--参照定位的元素--&gt;</span><br><span class="line">    &lt;div id="box2"&gt;相对参照元素进行定位&lt;/div&gt;&lt;!--相对定位元素--&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">从上面代码可以看出<span class="selector-tag">box1</span>是<span class="selector-tag">box2</span>的父元素（父元素当然也是前辈元素了）。</span><br><span class="line"></span><br><span class="line">2、参照定位的元素必须加入<span class="selector-tag">position</span><span class="selector-pseudo">:relative</span>;</span><br><span class="line"><span class="selector-id">#box1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">position</span>:relative;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3、定位元素加入<span class="selector-tag">position</span><span class="selector-pseudo">:absolute</span>，便可以使用<span class="selector-tag">top</span>、<span class="selector-tag">bottom</span>、<span class="selector-tag">left</span>、<span class="selector-tag">right</span>来进行偏移定位了。</span><br><span class="line"><span class="selector-id">#box2</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">30px</span>;         </span><br><span class="line">&#125;</span><br><span class="line">这样<span class="selector-tag">box2</span>就可以相对于父元素<span class="selector-tag">box1</span>定位了（这里注意参照物就可以不是浏览器了，而可以自由设置了）。</span><br></pre></td></tr></table></figure><h3 id="14-弹性盒模型"><a href="#14-弹性盒模型" class="headerlink" title="14.弹性盒模型"></a>14.弹性盒模型</h3><h4 id="设置flex"><a href="#设置flex" class="headerlink" title="设置flex"></a>设置flex</h4><p>三个块元素设置大小以及背景色，在父容器中添加flex。</p><p>技术点的解释：</p><p>1、设置display: flex属性可以把块级元素在一排显示。</p><p>2、flex需要添加在父元素上，改变子元素的排列顺序。</p><p>3、默认为从左往右依次排列,且和父元素左边没有间隙。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class="box"&gt;</span><br><span class="line">    &lt;div class="box1"&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class="box2"&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class="box3"&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line">    <span class="selector-class">.box</span> &#123;</span><br><span class="line">        <span class="attribute">background</span>: blue;</span><br><span class="line">        <span class="attribute">display</span>: flex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.box</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.box1</span> &#123;</span><br><span class="line">        <span class="attribute">background</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.box2</span> &#123;</span><br><span class="line">        <span class="attribute">background</span>: orange;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.box3</span> &#123;</span><br><span class="line">        <span class="attribute">background</span>: green;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h4 id="使用justify-content属性设置横轴排列方式"><a href="#使用justify-content属性设置横轴排列方式" class="headerlink" title="使用justify-content属性设置横轴排列方式"></a>使用justify-content属性设置横轴排列方式</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">justify-content: flex-start | flex-end | center | space-between | space-around;</span><br></pre></td></tr></table></figure><p><code>flex-start</code>：交叉轴的起点对齐</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">       <span class="attribute">background</span>: blue;</span><br><span class="line">       <span class="attribute">display</span>: flex;</span><br><span class="line">       <span class="attribute">justify-content</span>: flex-start;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><a href="https://img.mukewang.com/5e959b080001a38d25340322.jpg" target="_blank" rel="noopener"><img src="https://img.mukewang.com/5e959b080001a38d25340322.jpg" alt="img"></a></p><p><code>flex-end</code>：右对齐</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">       <span class="attribute">background</span>: blue;</span><br><span class="line">       <span class="attribute">display</span>: flex;</span><br><span class="line">       <span class="attribute">justify-content</span>: flex-end;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><a href="https://img1.mukewang.com/5e959b8b0001d43b25420308.jpg" target="_blank" rel="noopener"><img src="https://img1.mukewang.com/5e959b8b0001d43b25420308.jpg" alt="img"></a></p><p><code>center</code>： 居中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">       <span class="attribute">background</span>: blue;</span><br><span class="line">       <span class="attribute">display</span>: flex;</span><br><span class="line">       <span class="attribute">justify-content</span>: center;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><a href="https://img2.mukewang.com/5e959bdd0001ad2125300303.jpg" target="_blank" rel="noopener"><img src="https://img2.mukewang.com/5e959bdd0001ad2125300303.jpg" alt="img"></a></p><p><code>space-between</code>：两端对齐，项目之间的间隔都相等。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">       <span class="attribute">background</span>: blue;</span><br><span class="line">       <span class="attribute">display</span>: flex;</span><br><span class="line">       <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><a href="https://img2.mukewang.com/5e959c6400017b1c25530313.jpg" target="_blank" rel="noopener"><img src="https://img2.mukewang.com/5e959c6400017b1c25530313.jpg" alt="img"></a></p><p><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">        <span class="attribute">background</span>: blue;</span><br><span class="line">        <span class="attribute">display</span>: flex;</span><br><span class="line">        <span class="attribute">justify-content</span>: space-around;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><a href="https://img2.mukewang.com/5e959caf000113b125370303.jpg" target="_blank" rel="noopener"><img src="https://img2.mukewang.com/5e959caf000113b125370303.jpg" alt="img"></a></p><h4 id="使用align-items属性设置纵轴排列方式"><a href="#使用align-items属性设置纵轴排列方式" class="headerlink" title="使用align-items属性设置纵轴排列方式"></a>使用align-items属性设置纵轴排列方式</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-items: flex-start | flex-end | center | baseline | stretch;</span><br></pre></td></tr></table></figure><p><code>flex-start</code>：默认值，左对齐</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">700px</span>;</span><br><span class="line">     <span class="attribute">background</span>: blue;</span><br><span class="line">     <span class="attribute">display</span>: flex;</span><br><span class="line">     <span class="attribute">align-items</span>: flex-start;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><a href="https://img3.mukewang.com/5e95a3720001140325381051.jpg" target="_blank" rel="noopener"><img src="https://img3.mukewang.com/5e95a3720001140325381051.jpg" alt="img"></a></p><p><code>flex-end</code>：交叉轴的终点对齐</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">       <span class="attribute">height</span>: <span class="number">700px</span>;</span><br><span class="line">       <span class="attribute">background</span>: blue;</span><br><span class="line">       <span class="attribute">display</span>: flex;</span><br><span class="line">       <span class="attribute">align-items</span>: flex-end;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><a href="https://img2.mukewang.com/5e95a3ca0001550a25381056.jpg" target="_blank" rel="noopener"><img src="https://img2.mukewang.com/5e95a3ca0001550a25381056.jpg" alt="img"></a></p><p><code>center</code>： 交叉轴的中点对齐</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">700px</span>;</span><br><span class="line">        <span class="attribute">background</span>: blue;</span><br><span class="line">        <span class="attribute">display</span>: flex;</span><br><span class="line">        <span class="attribute">align-items</span>: center;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><a href="https://img3.mukewang.com/5e9667880001796c25371056.jpg" target="_blank" rel="noopener"><img src="https://img3.mukewang.com/5e9667880001796c25371056.jpg" alt="img"></a></p><p><code>baseline</code>：项目的第一行文字的基线对齐。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">700px</span>;</span><br><span class="line">        <span class="attribute">background</span>: blue;</span><br><span class="line">        <span class="attribute">display</span>: flex;</span><br><span class="line">        <span class="attribute">align-items</span>: baseline;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>三个盒子中设置不同的字体大小，可以参考右侧编辑器中的代码进行测试。</p><p>实现效果：</p><p><a href="https://img3.mukewang.com/5e9668ff0001f8f125341053.jpg" target="_blank" rel="noopener"><img src="https://img3.mukewang.com/5e9668ff0001f8f125341053.jpg" alt="img"></a></p><p><code>stretch（默认值）</code>：如果项目未设置高度或设为auto，将占满整个容器的高度。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">       <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">       <span class="attribute">background</span>: blue;</span><br><span class="line">       <span class="attribute">display</span>: flex;</span><br><span class="line">       <span class="attribute">align-items</span>: stretch;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="selector-class">.box</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">       <span class="comment">/*不设置高度，元素在垂直方向上铺满父容器*/</span></span><br><span class="line">       <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><a href="https://img2.mukewang.com/5e9669ef00017e0e25390453.jpg" target="_blank" rel="noopener"><img src="https://img2.mukewang.com/5e9669ef00017e0e25390453.jpg" alt="img"></a></p><h4 id="给子元素设置flex占比"><a href="#给子元素设置flex占比" class="headerlink" title="给子元素设置flex占比"></a>给子元素设置flex占比</h4><p><a href="https://img3.mukewang.com/5e966c3100011c5b25430450.jpg" target="_blank" rel="noopener"><img src="https://img3.mukewang.com/5e966c3100011c5b25430450.jpg" alt="img"></a></p><p><strong>技术点的解释：</strong></p><p>1、给子元素设置flex属性,可以设置子元素相对于父元素的占比。</p><p>2、flex属性的值只能是正整数,表示占比多少。其实是几个子块的比</p><p>3、给子元素设置了flex之后,其宽度属性会失效。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="selector-tag">DOCTYPE</span> <span class="selector-tag">html</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">html</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">head</span>&gt;</span><br><span class="line">    &lt;meta charset="UTF-8"&gt;</span><br><span class="line">    &lt;title&gt;flex占比&lt;/title&gt;</span><br><span class="line">    &lt;style type="text/css"&gt;</span><br><span class="line">    <span class="selector-class">.box</span> &#123;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">        <span class="attribute">background</span>: blue;</span><br><span class="line">        <span class="attribute">display</span>: flex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.box</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.box1</span> &#123;</span><br><span class="line">        <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">        <span class="attribute">background</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.box2</span> &#123;</span><br><span class="line">        <span class="attribute">flex</span>: <span class="number">3</span>;</span><br><span class="line">        <span class="attribute">background</span>: orange;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.box3</span> &#123;</span><br><span class="line">        <span class="attribute">flex</span>: <span class="number">2</span>;</span><br><span class="line">        <span class="attribute">background</span>: green;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">    &lt;div class="box"&gt;</span><br><span class="line">        &lt;div class="box1"&gt;flex:1&lt;/div&gt;</span><br><span class="line">        &lt;div class="box2"&gt;flex:3&lt;/div&gt;</span><br><span class="line">        &lt;div class="box3"&gt;flex:2&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="15-css样式设置技巧"><a href="#15-css样式设置技巧" class="headerlink" title="15.css样式设置技巧"></a>15.css样式设置技巧</h3><h4 id="水平居中设置-行内元素"><a href="#水平居中设置-行内元素" class="headerlink" title="水平居中设置-行内元素"></a>水平居中设置-行内元素</h4><p>如果被设置元素为文本、图片等行内元素时，水平居中是通过给父元素设置 <code>text-align:center</code> 来实现的。</p><h4 id="水平居中设置-定宽块状元素"><a href="#水平居中设置-定宽块状元素" class="headerlink" title="水平居中设置-定宽块状元素"></a>水平居中设置-定宽块状元素</h4><p>当被设置元素为 块状元素 时用 <code>text-align：center</code> 就不起作用了，这时也分两种情况：<strong>定宽块状元素</strong>和<strong>不定宽块状元素</strong>。</p><h5 id="定宽块状元素：块状元素的宽度width为固定值。"><a href="#定宽块状元素：块状元素的宽度width为固定值。" class="headerlink" title="定宽块状元素：块状元素的宽度width为固定值。"></a>定宽块状元素：块状元素的宽度width为固定值。</h5><p>满足定宽和块状两个条件的元素是可以通过设置“左右margin”值为“auto”来实现居中的。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">  &lt;div&gt;我是定宽块状元素，哈哈，我要水平居中显示。&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid red;<span class="comment">/*为了显示居中效果明显为 div 设置了边框*/</span></span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;<span class="comment">/*定宽*/</span></span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">20px</span> auto;<span class="comment">/* margin-left 与 margin-right 设置为 auto */</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h4 id="面试常考题之已知宽高实现盒子水平垂直居中"><a href="#面试常考题之已知宽高实现盒子水平垂直居中" class="headerlink" title="面试常考题之已知宽高实现盒子水平垂直居中"></a>面试常考题之已知宽高实现盒子水平垂直居中</h4><p>这一章节我们来学习已知宽高实现盒子水平垂直居中。通常使用定位完成，例如想要实现以下效果：</p><p><a href="https://img4.mukewang.com/5e967bb40001e35725570475.jpg" target="_blank" rel="noopener"><img src="https://img4.mukewang.com/5e967bb40001e35725570475.jpg" alt="img"></a></p><p>我们有如下两个div元素</p><p><img src="https://img3.mukewang.com/5e967a0500013c9104650162.jpg" alt="img"></p><p>要实现子元素相对于父元素垂直水平居中,我们只需要输入以下代码：</p><p><a href="https://img.mukewang.com/5e967a380001840f11050487.jpg" target="_blank" rel="noopener"><img src="https://img.mukewang.com/5e967a380001840f11050487.jpg" alt="img"></a></p><p><strong>技术点的解释：</strong></p><p>1、利用父元素设置相对定位,子元素设置绝对定位,那么子元素就是相对于父元素定位的特性。</p><p>2、子元素设置上和左偏移的值都为50%，是元素的左上角在父元素中心点的位置。效果：</p><p><a href="https://img2.mukewang.com/5e967c3d0001fbbf25600616.jpg" target="_blank" rel="noopener"><img src="https://img2.mukewang.com/5e967c3d0001fbbf25600616.jpg" alt="img"></a></p><p>3、然后再用margin给上和左都给负的自身宽高的一半,就能达到垂直水平居中的效果。</p><h4 id="面试常考题之宽高不定实现盒子水平垂直居中"><a href="#面试常考题之宽高不定实现盒子水平垂直居中" class="headerlink" title="面试常考题之宽高不定实现盒子水平垂直居中"></a>面试常考题之宽高不定实现盒子水平垂直居中</h4><p>这一章我们来学习未知宽高实现盒子水平垂直居中，通常使用定位以及translate完成。参考下面例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box1"</span>&gt;</span></span><br><span class="line">           慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网</span><br><span class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">       <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#00ee00</span>;</span><br><span class="line">       <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">       <span class="attribute">position</span>: relative;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="selector-class">.box1</span> &#123;</span><br><span class="line">       <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">       <span class="attribute">position</span>: absolute;</span><br><span class="line">       <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">       <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">       <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><a href="https://img4.mukewang.com/5e967f3b000117da25530461.jpg" target="_blank" rel="noopener"><img src="https://img4.mukewang.com/5e967f3b000117da25530461.jpg" alt="img"></a></p><p><strong>技术点的解释：</strong></p><p>1、利用父元素设置相对定位,子元素设置绝对定位,那么子元素就是相对于父元素定位的特性。</p><p>2、子元素设置上和左偏移的值都为50%。</p><p>3、然后再用css3属性translate位移,给上和左都位移-50%距离，就能达到垂直水平居中的效果。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计组笔记-P0-logisim状态机搭建</title>
      <link href="2021/01/29/CO-P0-logisim%E7%8A%B6%E6%80%81%E6%9C%BA%E6%90%AD%E5%BB%BA/"/>
      <url>2021/01/29/CO-P0-logisim%E7%8A%B6%E6%80%81%E6%9C%BA%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>北航计算机组成原理课程设计的Project0笔记，主要是关于logisim的使用和状态机的搭建。</p><a id="more"></a><h2 id="p0复习（logisim）"><a href="#p0复习（logisim）" class="headerlink" title="p0复习（logisim）"></a>p0复习（logisim）</h2><h3 id="注意的点"><a href="#注意的点" class="headerlink" title="注意的点"></a>注意的点</h3><ul><li>输入信号一般是通过<strong>MUX，多路选择器</strong>来实现对输出结果的控制。</li><li>刚连接好电路时或者连接电路中，可能出现有一些线路<strong>莫名其妙是蓝色</strong>，这时<strong>关闭logisim后再次打开</strong>往往就好了。</li><li><strong>comparator</strong>器件默认是有符号的，要调成<strong>unsigned</strong>来避免出现无符号数比较出现错误。</li><li>一些<strong>Arithmetic</strong>模块器件使用时，由于<strong>上下两侧也有输出端</strong>，如果连在一起可能出现意外。</li><li>组合逻辑部分如果输入、输出的位数较少，可直接用<strong>combinational analysis</strong> 里的 <strong>table</strong> 傻瓜式生成电路。</li><li>出现“xxxx”或者“EEEE”往往是因为电路中有<strong>连错的电路</strong>，比如<strong>把输入当成输出元件连了；某条线没有连接在模块/元件的端口上，而是连在了空白区域</strong>。</li><li>出现“ ”、fewer than output we expected可能是时序问题，比如超出了题目给出的时间。或者期待输出非零值时输出了0。也有可能是<strong>appearance</strong>不对</li><li>DMX最好设置成 <strong>Three-state:Yes</strong>    <strong>Disabled output:Float</strong>  如果Three state勾选为yes，那么DMX输出端<strong>没有被选中的路径</strong>会<strong>保持</strong>原来的值不变</li></ul><h3 id="时序逻辑—状态机"><a href="#时序逻辑—状态机" class="headerlink" title="时序逻辑—状态机"></a>时序逻辑—状态机</h3><p><strong>参考文章</strong>：<a href="https://www.cnblogs.com/BUAA-YiFei/articles/13855136.html" target="_blank" rel="noopener">lyyf的logisim状态机博客</a></p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li><strong>状态转移、输出逻辑</strong>用<strong>真值表生成</strong>。</li><li>寄存器的Q端在<strong>时钟信号为0时</strong>的值为<strong>初态</strong>，时钟信号的<strong>上升沿</strong>更新为<strong>次态</strong>。</li><li><strong>Moore输出逻辑</strong>，只和<strong>当前状态</strong>有关。</li><li><strong>Mealy输出逻辑</strong>，除了<strong>当前状态</strong>，还必须和<strong>输入</strong>发生联系。</li><li>（<strong>当前状态值</strong>：时钟上升沿前是寄存器现有的值，上升沿时是状态转移模块的输出值s’）</li></ul><h4 id="Moore型"><a href="#Moore型" class="headerlink" title="Moore型"></a>Moore型</h4><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/moore.png" alt=""></p><h4 id="Mealy型"><a href="#Mealy型" class="headerlink" title="Mealy型"></a>Mealy型</h4><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/mealy.png" alt=""></p><h4 id="同步复位"><a href="#同步复位" class="headerlink" title="同步复位"></a>同步复位</h4><p>具体来说就是用一个多路选择器，如果复位信号<strong>为0</strong>，则<strong>正常更新状态值</strong>，<strong>如果为1</strong>，就直接赋值给寄存器<strong>常量0</strong>。</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/同步复位.png" alt=""></p><h4 id="异步复位"><a href="#异步复位" class="headerlink" title="异步复位"></a>异步复位</h4><p>直接使用寄存器自带的<strong>clear</strong>端口进行复位即可</p><p>王pb助教的logisim评测帖子：<a href="http://cscore.net.cn/courses/course-v1:Internal+B3I062410+2020_T1/discussion/forum/course/threads/5f8ab909cf9bcc0efe0000bd" target="_blank" rel="noopener">http://cscore.net.cn/courses/course-v1:Internal+B3I062410+2020_T1/discussion/forum/course/threads/5f8ab909cf9bcc0efe0000bd</a></p><h3 id="logisim命令行调试"><a href="#logisim命令行调试" class="headerlink" title="logisim命令行调试"></a>logisim命令行调试</h3><p>要用 jar 文件</p><p>我的电脑：java -jar logisim-generic-2.7.1.jar fsm.circ -tty table</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-CO-2020 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL学习笔记</title>
      <link href="2021/01/29/sql-note/"/>
      <url>2021/01/29/sql-note/</url>
      
        <content type="html"><![CDATA[<p>最近结合廖雪峰教程学习了和sql,mysql相关的一些知识，对重要的部分做了一些梳理。<br><a id="more"></a></p><h2 id="英文教程"><a href="#英文教程" class="headerlink" title="英文教程"></a>英文教程</h2><h5 id="How-to-Load-the-Sample-Database-into-MySQL-Server"><a href="#How-to-Load-the-Sample-Database-into-MySQL-Server" class="headerlink" title="How to Load the Sample Database into MySQL Server"></a><a href="https://www.mysqltutorial.org/how-to-load-sample-database-into-mysql-database-server.aspx" target="_blank" rel="noopener">How to Load the Sample Database into MySQL Server</a></h5><h5 id="https-www-mysqltutorial-org"><a href="#https-www-mysqltutorial-org" class="headerlink" title="https://www.mysqltutorial.org/"></a><a href="https://www.mysqltutorial.org/" target="_blank" rel="noopener">https://www.mysqltutorial.org/</a></h5><h2 id="SQL教程（廖雪峰）笔记"><a href="#SQL教程（廖雪峰）笔记" class="headerlink" title="SQL教程（廖雪峰）笔记"></a>SQL教程（廖雪峰）笔记</h2><h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><p>关系数据库是建立在关系模型上的。而关系模型本质上就是若干个存储数据的<strong>二维表</strong>，可以把它们看作很多<strong>Excel表</strong>。</p><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><h4 id="脚本生成数据方式"><a href="#脚本生成数据方式" class="headerlink" title="脚本生成数据方式"></a>脚本生成数据方式</h4><p>1.打开MYSQL-command line </p><p>2.输入source 将相应的sql文件对应的地址输入（或者直接把文件拖入命令行）</p><p>廖老师的sql文件：<a href="F:\学习\工程与应用科学\CS技术学习\SQL-learn\init-test-data.sql">init-test-data.sql</a></p><p>3.<code>SHOW DATABASE</code>可以查看已有数据库</p><h4 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h4><p>使用SELECT查询的基本语句<code>SELECT * FROM &lt;表名&gt;</code>可以查询一个表的所有行和所有列的数据。</p><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &lt;表名&gt; WHERE &lt;条件表达式&gt;</span><br><span class="line">SELECT * FROM students WHERE score &gt;&#x3D; 80;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:left">条件</th><th style="text-align:left">表达式举例1</th><th style="text-align:left">表达式举例2</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">使用=判断相等</td><td style="text-align:left">score = 80</td><td style="text-align:left">name = ‘abc’</td><td style="text-align:left">字符串需要用单引号括起来</td></tr><tr><td style="text-align:left">使用&gt;判断大于</td><td style="text-align:left">score &gt; 80</td><td style="text-align:left">name &gt; ‘abc’</td><td style="text-align:left">字符串比较根据ASCII码，中文字符比较根据数据库设置</td></tr><tr><td style="text-align:left">使用&gt;=判断大于或相等</td><td style="text-align:left">score &gt;= 80</td><td style="text-align:left">name &gt;= ‘abc’</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">使用&lt;判断小于</td><td style="text-align:left">score &lt; 80</td><td style="text-align:left">name &lt;= ‘abc’</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">使用&lt;=判断小于或相等</td><td style="text-align:left">score &lt;= 80</td><td style="text-align:left">name &lt;= ‘abc’</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">使用&lt;&gt;判断不相等</td><td style="text-align:left">score &lt;&gt; 80</td><td style="text-align:left">name &lt;&gt; ‘abc’</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">使用LIKE判断相似</td><td style="text-align:left">name LIKE ‘ab%’</td><td style="text-align:left">name LIKE ‘%bc%’</td><td style="text-align:left">%表示任意字符，例如’ab%’将匹配’ab’，’abc’，’abcd’</td></tr><tr><td style="text-align:left">BETWEEN a AND b</td><td style="text-align:left">BETWEEN 60 AND 90</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">IN (a,b)</td><td style="text-align:left">是否等于a或b</td><td style="text-align:left"></td></tr></tbody></table></div><h4 id="投影查询"><a href="#投影查询" class="headerlink" title="投影查询"></a>投影查询</h4><p>基本格式：<code>SELECT 列1, 列2, 列3 FROM students</code></p><p>使用<code>SELECT 列1, 列2, 列3 FROM ...</code>时，还可以给每一列起个别名，这样，结果集的列名就可以与原表的列名不同。它的语法是<code>SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM ...</code>。</p><p>例如，以下<code>SELECT</code>语句将列名<code>score</code>重命名为<code>points</code>，而<code>id</code>和<code>name</code>列名保持不变：</p><p><code>SELECT id, score points, name FROM students;</code></p><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>查询结果集通常是按照<code>id</code>排序的，也就是根据主键排序。要根据其他条件排序——加上ORDER BY子句</p><p><strong>默认的排序规则</strong>是<code>ASC</code>：“<strong>升序</strong>”，即从小到大。ASC可以省略，即<code>ORDER BY score ASC和ORDER BY score</code>效果一样。</p><p>加上<code>DESC</code>表示“<strong>倒序</strong>”</p><p>如果score列有相同的数据，要进一步排序，可以继续添加列名。例如，使用<code>ORDER BY score DESC, gender</code>表示先按score列倒序，如果有相同分数的，再按gender列排序：</p><p>如果有<code>WHERE</code>子句，那么<code>ORDER BY</code>子句要放到WHERE子句后面。</p><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><p>使用<code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code>可以对结果集进行分页，每次查询返回结果集的一部分；</p><p>offset—从第几条记录开始查</p><p>limit—最多显示多少条数据</p><p>分页查询需要先确定每页的数量和当前页数，然后确定LIMIT和OFFSET的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, name, gender, score</span><br><span class="line">FROM students</span><br><span class="line">ORDER BY score DESC</span><br><span class="line">LIMIT 3 OFFSET 0;</span><br></pre></td></tr></table></figure><h4 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h4><p>对于统计总数、平均数这类计算，SQL提供了专门的聚合函数，使用聚合函数进行查询，就是聚合查询，它可以快速获得结果。</p><p><code>SELECT COUNT(*) FROM students;</code></p><p><code>COUNT(*)</code>表示查询所有列的行数，要注意聚合的计算结果虽然是一个数字，但查询的结果仍然是一个二维表，只是这个二维表只有一行一列，并且列名是<code>COUNT(*)</code>。通常，使用聚合查询时，我们应该给列名设置一个别名，便于处理结果：</p><p><code>SELECT COUNT(*) num FROM students;</code></p><p>聚合查询同样可以使用WHERE条件</p><p>除了COUNT()函数外，SQL还提供了如下聚合函数：</p><div class="table-container"><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">SUM</td><td style="text-align:left">计算某一列的合计值，该列必须为数值类型</td></tr><tr><td style="text-align:left">AVG</td><td style="text-align:left">计算某一列的平均值，该列必须为数值类型</td></tr><tr><td style="text-align:left">MAX</td><td style="text-align:left">计算某一列的最大值</td></tr><tr><td style="text-align:left">MIN</td><td style="text-align:left">计算某一列的最小值</td></tr></tbody></table></div><p>要特别注意：如果聚合查询的<code>WHERE</code>条件没有匹配到任何行，<code>COUNT()</code>会返回0，而<code>SUM()</code>、<code>AVG()</code>、<code>MAX()</code>和<code>MIN()</code>会返回<code>NULL</code>：</p><p>每页3条记录，如何通过聚合查询获得总页数？——<code>SELECT CEILING(COUNT(*) / 3) FROM students;</code></p><h5 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h5><p>按class_id分组: <code>SELECT COUNT(*) num FROM students GROUP BY class_id;</code></p><p><code>SELECT class_id, COUNT(*) num FROM students GROUP BY class_id;</code></p><p>请使用一条SELECT查询查出每个班级男生和女生的平均分：<code>SELECT class_id,gender,AVG(score) FROM students GROUP BY class_id,gender;</code></p><h4 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h4><p><code>SELECT * FROM &lt;表1&gt; &lt;表2&gt;</code></p><p>注意，多表查询时，要使用<code>表名.列名</code>这样的方式来引用列和设置别名，这样就避免了结果集的列名重复问题。但是，用<code>表名.列名</code>这种方式列举两个表的所有列实在是很麻烦，所以SQL还允许给表设置一个别名，让我们在投影查询中引用起来稍微简洁一点：</p><p><code>SELECT s.id sid, s.name, s.gender, s.score, c.id cid, c.name cname FROM students s, classes c;</code></p><p>注意到<code>FROM</code>子句给表设置别名的语法是<code>FROM &lt;表名1&gt; &lt;别名1&gt;, &lt;表名2&gt; &lt;别名2&gt;</code>。这样我们用别名<code>s</code>和<code>c</code>分别表示<code>students</code>表和<code>classes</code>表。</p><p>使用多表查询可以获取M x N行记录；</p><p>多表查询的结果集可能非常巨大，要小心使用。</p><h4 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h4><p>注意<strong>INNER JOIN</strong>查询的写法是：</p><ol><li>先确定主表，仍然使用<code>FROM &lt;表1&gt;</code>的语法；</li><li>再确定需要连接的表，使用<code>INNER JOIN &lt;表2&gt;</code>的语法；</li><li>然后确定连接条件，使用<code>ON &lt;条件...&gt;</code>，这里的条件是<code>s.class_id = c.id</code>，表示<code>students</code>表的<code>class_id</code>列与<code>classes</code>表的<code>id</code>列相同的行需要连接；</li><li>可选：加上<code>WHERE</code>子句、<code>ORDER BY</code>等子句。</li></ol><p>有<strong>RIGHT OUTER JOIN，就有LEFT OUTER JOIN，以及FULL OUTER JOIN</strong>。它们的区别是：</p><ul><li><p>INNER JOIN只返回同时存在于两张表的行数据，由于students表的class_id包含1，2，3，classes表的id包含1，2，3，4，所以，INNER JOIN根据条件s.class_id = c.id返回的结果集仅包含1，2，3。</p></li><li><p>RIGHT OUTER JOIN返回右表都存在的行。如果某一行仅在右表存在，那么结果集就会以NULL填充剩下的字段。</p></li><li><p>LEFT OUTER JOIN则返回左表都存在的行。如果我们给students表增加一行，并添加class_id=5，由于classes表并不存在id=5的行，所以，LEFT OUTER JOIN的结果会增加一行，对应的class_name是NULL：</p></li></ul><h4 id="查询数据方式小结"><a href="#查询数据方式小结" class="headerlink" title="查询数据方式小结"></a>查询数据方式小结</h4><p>代码形式总结知识点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT col1_name,col2_name,(COUNT(*),(AVG(col3_name)) average) #基本查询方式 聚合查询——聚合函数 投影查询</span><br><span class="line">FROM excel1_name replace1_name (,excel2_name replace2_name) #多表查询 同表名字替换</span><br><span class="line">INNER(&#x2F;FULL OUTER&#x2F;RIGHT OUTER&#x2F;LEFT OUTER)  JOIN classes c #连接查询</span><br><span class="line">(GROUP BY colx_name) #聚合查询——分组查询</span><br><span class="line">WHERE (EXPRESSION) #条件查询</span><br><span class="line">ORDER BY coly_name (ASC&#x2F;DESC) #排序</span><br><span class="line">LIMIT m OFFSET n; #分页查询</span><br></pre></td></tr></table></figure><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p>关系数据库的基本操作就是增删改查，即CRUD：Create、Retrieve、Update、Delete。</p><p>而对于增、删、改，对应的SQL语句分别是：</p><ul><li>INSERT：插入新记录；</li><li>UPDATE：更新已有记录；</li><li>DELETE：删除已有记录。</li></ul><h4 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h4><p><code>INSERT INTO &lt;表名&gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...);</code></p><p>注意到我们并没有列出<code>id</code>字段，也没有列出<code>id</code>字段对应的值，这是因为<code>id</code>字段是一个自增主键，它的值可以由数据库自己推算出来。此外，如果一个字段有默认值，那么在<code>INSERT</code>语句中也可以不出现。</p><p>还可以一次性添加多条记录，只需要在<code>VALUES</code>子句中指定多个记录值，每个记录是由<code>(...)</code>包含的一组值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO students (class_id, name, gender, score) VALUES</span><br><span class="line">  (1, &#39;大宝&#39;, &#39;M&#39;, 87),</span><br><span class="line">  (2, &#39;二宝&#39;, &#39;M&#39;, 81);</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure><h4 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h4><p><code>UPDATE &lt;表名&gt; SET 字段1=值1, 字段2=值2, ... WHERE ...;</code></p><p>可以一次更新多条记录</p><h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><p><code>DELETE FROM &lt;表名&gt; WHERE ...;</code></p><p>不带<code>WHERE</code>条件的<code>DELETE</code>语句会删除整个表的数据</p><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>查找MYSQL安装目录方法：进入mysql命令行输入：<code>show variables like &quot;%char%&quot;;</code></p><p>我的：C:\Program Files\MySQL\MySQL Server 8.0\bin</p><p><strong>加环境变量</strong>：我的计算机——属性——高级系统设置——环境变量——在用户变量和系统变量的path处加地址</p><p>打开命令提示符，输入命令<code>mysql -u root -p</code>，提示输入口令。填入MySQL的<code>root</code>口令，如果正确，就连上了MySQL Server，同时提示符变为<code>mysql&gt;</code>：</p><p>输入<code>exit</code>断开与MySQL Server的连接并返回到命令提示符。</p><p>MySQL Client的可执行程序是mysql，MySQL Server的可执行程序是mysqld。</p><p>MySQL Client和MySQL Server的关系如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──────────────┐  SQL   ┌──────────────┐</span><br><span class="line">│ MySQL Client │───────&gt;│ MySQL Server │</span><br><span class="line">└──────────────┘  TCP   └──────────────┘</span><br></pre></td></tr></table></figure><p>在MySQL Client中输入的SQL语句通过TCP连接发送到MySQL Server。默认端口号是3306，即如果发送到本机MySQL Server，地址就是<code>127.0.0.1:3306</code>。</p><p>也可以只安装MySQL Client，然后连接到远程MySQL Server。假设远程MySQL Server的IP地址是<code>10.0.1.99</code>，那么就使用<code>-h</code>指定IP或域名：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h <span class="number">10</span>.<span class="number">0</span>.<span class="number">1</span>.<span class="number">99</span> -u root -p</span><br></pre></td></tr></table></figure><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>命令行程序<code>mysql</code>实际上是MySQL客户端，真正的MySQL服务器程序是<code>mysqld</code>，在后台运行。</p><h4 id="管理MySQL"><a href="#管理MySQL" class="headerlink" title="管理MySQL"></a>管理MySQL</h4><p>要管理MySQL，可以使用可视化图形界面MySQL Workbench。</p><p>MySQL Workbench可以用可视化的方式查询、创建和修改数据库表，但是，归根到底，MySQL Workbench是一个图形客户端，它对MySQL的操作仍然是发送SQL语句并执行。因此，本质上，MySQL Workbench和MySQL Client命令行都是客户端，和MySQL交互，唯一的接口就是SQL。</p><p>因此，MySQL提供了大量的SQL语句用于管理。虽然可以使用MySQL Workbench图形界面来直接管理MySQL，但是，很多时候，通过SSH远程连接时，只能使用SQL命令，所以，了解并掌握常用的SQL管理操作是必须的。</p><h5 id="1-数据库"><a href="#1-数据库" class="headerlink" title="1.数据库"></a>1.数据库</h5><p>在一个运行MySQL的服务器上，实际上可以创建多个数据库（Database）。要列出所有数据库，使用命令：<code>SHOW DATABASES</code></p><p>其中，<code>information_schema</code>、<code>mysql</code>、<code>performance_schema</code>和<code>sys</code>是系统库，不要去改动它们。其他的是用户创建的数据库。</p><p>要<strong>创建</strong>一个新数据库，使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE test;</span><br></pre></td></tr></table></figure><p>要<strong>删除</strong>一个数据库，使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE test;</span><br></pre></td></tr></table></figure><p>注意：删除一个数据库将导致该数据库的所有表全部被删除。</p><p>对一个数据库进行操作时，要首先将其切换为当前数据库：<code>USE test;</code></p><h5 id="2-表"><a href="#2-表" class="headerlink" title="2.表"></a>2.表</h5><p>列出当前数据库的所有表，使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure><p>要查看一个表的结构，使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC students;</span><br></pre></td></tr></table></figure><p>还可以使用以下命令查看创建表的SQL语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE TABLE students;</span><br></pre></td></tr></table></figure><p>创建表使用<code>CREATE TABLE</code>语句，而删除表使用<code>DROP TABLE</code>语句：</p><p>修改表就比较复杂。如果要给<code>students</code>表新增一列<code>birth</code>，使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students ADD COLUMN birth VARCHAR(10) NOT NULL;</span><br></pre></td></tr></table></figure><p>要修改<code>birth</code>列，例如把列名改为<code>birthday</code>，类型改为<code>VARCHAR(20)</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students CHANGE COLUMN birth birthday VARCHAR(20) NOT NULL;</span><br></pre></td></tr></table></figure><p>要删除列，使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students DROP COLUMN birthday;</span><br></pre></td></tr></table></figure><h5 id="3-退出MySQL"><a href="#3-退出MySQL" class="headerlink" title="3.退出MySQL"></a>3.退出MySQL</h5><p>使用<code>EXIT</code>命令退出MySQL</p><h4 id="实用SQL语句"><a href="#实用SQL语句" class="headerlink" title="实用SQL语句"></a>实用SQL语句</h4><p>在编写SQL时，灵活运用一些技巧，可以大大简化程序逻辑。</p><h5 id="1-插入或替换"><a href="#1-插入或替换" class="headerlink" title="1.插入或替换"></a>1.插入或替换</h5><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就先删除原记录，再插入新记录。此时，可以使用<code>REPLACE</code>语句，这样就不必先查询，再决定是否先删除再插入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLACE INTO students (id, class_id, name, gender, score) VALUES (1, 1, &#39;小明&#39;, &#39;F&#39;, 99);</span><br></pre></td></tr></table></figure><p>若<code>id=1</code>的记录不存在，<code>REPLACE</code>语句将插入新记录，否则，当前<code>id=1</code>的记录将被删除，然后再插入新记录。</p><h5 id="2-插入或更新"><a href="#2-插入或更新" class="headerlink" title="2.插入或更新"></a>2.插入或更新</h5><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就更新该记录，此时，可以使用<code>INSERT INTO ... ON DUPLICATE KEY UPDATE ...</code>语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO students (id, class_id, name, gender, score) VALUES (1, 1, &#39;小明&#39;, &#39;F&#39;, 99) ON DUPLICATE KEY UPDATE name&#x3D;&#39;小明&#39;, gender&#x3D;&#39;F&#39;, score&#x3D;99;</span><br></pre></td></tr></table></figure><p>若<code>id=1</code>的记录不存在，<code>INSERT</code>语句将插入新记录，否则，当前<code>id=1</code>的记录将被更新，更新的字段由<code>UPDATE</code>指定。</p><h5 id="3-插入或忽略"><a href="#3-插入或忽略" class="headerlink" title="3.插入或忽略"></a>3.插入或忽略</h5><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就啥事也不干直接忽略，此时，可以使用<code>INSERT IGNORE INTO ...</code>语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT IGNORE INTO students (id, class_id, name, gender, score) VALUES (1, 1, &#39;小明&#39;, &#39;F&#39;, 99);</span><br></pre></td></tr></table></figure><p>若<code>id=1</code>的记录不存在，<code>INSERT</code>语句将插入新记录，否则，不执行任何操作。</p><h5 id="4-快照"><a href="#4-快照" class="headerlink" title="4.快照"></a>4.快照</h5><p>如果想要对一个表进行快照，即复制一份当前表的数据到一个新表，可以结合<code>CREATE TABLE</code>和<code>SELECT</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 对class_id&#x3D;1的记录进行快照，并存储为新表students_of_class1:</span><br><span class="line">CREATE TABLE students_of_class1 SELECT * FROM students WHERE class_id&#x3D;1;</span><br></pre></td></tr></table></figure><p>新创建的表结构和<code>SELECT</code>使用的表结构完全一致。</p><h5 id="5-写入查询结果集"><a href="#5-写入查询结果集" class="headerlink" title="5.写入查询结果集"></a>5.写入查询结果集</h5><p>如果查询结果集需要写入到表中，可以结合<code>INSERT</code>和<code>SELECT</code>，将<code>SELECT</code>语句的结果集直接插入到指定表中。</p><p>例如，创建一个统计成绩的表<code>statistics</code>，记录各班的平均成绩：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE statistics (</span><br><span class="line">    id BIGINT NOT NULL AUTO_INCREMENT,</span><br><span class="line">    class_id BIGINT NOT NULL,</span><br><span class="line">    average DOUBLE NOT NULL,</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>然后，我们就可以用一条语句写入各班的平均成绩：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO statistics (class_id, average) SELECT class_id, AVG(score) FROM students GROUP BY class_id;</span><br></pre></td></tr></table></figure><p>确保<code>INSERT</code>语句的列和<code>SELECT</code>语句的列能一一对应，就可以在<code>statistics</code>表中直接保存查询的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT * FROM statistics;</span><br><span class="line">+----+----------+--------------+</span><br><span class="line">| id | class_id | average      |</span><br><span class="line">+----+----------+--------------+</span><br><span class="line">|  1 |        1 |         86.5 |</span><br><span class="line">|  2 |        2 | 73.666666666 |</span><br><span class="line">|  3 |        3 | 88.333333333 |</span><br><span class="line">+----+----------+--------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h5 id="6-强制使用指定索引"><a href="#6-强制使用指定索引" class="headerlink" title="6.强制使用指定索引"></a>6.强制使用指定索引</h5><p>在查询的时候，数据库系统会自动分析查询语句，并选择一个最合适的索引。但是很多时候，数据库系统的查询优化器并不一定总是能使用最优索引。如果我们知道如何选择索引，可以使用<code>FORCE INDEX</code>强制查询使用指定的索引。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT * FROM students FORCE INDEX (idx_class_id) WHERE class_id &#x3D; 1 ORDER BY id DESC;</span><br></pre></td></tr></table></figure><p>指定索引的前提是索引<code>idx_class_id</code>必须存在。</p><h2 id="Python3-MySQL-数据库连接-PyMySQL-驱动"><a href="#Python3-MySQL-数据库连接-PyMySQL-驱动" class="headerlink" title="Python3 MySQL 数据库连接 - PyMySQL 驱动"></a>Python3 MySQL 数据库连接 - PyMySQL 驱动</h2><p><code>$ pip3 install PyMySQL</code></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>廖雪峰git课程笔记</title>
      <link href="2021/01/29/git-liaoxuefeng-note/"/>
      <url>2021/01/29/git-liaoxuefeng-note/</url>
      
        <content type="html"><![CDATA[<p>关于廖雪峰git教程的一点笔记</p><a id="more"></a><h2 id="git教程（廖雪峰）笔记"><a href="#git教程（廖雪峰）笔记" class="headerlink" title="git教程（廖雪峰）笔记"></a>git教程（廖雪峰）笔记</h2><h3 id="1-git简介"><a href="#1-git简介" class="headerlink" title="1.git简介"></a>1.git简介</h3><h4 id="git的诞生"><a href="#git的诞生" class="headerlink" title="git的诞生"></a>git的诞生</h4><p>Git是目前世界上最先进的<strong>分布式版本控制系统</strong>（没有之一）。开发Linux系统时，Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！Git迅速成为最流行的分布式版本控制系统，尤其是2008年，<strong>GitHub</strong>网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。</p><h4 id="分布式vs集中式"><a href="#分布式vs集中式" class="headerlink" title="分布式vs集中式"></a>分布式vs集中式</h4><p>CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统</p><h5 id="集中式版本控制系统"><a href="#集中式版本控制系统" class="headerlink" title="集中式版本控制系统"></a>集中式版本控制系统</h5><ul><li><p>版本库是<strong>集中存放在中央服务器的</strong>，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。</p></li><li><p>必须联网才能工作</p></li></ul><h5 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h5><ul><li><p><strong>分布式版本控制系统根本没有“中央服务器”</strong>，<strong>每个人的电脑上都是一个完整的版本库</strong>，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p></li><li><p>不用联网，且分支管理功能强大</p></li></ul><h3 id="2-git的安装"><a href="#2-git的安装" class="headerlink" title="2.git的安装"></a>2.<span id="anzhuang">git的安装</span></h3><h4 id="在windows上安装"><a href="#在windows上安装" class="headerlink" title="在windows上安装"></a>在windows上安装</h4><p>从Git官网直接<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">下载安装程序</a>，然后按默认选项安装即可。安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p><p>安装完成后，还需要最后一步设置，在命令行输入：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name "Your Name"</span><br><span class="line">$ git config --global user.email "email@example.com"</span><br></pre></td></tr></table></figure><p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：<strong>你的名字和Email地址</strong>。不用担心别人会冒充，如果有也可以查询。</p><p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><h3 id="3-创建版本库"><a href="#3-创建版本库" class="headerlink" title="3.创建版本库"></a>3.创建版本库</h3><p><strong>版本库</strong>：又名仓库，英文名<strong>repository</strong>，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p><h4 id="创建一个版本库"><a href="#创建一个版本库" class="headerlink" title="创建一个版本库"></a>创建一个版本库</h4><p>首先，选择一个合适的地方，创建一个空目录：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> learngit</span><br><span class="line">$ <span class="built_in">cd</span> learngit</span><br><span class="line">$ pwd</span><br><span class="line">/Users/michael/learngit</span><br></pre></td></tr></table></figure><ul><li><p><code>pwd</code>命令用于<strong>显示当前目录</strong>。在我的Mac上，这个仓库位于<code>/Users/michael/learngit</code>。</p></li><li><p>如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。</p></li></ul><p>第二步，通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /Users/michael/learngit/.git/</span><br></pre></td></tr></table></figure><ul><li>如果你没有看到<code>.git</code>目录，那是因为这个目录默认是隐藏的，用<code>ls -ah</code>命令就可以看见。</li></ul><h4 id="把文件添加到版本库"><a href="#把文件添加到版本库" class="headerlink" title="把文件添加到版本库"></a>把文件添加到版本库</h4><ul><li><p>所有的版本控制系统，其实只能跟踪<strong>文本文件的改动</strong>，比如<strong>TXT文件，网页，所有的程序代码</strong>等等，Git也不例外,图片、视频这些二进制文件，虽然也能由版本控制系统管理，但<strong>没法跟踪文件的变化</strong>,只能知道文件大小的变化。由于word文件是二进制文件，因此无法追踪。</p></li><li><p>建议使用标准的UTF-8编码。建议使用<strong>Notepad++</strong>而不是系统自带记事本</p></li><li><p>执行命令，没有任何显示，就对了，Unix的哲学是“没有消息就是好消息”，说明操作成功。</p></li></ul><h5 id="添加文件到Git仓库，分两步"><a href="#添加文件到Git仓库，分两步" class="headerlink" title="添加文件到Git仓库，分两步"></a>添加文件到Git仓库，分两步</h5><ol><li>使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</li><li>使用命令<code>git commit -m &lt;message&gt;</code>，完成。</li></ol><h3 id="4-版本管理"><a href="#4-版本管理" class="headerlink" title="4.版本管理"></a>4.版本管理</h3><ul><li>要随时掌握工作区的状态，使用<code>git status</code>命令。</li><li>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff &lt;file&gt;</code>可以查看修改内容。</li></ul><h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a><span id="moveback">版本回退</span></h4><ul><li><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</li></ul><p>上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，往上100个版本写成<code>HEAD~100</code>。</p><ul><li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li></ul><p><code>git log</code>命令显示从最近到最远的提交日志，如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数</p><ul><li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li></ul><h4 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h4><p><strong>工作区</strong>（Working Directory）就是你在电脑里能看到的目录</p><p><strong>版本库</strong>（Repository）:工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。Git的版本库里存了很多东西，其中最重要的就是称为<strong>stage（或者叫index）的暂存区</strong>，还有Git为我们<strong>自动创建的第一个分支</strong><code>master</code>，以及指向<code>master</code>的<strong>一个指针</strong>叫<code>HEAD</code>。</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/1.png" style="zoom:67%;" /></p><p>把文件往Git版本库里添加的时候，是分两步执行的：</p><p><strong>第一步</strong>是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p><p><strong>第二步</strong>是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p><p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p><h4 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h4><p>一个操作过程：第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code></p><p>Git管理的是修改，当你用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p><p>提交后，用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别：</p><h4 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h4><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- &lt;file&gt;</code>。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a href="#moveback">版本回退</a>一节，不过前提是没有推送到远程库。</p><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><p>命令<code>git rm &lt;file&gt;</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>。</p><h3 id="5-远程仓库"><a href="#5-远程仓库" class="headerlink" title="5.远程仓库"></a>5.远程仓库</h3><p>自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置</p><h4 id="设置流程方法"><a href="#设置流程方法" class="headerlink" title="设置流程方法"></a>设置流程方法</h4><p>第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C "youremail@example.com"</span><br></pre></td></tr></table></figure><p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><p>第2步：登陆GitHub，鼠标移到右上角头像，点击“Settings”，进入“SSH and GPG keys”页面：</p><p>然后，点“New SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容：点“Add Key”，你就应该看到已经添加的Key。</p><h4 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h4><p>创建一个新的Repository，在Repository name填入名字，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库</p><ul><li><p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</p></li><li><p>关联后，<strong>在需要提交的本地文件夹处的Git Bash</strong>使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p></li><li><p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p></li></ul><h4 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h4><p>要克隆一个仓库，首先必须知道仓库的地址，然后使用</p><p><code>git clone git@github.com:michaelliao/gitskills.git</code> (这个例子是<code>ssh</code>）命令克隆。也可以用<code>https://github.com/michaelliao/gitskills.git</code>  （<code>michaelliao</code>替换成自己的用户名，后者改为自己的项目名字）</p><p>Git支持多种协议，包括<code>https</code>，但<code>ssh</code>协议速度最快。</p><h3 id="6-分支管理"><a href="#6-分支管理" class="headerlink" title="6.分支管理"></a>6.分支管理</h3><h4 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h4><p>查看分支：<code>git branch</code></p><p>创建分支：<code>git branch &lt;name&gt;</code></p><p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code></p><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></p><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p><p>删除分支：<code>git branch -d &lt;name&gt;</code></p><h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p><p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p><p>用<code>git log --graph</code>命令可以看到分支合并图。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure><h4 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h4><p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。不能记录下来合并的过程。如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><p><code>--no-ff</code>方式的<code>git merge</code>可以禁用<code>Fast forward</code>    合并后，我们用<code>git log</code>看看分支历史：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m "merge with no-ff" dev</span><br><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure><h5 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h5><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p><ul><li><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p></li><li><p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p></li><li><p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p></li></ul><p>所以，团队合作的分支看起来如下图：</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/团队合作分支管理.png" alt=""></p><h4 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h4><ul><li><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p></li><li><p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，工作区是干净的，刚才的工作现场存到哪去了？用<code>git stash list</code>命令看看，再<code>git stash pop</code>，回到工作现场；</p></li></ul><p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p><p>一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</p><p>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了：</p><ul><li>在master分支上修复的bug，想要合并到当前dev分支，可以用<code>git cherry-pick &lt;commit&gt;</code>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</li></ul><h4 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h4><p>开发一个新feature，最好新建一个分支；</p><p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p><h4 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h4><ul><li><p>查看远程库信息，使用 <code>git remote</code> (简单信息)  <code>git remote -v</code>（详细信息）；</p></li><li><p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p></li><li><p>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</p><p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p><ul><li><code>master</code>分支是主分支，因此要时刻与远程同步；</li><li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li></ul><ul><li><p>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</p></li><li><p>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p></li></ul></li><li><p>当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的<code>master</code>分支。在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</p></li><li><p>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</p></li><li><p>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</p></li></ul><ul><li>多人协作工作模式</li></ul><ol><li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li></ol><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p><h4 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h4><ul><li>rebase操作可以把本地未push的分叉提交历史整理成直线；</li><li>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</li></ul><h3 id="7-标签管理"><a href="#7-标签管理" class="headerlink" title="7.标签管理"></a>7.标签管理</h3><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><ul><li>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id；</li><li>命令<code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；<code>-m</code>后面是说明文字</li><li>命令<code>git tag</code>可以查看所有标签。</li></ul><ul><li>用命令<code>git show &lt;tagname&gt;</code>可以看到说明文字：</li></ul><h4 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h4><ul><li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</li><li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li><li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</li><li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</li></ul><h3 id="8-使用GitHub"><a href="#8-使用GitHub" class="headerlink" title="8.使用GitHub"></a>8.使用GitHub</h3><p>我们一直用GitHub作为免费的远程仓库，如果是个人的开源项目，放到GitHub上是完全没有问题的。其实GitHub还是一个开源协作社区，通过GitHub，既可以让别人参与你的开源项目，也可以参与别人的开源项目。</p><p>如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页<a href="https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：" target="_blank" rel="noopener">https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：</a></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:michaelliao/bootstrap.git</span><br></pre></td></tr></table></figure><p>一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址<code>git@github.com:twbs/bootstrap.git</code>克隆，因为没有权限，你将不能推送修改。</p><p>Bootstrap的官方仓库<code>twbs/bootstrap</code>、你在GitHub上克隆的仓库<code>my/bootstrap</code>，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌─ GitHub ────────────────────────────────────┐</span><br><span class="line">│                                             │</span><br><span class="line">│ ┌─────────────────┐     ┌─────────────────┐ │</span><br><span class="line">│ │ twbs&#x2F;bootstrap  │────&gt;│  my&#x2F;bootstrap   │ │</span><br><span class="line">│ └─────────────────┘     └─────────────────┘ │</span><br><span class="line">│                                  ▲          │</span><br><span class="line">└──────────────────────────────────┼──────────┘</span><br><span class="line">                                   ▼</span><br><span class="line">                          ┌─────────────────┐</span><br><span class="line">                          │ local&#x2F;bootstrap │</span><br><span class="line">                          └─────────────────┘</span><br></pre></td></tr></table></figure><p>如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。</p><p>如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul><li>在GitHub上，可以任意Fork开源仓库；</li><li>自己拥有Fork后的仓库的读写权限；</li><li>可以推送pull request给官方仓库来贡献代码。</li></ul><h3 id="9-使用Gitee"><a href="#9-使用Gitee" class="headerlink" title="9.使用Gitee"></a>9.使用Gitee</h3><p>使用GitHub时，国内的用户经常遇到的问题是访问速度太慢，有时候还会出现无法连接的情况（原因你懂的）。</p><p>如果我们希望体验Git飞一般的速度，可以使用国内的Git托管服务——<a href="https://gitee.com/?utm_source=blog_lxf" target="_blank" rel="noopener">Gitee</a>（<a href="https://gitee.com/?utm_source=blog_lxf" target="_blank" rel="noopener">gitee.com</a>）。</p><p>和GitHub相比，Gitee也提供免费的Git仓库。此外，还集成了代码质量检测、项目演示等功能。对于团队协作开发，Gitee还提供了项目管理、代码托管、文档管理的服务，5人以下小团队免费。</p><p> Gitee的免费版本也提供私有库功能，只是有5人的成员上限。</p><p>使用Gitee和使用GitHub类似，我们在Gitee上注册账号并登录后，需要先上传自己的SSH公钥。选择右上角用户头像 -&gt; 菜单“修改资料”，然后选择“SSH公钥”，填写一个便于识别的标题，然后把用户主目录下的<code>.ssh/id_rsa.pub</code>文件的内容粘贴进去：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1163452910422880/l" alt="gitee-add-ssh-key"></p><p>点击“确定”即可完成并看到刚才添加的Key：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1163453163108928/l" alt="gitee-key"></p><p>如果我们已经有了一个本地的git仓库（例如，一个名为learngit的本地库），如何把它关联到Gitee的远程库上呢？</p><p>首先，我们在Gitee上创建一个新的项目，选择右上角用户头像 -&gt; 菜单“控制面板”，然后点击“创建项目”：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1163453517527296/l" alt="gitee-new-repo"></p><p>项目名称最好与本地库保持一致：</p><p>然后，我们在本地库上使用命令<code>git remote add</code>把它和Gitee的远程库关联：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@gitee.com:liaoxuefeng/learngit.git</span><br></pre></td></tr></table></figure><p>之后，就可以正常地用<code>git push</code>和<code>git pull</code>推送了！</p><p>如果在使用命令<code>git remote add</code>时报错：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@gitee.com:liaoxuefeng/learngit.git</span><br><span class="line"><span class="function">fatal: <span class="title">remote</span> <span class="title">origin</span> <span class="title">already</span> <span class="title">exists</span>.</span></span><br></pre></td></tr></table></figure><p>这说明本地库已经关联了一个名叫<code>origin</code>的远程库，此时，可以先用<code>git remote -v</code>查看远程库信息：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">origingit@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origingit@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure><p>可以看到，本地库已经关联了<code>origin</code>的远程库，并且，该远程库指向GitHub。</p><p>我们可以删除已有的GitHub远程库：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure><p>再关联Gitee的远程库（注意路径中需要填写正确的用户名）：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@gitee.com:liaoxuefeng/learngit.git</span><br></pre></td></tr></table></figure><p>此时，我们再查看远程库信息：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">origingit@gitee.com:liaoxuefeng/learngit.git (fetch)</span><br><span class="line">origingit@gitee.com:liaoxuefeng/learngit.git (push)</span><br></pre></td></tr></table></figure><p>现在可以看到，origin已经被关联到Gitee的远程库了。通过<code>git push</code>命令就可以把本地库推送到Gitee上。</p><p>有的小伙伴又要问了，一个本地库能不能既关联GitHub，又关联Gitee呢？</p><p>答案是肯定的，因为git本身是分布式版本控制系统，可以同步到另外一个远程库，当然也可以同步到另外两个远程库。</p><p>使用多个远程库时，我们要注意，git给远程库起的默认名称是<code>origin</code>，如果有多个远程库，我们需要用不同的名称来标识不同的远程库。</p><p>仍然以<code>learngit</code>本地库为例，我们先删除已关联的名为<code>origin</code>的远程库：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure><p>然后，先关联GitHub的远程库：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add github git@github.com:michaelliao/learngit.git</span><br></pre></td></tr></table></figure><p>注意，远程库的名称叫<code>github</code>，不叫<code>origin</code>了。</p><p>接着，再关联Gitee的远程库：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add gitee git@gitee.com:liaoxuefeng/learngit.git</span><br></pre></td></tr></table></figure><p>同样注意，远程库的名称叫<code>gitee</code>，不叫<code>origin</code>。</p><p>现在，我们用<code>git remote -v</code>查看远程库信息，可以看到两个远程库：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">giteegit@gitee.com:liaoxuefeng/learngit.git (fetch)</span><br><span class="line">giteegit@gitee.com:liaoxuefeng/learngit.git (push)</span><br><span class="line">githubgit@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">githubgit@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure><p>如果要推送到GitHub，使用命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push github master</span><br></pre></td></tr></table></figure><p>如果要推送到Gitee，使用命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push gitee master</span><br></pre></td></tr></table></figure><p>这样一来，我们的本地库就可以同时与多个远程库互相同步：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌─────────┐ ┌─────────┐</span><br><span class="line">│ GitHub  │ │  Gitee  │</span><br><span class="line">└─────────┘ └─────────┘</span><br><span class="line">     ▲           ▲</span><br><span class="line">     └─────┬─────┘</span><br><span class="line">           │</span><br><span class="line">    ┌─────────────┐</span><br><span class="line">    │ Local Repo  │</span><br><span class="line">    └─────────────┘</span><br></pre></td></tr></table></figure><p>Gitee也同样提供了Pull request功能，可以让其他小伙伴参与到开源项目中来。你可以通过Fork我的仓库：<a href="https://gitee.com/liaoxuefeng/learngit?utm_source=blog_lxf" target="_blank" rel="noopener">https://gitee.com/liaoxuefeng/learngit</a>，创建一个<code>your-gitee-id.txt</code>的文本文件， 写点自己学习Git的心得，然后推送一个pull request给我，这个仓库会在Gitee和GitHub做双向同步。</p><h3 id="10-自定义Git"><a href="#10-自定义Git" class="headerlink" title="10.自定义Git"></a>10.自定义Git</h3><p>在<a href="#anzhuang">安装Git</a>一节中，我们已经配置了<code>user.name</code>和<code>user.email</code>，实际上，Git还有很多可配置项。</p><p>比如，让Git显示颜色，会让命令输出看起来更醒目：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global <span class="built_in">color</span>.ui true</span><br></pre></td></tr></table></figure><h4 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h4><p>有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次<code>git status</code>都会显示<code>Untracked files ...</code>，有强迫症的童鞋心里肯定不爽。</p><p>好在Git考虑到了大家的感受，这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的<code>.gitignore</code>文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p><p>不需要从头写<code>.gitignore</code>文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：<a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a></p><p>忽略文件的原则是：</p><ol><li>忽略操作系统自动生成的文件，比如缩略图等；</li><li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的<code>.class</code>文件；</li><li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li></ol><p>举个例子：</p><p>假设你在Windows下进行Python开发，Windows会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有<code>Desktop.ini</code>文件，因此你需要忽略Windows自动生成的垃圾文件：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Windows:</span><br><span class="line">Thumbs.db</span><br><span class="line">ehthumbs.db</span><br><span class="line">Desktop.ini</span><br></pre></td></tr></table></figure><p>然后，继续忽略Python编译产生的<code>.pyc</code>、<code>.pyo</code>、<code>dist</code>等文件或目录：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Python:</span><br><span class="line">*.py[cod]</span><br><span class="line">*.so</span><br><span class="line">*.egg</span><br><span class="line">*.egg-info</span><br><span class="line">dist</span><br><span class="line">build</span><br></pre></td></tr></table></figure><p>加上你自己定义的文件，最终得到一个完整的<code>.gitignore</code>文件，内容如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Windows:</span><br><span class="line">Thumbs.db</span><br><span class="line">ehthumbs.db</span><br><span class="line">Desktop.ini</span><br><span class="line"></span><br><span class="line"># Python:</span><br><span class="line">*.py[cod]</span><br><span class="line">*.so</span><br><span class="line">*.egg</span><br><span class="line">*.egg-info</span><br><span class="line">dist</span><br><span class="line">build</span><br><span class="line"></span><br><span class="line"># My configurations:</span><br><span class="line">db.ini</span><br><span class="line">deploy_key_rsa</span><br></pre></td></tr></table></figure><p>最后一步就是把<code>.gitignore</code>也提交到Git，就完成了！当然检验<code>.gitignore</code>的标准是<code>git status</code>命令是不是说<code>working directory clean</code>。</p><p>使用Windows的童鞋注意了，如果你在资源管理器里新建一个<code>.gitignore</code>文件，它会非常弱智地提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为<code>.gitignore</code>了。</p><p>有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被<code>.gitignore</code>忽略了：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add App.class</span><br><span class="line">The following paths are ignored by one of your .gitignore files:</span><br><span class="line">App.class</span><br><span class="line">Use -f <span class="keyword">if</span> you really want to add them.</span><br></pre></td></tr></table></figure><p>如果你确实想添加该文件，可以用<code>-f</code>强制添加到Git：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add -f App.class</span><br></pre></td></tr></table></figure><p>或者你发现，可能是<code>.gitignore</code>写得有问题，需要找出来到底哪个规则写错了，可以用<code>git check-ignore</code>命令检查：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git check-ignore -v App.class</span><br><span class="line"><span class="function">.gitignore:3:*.<span class="title">class</span><span class="title">App.class</span></span></span><br></pre></td></tr></table></figure><p>Git会告诉我们，<code>.gitignore</code>的第3行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。</p><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><ul><li>忽略某些文件时，需要编写<code>.gitignore</code>；</li><li><code>.gitignore</code>文件本身要放到版本库里，并且可以对<code>.gitignore</code>做版本管理！</li></ul><h4 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h4><p>阅读: 8189585</p><hr><p>有没有经常敲错命令？比如<code>git status</code>？<code>status</code>这个单词真心不好记。</p><p>如果敲<code>git st</code>就表示<code>git status</code>那就简单多了，当然这种偷懒的办法我们是极力赞成的。</p><p>我们只需要敲一行命令，告诉Git，以后<code>st</code>就表示<code>status</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.st status</span><br></pre></td></tr></table></figure><p>好了，现在敲<code>git st</code>看看效果。</p><p>当然还有别的命令可以简写，很多人都用<code>co</code>表示<code>checkout</code>，<code>ci</code>表示<code>commit</code>，<code>br</code>表示<code>branch</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.co checkout</span><br><span class="line">$ git config --global alias.ci commit</span><br><span class="line">$ git config --global alias.br branch</span><br></pre></td></tr></table></figure><p>以后提交就可以简写成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git ci -m &quot;bala bala bala...&quot;</span><br></pre></td></tr></table></figure><p><code>--global</code>参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。</p><p>在<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897889638509536" target="_blank" rel="noopener">撤销修改</a>一节中，我们知道，命令<code>git reset HEAD file</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个<code>unstage</code>别名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.unstage &#39;reset HEAD&#39;</span><br></pre></td></tr></table></figure><p>当你敲入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git unstage test.py</span><br></pre></td></tr></table></figure><p>实际上Git执行的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD test.py</span><br></pre></td></tr></table></figure><p>配置一个<code>git last</code>，让其显示最后一次提交信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.last &#39;log -1&#39;</span><br></pre></td></tr></table></figure><p>这样，用<code>git last</code>就能显示最近一次的提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git last</span><br><span class="line">commit adca45d317e6d8a4b23f9811c3d7b7f0f180bfe2</span><br><span class="line">Merge: bd6ae48 291bea8</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Thu Aug 22 22:49:22 2013 +0800</span><br><span class="line"></span><br><span class="line">    merge &amp; fix hello.py</span><br></pre></td></tr></table></figure><p>甚至还有人丧心病狂地把<code>lg</code>配置成了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.lg &quot;log --color --graph --pretty&#x3D;format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;</span><br></pre></td></tr></table></figure><p>来看看<code>git lg</code>的效果：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919059728302912/0" alt="git-lg"></p><p>为什么不早点告诉我？别激动，咱不是为了多记几个英文单词嘛！</p><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><p>配置Git的时候，加上<code>--global</code>是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。</p><p>配置文件放哪了？每个仓库的Git配置文件都放在<code>.git/config</code>文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git&#x2F;config </span><br><span class="line">[core]</span><br><span class="line">    repositoryformatversion &#x3D; 0</span><br><span class="line">    filemode &#x3D; true</span><br><span class="line">    bare &#x3D; false</span><br><span class="line">    logallrefupdates &#x3D; true</span><br><span class="line">    ignorecase &#x3D; true</span><br><span class="line">    precomposeunicode &#x3D; true</span><br><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">    url &#x3D; git@github.com:michaelliao&#x2F;learngit.git</span><br><span class="line">    fetch &#x3D; +refs&#x2F;heads&#x2F;*:refs&#x2F;remotes&#x2F;origin&#x2F;*</span><br><span class="line">[branch &quot;master&quot;]</span><br><span class="line">    remote &#x3D; origin</span><br><span class="line">    merge &#x3D; refs&#x2F;heads&#x2F;master</span><br><span class="line">[alias]</span><br><span class="line">    last &#x3D; log -1</span><br></pre></td></tr></table></figure><p>别名就在<code>[alias]</code>后面，要删除别名，直接把对应的行删掉即可。</p><p>而当前用户的Git配置文件放在用户主目录下的一个隐藏文件<code>.gitconfig</code>中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat .gitconfig</span><br><span class="line">[alias]</span><br><span class="line">    co &#x3D; checkout</span><br><span class="line">    ci &#x3D; commit</span><br><span class="line">    br &#x3D; branch</span><br><span class="line">    st &#x3D; status</span><br><span class="line">[user]</span><br><span class="line">    name &#x3D; Your Name</span><br><span class="line">    email &#x3D; your@email.com</span><br></pre></td></tr></table></figure><p>配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。</p><h5 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h5><p>给Git配置好别名，就可以输入命令时偷个懒。我们鼓励偷懒。</p><h4 id="搭建Git服务器"><a href="#搭建Git服务器" class="headerlink" title="搭建Git服务器"></a>搭建Git服务器</h4><p>阅读: 45444012</p><hr><p>在<a href="https://www.liaoxuefeng.com/wiki/896043488029600/896954117292416" target="_blank" rel="noopener">远程仓库</a>一节中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了7x24小时开机并交换大家的修改。</p><p>GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。</p><p>搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的<code>apt</code>命令就可以完成安装。</p><p>假设你已经有<code>sudo</code>权限的用户账号，下面，正式开始安装。</p><p>第一步，安装<code>git</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install git</span><br></pre></td></tr></table></figure><p>第二步，创建一个<code>git</code>用户，用来运行<code>git</code>服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo adduser git</span><br></pre></td></tr></table></figure><p>第三步，创建证书登录：</p><p>收集所有需要登录的用户的公钥，就是他们自己的<code>id_rsa.pub</code>文件，把所有公钥导入到<code>/home/git/.ssh/authorized_keys</code>文件里，一行一个。</p><p>第四步，初始化Git仓库：</p><p>先选定一个目录作为Git仓库，假定是<code>/srv/sample.git</code>，在<code>/srv</code>目录下输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo git init --bare sample.git</span><br></pre></td></tr></table></figure><p>Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以<code>.git</code>结尾。然后，把owner改为<code>git</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown -R git:git sample.git</span><br></pre></td></tr></table></figure><p>第五步，禁用shell登录：</p><p>出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑<code>/etc/passwd</code>文件完成。找到类似下面的一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:x:1001:1001:,,,:&#x2F;home&#x2F;git:&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:x:1001:1001:,,,:&#x2F;home&#x2F;git:&#x2F;usr&#x2F;bin&#x2F;git-shell</span><br></pre></td></tr></table></figure><p>这样，<code>git</code>用户可以正常通过ssh使用git，但无法登录shell，因为我们为<code>git</code>用户指定的<code>git-shell</code>每次一登录就自动退出。</p><p>第六步，克隆远程仓库：</p><p>现在，可以通过<code>git clone</code>命令克隆远程仓库了，在各自的电脑上运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@server:&#x2F;srv&#x2F;sample.git</span><br><span class="line">Cloning into &#39;sample&#39;...</span><br><span class="line">warning: You appear to have cloned an empty repository.</span><br></pre></td></tr></table></figure><p>剩下的推送就简单了。</p><h5 id="管理公钥"><a href="#管理公钥" class="headerlink" title="管理公钥"></a>管理公钥</h5><p>如果团队很小，把每个人的公钥收集起来放到服务器的<code>/home/git/.ssh/authorized_keys</code>文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用<a href="https://github.com/res0nat0r/gitosis" target="_blank" rel="noopener">Gitosis</a>来管理公钥。</p><p>这里我们不介绍怎么玩<a href="https://github.com/res0nat0r/gitosis" target="_blank" rel="noopener">Gitosis</a>了，几百号人的团队基本都在500强了，相信找个高水平的Linux管理员问题不大。</p><h5 id="管理权限"><a href="#管理权限" class="headerlink" title="管理权限"></a>管理权限</h5><p>有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。<a href="https://github.com/sitaramc/gitolite" target="_blank" rel="noopener">Gitolite</a>就是这个工具。</p><p>这里我们也不介绍<a href="https://github.com/sitaramc/gitolite" target="_blank" rel="noopener">Gitolite</a>了，不要把有限的生命浪费到权限斗争中。</p><h5 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h5><ul><li>搭建Git服务器非常简单，通常10分钟即可完成；</li><li>要方便管理公钥，用<a href="https://github.com/res0nat0r/gitosis" target="_blank" rel="noopener">Gitosis</a>；</li><li>要像SVN那样变态地控制权限，用<a href="https://github.com/sitaramc/gitolite" target="_blank" rel="noopener">Gitolite</a>。</li></ul><h3 id="使用SourceTree"><a href="#使用SourceTree" class="headerlink" title="使用SourceTree"></a>使用SourceTree</h3><p>当我们对Git的提交、分支已经非常熟悉，可以熟练使用命令操作Git后，再使用GUI工具，就可以更高效。</p><p>Git有很多图形界面工具，这里我们推荐<a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">SourceTree</a>，它是由<a href="https://www.atlassian.com/" target="_blank" rel="noopener">Atlassian</a>开发的免费Git图形界面工具，可以操作任何Git库。</p><p>首先从<a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">官网</a>下载SourceTree并安装，然后直接运行SourceTree。</p><p>第一次运行SourceTree时，SourceTree并不知道我们的Git库在哪。如果本地已经有了Git库，直接从资源管理器把文件夹拖拽到SourceTree上，就添加了一个本地Git库：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1317162822139970/l" alt="add-local-repo"></p><p>也可以选择“New”-“Clone from URL”直接从远程克隆到本地。</p><h4 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h4><p>我们双击<code>learngit</code>这个本地库，SourceTree会打开另一个窗口，展示这个Git库的当前所有分支以及文件状态。选择左侧面板的“WORKSPACE”-“File status”，右侧会列出当前已修改的文件（Unstaged files）：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1317163279319106/l" alt="unstaged"></p><p>选中某个文件，该文件就自动添加到“Staged files”，实际上是执行了<code>git add README.md</code>命令：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1317163629543489/l" alt="add"></p><p>然后，我们在下方输入Commit描述，点击“Commit”，就完成了一个本地提交：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1317163717623874/l" alt="commit"></p><p>实际上是执行了<code>git commit -m &quot;update README.md&quot;</code>命令。</p><p>使用SourceTree进行提交就是这么简单，它的优势在于可以可视化地观察文件的修改，并以红色和绿色高亮显示。</p><h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><p>在左侧面板的“BRANCHES”下，列出了当前本地库的所有分支。当前分支会加粗并用○标记。要切换分支，我们只需要选择该分支，例如<code>master</code>，然后点击右键，在弹出菜单中选择“Checkout master”，实际上是执行命令<code>git checkout master</code>：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1317164906709058/l" alt="checkout"></p><p>要合并分支，同样选择待合并分支，例如<code>dev</code>，然后点击右键，在弹出菜单中选择“Merge dev into master”，实际上是执行命令<code>git merge dev</code>：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1317165154172993/l" alt="merge-dev-into-master"></p><h4 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h4><p>在SourceTree的工具栏上，分别有<code>Pull</code>和<code>Push</code>，分别对应命令<code>git pull</code>和<code>git push</code>，只需注意本地和远程分支的名称要对应起来，使用时十分简单。</p><p>注意到使用SourceTree时，我们只是省下了敲命令的麻烦，SourceTree本身还是通过Git命令来执行任何操作。如果操作失败，SourceTree会自动显示执行的Git命令以及错误信息，我们可以通过Git返回的错误信息知道出错的原因：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1317166563459138/l" alt="push-error"></p><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>使用SourceTree可以以图形界面操作Git，省去了敲命令的过程，对于常用的提交、分支、推送等操作来说非常方便。</p><p>SourceTree使用Git命令执行操作，出错时，仍然需要阅读Git命令返回的错误信息。</p><p>终于到了期末总结的时刻了！</p><p>经过几天的学习，相信你对Git已经初步掌握。一开始，可能觉得Git上手比较困难，尤其是已经熟悉SVN的童鞋，没关系，多操练几次，就会越用越顺手。</p><p>Git虽然极其强大，命令繁多，但常用的就那么十来个，掌握好这十几个常用命令，你已经可以得心应手地使用Git了。</p><p>友情附赠国外网友制作的Git Cheat Sheet，建议打印出来备用：</p><p><a href="https://gitee.com/liaoxuefeng/learn-java/raw/master/teach/git-cheatsheet.pdf" target="_blank" rel="noopener">Git Cheat Sheet</a></p><p>现在告诉你Git的官方网站：<a href="http://git-scm.com/" target="_blank" rel="noopener">http://git-scm.com</a>，英文自我感觉不错的童鞋，可以经常去官网看看。什么，打不开网站？相信我，我给出的绝对是官网地址，而且，Git官网决没有那么容易宕机，可能是你的人品问题，赶紧面壁思过，好好想想原因。</p><p>如果你学了Git后，工作效率大增，有更多的空闲时间健身看电影，那我的教学目标就达到了。</p><p>谢谢观看！</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> git家族 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello,My personal Blog!个人博客搭建总结</title>
      <link href="2021/01/29/hello-myblog/"/>
      <url>2021/01/29/hello-myblog/</url>
      
        <content type="html"><![CDATA[<p>经过了好几天的摸索，终于大概部署好了个人博客，之后会把所学的一些CS知识技术整理成笔记记录在这里，欢迎大家时不时来踩一踩！</p><p>这篇博客主要是关于个人博客搭建和更新方法的笔记，怕之后忘了所以赶紧记一下。目前博客仅仅是实现了基本功能，之后可能会视情况设置一下评论区，点赞，社交等功能。</p><a id="more"></a><h3 id="个人博客搭建总结"><a href="#个人博客搭建总结" class="headerlink" title="个人博客搭建总结"></a>个人博客搭建总结</h3><h4 id="Jekyll"><a href="#Jekyll" class="headerlink" title="Jekyll"></a>Jekyll</h4><p>这段时间为了搭建一下自己的博客尝试了两种方式，一种是基于<code>Jekyll</code>的，这种方式比较简单，但是有时过于简单了，之前试过用一个cayman的主题，但由于本人太菜，这个模板需要配置太多，只好放弃了，改用hexo搭建。如果想用<code>Jekyll</code>的可以参考这个网站：<a href="http://jekyllcn.com/" target="_blank" rel="noopener">http://jekyllcn.com/</a> ，此站目标是<strong>成为 Jekyll 的全面指南</strong>，内容详细，值得看一看。</p><h4 id="hexo搭建大致流程"><a href="#hexo搭建大致流程" class="headerlink" title="hexo搭建大致流程"></a>hexo搭建大致流程</h4><p>大致参考了以下几篇博客</p><p><a href="https://blog.csdn.net/jinxiaonian11/article/details/82900119（这个作者有两篇这方面的博客，讲的挺详细的）" target="_blank" rel="noopener">https://blog.csdn.net/jinxiaonian11/article/details/82900119（这个作者有两篇这方面的博客，讲的挺详细的）</a></p><p><a href="https://blog.csdn.net/qq_37210523/article/details/80909983" target="_blank" rel="noopener">https://blog.csdn.net/qq_37210523/article/details/80909983</a></p><ol><li><p>选好一个空文件夹，最好不要有中文路径，之后用bash cd到这个路径下，继续下面的操作。</p></li><li><p>安装配置好node.js（node.js下载地址：<a href="https://nodejs.org/en/download/），hexo" target="_blank" rel="noopener">https://nodejs.org/en/download/），hexo</a> (<code>npm install hexo -g</code>)。</p><p>npm安装hexo时可能会出问题，更换一下镜像就好了。（如：<code>npm config set registry http://registry.npm.taobao.org</code></p></li><li><p>安装必要的组件：<code>npm install</code>，之后输入处理命令 <code>hexo g</code>   并开启服务器<code>hexo s</code> 出现了能够打开本地网页的提示（这个打开和那个线上的是一样的效果）就说明已经成功了，之后<code>ctrl+C</code>退出继续下面步骤</p></li><li><p>在github上新增仓库，命名为: username.github.io，并在本地的根目录下的 _config.yml 文件中的<strong>Deployment</strong>设置处，添加以下代码，<strong>repo</strong>和<strong>branch</strong>根据自己情况修改</p></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:BUAADreamer/BUAADreamer.github.io.git</span> </span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><ol><li><p>之后选好主题，并利用作者提供的方式git clone到本地theme文件夹下即可，并在根目录下的)_config.yml改一下theme设置，很多人推荐next，我的这个用的是ocean，也看到有同学用的黄玄大神的<a href="https://huangxuan.me/" target="_blank" rel="noopener">https://huangxuan.me/</a>  </p><p>然后创建博客：<code>hexo new blog-name</code>，之后一行代码部署到github上即可：<code>hexo d -g</code>，再打开自己的网站：username.github.io即可看到了！</p></li><li><p>后续配置，这个每个主题都有区别，去github上看作者的文档就行。可以添加很多功能。下面记录一下常用的几个tips和资源</p><ul><li><p>修改文章：直接修改之后用hexo d- g就可以完成push的操作。</p></li><li><p>设置摘要：使用<code>&lt;!--more--&gt;</code>标签设置摘要。这样在index页只会展示这行代码之前的文字</p></li><li><p>hexo官方中文文档：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></p></li></ul></li></ol><h4 id="问题和个人用法总结"><a href="#问题和个人用法总结" class="headerlink" title="问题和个人用法总结"></a>问题和个人用法总结</h4><ol><li>图片用的腾讯云对象存储</li><li>md文件配置时一定是类似<code>tags: 123</code>这样的格式。<code>tags</code>和<code>123</code>之间<strong>一定要有空格</strong>！！！</li></ol><h4 id="评论功能"><a href="#评论功能" class="headerlink" title="评论功能"></a>评论功能</h4><p>我的博客使用的<code>Utterances</code>，配置非常简单，并且也比较安全简洁。</p><p>可以参考这篇文章：<a href="https://roife.github.io/2021/02/12/use-utterances-for-comment/" target="_blank" rel="noopener">https://roife.github.io/2021/02/12/use-utterances-for-comment/</a></p><p>其他的还有<code>Gitalk</code>,<code>Valine</code>，也可以用，但是<code>Gitalk</code>配置麻烦且很容易挂，后者貌似需要花钱。</p><h4 id="更换代理"><a href="#更换代理" class="headerlink" title="更换代理"></a>更换代理</h4><p>同时参考下面这<strong>两篇</strong>文章，因为都有些不全面。记得要实名认证+获取证书+域名解析</p><p><a href="https://blog.csdn.net/obsession753/article/details/84110360" target="_blank" rel="noopener">https://blog.csdn.net/obsession753/article/details/84110360</a></p><p><a href="https://blog.csdn.net/i042416/article/details/89926005" target="_blank" rel="noopener">https://blog.csdn.net/i042416/article/details/89926005</a></p><h4 id="2021-4-24"><a href="#2021-4-24" class="headerlink" title="2021.4.24"></a>2021.4.24</h4><p>更换了主题，换成了感觉更美观的huxblog主题</p><p>更换过程很简单，只需要到<a href="https://github.com/Kaijun/hexo-theme-huxblog" target="_blank" rel="noopener">https://github.com/Kaijun/hexo-theme-huxblog</a> 这个网站下载代码，之后将themes里的huxblog文件夹copy到你自己的themes目录下，然后在根目录下的_config.xml修改themes名字为huxblog即可。</p><h4 id="2021-4-25"><a href="#2021-4-25" class="headerlink" title="2021.4.25"></a>2021.4.25</h4><p>调换过程很简单，但是由于hexo版的黄玄主题作者已经不维护了，出现了各式各样的问题，于是决定换成长得差不多的snail主题，这个主题作者给了详细的说明文档。<a href="https://github.com/dusign/hexo-theme-snail" target="_blank" rel="noopener">https://github.com/dusign/hexo-theme-snail</a></p><h4 id="2021-6-3-图片配置"><a href="#2021-6-3-图片配置" class="headerlink" title="2021.6.3 图片配置"></a>2021.6.3 图片配置</h4><p>以下内容搬运自：<a href="https://blog.csdn.net/qq_36408085/article/details/104117319" target="_blank" rel="noopener">https://blog.csdn.net/qq_36408085/article/details/104117319</a></p><p>修改 hexo 目录下的 .config.yml 文件，将 post_asset_folder: false 修改为 post_asset_folder: true。</p><p>安装一个图片路径转换的插件。在hexo文件夹下打开 Git bush。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/7ym0n/hexo-asset-image --save  <span class="comment">#注意，不是官方的那个！！！</span></span><br></pre></td></tr></table></figure><p>这样就可以让本地和远程显示一样了！就正常使用绝对或相对路径插入图片代码即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](文章名/1.png)</span><br></pre></td></tr></table></figure><p><strong>注意</strong>： 这是经过修改的插件代码，网上流传的另一份代码 npm install <a href="https://github.com/CodeFalling/hexo-asset-image" target="_blank" rel="noopener">https://github.com/CodeFalling/hexo-asset-image</a> —save 并不能使用。</p><p>如果你之前安装了这个错误的插件，请将 /node_modules/hexo-asset-image/index.js<br>这个文件替换成下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="built_in">String</span>(hexo.version).split(<span class="string">'.'</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">'after_post_render'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> config = hexo.config;</span><br><span class="line"><span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">    <span class="keyword">var</span> link = data.permalink;</span><br><span class="line"><span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">'/'</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">'/'</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html".</span></span><br><span class="line"><span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>;</span><br><span class="line">link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> toprocess = [<span class="string">'excerpt'</span>, <span class="string">'more'</span>, <span class="string">'content'</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">    ignoreWhitespace: <span class="literal">false</span>,</span><br><span class="line">    xmlMode: <span class="literal">false</span>,</span><br><span class="line">    lowerCaseTags: <span class="literal">false</span>,</span><br><span class="line">    decodeEntities: <span class="literal">false</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    $(<span class="string">'img'</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ($(<span class="keyword">this</span>).attr(<span class="string">'src'</span>))&#123;</span><br><span class="line">        <span class="comment">// For windows style path, we replace '\' to '/'.</span></span><br><span class="line">        <span class="keyword">var</span> src = $(<span class="keyword">this</span>).attr(<span class="string">'src'</span>).replace(<span class="string">'\\'</span>, <span class="string">'/'</span>);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;</span><br><span class="line">            !<span class="regexp">/^\s*\//</span>.test(src)) &#123;</span><br><span class="line">            <span class="comment">// For "about" page, the first part of "src" can't be removed.</span></span><br><span class="line">            <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">            <span class="keyword">var</span> linkArray = link.split(<span class="string">'/'</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> elem != <span class="string">''</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">var</span> srcArray = src.split(<span class="string">'/'</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> elem != <span class="string">''</span> &amp;&amp; elem != <span class="string">'.'</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">            srcArray.shift();</span><br><span class="line">            src = srcArray.join(<span class="string">'/'</span>);</span><br><span class="line">            $(<span class="keyword">this</span>).attr(<span class="string">'src'</span>, config.root + link + src);</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">"update link as:--&gt;"</span>+config.root + link + src);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">"no src attr, skipped..."</span>);</span><br><span class="line">        <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    data[key] = $.html();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> hello my blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Theme-Snail</title>
      <link href="2019/11/01/Hexo-Theme-Snail/"/>
      <url>2019/11/01/Hexo-Theme-Snail/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-theme-snail"><a href="#hexo-theme-snail" class="headerlink" title="hexo-theme-snail"></a>hexo-theme-snail</h1><p><a href="https://github.com/dusign/hexo-theme-snail" target="_blank" rel="noopener">View Hexo-Theme-Snail Sources On Github &#10174; </a></p><p><a href="https://www.dusign.net" target="_blank" rel="noopener">View Live Super Snail Blog &#10174;</a></p><p><img src="snail.png" alt="hexo-theme-snail"></p><p>Hexo-theme-snail is a succinct hexo theme. It has two colors, light and star, that can be set according to your own preferences in the settings, and also has the functions of sharing and commenting. More features are under development.</p><h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ul><li>light color theme and star theme</li><li>diversified comment system</li><li>notice tips</li><li>share to other platforms (under development)</li><li>picture sharing (under development)</li></ul><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Install-Hexo"><a href="#Install-Hexo" class="headerlink" title="Install Hexo"></a>Install Hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h3 id="Setup-your-blog"><a href="#Setup-your-blog" class="headerlink" title="Setup your blog"></a>Setup your blog</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init blog</span><br></pre></td></tr></table></figure><h3 id="Installation-Theme"><a href="#Installation-Theme" class="headerlink" title="Installation Theme"></a>Installation Theme</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ rm -rf <span class="built_in">source</span></span><br><span class="line">$ rm _config.yml package.json README.md LICENSE</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/dusign/hexo-theme-snail.git</span><br><span class="line">$ mv ./hexo-theme-snail/snail ./themes</span><br><span class="line">$ mv ./hexo-theme-snail/* ./</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><h3 id="Set-Theme"><a href="#Set-Theme" class="headerlink" title="Set Theme"></a>Set Theme</h3><p>Modify the value of <code>theme:</code> in <code>_config.yml</code><br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">snail</span></span><br></pre></td></tr></table></figure></p><h3 id="Start-the-Server"><a href="#Start-the-Server" class="headerlink" title="Start the Server"></a>Start the Server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><h3 id="Site"><a href="#Site" class="headerlink" title="Site"></a>Site</h3><p>Replace the following information with your own.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> </span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">At</span> <span class="string">the</span> <span class="string">bottom</span> <span class="string">of</span> <span class="string">the</span> <span class="string">well,</span> <span class="string">it</span> <span class="string">is</span> <span class="string">destined</span> <span class="string">to</span> <span class="string">see</span> <span class="string">only</span> <span class="string">the</span> <span class="string">sky</span> <span class="string">at</span> <span class="string">the</span> <span class="string">wellhead.</span> </span><br><span class="line">          <span class="string">However,</span> <span class="string">the</span> <span class="string">starting</span> <span class="string">point</span> <span class="string">only</span> <span class="string">affects</span> <span class="string">the</span> <span class="string">process</span> <span class="string">of</span> <span class="string">reaching</span> <span class="string">your</span> <span class="string">peak</span> <span class="string">and</span> <span class="string">does</span> <span class="string">not</span> <span class="string">determine</span> <span class="string">the</span> <span class="string">height</span> <span class="string">you</span> <span class="string">reach.</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Dusign</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">en</span></span><br><span class="line"><span class="attr">timezone:</span></span><br></pre></td></tr></table></figure></p><h3 id="Site-Settings"><a href="#Site-Settings" class="headerlink" title="Site Settings"></a>Site Settings</h3><p>Put customized pictures in <code>img</code> directory.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site settings</span></span><br><span class="line"><span class="attr">SEOTitle:</span> <span class="string">Hexo-theme-snail</span></span><br><span class="line"><span class="attr">email:</span> <span class="string">hexo-theme-snail@mail.com</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">"A hexo theme"</span></span><br><span class="line"><span class="attr">keyword:</span> <span class="string">"dusign, hexo-theme-snail"</span></span><br><span class="line"><span class="attr">header-img:</span> <span class="string">img/header_img/home-bg-1-dark.jpg</span></span><br><span class="line"><span class="attr">signature:</span> <span class="literal">true</span> <span class="comment">#show signature</span></span><br><span class="line"><span class="attr">signature-img:</span> <span class="string">img/signature/Just-do-it-white.png</span></span><br></pre></td></tr></table></figure></p><h3 id="SNS-Settings"><a href="#SNS-Settings" class="headerlink" title="SNS Settings"></a>SNS Settings</h3><p>If you don’t want to display it, you can delete it directly.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SNS settings</span></span><br><span class="line"><span class="attr">github_username:</span>    <span class="string">dusign</span></span><br><span class="line"><span class="attr">twitter_username:</span>   <span class="string">dusignr</span></span><br><span class="line"><span class="attr">facebook_username:</span>  <span class="string">Gang</span> <span class="string">Du</span></span><br><span class="line"><span class="attr">zhihu_username:</span> <span class="string">dusignr</span></span><br></pre></td></tr></table></figure></p><h3 id="Sidebar-Settings"><a href="#Sidebar-Settings" class="headerlink" title="Sidebar Settings"></a>Sidebar Settings</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sidebar Settings</span></span><br><span class="line"><span class="attr">sidebar:</span> <span class="literal">true</span>                      <span class="comment"># whether or not using Sidebar.</span></span><br><span class="line"><span class="attr">sidebar-about-description:</span> <span class="string">"Welcome to visit, I'm Dusign!"</span></span><br><span class="line"><span class="attr">sidebar-avatar:</span> <span class="string">img/ironman-draw.png</span>      <span class="comment"># use absolute URL, seeing it's used in both `/` and `/about/`</span></span><br><span class="line"><span class="attr">widgets:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">featured-tags</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">short-about</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">recent-posts</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">friends-blog</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">archive</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">category</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># widget behavior</span></span><br><span class="line"><span class="comment">## Archive</span></span><br><span class="line"><span class="attr">archive_type:</span> <span class="string">'monthly'</span></span><br><span class="line"><span class="attr">show_count:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## Featured Tags</span></span><br><span class="line"><span class="attr">featured-tags:</span> <span class="literal">true</span>                     <span class="comment"># whether or not using Feature-Tags</span></span><br><span class="line"><span class="attr">featured-condition-size:</span> <span class="number">1</span>              <span class="comment"># A tag will be featured if the size of it is more than this condition value</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## Friends</span></span><br><span class="line"><span class="attr">friends:</span> <span class="string">[</span></span><br><span class="line">    <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">"Dusign's Blog"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span> <span class="string">"https://blog.csdn.net/d_Nail"</span></span><br><span class="line">    <span class="string">&#125;,&#123;</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">"Dusign's Web"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span> <span class="string">"#"</span></span><br><span class="line">    <span class="string">&#125;,&#123;</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">"Dusign's Github"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span> <span class="string">"https://github.com/dusign"</span></span><br><span class="line">    <span class="string">&#125;,&#123;</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">"Other"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span> <span class="string">"#"</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br></pre></td></tr></table></figure><h3 id="Theme"><a href="#Theme" class="headerlink" title="Theme"></a>Theme</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">snail</span></span><br></pre></td></tr></table></figure><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">      <span class="attr">github:</span> <span class="string">github.repository.address</span></span><br><span class="line">      <span class="attr">coding:</span> <span class="string">coding.repository.address</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><h3 id="Comment"><a href="#Comment" class="headerlink" title="Comment"></a>Comment</h3><p>See httpymls://github.com/imsun/gitment for detailed configuration method.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Comment</span></span><br><span class="line"><span class="comment">## This comment system is gitment</span></span><br><span class="line"><span class="comment">## gitment url: https://github.com/imsun/gitment</span></span><br><span class="line"><span class="attr">comment:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">owner:</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">  <span class="attr">client_id:</span></span><br><span class="line">  <span class="attr">client_secret:</span></span><br></pre></td></tr></table></figure></p><h3 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Tip</span></span><br><span class="line"><span class="attr">tip:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">content:</span> <span class="string">欢迎访问</span> <span class="string">&lt;a</span> <span class="string">href="https://www.dusign.net"</span> <span class="string">target="dusign"&gt;dusign&lt;/a&gt;</span> <span class="string">的博客，博客系统一键分享的功能还在完善中，请大家耐心等待。</span></span><br><span class="line">          <span class="string">若有问题或者有好的建议欢迎留言，笔者看到之后会及时回复。</span></span><br><span class="line">          <span class="string">评论点赞需要github账号登录，如果没有账号的话请点击</span> </span><br><span class="line">          <span class="string">&lt;a</span> <span class="string">href="https://github.com"</span> <span class="string">target="view_window"</span> <span class="string">&gt;</span> <span class="string">github</span> <span class="string">&lt;/a&gt;</span> <span class="string">注册，</span> <span class="string">谢谢</span> <span class="string">!</span></span><br></pre></td></tr></table></figure><h3 id="Color-Sheme"><a href="#Color-Sheme" class="headerlink" title="Color Sheme"></a>Color Sheme</h3><p>Set the <code>enable</code> value of the desired color sheme to <code>true</code>. If the value of <code>bg_effects.star.enable</code> is <code>true</code>, please modify the value of <code>highlight_theme</code> in <code>./themes/snail/_config.yml</code> to <code>night</code>.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Color Sheme</span></span><br><span class="line"><span class="comment">## If there is no effect after modification, please empty the cache and try again.</span></span><br><span class="line"><span class="comment">## ⚠️ The following special effects will take up a lot of cpu resorces, please open it carefully.</span></span><br><span class="line"><span class="attr">bg_effects:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">color:</span> <span class="number">129</span><span class="string">,200,61</span></span><br><span class="line">    <span class="attr">pointColor:</span> <span class="number">129</span><span class="string">,200,61</span></span><br><span class="line">    <span class="attr">opacity:</span> <span class="number">0.7</span></span><br><span class="line">    <span class="attr">zIndex:</span> <span class="number">-9</span></span><br><span class="line">    <span class="attr">count:</span> <span class="number">99</span></span><br><span class="line">  <span class="attr">mouse_click:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">content:</span> <span class="string">'"🌱","just do it","🌾","🍀","don'</span><span class="string">'t give up","🍂","🌻","try it again","🍃","never say die","🌵","🌿","🌴"'</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">'"rgb(121,93,179)"</span></span><br><span class="line"><span class="string">          ,"rgb(76,180,231)"</span></span><br><span class="line"><span class="string">          ,"rgb(184,90,154)"</span></span><br><span class="line"><span class="string">          ,"rgb(157,211,250)"</span></span><br><span class="line"><span class="string">          ,"rgb(255,0,0)"</span></span><br><span class="line"><span class="string">          ,"rgb(242,153,29)"</span></span><br><span class="line"><span class="string">          ,"rgb(23,204,16)"</span></span><br><span class="line"><span class="string">          ,"rgb(222,0,0)"</span></span><br><span class="line"><span class="string">          ,"rgb(22,36,92)"</span></span><br><span class="line"><span class="string">          ,"rgb(127,24,116)"</span></span><br><span class="line"><span class="string">          ,"rgb(119,195,79)"</span></span><br><span class="line"><span class="string">          ,"rgb(4,77,34)"</span></span><br><span class="line"><span class="string">          ,"rgb(122,2,60)"'</span></span><br><span class="line">  <span class="attr">star:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><h2 id="Releases"><a href="#Releases" class="headerlink" title="Releases"></a>Releases</h2><p>V1.0</p><ul><li>fix the bugs</li><li>add comment system</li><li>add notice tips</li><li>add star sheme</li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>Apache License 2.0 Copyright(c) 2018-2020 <a href="https://github.com/dusign" target="_blank" rel="noopener">Dusign</a>   </p><p><a href="https://github.com/dusign/hexo-theme-snail" target="_blank" rel="noopener">hexo-theme-snail</a> is derived from <a href="https://github.com/Huxpro/huxpro.github.io" target="_blank" rel="noopener">Huxpro</a> Apache License 2.0. Copyright (c) 2015-2020 Huxpro</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo-theme-snail </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
