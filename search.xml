<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RAG理论-多模态RAG</title>
      <link href="2024/01/17/RAG%E7%90%86%E8%AE%BA-%E5%A4%9A%E6%A8%A1%E6%80%81RAG/"/>
      <url>2024/01/17/RAG%E7%90%86%E8%AE%BA-%E5%A4%9A%E6%A8%A1%E6%80%81RAG/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> LLM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RAG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RAG理论-第五篇-增强方法</title>
      <link href="2024/01/17/RAG%E7%90%86%E8%AE%BA-%E5%A2%9E%E5%BC%BA%E6%96%B9%E6%B3%95/"/>
      <url>2024/01/17/RAG%E7%90%86%E8%AE%BA-%E5%A2%9E%E5%BC%BA%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> LLM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RAG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RAG理论-第四篇-生成器</title>
      <link href="2024/01/17/RAG%E7%90%86%E8%AE%BA-%E7%94%9F%E6%88%90%E5%99%A8/"/>
      <url>2024/01/17/RAG%E7%90%86%E8%AE%BA-%E7%94%9F%E6%88%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> LLM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RAG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RAG理论-第三篇-检索</title>
      <link href="2024/01/17/RAG%E7%90%86%E8%AE%BA-%E6%A3%80%E7%B4%A2%E5%99%A8/"/>
      <url>2024/01/17/RAG%E7%90%86%E8%AE%BA-%E6%A3%80%E7%B4%A2%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="RAG理论-第三篇-检索"><a href="#RAG理论-第三篇-检索" class="headerlink" title="RAG理论-第三篇-检索"></a>RAG理论-第三篇-检索</h1><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h2><p>本系列以同济大学的检索增强生成（RAG）综述[1]，ACL2023 检索增强语言模型（RALM） Tutorial[2]作为参考材料，讲解RAG的前世今身，包含概述，评估方法，检索器，生成器，增强方法，多模态RAG等内容。</p><p>本篇为<strong>检索篇</strong>，介绍RAG<strong>检索器概述</strong>和三种<strong>检索器优化方法</strong>。</p><h2 id="1-检索器概述"><a href="#1-检索器概述" class="headerlink" title="1.检索器概述"></a>1.检索器概述</h2><p>检索的目的是给定一个查询和一个文档集合，检索器需要对文档进行相关性排序，返回在特定需求下与查询最相关的文档列表。根据[2]，文本检索中主要包含<strong>稀疏检索</strong>和<strong>稠密检索</strong>两大类。此外还有<strong>后交互检索</strong>[6]，即使用跨注意力编码器直接得到两个文档的相似度，由于这种检索方式效率较低，一般用于重排，本文不单独探讨这种技术。</p><h3 id="稀疏检索"><a href="#稀疏检索" class="headerlink" title="稀疏检索"></a>稀疏检索</h3><p>稀疏检索<strong>不需要训练</strong>，直接通过<strong>词语重叠</strong>计算相似度，如下图。</p><p><img src="/2024/01/17/RAG%E7%90%86%E8%AE%BA-%E6%A3%80%E7%B4%A2%E5%99%A8/image-20240117120600021.png" alt="image-20240117120600021"></p><p>稀疏检索用于检索一般分为如下步骤：</p><ul><li>对所有的文档进行分词，确定<strong>词表</strong></li><li>计算每个文档词表中每个词的<strong>词频</strong></li><li>利用合适算法结合词频信息将文档<strong>转换为向量</strong></li><li>计算<strong>向量相似度</strong>从而进行排序检索</li></ul><p>接下来简要介绍两个最常见算法：</p><ol><li><strong>TF-IDF</strong>（<strong>t</strong>erm <strong>f</strong>requency–<strong>i</strong>nverse <strong>d</strong>ocument <strong>f</strong>requency）[3]<ul><li><strong>词频</strong>（TF）是<strong>一个给定词语在某个文档</strong>中出现频率，度量<strong>词语</strong>在<strong>某个文件中的重要性</strong>。词频是对<strong>词数的标准化</strong>，防止偏向长文档（因为长文档中可能出现更多次某个词语，即使该词语并不重要）。</li><li>假设文档$d<em>j$中有K个词语，$n</em>{k,j}$是词语$t<em>k$在文档$d_j$中出现次数，则对于词语$t_i$，其<strong>词频计算公式</strong>为$tf</em>{i,j}=\frac {n<em>{i,j}} {\sum</em>{k=1}^Kn_{k,j}}$。</li><li><strong>逆向文档频率</strong>（IDF）是一个<strong>词语普遍重要性</strong>的度量。</li><li>假设一共有D个文档，$df_i$表示含有词语$t_i$的文档数量，即<strong>文档频率</strong>，则对于词语$t_i$，其<strong>逆向文档频率计算公式</strong>为$idf_i=\log_2(D/df_i)$</li><li>最终某个文档$d<em>j$中词语$t_i$的TF-IDF分数为$tdidf</em>{i,j}=tf_{i,j}\times idf_i$ </li><li>词表中每个词的TF-IDF分数拼成一个列表，组成了这个文档的向量</li><li>TF-IDF倾向于<strong>过滤常见</strong>的词语，<strong>保留重要</strong>的词语。</li></ul></li><li><strong>BM25</strong>（Okapi BM25）[4]<ul><li>BM25在TF-IDF基础上进行改进，主要面向信息检索。</li><li>假设一个查询Q含有n个词语$q<em>1,q_2,…,q_n$，对于文档$d_j$，$f(q_i,d_j)$表示$q_i$在$d_j$中出现次数，$|d_j|$表示文档长度，$avgdl$表示文档集合中文档的平均长度，$k_1,b$为超参数，BM25分数计算公式为： $score(d_j,Q)=\sum</em>{i=1}^nIDF(q_i)\cdot\frac {f(q_i,d_j)\cdot (k_1+1)} {f(q_i,d_j)+k_1\cdot(1-b+b\cdot\frac {|d_j|} {avgdl})}$</li><li>$IDF(q<em>i)=\ln(\frac {N-df</em>{q<em>i}+0.5} {df</em>{q<em>i}+0.5}+1)$，N表示文档数量，$df</em>{q_i}$表示含有$q_i$的文档数量</li></ul></li></ol><h3 id="稠密检索"><a href="#稠密检索" class="headerlink" title="稠密检索"></a>稠密检索</h3><p>稠密检索需要训练，一般来说使用单编码器或双编码器架构，将查询和文档分别编码为相同维度向量，并计算相似度。有代表性的工作比如DPR[5]，SimCSE[9]，Contriever[6]。下图演示了<strong>DPR</strong>的推理过程：</p><p><img src="/2024/01/17/RAG%E7%90%86%E8%AE%BA-%E6%A3%80%E7%B4%A2%E5%99%A8/image-20240117162453398.png" alt="image-20240117162453398"></p><p>DPR采用<strong>有监督</strong>的批内对比学习的方法把查询与相关文档拉近，和不相关文档推远，如下图所示（注意，对比学习中每个相似度计算后应当除以温度参数$\tau$，图中可以认为是$\tau=1$时的情况）：</p><p><img src="/2024/01/17/RAG%E7%90%86%E8%AE%BA-%E6%A3%80%E7%B4%A2%E5%99%A8/image-20240117162855041.png" alt="image-20240117162855041"></p><p>此外也可以通过<strong>无监督训练</strong>，<strong>Contriever</strong>[6]从文档中随机选取两段没有重叠的词语序列组成两个子文档，这两个子文档互相作为正例。而一个文档的子文档和其他文档的子文档互相构成了负例对，如下图所示：</p><p><img src="/2024/01/17/RAG%E7%90%86%E8%AE%BA-%E6%A3%80%E7%B4%A2%E5%99%A8/image-20240117163912537.png" alt="image-20240117163912537"></p><h3 id="检索评估"><a href="#检索评估" class="headerlink" title="检索评估"></a>检索评估</h3><h4 id="英文基准"><a href="#英文基准" class="headerlink" title="英文基准"></a>英文基准</h4><ol><li><strong>BEIR</strong>（Benchmarking-IR）[7]：包含18个检索数据集，9个任务以及不同领域。大部分不包含训练集，评估时直接进行<strong>零样本检索</strong>。开源地址：<a href="https://github.com/UKPLab/beir" target="_blank" rel="noopener">https://github.com/UKPLab/beir</a></li><li><strong>MTEB</strong>（Massive Text Embedding Benchmark）[16]：扩展了BEIR数据集，集成了56个数据集，可以对所有重要的文本编码功能进行评估，如检索、排序、聚类等。开源地址：<a href="https://github.com/embeddings-benchmark/mteb" target="_blank" rel="noopener">https://github.com/embeddings-benchmark/mteb</a></li><li><strong>MS MARCO</strong>（Machine Reading Comprehension Dataset）[8]：大规模的机器阅读理解数据集，可以使用这个基准中的<strong>段落排序</strong>任务评估检索。开源地址：<a href="https://microsoft.github.io/msmarco/" target="_blank" rel="noopener">https://microsoft.github.io/msmarco/</a></li><li><strong>STS</strong>（semantic textual similarity）任务：STS2012-2016[13]，STS-Benchmark[14]，SICK-Relatedness [15]，GitHub Issues Similarity Dataset[10]。此任务要求给出一对句子, 使用1~5的评分评价两者在语义上的相似程度，一般用来评估<strong>编码的质量</strong>。</li></ol><h4 id="中文基准"><a href="#中文基准" class="headerlink" title="中文基准"></a>中文基准</h4><ol><li><strong>C-MTEB</strong>[12]：作为MTEB的扩充，C-MTEB收集了包含6种任务类型的35个公共数据集。由于C-MTEB的规模和多样性，中文编码的所有主要功能都可以被可靠地评估，使其成为评估中文编码通用性的最合适的基准。开源地址：<a href="https://huggingface.co/C-MTEB" target="_blank" rel="noopener">https://huggingface.co/C-MTEB</a></li><li><strong>MTEB-zh</strong>：选取了常用的若干中文数据集，使用MTEB的方式进行评测。开源地址：<a href="https://github.com/wangyuxinwhy/uniem/tree/main/mteb-zh" target="_blank" rel="noopener">https://github.com/wangyuxinwhy/uniem/tree/main/mteb-zh</a></li></ol><h2 id="2-增强语义表示"><a href="#2-增强语义表示" class="headerlink" title="2.增强语义表示"></a>2.增强语义表示</h2><p>语义表示空间对于检索至关重要，需要通过优化文本分块和微调编码模型来提升语义表示效果。</p><h3 id="文本分块优化"><a href="#文本分块优化" class="headerlink" title="文本分块优化"></a>文本分块优化</h3><p>选择合适的文本分块策略，需要考虑<strong>内容的性质</strong>、<strong>编码模型</strong>及其<strong>最佳块大小</strong>、用户<strong>查询的预期长度</strong>和<strong>复杂度</strong>，以及<strong>特定应用程序</strong>对检索结果的<strong>利用情况</strong>。比如对于sentence-transformer选用单句话最佳，而对于OpenAI的 text-embedding-ada-002，尽量选取256-512token长度的文本块。对于问答任务和语义检索任务来说最佳文本分块策略也不一样。一般来说对于每一个特定的场景，都存在相应的最优分块策略，<strong>没有通用的最优解</strong>。</p><p>本文介绍常见的几种策略：</p><ul><li><strong>滑动窗口</strong>：用一个固定长度的上下文窗口输入语言模型进行生成，不断根据当前窗口内的上下文多次检索相应的内容。</li><li><strong>递归分块</strong>（small2big）：检索小的文本块，每个小的文本块对应于一个大文本块，将大文本块输入语言模型。</li><li><strong>摘要编码</strong>：检索文档的摘要对检索结果进行精排。</li><li><strong>元数据过滤</strong>：使用文档的元数据来过滤无关文档。</li><li><strong>图索引</strong>：将实体和关系转换为节点和边，用于解决多跳问题。</li></ul><h3 id="微调编码模型"><a href="#微调编码模型" class="headerlink" title="微调编码模型"></a>微调编码模型</h3><p>一般来说需要使用<strong>预训练的编码模型</strong>将文本块转换为向量。下面介绍常见的几个模型：</p><ol><li><strong>AngIE</strong>[10]：提出了复数空间角度优化，与之前的批内对比学习，余弦目标结合，缓解了一般的余弦相似度优化中的梯度消失问题。模型架构为BERT-base。</li><li><strong>Voyage</strong>[11]：面向特定领域和特定公司创建编码模型。</li><li><strong>BGE</strong>[12]<ul><li>模型架构为BERT，分为small，base，large等若干尺寸。</li><li>训练分为三步。第一步是<strong>预训练</strong>，在Wudao语料[17]上利用类似MAE的方式进行文本重建，即将没被遮挡的文本编码输入一个轻量解码器还原遮挡的文本。第二步是<strong>通用微调</strong>，在C-MTP[12]的无标注文本对数据集上进行对比学习。第三步是<strong>特定任务微调</strong>，在C-MTP[12]的有标注文本对数据集上进行<strong>指令编码微调</strong>，针对不同任务指令得到不同的编码。</li><li>开源工具：<a href="https://github.com/FlagOpen/FlagEmbedding" target="_blank" rel="noopener">https://github.com/FlagOpen/FlagEmbedding</a></li></ul></li><li><strong>M3E</strong>[13]：<ul><li>在2200万中文句子对上进行了批内对比学习训练。</li><li>开源工具：<a href="https://github.com/wangyuxinwhy/uniem" target="_blank" rel="noopener">https://github.com/wangyuxinwhy/uniem</a></li></ul></li></ol><p>选择好了合适的编码模型，根据<strong>不同的领域</strong>和<strong>下游任务</strong>有时需要进行相应的微调。</p><ol><li><strong>领域知识微调</strong>：需要构造特定领域的编码微调数据集，包含文档集合，查询-文档对。LlamaIndex[18]开发了一系列类和函数来简化微调过程。</li><li><strong>下游任务微调</strong>：有的方法利用LLM的能力来微调编码模型，Promptagator[19]利用LLM作为少样本查询生成器，并基于生成的数据创建特定于任务的检索器；LLM-Embedder[20]使用LLM对许多下游任务生成奖励信号，检索器使用数据集中的硬标签和LLM产生的软标签进行监督微调，这种方式让下游任务微调更高效。</li></ol><h2 id="3-对齐查询和文档"><a href="#3-对齐查询和文档" class="headerlink" title="3.对齐查询和文档"></a>3.对齐查询和文档</h2><p>用户查询有时不够精确或缺少信息，需要对用户查询进行重写或查询向量进行转换以适配特定需求。</p><h3 id="查询重写"><a href="#查询重写" class="headerlink" title="查询重写"></a>查询重写</h3><p>用户查询有时缺少语义信息或不够精确，因此需要重写。</p><ul><li>Qurey2Doc[21]和ITER-RETGEN[22]提示LLM为查询<strong>创建伪文档</strong>。</li><li>HyDE[23]提示LLM为查询生成包含核心要素的<strong>假设文档</strong>。</li><li>RRR[24]提出了重写-检索-阅读过程，利用LLM作为重写模块的强化学习激励信号或直接用于重写模块，使得重写器能够修改和<strong>完善检索查询</strong>。</li><li>STEP-BACKPROMPTING[25]让语言模型发现用户查询<strong>背后的定理</strong>来完善查询。<strong>多查询方法</strong>用LLM生成多个查询来检索相关文档，可以被用于复杂问题的<strong>子问题拆解</strong>。</li></ul><h3 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h3><ul><li>LlamaIndex[18]开发了查询编码适配器模块，微调适配器将查询编码转换为对特定任务更好的编码。</li><li>SANTA[26]使用两种预训练策略（利用内在关系对齐结构化文本和非结构化文本；遮蔽实体预测）将查询与结构化文本对齐，解决了结构化文本与非结构化文本的异质问题。</li></ul><h2 id="4-对齐检索器和LLM"><a href="#4-对齐检索器和LLM" class="headerlink" title="4.对齐检索器和LLM"></a>4.对齐检索器和LLM</h2><p>仅优化检索器有时不一定可以提升最终效果，因为检索结果可能和LLM的需求不一致，因此需要研究如何将检索器和LLM的偏好对齐。</p><h3 id="微调检索器"><a href="#微调检索器" class="headerlink" title="微调检索器"></a>微调检索器</h3><p>许多方法使用来自LLM的反馈信号来优化检索模型。</p><ul><li>AAR[27]使用FiD<strong>跨注意力</strong>分数来判断LLM的偏好文档，并使用难负例挖掘和传统的交叉熵损失，对检索器进行优化，这篇工作还发现LLM更喜欢易读的而不是信息丰富的文本。</li><li>REPLUG[28]使用一个检索器和一个<strong>冻结的LLM</strong>来计算不同文档的概率分布（每个文档拼接进上下文后输入LLM，得到的正确答案token概率作为这个文档的概率），并用KL散度对检索器进行监督训练，<strong>不需要跨注意力机制</strong>。</li><li>UPRISE[29]也使用冻结的LLM和一个可微调的<strong>提示词检索器</strong>，检索器用LLM返回的信号来优化。</li><li>Atlas[30]提出了四种方法来微调编码模型：<strong>注意力蒸馏</strong>（利用LLM跨注意力分数），<strong>EMDR2</strong>（使用EM算法，将检索结果作为隐变量），<strong>复杂度蒸馏</strong>（使用生成token的复杂度作为监督信号），<strong>LOOP</strong>（利用文档删除对于LLM预测结果的影响设计损失函数）。</li></ul><h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><ul><li>PRCA[31]通过<strong>自回归策略来训练适配器</strong>，优化检索器输出的向量。</li><li>[32]通过查询<strong>token过滤</strong>的方法来删去一些用户查询中信息含量低的token。</li><li>RECOMP[33]使用<strong>文本摘要</strong>技术来压缩文档。</li><li>PKG[34]将检索模块直接替换为一个白盒语言模型（比如llama），将知识注入白盒语言模型的方式，并通过<strong>白盒语言模型的输出作为增强知识</strong>给黑盒LLM提供输入。</li></ul><h2 id="5-引用"><a href="#5-引用" class="headerlink" title="5.引用"></a>5.引用</h2><p>[1]Gao Y, Xiong Y, Gao X, et al. Retrieval-augmented generation for large language models: A survey[J]. arXiv preprint arXiv:2312.10997, 2023.</p><p>[2]Asai A, Min S, Zhong Z, et al. Retrieval-based language models and applications[C]//Proceedings of the 61st Annual Meeting of the Association for Computational Linguistics (Volume 6: Tutorial Abstracts). 2023: 41-46.</p><p>[3]Ramos J. Using tf-idf to determine word relevance in document queries[C]//Proceedings of the first instructional conference on machine learning. 2003, 242(1): 29-48.</p><p>[4]Robertson S, Zaragoza H. The probabilistic relevance framework: BM25 and beyond[J]. Foundations and Trends® in Information Retrieval, 2009, 3(4): 333-389.</p><p>[5]Karpukhin V, Oguz B, Min S, et al. Dense Passage Retrieval for Open-Domain Question Answering[C]//Proceedings of the 2020 Conference on Empirical Methods in Natural Language Processing (EMNLP). 2020: 6769-6781.</p><p>[6]Izacard G, Caron M, Hosseini L, et al. Unsupervised Dense Information Retrieval with Contrastive Learning[J]. Transactions on Machine Learning Research, 2022.</p><p>[7]Thakur N, Reimers N, Rücklé A, et al. BEIR: A Heterogeneous Benchmark for Zero-shot Evaluation of Information Retrieval Models[C]//Thirty-fifth Conference on Neural Information Processing Systems Datasets and Benchmarks Track (Round 2). 2021.</p><p>[8]Bajaj P, Campos D, Craswell N, et al. Ms marco: A human generated machine reading comprehension dataset[J]. arXiv preprint arXiv:1611.09268, 2016.</p><p>[9]Gao T, Yao X, Chen D. SimCSE: Simple Contrastive Learning of Sentence Embeddings[C]//Proceedings of the 2021 Conference on Empirical Methods in Natural Language Processing. 2021: 6894-6910.</p><p>[10]Li X, Li J. Angle-optimized text embeddings[J]. arXiv preprint arXiv:2309.12871, 2023.</p><p>[11]VoyageAI. Voyage’s embedding models.<a href="https://docs.voyageai.com/embeddings/" target="_blank" rel="noopener">https://docs.voyageai.com/embeddings/</a>, 2023.</p><p>[12]Xiao S, Liu Z, Zhang P, et al. C-pack: Packaged resources to advance general chinese embedding[J]. arXiv preprint arXiv:2309.07597, 2023.</p><p>[13]Agirre E, Banea C, Cer D, et al. SemEval-2016 Task 1: Semantic Textual Similarity, Monolingual and Cross-Lingual Evaluation[C]//Proceedings of the 10th International Workshop on Semantic Evaluation (SemEval-2016). 2016: 497-511.</p><p>[14]Cer D, Diab M, Agirre E, et al. Semeval-2017 task 1: Semantic textual similarity-multilingual and cross-lingual focused evaluation[J]. arXiv preprint arXiv:1708.00055, 2017.</p><p>[15]Marelli M, Bentivogli L, Baroni M, et al. Semeval-2014 task 1: Evaluation of compositional distributional semantic models on full sentences through semantic relatedness and textual entailment[C]//Proceedings of the 8th international workshop on semantic evaluation (SemEval 2014). 2014: 1-8.</p><p>[16]Muennighoff N, Tazi N, Magne L, et al. MTEB: Massive Text Embedding Benchmark[C]//Proceedings of the 17th Conference of the European Chapter of the Association for Computational Linguistics. 2023: 2006-2029.</p><p>[17]Yuan S, Zhao H, Du Z, et al. Wudaocorpora: A super large-scale chinese corpora for pre-training language models[J]. AI Open, 2021, 2: 65-68.</p><p>[18]Jerry Liu. Building production-ready rag applications. <a href="https://www.ai.engineer/summit/schedule/building-production-ready-rag-applications" target="_blank" rel="noopener">https://www.ai.engineer/summit/schedule/building-production-ready-rag-applications</a>, 2023.</p><p>[19]Dai Z, Zhao V Y, Ma J, et al. Promptagator: Few-shot Dense Retrieval From 8 Examples[C]//The Eleventh International Conference on Learning Representations. 2022.</p><p>[20]Zhang P, Xiao S, Liu Z, et al. Retrieve anything to augment large language models[J]. arXiv preprint arXiv:2310.07554, 2023.</p><p>[21]Wang L, Yang N, Wei F. Query2doc: Query Expansion with Large Language Models[J]. arXiv preprint arXiv:2303.07678, 2023.</p><p>[22]Shao Z, Gong Y, Shen Y, et al. Enhancing Retrieval-Augmented Large Language Models with Iterative Retrieval-Generation Synergy[J]. arXiv preprint arXiv:2305.15294, 2023.</p><p>[23]Gao L, Ma X, Lin J, et al. Precise zero-shot dense retrieval without relevance labels[J]. arXiv preprint arXiv:2212.10496, 2022.</p><p>[24]Ma X, Gong Y, He P, et al. Query Rewriting for Retrieval-Augmented Large Language Models[J]. arXiv preprint arXiv:2305.14283, 2023.</p><p>[25]Zheng H S, Mishra S, Chen X, et al. Take a step back: evoking reasoning via abstraction in large language models[J]. arXiv preprint arXiv:2310.06117, 2023.</p><p>[26]Li X, Liu Z, Xiong C, et al. Structure-Aware Language Model Pretraining Improves Dense Retrieval on Structured Data[J]. arXiv preprint arXiv:2305.19912, 2023.</p><p>[27]Yu Z, Xiong C, Yu S, et al. Augmentation-Adapted Retriever Improves Generalization of Language Models as Generic Plug-In[J]. arXiv preprint arXiv:2305.17331, 2023.</p><p>[28]Shi W, Min S, Yasunaga M, et al. Replug: Retrieval-augmented black-box language models[J]. arXiv preprint arXiv:2301.12652, 2023.</p><p>[29]Cheng D, Huang S, Bi J, et al. UPRISE: Universal Prompt Retrieval for Improving Zero-Shot Evaluation[J]. arXiv preprint arXiv:2303.08518, 2023.</p><p>[30]Izacard G, Lewis P, Lomeli M, et al. Few-shot learning with retrieval augmented language models[J]. arXiv preprint arXiv:2208.03299, 2022.</p><p>[31]Yang H, Li Z, Zhang Y, et al. PRCA: Fitting Black-Box Large Language Models for Retrieval Question Answering via Pluggable Reward-Driven Contextual Adapter[C]//Proceedings of the 2023 Conference on Empirical Methods in Natural Language Processing. 2023: 5364-5375.</p><p>[32]Berchansky M, Izsak P, Caciularu A, et al. Optimizing Retrieval-augmented Reader Models via Token Elimination[C]//Proceedings of the 2023 Conference on Empirical Methods in Natural Language Processing. 2023: 1506-1524.</p><p>[33]Recomp: Improving retrieval-augmented lms with compression and selective augmentation[J]. arXiv preprint arXiv:2310.04408, 2023.</p><p>[34]Luo Z, Xu C, Zhao P, et al. Augmented Large Language Models with Parametric Knowledge Guiding[J]. arXiv preprint arXiv:2305.04757, 2023.</p>]]></content>
      
      
      <categories>
          
          <category> LLM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RAG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RAG理论-评估2</title>
      <link href="2024/01/16/RAG%E7%90%86%E8%AE%BA-%E8%AF%84%E4%BC%B02/"/>
      <url>2024/01/16/RAG%E7%90%86%E8%AE%BA-%E8%AF%84%E4%BC%B02/</url>
      
        <content type="html"><![CDATA[<h1 id="RAG理论-第二篇-评估2">RAG理论-第二篇-评估2<a class="anchor" href="#RAG理论-第二篇-评估2">·</a></h1><h2 id="0-前言">0.前言<a class="anchor" href="#0-前言">·</a></h2><p>本文为RAG评估篇的第2讲，补充一些RAG方法常用的评估方式</p><h2 id="1-补充评估方式">1.补充评估方式<a class="anchor" href="#1-补充评估方式">·</a></h2><h3 id="语言模型评估">语言模型评估<a class="anchor" href="#语言模型评估">·</a></h3><ol><li><strong>Perplexity</strong>（困惑度）<ul><li>代表方法：ICRALM[2]</li><li>$perplexity=(\prod_{i=1}^n\frac {1} {p(w_i|w_{1},…,w_{i-1})})^{\frac 1 n}$</li><li><strong>取对数</strong>其实就得到了语言模型的<strong>交叉熵损失函数</strong>：$\mathcal L=-\frac 1 n\sum_{i=1}^n\log p(w_i|w_{1},…,w_{i-1})$</li><li>一般是使用wikitext[4]训练集作为检索文档集，使用wikitext测试集验证困惑度</li><li>在GPT2，GPT3，ChatGPT，LLaMA等模型上测试</li></ul></li><li><strong>BPB</strong>（bits per UTF-8 encoded byte）<ul><li>代表方法：REPLUG[1]</li><li>$BPB=(L_T/L_B)\log_2(e^\mathcal L)=(L_T/L_B)\mathcal L/\ln 2$；$L_T$代表token长度，$L_B$代表字节长度；</li><li>BPB是Pile[3]建议的评估指标，因此一般也在Pile的测试集上测试</li><li>在GPT2，GPT3，ChatGPT，LLaMA等模型上测试</li></ul></li></ol><h3 id="下游任务评估">下游任务评估<a class="anchor" href="#下游任务评估">·</a></h3><ol><li><strong>专业知识问答</strong><ul><li>代表方法：REPLUG[1]</li><li>用选择题的<strong>准确率</strong>来<strong>评估</strong></li><li>数据集：MMLU[5]</li></ul></li><li><strong>开放领域问答</strong><ul><li>代表方法：REPLUG[1]</li><li>用问答的<strong>准确率</strong>来<strong>评估</strong></li><li>数据集：Natural Questions (NQ) [6]，TriviaQA[7]</li></ul></li></ol><h2 id="2-引用">2.引用<a class="anchor" href="#2-引用">·</a></h2><p>[1]Shi W, Min S, Yasunaga M, et al. Replug: Retrieval-augmented black-box language models[J]. arXiv preprint arXiv:2301.12652, 2023.</p><p>[2]Ram O, Levine Y, Dalmedigos I, et al. In-context retrieval-augmented language models[J]. arXiv preprint arXiv:2302.00083, 2023.</p><p>[3]Gao L, Biderman S, Black S, et al. The pile: An 800gb dataset of diverse text for language modeling[J]. arXiv preprint arXiv:2101.00027, 2020.</p><p>[4]Karpukhin V, Oguz B, Min S, et al. Dense Passage Retrieval for Open-Domain Question Answering[C]//Proceedings of the 2020 Conference on Empirical Methods in Natural Language Processing (EMNLP). 2020: 6769-6781.</p><p>[5]Hendrycks D, Burns C, Basart S, et al. Measuring Massive Multitask Language Understanding[C]//International Conference on Learning Representations. 2020.</p><p>[6]Kwiatkowski T, Palomaki J, Redfield O, et al. Natural Questions: a Benchmark for Question Answering Research[J]. Transactions of the Association for Computational Linguistics, 2019, 7: 452-466.</p><p>[7]Joshi M, Choi E, Weld D S, et al. TriviaQA: A Large Scale Distantly Supervised Challenge Dataset for Reading Comprehension[C]//Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers). 2017: 1601-1611.</p>]]></content>
      
      
      <categories>
          
          <category> LLM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RAG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RAG理论-第二篇-评估</title>
      <link href="2024/01/15/RAG%E7%90%86%E8%AE%BA-%E8%AF%84%E4%BC%B0/"/>
      <url>2024/01/15/RAG%E7%90%86%E8%AE%BA-%E8%AF%84%E4%BC%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="RAG理论-第二篇-评估">RAG理论-第二篇-评估<a class="anchor" href="#RAG理论-第二篇-评估">·</a></h1><h2 id="0-前言-2">0.前言<a class="anchor" href="#0-前言-2">·</a></h2><p>本系列以同济大学的检索增强生成（RAG）综述[1]，ACL2023 检索增强语言模型（RALM） Tutorial[2]作为参考材料，讲解RAG的前世今身，包含概述，评估方法，检索器，生成器，增强方法，多模态RAG等内容。</p><p>本篇为<strong>评估篇</strong>，介绍RAG的<strong>评估目标</strong>以及常见的<strong>基准和工具</strong>。</p><h2 id="1-评估目标">1.评估目标<a class="anchor" href="#1-评估目标">·</a></h2><h3 id="质量">质量<a class="anchor" href="#质量">·</a></h3><p>一般从<strong>检索质量</strong>和<strong>生成质量</strong>两方面进行评估。</p><h4 id="检索质量">检索质量<a class="anchor" href="#检索质量">·</a></h4><p>首先需要评估数据，可以采用现有信息检索数据集或用LLM构造自己领域的专属数据集，对<strong>每个查询-文档对</strong>都需要标注<strong>是否相关</strong>，或者<strong>相关程度</strong>。</p><p>一般采用搜索引擎，<strong>推荐系统和信息检索</strong>系统中的<strong>指标</strong>来衡量RAG检索效果。比如Hit Rate（类似Recall@K），MRR，NDCG[3]。</p><h4 id="生成质量">生成质量<a class="anchor" href="#生成质量">·</a></h4><p>生成质量评估可以根据生成内容的目标来分类，即无标签的和有标签。对于无标签内容，主要从生成答案的<strong>诚实性，相关性和无害性</strong>来评估。对于有标签内容，可以从生成内容的<strong>准确性</strong>来评估。检索和生成质量都可以用<strong>人工</strong>或<strong>自动评估</strong>方法[4,5]。</p><h3 id="需求">需求<a class="anchor" href="#需求">·</a></h3><h4 id="质量需求">质量需求<a class="anchor" href="#质量需求">·</a></h4><p>包含上下文相关性，答案诚实性和答案相关性[6,7,8]。</p><ul><li><p><strong>上下文相关性</strong>：检索到的文档的准确性和特异性，确保相关性，尽量降低无关内容的处理成本。（<strong>检索</strong>）</p></li><li><p><strong>答案诚实性</strong>：生成的答案相对于检索到的上下文保持真实和一致。（<strong>生成</strong>）</p></li><li><p><strong>答案相关性</strong>：生成的答案和用户提出问题相关，有效地解决核心问题。（<strong>生成</strong>）</p></li></ul><h4 id="能力需求">能力需求<a class="anchor" href="#能力需求">·</a></h4><p>包含四个方面的能力用来评估RAG的适应性和效率[9,10]：</p><ul><li><strong>噪声鲁棒性</strong>：模型管理和<strong>问题相关</strong>但<strong>缺乏足够信息</strong>的文档的能力。（<strong>检索</strong>）</li><li><strong>负排斥</strong>：当检索到的文档<strong>不包含</strong>回答问题所<strong>必需的知识</strong>时，模型是否能够拒绝回答。（<strong>生成</strong>）</li><li><strong>信息集成</strong>：从<strong>多个文档中综合信息</strong>来解决<strong>复杂</strong>问题能力。（<strong>生成</strong>）</li><li><strong>反事实鲁棒性</strong>：测试模型<strong>识别和忽略</strong>文档中<strong>不准确信息</strong>的能力，<strong>即使已经被要求</strong>使用错误信息。（<strong>检索</strong>）</li></ul><h3 id="评价指标">评价指标<a class="anchor" href="#评价指标">·</a></h3><p>[1]中的下图展示了各个需求对应的指标：</p><p><img src="/2024/01/15/RAG%E7%90%86%E8%AE%BA-%E8%AF%84%E4%BC%B0/image-20240115225401879.png" alt="image-20240115225401879"></p><p>接下来介绍常见指标的定义。首先是机器学习常见指标：</p><ul><li><strong>Accuracy</strong>：正确识别<strong>正负样本</strong>的比例（即考虑<strong>每个样本的预测</strong>是否正确）。$accuracy=\frac {TP+TN} {P+N}$</li><li><strong>Recall</strong>：正确识别<strong>正样本</strong>的比例。（即所有的正样本<strong>被召回</strong>的比例）。$recall=\frac {TP} {TP+FN}$</li><li><strong>Precision</strong>：<strong>预测为正样本</strong>的样本中<strong>确实为</strong>正样本的<strong>比例</strong>（只考虑<strong>预测为正样本</strong>的这一部分）。$precision=\frac {TP} {TP+FP}$</li><li><strong>F分数</strong>：$F_\beta=\frac {(1+\beta^2)\times precision\times recall} {\beta^2\times precision + recall}$</li></ul><p>之后是一些常见的推荐/检索指标：</p><ul><li><strong>EM（Exact Match）</strong>：常用于<strong>问答系统</strong>，预测中和正确答案（ground truth answers）完全匹配的百分比</li><li><strong>MRR（mean reciprocal rank）</strong>：评估<strong>排序性能</strong>，每个rank表示这个query对应的target文档在候选文档中的排序。$MRR=\frac 1 Q \sum_{i=1}^Q\frac 1 {rank_i}$</li><li><strong>Cosine Similarity</strong>：两个文档的表征的<strong>余弦相似度</strong></li><li><strong>MAP</strong>：AP的平均值。AP可以被简单定义为：如果某个查询有K个相关文档，返回结果中这K个文档的排序为$rank_i$（从小到大），则$AP=\sum_{i=1}^K\frac i {rank_i}$，MAP是多个查询的AP的平均值。</li><li><strong>NDCG</strong>：<ul><li>$NDCG=DCG/IDCG$</li><li>$DCG=\sum_{i=1}^k\frac {rel(i)} {log_2 (i+1)}$ $rel(i)$代表返回列表中第i个文档与查询的相关程度</li><li>$IDCG$代表最理想的返回列表的$DCG$结果，即按照$rel(i)$从高到低排序。</li></ul></li><li><strong>Hit Rate（Recall@K）</strong>：对每个查询返回的前K个文档中含有正确文档的比例</li></ul><h2 id="2-评估基准与工具">2.评估基准与工具<a class="anchor" href="#2-评估基准与工具">·</a></h2><h3 id="基准">基准<a class="anchor" href="#基准">·</a></h3><p>主流的基准有RGB[9]和RECALL[10]，侧重评估RAG的基础能力。</p><ol><li><strong>RGB</strong><ul><li>开源地址：https://github.com/chen700564/RGB</li><li>问答对形式，1000个问题，600个基础问题，200个专门面向信息集成的问题，200个专门面向反事实鲁棒性的问题。一半中文一半英文。</li><li>从互联网和新闻中搜寻文档，利用编码模型m3e（中文）和mpnet（英文）进行重排。</li><li>评估模型：ChatGPT，ChatGLM，Vicuna-7B，Qwen-7B，BELLE-7B-2M</li><li>结论：对于噪声鲁棒性，随着<strong>噪声文档的增加</strong>（即不相关文档数量增加），RAG的<strong>性能逐渐下降</strong>；负排斥，信息集成，反事实鲁棒性对于RAG都很<strong>困难</strong>，提升空间都很大。</li><li>关注<strong>RAG的整体</strong></li></ul></li><li><strong>RECALL</strong><ul><li>问答对形式，每个问题的提示都含有一段包含错误内容的文本，有的文本修改答案文本，有的文本修改非答案文本。模型被提供正确和错误答案两个选项。</li><li>评估模型：ChatGLM2，Llama2，Vicuna，Baichuan2</li><li>结论：模型很容易被错误的上下文误导，且内在知识和上下文矛盾时很容易产生质量较低的回复。通过<strong>提示词优化</strong>与<strong>推理干预</strong>方法没法很好的解决，需要设计更好的方法。</li><li>只关注<strong>生成</strong>。</li></ul></li></ol><h3 id="工具">工具<a class="anchor" href="#工具">·</a></h3><p>最先进的自动化工具有RAGAS[6]，ARES[7]和Trulens[11]，使用LLM来自动评估。这部分工作主要以和人类的标注对齐为主要贡献，没有给出不同方法的对比。</p><ol><li><strong>RAGAS</strong><ul><li>开源地址：https://github.com/explodinggradients/ragas</li><li>创建了WikiEval数据集：https://huggingface.co/datasets/explodinggradients/WikiEval。根据50个wiki页面提示ChatGPT得到问题和答案。</li><li>提示ChatGPT的方式评估，实验表明人类标注和RAGAS提出的标注方式的结果基本一致。</li><li>评估目标包含上下文相关性，答案诚实性，答案相关性。</li><li>关注<strong>RAG整体</strong></li></ul></li><li><strong>ARES</strong><ul><li>开源地址：https://github.com/stanford-futuredata/ARES</li><li>和RAGAS的评估目标一致。训练一个小型LM来进行评估。</li><li>包含KILT和SuperGLUE中的6个不同的知识密集型任务。</li><li>关注<strong>RAG整体</strong></li></ul></li><li><strong>Trulens</strong><ul><li>开源地址：https://github.com/truera/trulens</li><li>和RAGAS的评估目标一致。</li><li>关注<strong>RAG整体</strong></li></ul></li></ol><h2 id="3-结论">3.结论<a class="anchor" href="#3-结论">·</a></h2><p>[1]中的下图展示了各个基准或工具的相应评估目标，其中<em>Evaluation Targets</em>代表是哪个方面的质量，<em>Evaluation Aspects</em>代表是哪个方面的需求。个人认为，综合易用性和全面性，比较适合用于<strong>学术评估</strong>的是<strong>RGB和RAGAS</strong>。TruLens含有对<strong>向量数据库的支持</strong>，ARES需要对<strong>特定领域</strong>进行<strong>打分器训练</strong>后再评估，可以考虑根据不同用途选用这两个工具进行评估。</p><p><img src="/2024/01/15/RAG%E7%90%86%E8%AE%BA-%E8%AF%84%E4%BC%B0/image-20240115231628173.png" alt="image-20240115231628173"></p><h2 id="4-引用-2">4.引用<a class="anchor" href="#4-引用-2">·</a></h2><p>[1]Gao Y, Xiong Y, Gao X, et al. Retrieval-augmented generation for large language models: A survey[J]. arXiv preprint arXiv:2312.10997, 2023.</p><p>[2]Asai A, Min S, Zhong Z, et al. Retrieval-based language models and applications[C]//Proceedings of the 61st Annual Meeting of the Association for Computational Linguistics (Volume 6: Tutorial Abstracts). 2023: 41-46.</p><p>[3]Isabelle Nguyen. Evaluating rag part i: How to evaluate document retrieval. https://www.deepset.ai/blog/rag-evaluation-retrieval, 2023.</p><p>[4]Tian Lan, Deng Cai, Yan Wang, Heyan Huang, and Xian-Ling Mao. Copy is all you need. In The Eleventh International Conference on Learning Representations, 2022.</p><p>[5]Quinn Leng, Kasey Uhlenhuth, and Alkis Polyzotis. Best practices for llm evaluation of rag applications. https://www.databricks.com/blog/LLM-auto-eval-best-practices-RAG, 2023.</p><p>[6]Es S, James J, Espinosa-Anke L, et al. Ragas: Automated evaluation of retrieval augmented generation[J]. arXiv preprint arXiv:2309.15217, 2023.</p><p>[7]Saad-Falcon J, Khattab O, Potts C, et al. Ares: An automated evaluation framework for retrieval-augmented generation systems[J]. arXiv preprint arXiv:2311.09476, 2023.</p><p>[8]Colin Jarvis and John Allard. A survey of techniques for maximizing llm performance. https://community.openai.com/t/openai-dev-day-2023-breakout-sessions/505213#a-survey-of-techniques-for-maximizing-llm-performance-2, 2023.</p><p>[9]Chen J, Lin H, Han X, et al. Benchmarking large language models in retrieval-augmented generation[J]. arXiv preprint arXiv:2309.01431, 2023.</p><p>[10]Liu Y, Huang L, Li S, et al. RECALL: A Benchmark for LLMs Robustness against External Counterfactual Knowledge[J]. arXiv preprint arXiv:2311.08147, 2023.</p><p>[11]https://www.trulens.org/trulens_eval/core_concepts_rag_triad/</p>]]></content>
      
      
      <categories>
          
          <category> LLM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RAG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RAG理论-第一篇-概述</title>
      <link href="2024/01/15/RAG%E7%90%86%E8%AE%BA-%E6%A6%82%E8%BF%B0/"/>
      <url>2024/01/15/RAG%E7%90%86%E8%AE%BA-%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="RAG理论-第一篇-概述">RAG理论-第一篇-概述<a class="anchor" href="#RAG理论-第一篇-概述">·</a></h1><h2 id="0-前言">0.前言<a class="anchor" href="#0-前言">·</a></h2><p>本系列以同济大学的检索增强生成（RAG）综述[1]，ACL2023 检索增强语言模型（RALM） Tutorial[2]作为参考材料，讲解RAG的前世今身，包含概述，评估方法，检索器，生成器，增强方法，多模态RAG等内容。</p><p>本篇为<strong>概述篇</strong>，介绍RAG的<strong>基本概念</strong>和<strong>技术分类</strong>。</p><h2 id="1-介绍">1.介绍<a class="anchor" href="#1-介绍">·</a></h2><p>GPT系列，LLaMA，Gemini等取得了很好的效果，但是对于<strong>特定领域或高度专业化的用户查询</strong>，尤其是查询<strong>超出了模型的训练数据</strong>或者<strong>需要最新的信息</strong>时，大模型很容易产生<strong>错误的信息或幻觉现象</strong>，从而使得大模型的落地较为困难，一个缓解这些限制的方法是检索增强生成（RAG）。RAG将<strong>外部的数据检索</strong>整合到生成过程中，从而使模型能够提供<strong>准确且相关</strong>的回复。</p><p>[3]提出了RAG的概念，如下图，给定query先用最小内积搜索（MIPS）检索最相关的k个文档，得到相应的文档编码z，利用查询编码x和z组合输入生成器得到最终的输出。</p><p><img src="/2024/01/15/RAG%E7%90%86%E8%AE%BA-%E6%A6%82%E8%BF%B0/RAG%E5%BC%80%E5%B1%B1%E9%BC%BB%E7%A5%96.png" alt="image-20240114154436478"></p><p>RAG发展经历了几个阶段，最开始以基于<strong>Transformer</strong>的<strong>预训练阶段的优化</strong>为主，接下来是一段<strong>沉寂期</strong>。直到ChatGPT的出现，RAG研究重点转向为利用LLM的能力获得更高的可控性和解决不断发展的需求，主流的研究集中在<strong>推理</strong>上，<strong>微调</strong>的研究相对较少。随着GPT4的出现，研究重点再次转变为<strong>混合方法</strong>，即推理，微调和预训练三种方法及结合。</p><p><img src="/2024/01/15/RAG%E7%90%86%E8%AE%BA-%E6%A6%82%E8%BF%B0/RAG%E5%8F%91%E5%B1%95%E6%A0%91.png" alt="image-20240114154741484"></p><h2 id="2-定义">2.定义<a class="anchor" href="#2-定义">·</a></h2><p>下图是[1]中一个简单的RAG应用流。包含<strong>用户输入，文档查询，文档与提示组合，获得输出</strong>四个步骤。</p><img src="/2024/01/15/RAG%E7%90%86%E8%AE%BA-%E6%A6%82%E8%BF%B0/RAG定义1.png" alt="image-20240114155729001" style="zoom: 80%;"><p>下图是[2]中定义的检索增强生成的基本组成，即必要条件为：<strong>推理阶段</strong>使用<strong>外部数据库</strong>进行<strong>辅助生成</strong>。</p><p><img src="/2024/01/15/RAG%E7%90%86%E8%AE%BA-%E6%A6%82%E8%BF%B0/RAG%E5%AE%9A%E4%B9%892.png" alt="RALLM"></p><p>[2]中主要认为检索增强生成主要需要解决3个问题，即<strong>检索什么，怎样使用检索结果，什么时候检索</strong>。下列小括号中为代表性方法。</p><ul><li>检索什么分为文本块（REALM[8] ICRALM[4]），词语（KNN-LM[5]），实体（EASE[9]），知识图谱（KGALM[10]）等。综合来看效率最高的方法为文本块。</li><li>怎样使用检索结果分为输入层使用（REALM[8] ICRALM[4] DSP[12]），中间层使用（RETRO[11]），输出层使用（REPLUG[7] KNN-LM[5] InterGen[13]）。其中中间层使用往往需要修改模型结构以及重新训练，因此一般使用输入层和输出层使用的方法。</li><li>什么时候检索分为单次检索（REALM[8] REPLUG[7] SKR[14]），多次检索（ICRALM[4] Atlas[17]），适应性检索（Adapt-KNN-LM[6] FLARE[15] RAVEN[16]）。</li></ul><p><img src="/2024/01/15/RAG%E7%90%86%E8%AE%BA-%E6%A6%82%E8%BF%B0/3problemanswer.png" alt="3problemanswer"></p><p>总的来说RAG融合了<strong>信息检索技术</strong>和<strong>上下文学习技术</strong>来提升LLM能力。现在的研究一般将RAG分为三步进行：</p><ul><li>语料被<strong>分割</strong>为多个离散的文本块，同时创建<strong>向量索引</strong></li><li>RAG使用向量<strong>检索</strong>得到相关的文本块</li><li>模型结合用户输入与检索到的文档进行推理<strong>生成</strong>获得相应的<strong>输出</strong></li></ul><h2 id="3-RAG框架">3.RAG框架<a class="anchor" href="#3-RAG框架">·</a></h2><p>下图为三种RAG框架的展示与对比。三种RAG从左至右逐渐扩大范围，<strong>右边包含了左边的技术</strong>。此部分内容也可参考IVAN ILIN大佬的博客<a href="https://pub.towardsai.net/advanced-rag-techniques-an-illustrated-overview-04d193d8fec6" target="_blank" rel="noopener">Advanced RAG Techniques: an Illustrated Overview</a></p><p>Naive RAG主要包含了<strong>检索</strong>和<strong>阅读</strong>两个模块，而Advanced RAG在Naive RAG基础上主要增加了<strong>查询重写</strong>和<strong>重排序</strong>，而Modular RAG在Advance RAG基础上更加<strong>多样化</strong>且更加<strong>灵活</strong>。</p><p><img src="/2024/01/15/RAG%E7%90%86%E8%AE%BA-%E6%A6%82%E8%BF%B0/%E4%B8%89%E7%A7%8DRAG%E6%A1%86%E6%9E%B6.png" alt="image-20240114163830249"></p><h3 id="Naive-RAG">Naive RAG<a class="anchor" href="#Naive-RAG">·</a></h3><p>Naive RAG是基本的“检索-阅读”框架：<strong>索引，检索，生成</strong>三步走。</p><p>索引包括<strong>文档转换</strong>（将pdf，html，word，markdown等内容转换为纯文本），<strong>分块</strong>，<strong>编码得到文本块向量</strong>，<strong>索引建立</strong>（一般使用向量数据库比如Faiss，Milvus等）</p><p>存在的问题：</p><ul><li>检索：低召回率，文本不相关或过时，重要性和相关性如何衡量</li><li>生成：仍然产生幻觉，毒性，过度依赖检索文档</li><li>增强：产生不连贯不一致的回复，重复内容</li></ul><h3 id="Advanced-RAG">Advanced RAG<a class="anchor" href="#Advanced-RAG">·</a></h3><p>Advanced RAG主要优化Naive RAG中的<strong>检索</strong>流程</p><ol><li><strong>检索前处理</strong>：即优化数据索引<ul><li>增强数据粒度。增加文本标准化，一致性，事实准确性与丰富的上下文。包含无关信息去除，实体消歧，事实核查，更新过时文档</li><li>优化索引结构：块大小调整，多个索引路径查询，从图数据中捕捉相关上下文</li><li>加入元数据信息：加入日期，用途，章节号等信息</li><li>对齐优化：SANTA[18]引入假设性问题解决文档的差异性（对齐结构化和非结构化文档）</li></ul></li><li><strong>检索模型优化</strong><ul><li>微调编码：定制特定领域的编码模型。可以使用BGE模型作为基础，使用GPT和领域语料针对语料的文本块生成查询，构成查询-文档对组成训练数据。</li><li>动态编码：与静态嵌入（word2vec，glove）不同，动态嵌入（BERT，GPT）使用Transformer对每个词语根据上下文不同得到不同的特征</li></ul></li><li><strong>检索后处理</strong>：将检索文档与查询合并为LLM的输入，解决上下文长度限制。直接添加文档会引入噪音，且失去了对关键信息的关注。<ul><li>重排序：将<strong>检索信息进行重排序</strong>并将最相关内容放在<strong>提示词的末尾</strong>是一个关键的策略。这个概念在许多框架比如<a href="https://www.llamaindex.ai" target="_blank" rel="noopener">LlamaIndex</a>，<a href="https://www.langchain.com/" target="_blank" rel="noopener">LangChain</a>，<a href="https://haystack.deepset.ai/blog/enhancing-rag-pipelines-in-haystack" target="_blank" rel="noopener">HayStack</a>。<a href="https://haystack.deepset.ai/blog/enhancing-rag-pipelines-in-haystack" target="_blank" rel="noopener">Diversity Ranker</a>根据文档多样性进行重排序，LostInTheMiddleRanker将最佳文档放在上下文窗口的<strong>最开始和最末尾</strong>。还有<a href="https://txt.cohere.com/rerank/" target="_blank" rel="noopener">cohereAI rerank</a>，<a href="https://huggingface.co/BAAI/bge-reranker-large" target="_blank" rel="noopener">bge-rerank</a>，LongLLMLingua[19]等根据查询与文档的语义相似度进行重新计算与排序，这些模型一般采用效率低但精读高的<strong>跨注意力编码器</strong>。</li><li>提示压缩：压缩不相关的上下文，突出关键段落，并减少整体上下文长度。 Selective Context[20]和LLMLingua[21]使用小模型计算互信息或复杂度，估计每个元素的重要性，留下<strong>重要的token序列</strong>。Recomp[22]，LongContext[23]和<em>Walking down the Memory Maze</em>[24]设计了文本摘要模块来增强LLM的关键信息感知能力。</li></ul></li></ol><h3 id="Modular-RAG">Modular RAG<a class="anchor" href="#Modular-RAG">·</a></h3><p>Modular RAG结合了各种方法来提升各个模块性能。模块化的RAG范式正日益成为RAG领域的规范，允许使用<strong>序列化流水线</strong>或<strong>跨多个模块的端到端训练</strong>方法。</p><h4 id="新模块">新模块<a class="anchor" href="#新模块">·</a></h4><ul><li><strong>搜索模块</strong>：与相似度检索不同，这部分可以被应用于特定的场景并在一些特殊语料上进行检索。一般使用LLM代码生成SQL或Cypher或使用其他工具进行查询。这部分数据源包括<strong>搜索引擎，文本数据，表格数据和知识图谱</strong>。</li><li><strong>存储模块</strong>：使用LLM的存储能力来指导检索。一般需要找出LLM存储中和当前输入最相似的部分。Selfmem[25]使用了一个检索增强的生成器来迭代创建一个无上限的存储池（即很多个自己的回复），并用检索器选择最合适的存储来改进自己（和用户输入拼接在一起），文本在推理过程中与数据分布更加一致。检索部分利用模型生成的文本与标注输出文本之间的BLEU分数作为每个存储内容的分数标签。</li><li><strong>融合模块</strong>：RAG-Fusion[26]使用LLM将用户查询扩展为多个查询。这个方法不仅捕捉了用户需要的显示信息，也揭示了更深层次的知识。融合过程包括对原始查询和扩展查询的并行向量搜索，智能重排序，并得到最佳搜索结果。这种复杂的方法确保了搜索结果与用户的显式和隐含的意图保持紧密一致，从而能找到更深刻和更相关的信息。</li><li><strong>路由</strong>：RAG系统的检索流程使用了各种来源的内容，包含不同领域、语言、形式。这些内容都可以根据需要进行修改或合并[27]。查询路由决定对用户查询的<strong>后续操作</strong>，其选项包括<strong>摘要</strong>、<strong>搜索特定数据库</strong>或<strong>将不同的路径合并到单个响应</strong>中。查询路由器还为查询选择适当的数据库，其中可能包括各种来源内容，如<strong>向量数据库、图数据库或关系数据库，或层次结构索引</strong>。开发者需要<strong>预先定义好</strong>查询路由器的<strong>决策</strong>方式，并通过<strong>LLM调用执行</strong>，它将查询指向所选的索引。</li><li><strong>预测</strong>：这个技术减少了检索内容中的<strong>冗余和噪声</strong>。该模块不是直接进行检索，而是利用LLM来<strong>生成必要的上下文</strong>[28]。与通过直接检索获得的内容相比，LLM生成上下文后检索得到的内容更有可能包含相关信息。</li><li><strong>任务适配器</strong>：本模块侧重于使RAG适应各种下游任务。UPRISE[29]可以从预先构建好的提示词池中自动检索零样本任务输入的提示词，从而增强了模型的不同任务通用性。同时，Promptagator[30]利用LLM作为少样本查询生成器，并基于生成的数据创建特定于任务的检索器。通过利用LLM的泛化能力，它可以通过最小的示例开发特定于任务的端到端检索器。</li></ul><h4 id="新模式">新模式<a class="anchor" href="#新模式">·</a></h4><ul><li><strong>添加或替换模块</strong>：这部分一般保留RAG的主要框架，增加或替换其中某些模块。可以添加模块，RRR[31]提出了重写-检索-阅读过程，利用LLM作为重写模块的强化学习激励信号或直接用于重写模块，使得重写器能够修改和<strong>完善检索查询</strong>，从而提高阅读过程中下游任务性能。可以替换模块，Generate-Read[28]方法使用<strong>LLM生成模块代替了检索模块</strong>。 Recite-Read[32]方法将外部搜索转换为<strong>从模型自身权重进行搜索</strong>，要求LLM首先训练一个背诵LM，用于根据问题生成相应的段落提示词和背诵内容，之后利用背诵LM对不同问题生成不同的背诵内容，并与用户输入拼接后生成回复。</li><li><strong>调整模块间的顺序</strong>：这部分重点关注如何增强语言模型和检索模型间的联系。DSP[12]提出了Demonstrate-Search-Predict框架，将上下文学习当作一个程序而不只是简单的提示词组成，每一个问题都含有几个示例，先对<strong>示例中的问题尝试进行检索与生成</strong>，筛选出较好的示例；之后利用这些示例，利用<strong>LLM生成查询进行检索</strong>得到检索结果；最终利用示例，检索结果生成答案。ITER-RETGEN [33]该方法利用生成的内容来指导检索，即先进行一次<strong>检索增强生成</strong>，将生成结果与用户查询拼接在一起进行检索（即<strong>生成增强检索</strong>），再利用检索到的结果进行<strong>检索增强生成</strong>，如此<strong>反复迭代</strong>，该方法展示了一种使用一个模块的输出来改进另一个模块的功能。</li></ul><h4 id="优化RAG流水线">优化RAG流水线<a class="anchor" href="#优化RAG流水线">·</a></h4><p>这一部分主要优化了检索流程，力求取得检索效率和上下文信息含量的平衡。</p><ul><li><strong>混合搜索</strong>：使用关键词搜索，语义搜索，向量搜索多种方式</li><li><strong>递归检索</strong>：递归检索先检索文档的小文本块，之后利用小块与大块之间的关系得到相应的大文本块</li><li><strong>溯源提示</strong>：这部分内容主要让LLM不仅利用具体的实例，还能利用更多的概念和定理[34]，主要思想是对问题进行抽象化，得到其根问题，比如对一道具体的物理题得到根问题为“问题背后的物理原理是什么？”，之后利用这一根问题让模型背诵自己固有知识中的相应原理，根据原理得到更准确的答案。</li><li><strong>子查询</strong>：将查询利用LLM分解成几个子查询再进行检索。</li><li><strong>查询引擎</strong>：LlamaIndex使用了树查询，向量查询或简单的顺序块查询</li><li><strong>假设文档嵌入</strong>：一种方式是对每个文本块使用LLM生成相应的<strong>假设问题</strong>。另一种是HyDE[35]，利用查询输入LLM生成可能的<strong>假设返回结果</strong>，利用<strong>假设返回结果</strong>检索更准确的文档。但当语言模型本身没见过这类问题时，这种方法效果较差。</li></ul><h2 id="4-引用">4.引用<a class="anchor" href="#4-引用">·</a></h2><p>[1]Gao Y, Xiong Y, Gao X, et al. Retrieval-augmented generation for large language models: A survey[J]. arXiv preprint arXiv:2312.10997, 2023.</p><p>[2]Asai A, Min S, Zhong Z, et al. Retrieval-based language models and applications[C]//Proceedings of the 61st Annual Meeting of the Association for Computational Linguistics (Volume 6: Tutorial Abstracts). 2023: 41-46.</p><p>[3]Lewis P, Perez E, Piktus A, et al. Retrieval-augmented generation for knowledge-intensive nlp tasks[J]. Advances in Neural Information Processing Systems, 2020, 33: 9459-9474.</p><p>[4]Ram O, Levine Y, Dalmedigos I, et al. In-context retrieval-augmented language models[J]. arXiv preprint arXiv:2302.00083, 2023.</p><p>[5]Khandelwal U, Levy O, Jurafsky D, et al. Generalization through Memorization: Nearest Neighbor Language Models[C]//International Conference on Learning Representations. 2019.</p><p>[6]He J, Neubig G, Berg-Kirkpatrick T. Efficient Nearest Neighbor Language Models[C]//Proceedings of the 2021 Conference on Empirical Methods in Natural Language Processing. 2021: 5703-5714.</p><p>[7]Shi W, Min S, Yasunaga M, et al. Replug: Retrieval-augmented black-box language models[J]. arXiv preprint arXiv:2301.12652, 2023.</p><p>[8]Guu K, Lee K, Tung Z, et al. Retrieval augmented language model pre-training[C]//International conference on machine learning. PMLR, 2020: 3929-3938.</p><p>[9]Nishikawa S, Ri R, Yamada I, et al. EASE: Entity-Aware Contrastive Learning of Sentence Embedding[C]//Proceedings of the 2022 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies. 2022: 3870-3885.</p><p>[10]Kang M, Kwak J M, Baek J, et al. Knowledge Graph-Augmented Language Models for Knowledge-Grounded Dialogue Generation[J]. arXiv preprint arXiv:2305.18846, 2023.</p><p>[11]Borgeaud S, Mensch A, Hoffmann J, et al. Improving language models by retrieving from trillions of tokens[C]//International conference on machine learning. PMLR, 2022: 2206-2240.</p><p>[12]Khattab O, Santhanam K, Li X L, et al. Demonstrate-Search-Predict: Composing retrieval and language models for knowledge-intensive NLP[J]. arXiv preprint arXiv:2212.14024, 2022.</p><p>[13]Liang H, Zhang W, Li W, et al. InterGen: Diffusion-based Multi-human Motion Generation under Complex Interactions[J]. arXiv preprint arXiv:2304.05684, 2023.</p><p>[14]Wang Y, Li P, Sun M, et al. Self-knowledge guided retrieval augmentation for large language models[J]. arXiv preprint arXiv:2310.05002, 2023.</p><p>[15]Jiang Z, Xu F F, Gao L, et al. Active retrieval augmented generation[J]. arXiv preprint arXiv:2305.06983, 2023.</p><p>[16]Huang J, Ping W, Xu P, et al. Raven: In-context learning with retrieval augmented encoder-decoder language models[J]. arXiv preprint arXiv:2308.07922, 2023.</p><p>[17]Izacard G, Lewis P, Lomeli M, et al. Few-shot learning with retrieval augmented language models[J]. arXiv preprint arXiv:2208.03299, 2022.</p><p>[18]Li X, Liu Z, Xiong C, et al. Structure-Aware Language Model Pretraining Improves Dense Retrieval on Structured Data[J]. arXiv preprint arXiv:2305.19912, 2023.</p><p>[19]Jiang H, Wu Q, Lin C Y, et al. Llmlingua: Compressing prompts for accelerated inference of large language models[J]. arXiv preprint arXiv:2310.05736, 2023.</p><p>[20]Litman R, Anschel O, Tsiper S, et al. Scatter: selective context attentional scene text recognizer[C]//proceedings of the IEEE/CVF conference on computer vision and pattern recognition. 2020: 11962-11972.</p><p>[21]Jiang H, Wu Q, Lin C Y, et al. LLMLingua: Compressing Prompts for Accelerated Inference of Large Language Models[C]//Proceedings of the 2023 Conference on Empirical Methods in Natural Language Processing. 2023: 13358-13376.</p><p>[22]Xu F, Shi W, Choi E. Recomp: Improving retrieval-augmented lms with compression and selective augmentation[J]. arXiv preprint arXiv:2310.04408, 2023.</p><p>[23]Xu P, Ping W, Wu X, et al. Retrieval meets long context large language models[J]. arXiv preprint arXiv:2310.03025, 2023.</p><p>[24]Chen H, Pasunuru R, Weston J, et al. Walking down the memory maze: Beyond context limit through interactive reading[J]. arXiv preprint arXiv:2310.05029, 2023.</p><p>[25]Cheng X, Luo D, Chen X, et al. Lift Yourself Up: Retrieval-augmented Text Generation with Self Memory[J]. arXiv preprint arXiv:2305.02437, 2023.</p><p>[26]Adrian H. Raudaschl. Forget rag, the future is rag-fusion. https://towardsdatascience.com/forget-rag-the-future-is-rag-fusion-1147298d8ad1, 2023.</p><p>[27]Li X, Nie E, Liang S. From classification to generation: Insights into crosslingual retrieval augmented icl[J]. arXiv preprint arXiv:2311.06595, 2023.</p><p>[28]Yu W, Iter D, Wang S, et al. Generate rather than retrieve: Large language models are strong context generators[J]. arXiv preprint arXiv:2209.10063, 2022.</p><p>[29]Cheng D, Huang S, Bi J, et al. UPRISE: Universal Prompt Retrieval for Improving Zero-Shot Evaluation[J]. arXiv preprint arXiv:2303.08518, 2023.</p><p>[30]Dai Z, Zhao V Y, Ma J, et al. Promptagator: Few-shot Dense Retrieval From 8 Examples[C]//The Eleventh International Conference on Learning Representations. 2022.</p><p>[31]Ma X, Gong Y, He P, et al. Query Rewriting for Retrieval-Augmented Large Language Models[J]. arXiv preprint arXiv:2305.14283, 2023.</p><p>[32]Sun Z, Wang X, Tay Y, et al. Recitation-augmented language models[J]. arXiv preprint arXiv:2210.01296, 2022.</p><p>[33]Shao Z, Gong Y, Shen Y, et al. Enhancing Retrieval-Augmented Large Language Models with Iterative Retrieval-Generation Synergy[J]. arXiv preprint arXiv:2305.15294, 2023.</p><p>[34]Zheng H S, Mishra S, Chen X, et al. Take a step back: evoking reasoning via abstraction in large language models[J]. arXiv preprint arXiv:2310.06117, 2023.</p><p>[35]Gao L, Ma X, Lin J, et al. Precise zero-shot dense retrieval without relevance labels[J]. arXiv preprint arXiv:2212.10496, 2022.</p>]]></content>
      
      
      <categories>
          
          <category> LLM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RAG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习导论</title>
      <link href="2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/"/>
      <url>2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="一、引论">一、引论<a class="anchor" href="#一、引论">·</a></h1><h3 id="机器学习定义">机器学习定义<a class="anchor" href="#机器学习定义">·</a></h3><p>Tom Mitchell：Well-posed Learning Problem: A computer program is said to learn from <strong>experience E</strong> with respect to some <strong>task T</strong> and some <strong>performance measure P</strong>, if its performance on T, as measured by P, improves with experience E (1998).</p><h3 id="机器学习研究问题">机器学习研究问题<a class="anchor" href="#机器学习研究问题">·</a></h3><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/1.png" style="zoom:50%;"><h1 id="二、模型评估与选择">二、模型评估与选择<a class="anchor" href="#二、模型评估与选择">·</a></h1><h2 id="误差">误差<a class="anchor" href="#误差">·</a></h2><p>误差 训练误差/经验误差 测试误差/泛化误差</p><h2 id="数据集划分">数据集划分<a class="anchor" href="#数据集划分">·</a></h2><p>划分为训练集与测试集，两者尽可能互斥。</p><h3 id="保持-留出法-hold-out">保持/留出法**(hold-out)**<a class="anchor" href="#保持-留出法-hold-out">·</a></h3><p>随即划分两个集合，一版2/3为训练，1/3为测试</p><h3 id="随机子抽样-random-sub-sampling">随机子抽样(random sub-sampling)<a class="anchor" href="#随机子抽样-random-sub-sampling">·</a></h3><p>随机选择，保持方法重复K次，总准确率取平均</p><h3 id="K折交叉验证-k-fold-cross-validation">K折交叉验证(k-fold cross-validation)<a class="anchor" href="#K折交叉验证-k-fold-cross-validation">·</a></h3><p>开始时分为k个大小相似的折，训练测试k次，第i次迭代时，第i折用于测试，其余用于训练。</p><h3 id="留一法-leave-one-out">留一法(leave-one-out)<a class="anchor" href="#留一法-leave-one-out">·</a></h3><p>K折交叉的特殊情况，只给检验集留<strong>1个样本</strong></p><h3 id="自助法">自助法<a class="anchor" href="#自助法">·</a></h3><p>有放回等可能地从初始样本D中均匀抽样，采样D次即可产生|D|长度数据集。对于小数据集和集成学习有较好效果。</p><h2 id="性能度量">性能度量<a class="anchor" href="#性能度量">·</a></h2><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/6.png" style="zoom:50%;"><p><strong>分类任务</strong>中，虽然错误率和精度计算简单，但是当<strong>数据类别不均衡</strong>时，<strong>占比大类</strong>成为影响结果的主要因素，不能提供更详细评估。</p><h3 id="性能度量-混淆矩阵">性能度量-混淆矩阵<a class="anchor" href="#性能度量-混淆矩阵">·</a></h3><p>包括每一类的正确和错误的样本个数，包括正确和错误的分类。主对角线上的是正确预测的，其他的是预测错误的。</p><h4 id="混淆矩阵-两类">混淆矩阵-两类<a class="anchor" href="#混淆矩阵-两类">·</a></h4><p>仅有正、负样本2类。用T和F（或1和0）来表征正确错误，P表示正例，N表示反例</p><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/7.png" style="zoom:50%;"><ul><li>TP ：被分类器<strong>正确分类</strong>的<strong>正元组</strong>；期望为P，分类为P：称为<strong>真正</strong></li><li>TN：被分类器<strong>正确分类</strong>的<strong>负元组</strong>； 期望为N，分类为N：称为<strong>真负</strong></li><li>FP：被<strong>错误标记为正元组</strong>的<strong>负元组</strong>； 期望为N，分类为P：称为<strong>假正</strong></li><li>FN：被<strong>错误标记为负元组</strong>的<strong>正元组</strong>。期望为P，分类为N：称为<strong>假负</strong></li></ul><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/21.png" style="zoom:50%;"><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/22.png" style="zoom: 50%;"><h4 id="P-R曲线">P-R曲线<a class="anchor" href="#P-R曲线">·</a></h4><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/23.png" style="zoom:50%;"><p>查全率/召回率其实是看所有的正样本中，有多少被成功标记成正的。</p><p>查准率则是，判断为正的样本中，有多少是正确的。</p><p>查准率与查全率<strong>相互矛盾</strong></p><h3 id="性能度量-F分数">性能度量-F分数<a class="anchor" href="#性能度量-F分数">·</a></h3><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/24.png" style="zoom:50%;"><h3 id="代价敏感性能度量">代价敏感性能度量<a class="anchor" href="#代价敏感性能度量">·</a></h3><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/25.png" style="zoom:50%;"><h1 id="三、贝叶斯决策理论">三、贝叶斯决策理论<a class="anchor" href="#三、贝叶斯决策理论">·</a></h1><p>统计决策理论</p><h2 id="基本概念">基本概念<a class="anchor" href="#基本概念">·</a></h2><p>样本 每个人的身高体重等信息</p><p>类别/状态 例如：男女性别</p><p>先验概率 类别比例/出现概率 —— 以往历史数据得到的概率</p><p>样本分布密度</p><p>类条件概率密度</p><p>后验概率 —— 利用最新输入数据对先验概率进行修正后的概率</p><p>错误概率</p><p>平均错误率</p><p>正确率</p><h2 id="贝叶斯决策">贝叶斯决策<a class="anchor" href="#贝叶斯决策">·</a></h2><h3 id="基于最大后验概率进行决策（即最小错误率）">基于最大后验概率进行决策（即最小错误率）<a class="anchor" href="#基于最大后验概率进行决策（即最小错误率）">·</a></h3><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/2.png" style="zoom: 33%;"><p>$P(x|\omega_i)$：类条件概率密度</p><p>$P(\omega_i)$：先验概率</p><p>$P(\omega_i|x)$：后验概率</p><p><strong>解决分类问题</strong></p><h4 id="最小错误率贝叶斯决策">最小错误率贝叶斯决策<a class="anchor" href="#最小错误率贝叶斯决策">·</a></h4><p>对于每一个样本后验概率均选择错误率较小的结果</p><h2 id="最小风险贝叶斯决策">最小风险贝叶斯决策<a class="anchor" href="#最小风险贝叶斯决策">·</a></h2><p>损失函数：对特定的x采取特定的期望损失</p><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/31.png" style="zoom:50%;"><h4 id="朴素贝叶斯决策">朴素贝叶斯决策<a class="anchor" href="#朴素贝叶斯决策">·</a></h4><p>直接根据样本的各个属性发生概率之积来计算</p><h3 id="概率密度估计">概率密度估计<a class="anchor" href="#概率密度估计">·</a></h3><h4 id="参数化方法">参数化方法<a class="anchor" href="#参数化方法">·</a></h4><p>最大似然估计</p><p>贝叶斯估计</p><h4 id="非参数化方法">非参数化方法<a class="anchor" href="#非参数化方法">·</a></h4><p>$Parzen$窗法</p><p>$k_n$近邻法</p><h1 id="四、线性模型">四、线性模型<a class="anchor" href="#四、线性模型">·</a></h1><h3 id="线性回归">线性回归<a class="anchor" href="#线性回归">·</a></h3><h4 id="梯度下降法">梯度下降法<a class="anchor" href="#梯度下降法">·</a></h4><p><strong>梯度下降</strong>—利用所有数据</p><p><strong>批处理梯度下降(Batch Gradient Descent)</strong>—每次选取一个mini-batch进行梯度下降，一个循环称为一个epoch</p><p><strong>随机梯度下降（Stochastic Gradient Descent）</strong>，又称Online Learning，每次看一个样本</p><p>样本量较大时使用</p><h4 id="标准方程组法">标准方程组法<a class="anchor" href="#标准方程组法">·</a></h4><p>直接对损失函数求导得到标准解</p><p>样本量较小时使用</p><h3 id="线性判别函数">线性判别函数<a class="anchor" href="#线性判别函数">·</a></h3><p>线性判别函数$g(x)=\omega ^T x+\omega_0$</p><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/41.png" style="zoom:50%;"><p>广义线性判别函数容易带来维数灾难。因此使用线性判别函数的简单性解决问题。利用齐次简化后的线性判别函数</p><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/42.png" style="zoom:50%;"><p>设计分类函数，准则函数，之后求准则函数极值</p><h4 id="Fisher准则">Fisher准则<a class="anchor" href="#Fisher准则">·</a></h4><p>寻找投影方向最好的方向</p><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/43.png" style="zoom:67%;"><p>上面的<code>m1/m2</code>是某一类的均值，下面的<code>S1/S2</code>是类内的离散度，即类之间的差别越大，类内差别越小</p><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/46.png" style="zoom:50%;"><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/44.png" style="zoom: 67%;"><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/45.png" style="zoom:50%;"><h4 id="感知机准则">感知机准则<a class="anchor" href="#感知机准则">·</a></h4><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/47.png" style="zoom:50%;"><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/48.png" style="zoom:50%;"><h1 id="五、支持向量机">五、支持向量机<a class="anchor" href="#五、支持向量机">·</a></h1><h2 id="概念">概念<a class="anchor" href="#概念">·</a></h2><p>SVM从线性可分情况下的<strong>最优分类面</strong>发展而来。最优分类面就是要求分类线不但能<strong>将两类正确分开</strong>(训练错误率为0)，且使<strong>分类间隔最大</strong>。寻找一个<strong>满足分类要求</strong>的超平面，并且使训练集中的<strong>点距离分类面</strong>尽可能的<strong>远</strong>，也就是寻找一个分类面使它两侧的空白区域(<strong>Margin</strong>)最大</p><h2 id="线性支持向量机">线性支持向量机<a class="anchor" href="#线性支持向量机">·</a></h2><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/54.png" style="zoom:50%;"><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/55.png" style="zoom:50%;"><h3 id="KKT条件">KKT条件<a class="anchor" href="#KKT条件">·</a></h3><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/53.png" style="zoom:50%;"><p>处理噪声和离群点</p><h2 id="非线性支持向量机">非线性支持向量机<a class="anchor" href="#非线性支持向量机">·</a></h2><p>用一个固定的非线性映射将特征空间学习的线性分类器等价于基于原始数据学习的非线性分类器</p><p>这个非线性映射即为<strong>核函数</strong></p><h3 id="常用核函数">常用核函数<a class="anchor" href="#常用核函数">·</a></h3><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/51.png" style="zoom:50%;"><h4 id="判断是否可以作为核函数">判断是否可以作为核函数<a class="anchor" href="#判断是否可以作为核函数">·</a></h4><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/52.png" style="zoom:50%;"><h3 id="序列最小优化算法">序列最小优化算法<a class="anchor" href="#序列最小优化算法">·</a></h3><p><strong>序列最小优化算法(Sequential Minimal Optimization, SMO)<strong>是一种启发式算法。基本思想是：如果所有变量都满足此优化问题的</strong>KKT</strong>条件，那么这个问题的解就得到了。</p><h3 id="支持向量机工具">支持向量机工具<a class="anchor" href="#支持向量机工具">·</a></h3><p>LibSVM: http://www.csie.ntu.edu.tw/~cjlin/libsvm/</p><h1 id="六、决策树">六、决策树<a class="anchor" href="#六、决策树">·</a></h1><p>树型结构，由<strong>结点</strong>和<strong>有向边</strong>组成</p><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/61.png" style="zoom:50%;"><p>采用<strong>自顶向下</strong>的递归方法，以<strong>信息熵为度量</strong>构造一棵<strong>熵值下降最快</strong>的树，到叶子结点处的熵值为0，此时叶结点中的实例属于同一类。决策树可以看成一堆<code>if-else</code>的规则集合</p><h2 id="算法流程">算法流程<a class="anchor" href="#算法流程">·</a></h2><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/62.png" style="zoom:50%;"><h2 id="主要算法">主要算法<a class="anchor" href="#主要算法">·</a></h2><p>每个分支结点的样本<strong>尽可能属于同一类别</strong>，即结点的<strong>纯度</strong>越来越高</p><p>不同目标函数建立决策树主要有以下三种算法：</p><ul><li>ID3：信息增益</li><li>C4.5：信息增益率</li><li>CART：基尼指数</li></ul><h3 id="ID3算法">ID3算法<a class="anchor" href="#ID3算法">·</a></h3><p>以<strong>信息熵</strong>为度量，优先选择<strong>熵值下降最快</strong>的决策树，即熵值最小的属性</p><h4 id="信息熵-Entropy">信息熵(Entropy)<a class="anchor" href="#信息熵-Entropy">·</a></h4><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/63.png" style="zoom:50%;"><p>不确定性越大，熵值越大。</p><h4 id="经验-信息-熵">经验(信息)熵<a class="anchor" href="#经验-信息-熵">·</a></h4><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/64.png" style="zoom:50%;"><h4 id="条件熵-Conditional-Entropy">条件熵(Conditional Entropy)<a class="anchor" href="#条件熵-Conditional-Entropy">·</a></h4><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/65.png" style="zoom:50%;"><h4 id="信息增益">信息增益<a class="anchor" href="#信息增益">·</a></h4><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/66.png" style="zoom:50%;"><h4 id="ID3算法-决策树生成算法">ID3算法-决策树生成算法<a class="anchor" href="#ID3算法-决策树生成算法">·</a></h4><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/67.png" style="zoom:50%;"><h4 id="算法特点">算法特点<a class="anchor" href="#算法特点">·</a></h4><p><strong>优点</strong>：只要有较好的标注就可以进行学习，可从无序无规则事物中推理出分类规则。分类模型为树状，简单直观容易理解。</p><p><strong>缺点</strong>：偏好<strong>取值多</strong>的属性，极限趋近于均匀分布，可能受到<strong>噪声或小样本</strong>影响，容易出现<strong>过拟合</strong>问题。无法处理<strong>连续值</strong>，<strong>属性值不完整</strong>，<strong>不同代价</strong>等情况的属性。</p><h3 id="属性筛选度量标准">属性筛选度量标准<a class="anchor" href="#属性筛选度量标准">·</a></h3><h4 id="信息增益率">信息增益率<a class="anchor" href="#信息增益率">·</a></h4><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/68.png" style="zoom: 50%;"><p>对可取值数目N较多的属性有所偏好。使用如下的<strong>信息增益率</strong>，可以<strong>缓解</strong>信息增益准则对<strong>可取值数目较多</strong>的属性的偏好</p><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/69.png" style="zoom:50%;"><p><strong>C4.5算法</strong>采用了这种方式替代了ID3的信息增益。</p><h4 id="基尼指数-Gini-Index">基尼指数(Gini Index)<a class="anchor" href="#基尼指数-Gini-Index">·</a></h4><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/610.png" style="zoom:50%;"><p><strong>CART算法</strong>就采用<strong>基尼指数</strong>替代了ID3算法的信息增益</p><h2 id="剪枝处理-Pruning">剪枝处理(Pruning)<a class="anchor" href="#剪枝处理-Pruning">·</a></h2><p><strong>问题</strong>：<strong>过拟合</strong></p><p><strong>基本策略</strong>：</p><ul><li><strong>预剪枝策略(Pre-pruning)</strong>：决策树生成过程中，对每个结点在划分前进行估计，如果<strong>不能</strong>带来决策树<strong>泛化性能提升</strong>，<strong>停止划分</strong>并作为叶结点。<ul><li>剪掉很多没有必要的分支，<strong>降低过拟合风险</strong>，但是由于有些划分可能之后会提高泛化性能，所以可能导致<strong>欠拟合</strong>。</li></ul></li><li><strong>后剪枝策略(Post-pruning)</strong>：先利用训练集生成决策树，自底向上考察非叶结点，如果将这个结点对应子树<strong>替换成叶结点</strong>可以<strong>提升泛化性能</strong>，则替换该子树为叶结点。<ul><li>比预剪枝决策树保留了更多分支，降低欠拟合风险，泛化性能更好，但训练开销也更大。</li></ul></li></ul><h2 id="连续值处理">连续值处理<a class="anchor" href="#连续值处理">·</a></h2><p>采用**二分法(Bi-Partition)**进行离散化。</p><p>具体来说，是把从小到大排列的数据每两个相邻的数值的平均作为划分依据，计算相应的信息增益。</p><h2 id="缺失值处理">缺失值处理<a class="anchor" href="#缺失值处理">·</a></h2><p>让样本以不同概率划分到不同的子结点去。即只计算无缺失样本的信息增益，并乘一个无缺失样本占比的系数。</p><h2 id="不同代价属性的处理">不同代价属性的处理<a class="anchor" href="#不同代价属性的处理">·</a></h2><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/611.png" style="zoom:50%;"><h2 id="延申">延申<a class="anchor" href="#延申">·</a></h2><p><strong>概念学习系统</strong>(Concept Learning System, CLS) 1966年Hunt等人提出</p><p><strong>分类回归树</strong>(Classification And Regression Tree, <strong>CART</strong>)算法 1984年Breiman等人提出，一种二分递归分割技术</p><p><strong>J. R. Quinlan</strong>：1979年 ID3/1993年 C4.5算法</p><p><strong>多变量决策树</strong></p><h1 id="七、人工神经网络">七、人工神经网络<a class="anchor" href="#七、人工神经网络">·</a></h1><h2 id="MP模型">MP模型<a class="anchor" href="#MP模型">·</a></h2><p>一种人工神经元的数学模型。</p><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/71.png" style="zoom: 50%;"><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/72.png" style="zoom:50%;"><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/73.png" style="zoom:80%;"><p>MP模型采用阙值（阶跃）函数作为激活函数。</p><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/74.png" style="zoom:50%;"><p>神经元此时可以看成一个<strong>线性分类器</strong></p><p>激活函数：线性函数，非线性斜面函数，Sigmoid输出函数（S型函数）</p><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/75.png" style="zoom:50%;"><h2 id="感知器">感知器<a class="anchor" href="#感知器">·</a></h2><p>实际上是一种MP模型，监督学习</p><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/76.png" style="zoom:50%;"><p><strong>三层感知器</strong>可以<strong>实现任意的逻辑运算</strong>，在<strong>激活函数为Sigmoid函数</strong>的情况下，可以<strong>逼近</strong>任何非线性多元函数。</p><h3 id="前馈神经网络">前馈神经网络<a class="anchor" href="#前馈神经网络">·</a></h3><p>前向传播</p><h3 id="反向传播-BP-算法">反向传播(BP)算法<a class="anchor" href="#反向传播-BP-算法">·</a></h3><p>以一个三层感知器为例</p><p>有训练集<code>D={(x1,t1),(x2,t2),...,(xN,tN)}</code></p><p>隐藏层有<code>M</code>个神经元，激活函数为<code>f1</code>。输出层有<code>K</code>个神经元，激活函数为<code>f2</code>，最终的损失函数为$E(\omega)=\frac 1 2 \sum_{k=1}^K (y_k-t_k)^2$</p><p>$z_j=f1(\sum_{i=1}^{N}a_{ji}*x_i)=f1(c_j)$</p><p>$y_k=f2(\sum_{j=1}^M b_{kj}*z_j)=f2(d_k)$</p><p>方便起见，有如下标记</p><p>$c_j=\sum_{i=1}^{N}a_{ji}*x_i$</p><p>$d_k=\sum_{j=1}^M b_{kj}*z_j$</p><p>则如果需要更新参数，以更新$a_{mn}$和$b_{km}$为例。</p><p>先计算$b_{km}$梯度</p><p>$\Delta(b_{km})=(y_k-t_k)*f2’(d_k)*z_m$</p><p>再计算$a_{mn}$梯度</p><p>$\Delta(a_{mn})=\sum_{k=1}^K(y_k-t_k)*f2’(d_k)*b_{km}*f1’(c_m)*x_n$</p><h1 id="八、聚类">八、聚类<a class="anchor" href="#八、聚类">·</a></h1><p>一种非监督学习</p><h2 id="性能度量-2">性能度量<a class="anchor" href="#性能度量-2">·</a></h2><h3 id="外部指标">外部指标<a class="anchor" href="#外部指标">·</a></h3><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/81.png" style="zoom:50%;"><h3 id="内部指标">内部指标<a class="anchor" href="#内部指标">·</a></h3><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/82.png" style="zoom:50%;"><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/83.png" style="zoom:50%;"><h2 id="聚类方法">聚类方法<a class="anchor" href="#聚类方法">·</a></h2><h3 id="K均值-K-Means">K均值(K-Means)<a class="anchor" href="#K均值-K-Means">·</a></h3><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/84.png" style="zoom: 50%;"><h3 id="K-means">K-means++<a class="anchor" href="#K-means">·</a></h3><p>已经选取了n个初始聚类中心，在选取第n+1个中心时，距离当前n个聚类中心越远的点会有更高概率被选为第n+1个聚类中心。</p><h3 id="Kernel-K-means">Kernel K-means<a class="anchor" href="#Kernel-K-means">·</a></h3><p>参照<strong>核函数</strong>思想，将所有样本映射到另一个<strong>特征空间</strong>中再进行聚类。</p><h3 id="ISODATA">ISODATA<a class="anchor" href="#ISODATA">·</a></h3><p><strong>迭代自组织数据分析算法 Iterative Self-Organizing Data Analysis Technique Algorithm</strong></p><p>当某<strong>两个聚类中心距离小于某阙值</strong>时将它们合并为一类，当某类<strong>标准差大于某一阙值</strong>时，将其分裂为两类。某类<strong>样本数目少于某阙值取消</strong>这个过程。</p><h3 id="层次聚类算法">层次聚类算法<a class="anchor" href="#层次聚类算法">·</a></h3><p>分为自底向上和自顶向下</p><h4 id="AGNES算法（Agglomerative-Nesting）">AGNES算法（Agglomerative Nesting）<a class="anchor" href="#AGNES算法（Agglomerative-Nesting）">·</a></h4><p><strong>自底向上</strong></p><p>初始时，每个样本看作一个初始聚类簇，之后每一步找出距离最近的两个聚类簇进行合并，并不断重复。直到达到<strong>预设的聚类簇个数</strong>。度量两个聚类簇之间的距离，常用度量方式：</p><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/85.png" style="zoom:50%;"><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/86.png" style="zoom:50%;"><h2 id="聚类应用">聚类应用<a class="anchor" href="#聚类应用">·</a></h2><p>医学图像-组织分类</p><p>遥感图像-地貌分类</p><p>BOW模型——词袋模型</p><p>网络用户分类</p><h1 id="九、数据降维">九、数据降维<a class="anchor" href="#九、数据降维">·</a></h1><h2 id="数据维度">数据维度<a class="anchor" href="#数据维度">·</a></h2><p>点0 线1 面2 体3</p><h2 id="数据降维">数据降维<a class="anchor" href="#数据降维">·</a></h2><p>高维空间中有很多冗余信息和噪声信息，会在实际应用中引入误差，影响准确率。</p><p>降维可以提取数据内部本质结构，减少冗余信息和噪声信息造成的误差，提高应用精度。</p><p><strong>降维</strong>：利用<strong>某种映射</strong>将原高维度空间的数据点投射到低维度空间。</p><h2 id="降维方法">降维方法<a class="anchor" href="#降维方法">·</a></h2><h3 id="主成分分析-PCA">主成分分析 PCA<a class="anchor" href="#主成分分析-PCA">·</a></h3><p>将原有的众多具有一定相关性的指标重新组合成一组少量相互无关的综合指标。</p><p>使得降维后方差尽可能大，均方误差尽可能小</p><p><strong>最大方差思想</strong>：使用较少的数据维度保留住较多的原数据特性</p><p><strong>最小均方误差思想</strong>：使原数据与降维后的数据(在原空间中的重建)的误差最小</p><h4 id="应用">应用<a class="anchor" href="#应用">·</a></h4><h5 id="利用PCA处理高维数据">利用PCA处理高维数据<a class="anchor" href="#利用PCA处理高维数据">·</a></h5><h4 id="LDA">LDA<a class="anchor" href="#LDA">·</a></h4><p>LDA是一种监督学习的降维技术，也就是说它的数据集的每个样本是有类别输出的。这点和PCA不同。PCA是不考虑样本类别输出的无监督降维技术。LDA的思想可以用一句话概括，就是“投影后类内方差最小，类间方差最大”。什么意思呢？ 我们要将数据在低维度上进行投影，投影后希望每一种类别数据的投影点尽可能的接近，而不同类别的数据的类别中心之间的距离尽可能的大。</p><h4 id="PCA和LDA区别">PCA和LDA区别<a class="anchor" href="#PCA和LDA区别">·</a></h4><p>PCA追求降维后能够<strong>最大化保持数据内在信息</strong>，并通过衡量在<strong>投影方向上的数据方差</strong>来判断其重要性。但这对数据的区分作用并不大，反而可能使得数据点混杂在一起。</p><p>LDA所追求的目标与PCA不同，<strong>不是希望</strong>保持数据最多的信息，而是<strong>希望数据在降维后能够很容易地被区分开</strong>。</p><h4 id="Kernel-PCA">Kernel PCA<a class="anchor" href="#Kernel-PCA">·</a></h4><p>线性假设一般化，引入核函数。</p><h3 id="等距映射">等距映射<a class="anchor" href="#等距映射">·</a></h3><h3 id="局部线性嵌入">局部线性嵌入<a class="anchor" href="#局部线性嵌入">·</a></h3><h1 id="十、集成学习">十、集成学习<a class="anchor" href="#十、集成学习">·</a></h1><h2 id="基本概念-2">基本概念<a class="anchor" href="#基本概念-2">·</a></h2><p>通过构建并结合<strong>多个分类器</strong>完成学习任务</p><p>又称为<strong>多分类器系统</strong>，<strong>基于委员会的学习</strong></p><p><strong>弱分类器</strong>：准确率仅比随机猜测略高的分类器</p><p><strong>强分类器</strong>：准确率高并能在多项式时间内完成的分类器</p><p>个体学习器生成方式不同，可以分为两大类方法</p><ul><li>串行化方法：个体学习器间<strong>存在强依赖</strong>关系<ul><li>典型算法：<strong>Boosting(Adaboost)</strong></li></ul></li><li>并行化方法：个体学习器间<strong>不存在强依赖</strong>关系<ul><li>典型算法：<strong>Bagging/随机森林(Random Forest)</strong></li></ul></li></ul><h2 id="串行化方法-Boosting">串行化方法 Boosting<a class="anchor" href="#串行化方法-Boosting">·</a></h2><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/101.png" style="zoom:50%;"><h3 id="Adaboost算法">Adaboost算法<a class="anchor" href="#Adaboost算法">·</a></h3><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/102.png" style="zoom:40%;"><h3 id="Boosting算法特点">Boosting算法特点<a class="anchor" href="#Boosting算法特点">·</a></h3><h4 id="基学习器能学习特定的数据分布">基学习器能学习特定的数据分布<a class="anchor" href="#基学习器能学习特定的数据分布">·</a></h4><p>重赋权法(Re-weighting)</p><p>重采样法(Re-sampling)</p><h4 id="特点总结">特点总结<a class="anchor" href="#特点总结">·</a></h4><p>主要关注降低偏差，每个模型是<strong>弱模型，偏差高，方差低</strong></p><p><strong>贪心法</strong>最小化损失函数</p><h2 id="并行化方法-Bagging算法">并行化方法 Bagging算法<a class="anchor" href="#并行化方法-Bagging算法">·</a></h2><p>基于<strong>自助法采样 (Bootstrap Sampling)</strong></p><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/103.png" style="zoom:50%;"><h3 id="基本思想">基本思想<a class="anchor" href="#基本思想">·</a></h3><p>利用自助法采样可构造T个含m个训练样本的采样集，基于每个采样集训练出一个基学习器，再将它们进行结合(在对预测输出结合时，通常对分类任务使用简单投票法，对回归任务使用简单平均法)。</p><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/104.png" style="zoom:50%;"><h3 id="特点">特点<a class="anchor" href="#特点">·</a></h3><p>主要关注降低方差，在易受扰动的学习器上效用更加明显。是强模型，偏差低，方差高</p><h2 id="并行化方法-随机森林算法">并行化方法 随机森林算法<a class="anchor" href="#并行化方法-随机森林算法">·</a></h2><p>Bagging方法的一种扩展变体</p><p><strong>Random Forest</strong>，简称<strong>RF</strong></p><p>以<strong>决策树</strong>为基学习器</p><p>训练过程引入<strong>随机属性选择</strong></p><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/105.png" style="zoom: 67%;"><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/1015.png" style="zoom:50%;"><h2 id="结合策略">结合策略<a class="anchor" href="#结合策略">·</a></h2><h3 id="平均法">平均法<a class="anchor" href="#平均法">·</a></h3><h4 id="简单平均法">简单平均法<a class="anchor" href="#简单平均法">·</a></h4><p>个体学习器性能相近时适用</p><h4 id="加权平均法">加权平均法<a class="anchor" href="#加权平均法">·</a></h4><p>个体学习器性能迥异时适用</p><h3 id="结合策略—投票法">结合策略—投票法<a class="anchor" href="#结合策略—投票法">·</a></h3><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/106.png" style="zoom:40%;"><h3 id="结合策略—学习法">结合策略—学习法<a class="anchor" href="#结合策略—学习法">·</a></h3><p>从初始数据集训练初始学习器，初级学习器的输出被当作样例输入特征，继承初始样本标记，从次级数据集训练次级学习器</p><h2 id="多样性">多样性<a class="anchor" href="#多样性">·</a></h2><p>度量集成中个体学习器的<strong>多样性</strong>，考虑<strong>个体学习器</strong>的两两<strong>相似</strong>/<strong>不相似</strong>性</p><h3 id="多样性度量">多样性度量<a class="anchor" href="#多样性度量">·</a></h3><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/107.png" style="zoom:40%;"><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/108.png" style="zoom:40%;"><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/109.png" style="zoom:40%;"><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/1010.png" style="zoom:40%;"><h3 id="多样性增强">多样性增强<a class="anchor" href="#多样性增强">·</a></h3><ul><li>数据样本扰动<ul><li><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/1011.png" style="zoom:40%;"></li></ul></li><li>输入属性扰动<ul><li><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/1012.png" style="zoom:40%;"></li></ul></li><li>输出表示扰动<ul><li><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/1013.png" style="zoom:40%;"></li></ul></li><li>算法参数扰动<ul><li><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/1014.png" style="zoom:40%;"></li></ul></li><li>不同的多样性增强机制也可一起使用<ul><li>Adaboost：加入了<strong>数据样本扰动</strong></li><li>随机森林：同时加入了<strong>数据样本扰动</strong>和<strong>输入属性扰动</strong></li></ul></li></ul><h1 id="十一、半监督学习">十一、半监督学习<a class="anchor" href="#十一、半监督学习">·</a></h1><p>如何有效利用<strong>已标记</strong>和<strong>未标记</strong>的样本集</p><h2 id="基本假设">基本假设<a class="anchor" href="#基本假设">·</a></h2><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/111.png" style="zoom:50%;"><h2 id="自学习方法-Self-Training-Methods">自学习方法 (Self-Training Methods)<a class="anchor" href="#自学习方法-Self-Training-Methods">·</a></h2><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/112.png" style="zoom:50%;"><h3 id="典型代表-最近邻自学习算法">典型代表-最近邻自学习算法<a class="anchor" href="#典型代表-最近邻自学习算法">·</a></h3><img src="/2023/01/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/113.png" style="zoom:40%;"><h3 id="典型代表-半监督SVM">典型代表-半监督SVM<a class="anchor" href="#典型代表-半监督SVM">·</a></h3><h4 id="直推式支持向量机T-SVM">直推式支持向量机T-SVM<a class="anchor" href="#直推式支持向量机T-SVM">·</a></h4><p>针对二分类问题，同时利用标记和未标记样本，通过<strong>尝试将每个未标记样本分别作为正例和反例</strong>来寻找<strong>最优分类边界</strong>，来得到原始数据中两类样本的最大分类间隔</p><h3 id="典型代表-半监督聚类">典型代表-半监督聚类<a class="anchor" href="#典型代表-半监督聚类">·</a></h3><ul><li><strong>必连</strong>与<strong>勿连</strong>约束<ul><li>利用这样的关系进行约束K均值</li><li></li></ul></li><li>具有少量标记样本<ul><li>直接将初始的有标记样本作为种子，初始化Kmeans的K个聚类中心</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DeepLearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译技术理论课笔记</title>
      <link href="2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
      <url>2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="工具准备">工具准备<a class="anchor" href="#工具准备">·</a></h2><p>https://wenku.baidu.com/view/b8b4510bba1aa8114431d96c.html</p><p>https://max.book118.com/html/2018/1224/7166031033001166.shtm</p><p>https://wenku.baidu.com/view/d846931e6bec0975f465e295?bfetype=new</p><p>C语言栈方向从高到低延申，字符串拷贝数组操作不对数据长度做审核，实际数据长度超过栈中预留空间，则会栈溢出</p><p>龙书 虎书 鲸书</p><p>模型驱动 MDA MDE MDT MBSE</p><p>建模即编程—低代码，程序自动生成</p><h2 id="编译知识结构图">编译知识结构图<a class="anchor" href="#编译知识结构图">·</a></h2><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/13.png" style="zoom:80%;"><h1 id="一、编译基础">一、编译基础<a class="anchor" href="#一、编译基础">·</a></h1><h2 id="1-1-基本概念">1.1 基本概念<a class="anchor" href="#1-1-基本概念">·</a></h2><p><strong>源程序</strong>：用<strong>汇编语言</strong>或<strong>高级语言</strong>编写的程序称为源程序。</p><p><strong>目标程序</strong>：用目标语言所表示的程序。<strong>机器语言</strong>，或某机器的<strong>汇编语言</strong>。</p><p><strong>翻译程序</strong>：将<strong>源程序转换为目标程序</strong>的程序称为翻译程序。是<strong>汇编程序、编译程序以及各种变换程序</strong>的总称</p><p>编译 ==&gt; <strong>Compile</strong> ==&gt; 将高级语言经过加工得到目标程序，这样的翻译过程</p><p>汇编 ==&gt; <strong>Assemble</strong> ==&gt; 汇编语言书写，经过翻译程序得到机器语言表示的程序，这时的<strong>翻译程序</strong>称为汇编程序</p><p>分为两种：<strong>编译运行</strong>和<strong>编译-解释执行</strong></p><h2 id="1-2-编译过程">1.2 编译过程<a class="anchor" href="#1-2-编译过程">·</a></h2><p>词法分析–&gt;语法分析–&gt;语义分析、生成中间代码–&gt;代码优化–&gt;生成目标程序</p><h3 id="词法分析">词法分析<a class="anchor" href="#词法分析">·</a></h3><p>分析和识别<strong>单词</strong> 单词是语言的基本单位 ==&gt; <strong>线性分析</strong></p><h3 id="语法分析">语法分析<a class="anchor" href="#语法分析">·</a></h3><p>根据语法规则<strong>分析并识别</strong>各种<strong>语法成分</strong>，并进行<strong>语法正确性检查</strong> ==&gt; <strong>层次分析</strong></p><h3 id="语义分析">语义分析<a class="anchor" href="#语义分析">·</a></h3><p>生成 <strong>中间代码</strong>==&gt;一种介于<strong>源语言和目标语言之间</strong>的<strong>中间语言</strong>形式</p><p>分析语义上的正确性然后翻译成等价的另一种语言</p><p>便于<strong>做优化</strong>，便于<strong>编译程序的移植</strong></p><p>中间代码常用的有<strong>四元式</strong>、<strong>三元式</strong>、<strong>逆波兰表示</strong></p><h3 id="代码优化">代码优化<a class="anchor" href="#代码优化">·</a></h3><p>得到高质量的目标程序</p><h3 id="生成目标程序">生成目标程序<a class="anchor" href="#生成目标程序">·</a></h3><h3 id="建表查表">建表查表<a class="anchor" href="#建表查表">·</a></h3><p>符号表管理</p><h3 id="出错处理">出错处理<a class="anchor" href="#出错处理">·</a></h3><h3 id="遍（pass）">遍（pass）<a class="anchor" href="#遍（pass）">·</a></h3><p>对源程序（包括源程序中间形式）<strong>从头到尾扫描一次</strong>， 并做有关的加工处理 ，<strong>生成</strong>新的<strong>源程序中间形式</strong>或<strong>目标程序</strong></p><h3 id="典型编译程序7个逻辑部分">典型编译程序7个逻辑部分<a class="anchor" href="#典型编译程序7个逻辑部分">·</a></h3><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/11.png" style="zoom:50%;"><h3 id="前端和后端">前端和后端<a class="anchor" href="#前端和后端">·</a></h3><p>与<strong>源程序</strong>有关的编译部分称为前端 ==&gt; 词法分析，语法分析，语义分析，中间代码生成，代码优化</p><p>与<strong>目标机</strong>有关的部分称为后端 ==&gt;目标程序生成(与目标机有关的优化)</p><h3 id="编译程序的前后处理器">编译程序的前后处理器<a class="anchor" href="#编译程序的前后处理器">·</a></h3><p><strong>源程序</strong>：<strong>多文件、宏定义和宏调用</strong>，包含文件</p><p><strong>目标程序</strong>：一般为<strong>汇编程序</strong>或<strong>可重定位的机器代码</strong></p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/12.png" style="zoom:67%;"><h2 id="作业">作业<a class="anchor" href="#作业">·</a></h2><p>P21： 1,2,3,4,5</p><h1 id="二、文法与语言">二、文法与语言<a class="anchor" href="#二、文法与语言">·</a></h1><h2 id="2-1-预备知识">2.1 预备知识<a class="anchor" href="#2-1-预备知识">·</a></h2><h3 id="字母表与符号串">字母表与符号串<a class="anchor" href="#字母表与符号串">·</a></h3><p><strong>字母表</strong>：符号的非空有限集</p><p><strong>符号</strong>：字母表中的元素</p><p><strong>符号串</strong>：符号的有穷序列</p><p><strong>空符号串</strong>：无任何符号的符号串</p><h3 id="符号串运算">符号串运算<a class="anchor" href="#符号串运算">·</a></h3><p><strong>符号串相等</strong> 每个字符依次相等</p><p><strong>符号串的长度</strong>（符号串中符号的个数）</p><p><strong>符号串联接</strong></p><p><strong>符号串乘积运算</strong> $AB={xy|x\in A,y\in B}$</p><p><strong>幂运算</strong> $A^n=A*…*A$  $A^0=\epsilon$</p><p><strong>闭包，正闭包</strong></p><p>$闭包A<sup>*:A</sup>0\cup A^1\cup …\cup A^n\cup …$</p><p>$正闭包A<sup>+:A</sup>1\cup …\cup A^n\cup …$</p><p>某语言分为字符集A和单词集B</p><p>单词是定义在字符集上的字符串，句子是定义在单词集上的字符串</p><h2 id="2-2-文法的非形式讨论">2.2 文法的非形式讨论<a class="anchor" href="#2-2-文法的非形式讨论">·</a></h2><h3 id="2-2-1-文法">2.2.1 文法<a class="anchor" href="#2-2-1-文法">·</a></h3><p>文法和语言&lt;句子&gt;::=&lt;主语&gt;&lt;谓语&gt;</p><p><code>::=</code> 由…组成</p><p><code>|</code>表示或</p><p><code>BNF</code>表示法</p><p>&lt;句子&gt;::=&lt;主语&gt;&lt;谓语&gt;</p><p>&lt;主语&gt;::=&lt;代词&gt;|&lt;名语&gt;</p><p>文法是<strong>形式上描述和推导句子</strong>，形式上对句子结构进行定义和描述，但<strong>不涉及语义</strong></p><h3 id="2-2-2-语法规则">2.2.2 语法规则<a class="anchor" href="#2-2-2-语法规则">·</a></h3><p><strong>建立一组规则</strong>，来描述句子的语法结构</p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;A&gt;::&#x3D;&lt;B&gt;&lt;C&gt;</span><br><span class="line">&lt;B&gt;::&#x3D;a</span><br><span class="line">&lt;C&gt;::&#x3D;d|e</span><br></pre></td></tr></table></figure><h3 id="2-2-3-由规则推导句子">2.2.3 由规则推导句子<a class="anchor" href="#2-2-3-由规则推导句子">·</a></h3><p>有了一组规则，可以按照一定方式推导句子</p><p>即从一个要识别的符号开始推导，用<strong>相应的规则右部</strong>代替<strong>左部</strong>，每次<strong>仅用一条规则</strong>，直到<strong>所有非终结符</strong>均<strong>被终结符</strong>替代</p><p><strong>最左推导</strong> ==&gt; 有若干语法成分同时存在，先从最左的语法成分进行推导</p><p>最右推导类似</p><p>例子同上，比如上面的文法推出<strong>ad</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#最左推导</span><br><span class="line">A&#x3D;&gt;BC&#x3D;&gt;aC&#x3D;&gt;ad</span><br><span class="line">#最右推导</span><br><span class="line">A&#x3D;&gt;BC&#x3D;&gt;Bd&#x3D;&gt;ad</span><br></pre></td></tr></table></figure><h3 id="2-2-4-语法树——描述语法结构">2.2.4 语法树——描述语法结构<a class="anchor" href="#2-2-4-语法树——描述语法结构">·</a></h3><p>识别符号=&gt;开始符号，属于非终结符</p><p>非终结符==&gt;语法成分</p><p>终结符==&gt;单词符号</p><h2 id="2-3-文法和语言的形式定义">2.3 文法和语言的形式定义<a class="anchor" href="#2-3-文法和语言的形式定义">·</a></h2><h3 id="2-3-1-文法的形式定义">2.3.1 文法的形式定义<a class="anchor" href="#2-3-1-文法的形式定义">·</a></h3><h4 id="定义1">定义1<a class="anchor" href="#定义1">·</a></h4><p>文法定义：$G=(V_n,V_t,P,Z)$</p><p>$V_n$ 非终结符号集</p><p>$V_t$ 终结符号集</p><p>$V=V_n\cup V_t$称为文法的<strong>字汇表</strong></p><p>$P$ 产生式或规则的集合</p><p>$Z$ 开始符号（识别符号）$Z\in V_n$</p><p>规则定义：$U\rightarrow x 或 U::=x$  $U\in V_n ,x\in V^*$</p><h4 id="说明-3">说明<a class="anchor" href="#说明-3">·</a></h4><ul><li>产生式左边符号构成集合$V_n$</li><li>有些产生式<strong>左部相同</strong>，可以<strong>合并</strong> 类似<code>A-&gt;B|C</code>这样的，也称为文法的<strong>BNF表示</strong></li><li>给定一个文法，需给出<strong>产生式（规则）集合</strong>，并指定<strong>识别符号</strong></li></ul><h3 id="2-3-2-推导的形式定义">2.3.2 推导的形式定义<a class="anchor" href="#2-3-2-推导的形式定义">·</a></h3><h4 id="定义2">定义2<a class="anchor" href="#定义2">·</a></h4><p>$文法G:v=xUy,w=xuy.其中x,y,u\in V^*,U\in V_n$</p><p>$若U::=u\in P,则v\Rightarrow w$</p><p>$若x=y=\epsilon，有U::=u，则U\stackrel G\Rightarrow u$</p><h4 id="定义3-v-stackrel-Rightarrow-w">定义3 $v\stackrel{+}\Rightarrow  w$<a class="anchor" href="#定义3-v-stackrel-Rightarrow-w">·</a></h4><p>$文法G，u_0,u_1,…,u_n\in V^+$</p><p>$若 v=u_0\Rightarrow u_1\Rightarrow u_2…\Rightarrow u_n=w$，则$v\stackrel{+}\Rightarrow  w$</p><h4 id="定义4-v-stackrel-Rightarrow-w">定义4 $v\stackrel * \Rightarrow w$<a class="anchor" href="#定义4-v-stackrel-Rightarrow-w">·</a></h4><p>$若v\stackrel + \Rightarrow w或v=w$，则$v\stackrel * \Rightarrow w$</p><h4 id="定义5-规范推导">定义5 规范推导<a class="anchor" href="#定义5-规范推导">·</a></h4><p>$有xUy\Rightarrow xuy，若y\in V_t^*$，则此推导为规范的，记为$xUy\nRightarrow xuy$</p><p>直观：规范推导=最右推导</p><h3 id="2-3-3-语言的形式定义">2.3.3 语言的形式定义<a class="anchor" href="#2-3-3-语言的形式定义">·</a></h3><h4 id="定义6-文法G-Z">定义6 文法G[Z]<a class="anchor" href="#定义6-文法G-Z">·</a></h4><ol><li><font color="red">句型 </font> $x是句型\Leftrightarrow Z\stackrel * \Rightarrow x，且x\in V^*$</li><li><font color="red">句子</font> $x是句子\Leftrightarrow Z\stackrel + \Rightarrow x，且x\in V_t^*$</li><li><font color="red">语言 </font> $L(G[Z])={x|x\in V_t^*,Z\stackrel + \Rightarrow x}$</li></ol><p>形式语言理论可证明以下两点：</p><ol><li>$G\rightarrow L(G)$</li><li>$L(G)\rightarrow G1,G2…Gn$</li></ol><p><strong>已知文法求语言</strong>通过<strong>推导</strong>即可，但是<strong>已知语言求文法无形式化方法</strong>，一般是凭借经验</p><h4 id="定义7-等价文法">定义7 等价文法<a class="anchor" href="#定义7-等价文法">·</a></h4><p>$G和G’是两个不同文法，若L(G)=L(G’),则G与G’为等价文法$</p><p><font color="red">编译感兴趣的问题</font>： 给定句子以及文法G，求$x\in L(G)?$</p><h3 id="2-3-4-递归文法">2.3.4 递归文法<a class="anchor" href="#2-3-4-递归文法">·</a></h3><p><strong>规则右部</strong>有和<strong>左部相同</strong>的符号比如 <code>U::=bUc</code> <code>U::=aU</code> <code>U::=Ua</code> 分别代表<strong>递归，左递归，右递归</strong></p><h3 id="2-3-5-句型的短语、简单短语和句柄">2.3.5 句型的短语、简单短语和句柄<a class="anchor" href="#2-3-5-句型的短语、简单短语和句柄">·</a></h3><h4 id="定义8-短语与简单短语">定义8 短语与简单短语<a class="anchor" href="#定义8-短语与简单短语">·</a></h4><p>$给定文法G[Z]，w=xuy\in V^+，为该文法的句型$</p><p>$若Z\stackrel * \Rightarrow xUy，且U\stackrel + \Rightarrow u，则u是句型w相对于U的短语$</p><p>$若Z\stackrel * \Rightarrow xUy，且U\Rightarrow u(即单步推出)，则u是句型w相对于U的简单短语$</p><p>其中$U\in V_n，u\in V^+，x,y\in V^*$</p><h5 id="说明-4">说明<a class="anchor" href="#说明-4">·</a></h5><p>短语是前面句型的<strong>某个非终结符所能推出</strong>的符号串</p><p>任何句型本身一定是<strong>相对于识别符号Z</strong>的短语</p><h4 id="定义9-任一句型的最左简单短语称为-font-color-red-句柄-font">定义9 任一句型的最左简单短语称为<font color="red">句柄</font><a class="anchor" href="#定义9-任一句型的最左简单短语称为-font-color-red-句柄-font">·</a></h4><h2 id="2-4-语法树与二义性文法">2.4 语法树与二义性文法<a class="anchor" href="#2-4-语法树与二义性文法">·</a></h2><h3 id="2-4-1-推导与语法（推导）树">2.4.1 推导与语法（推导）树<a class="anchor" href="#2-4-1-推导与语法（推导）树">·</a></h3><h4 id="语法树">语法树<a class="anchor" href="#语法树">·</a></h4><p>句子（句型）结构的<strong>图示表示法</strong>，<strong>有向图</strong>，由<strong>结点</strong>和<strong>有向边</strong>组成</p><p><strong>结点</strong>：符号</p><p><strong>根结点</strong>：识别符号（编译单元）</p><p><strong>中间结点</strong>：非终结符（各个语法成分）</p><p><strong>叶结点</strong>：终结符或非终结符（推导过程的每一步的句型或句子都可以以语法树表示，所以中间过程的语法树叶结点可以是非终结符）</p><p><strong>有向边</strong>：结点间派生关系</p><p>比如下列的树：</p><pre class="mermaid">graph TDZ-->UZ-->VU-->aU-->bV-->cV-->d</pre><h4 id="子树与短语">子树与短语<a class="anchor" href="#子树与短语">·</a></h4><p><strong>子树</strong>：语法树中某个结点（也就是子树的根）连同它向下的派生部分所组成</p><p>子树末端结点自左至右顺序为句型的符号串，这个符号串即为<strong>相对于该子树根的短语</strong>。</p><h4 id="font-color-red-短语和简单短语？？-font"><font color="red">短语和简单短语？？</font><a class="anchor" href="#font-color-red-短语和简单短语？？-font">·</a></h4><p>简单区分：看语法树</p><p><strong>短语</strong>：对于原语法树中<strong>所有节点数大于1的子树</strong>，将<strong>所有叶子结点从左往右连接起来</strong>组成短语。</p><p><strong>简单短语</strong>：短语中，可以由一个中间句子成分直接推导出来的</p><p><strong>句柄</strong>：最左边的第一个简单短语</p><p>下图中，短语有D F DFE，简单短语有D F 句柄为D</p><pre class="mermaid">graph TDa[A]-->b[B]a-->c[C]b-->d[D]a-->e[E]c-->f(F)</pre><h4 id="树与推导">树与推导<a class="anchor" href="#树与推导">·</a></h4><p>语法树生长过程 &lt;=&gt; 句型推导过程</p><h5 id="从推导构造语法树">从推导构造语法树<a class="anchor" href="#从推导构造语法树">·</a></h5><p>一般采用<strong>规范推导</strong>即<strong>最右推导</strong></p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/21.png" style="zoom:50%;"><h5 id="由语法树构造推导">由语法树构造推导<a class="anchor" href="#由语法树构造推导">·</a></h5><p>每次修建都剪掉句柄</p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/22.png" style="zoom: 50%;"><p><strong>规范归约</strong>和<strong>规范推导</strong>互为<strong>逆过程</strong></p><p><strong>规范规约</strong>：对句型中最左简单短语（句柄）进行的归约</p><p><strong>规范句型</strong>：通过<strong>规范推导</strong>或<strong>规范归约</strong>所得到的句型</p><h4 id="二义性文法">二义性文法<a class="anchor" href="#二义性文法">·</a></h4><p>一个文法</p><ul><li>某句子存在<strong>两种不同的语法树</strong>，则此文法为二义性文法，否则是无二义性文法</li><li>某句子存在<strong>两个不同的规范推导</strong>，则此文法为二义性文法，否则是无二义性文法</li><li>某<strong>规范句型的句柄不唯一</strong>，则此文法为二义性文法，否则是无二义性文法</li></ul><h2 id="2-5-句子的分析">2.5 句子的分析<a class="anchor" href="#2-5-句子的分析">·</a></h2><p>给定一个$G[Z]:S\in V_t^*，判断S\in L(G[Z])是否成立$</p><p><strong>词法分析</strong>和<strong>语法分析</strong>的工作</p><h2 id="2-6-有关文法的实用限制">2.6 有关文法的实用限制<a class="anchor" href="#2-6-有关文法的实用限制">·</a></h2><h4 id="有害规则">有害规则<a class="anchor" href="#有害规则">·</a></h4><p>类似<code>U::=U</code>，会引起二义性和无穷递归</p><p>一般左递归就是有害规则</p><h4 id="多余规则">多余规则<a class="anchor" href="#多余规则">·</a></h4><ol><li>在推导文法的所有句子中，<strong>始终用不到的规则</strong>。 即该规则的<strong>左部非终结符不出现在任何句型</strong>中（<strong>不可达符号</strong>）</li><li>在推导句子的过程中，一旦使用了该规则，将推不出任何终结符号串。即该规则中含有<strong>推不出任何终结符号串</strong>的非终结符（<strong>不活动符号</strong>）</li></ol><p>若某文法中<strong>没有有害规则或者多余规则</strong>，则称该文法是<font color="blue">压缩过的</font></p><h4 id="font-color-red-删除文法中多余结点算法？-font"><font color="red">删除文法中多余结点算法？</font><a class="anchor" href="#font-color-red-删除文法中多余结点算法？-font">·</a></h4><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1.jpg" style="zoom:50%;"><h2 id="2-7-文法的其他表示法">2.7 文法的其他表示法<a class="anchor" href="#2-7-文法的其他表示法">·</a></h2><h3 id="扩充的BNF表示">扩充的BNF表示<a class="anchor" href="#扩充的BNF表示">·</a></h3><p>BNF元符号：<code>&lt; </code> <code>&gt;</code> <code>::=</code> <code>|</code></p><p>扩充的BNF元符号：<code>&lt; </code> <code>&gt;</code> <code>::=</code> <code>|</code> <code>{</code> <code>}</code> <code>[</code> <code>]</code> <code>(</code> <code>) </code> 后面几个分别是<strong>0-无穷次</strong> <strong>1-无穷次</strong> <strong>0-1次</strong></p><h3 id="语法图">语法图<a class="anchor" href="#语法图">·</a></h3><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/23.png" style="zoom:50%;"><h2 id="2-8-文法和语言分类">2.8 文法和语言分类<a class="anchor" href="#2-8-文法和语言分类">·</a></h2><h3 id="形式语言，文法，语言">形式语言，文法，语言<a class="anchor" href="#形式语言，文法，语言">·</a></h3><p><strong>形式语言</strong>：用文法和自动机描述的没有语义的语言</p><p><strong>乔姆斯基文法定义</strong>：</p><p>$G=(V_n,V_t,P,Z)$</p><p>​$V_n$ 非终结符号集$V_t$ 终结符号集</p><p>​$P$ 产生式或规则的集合$Z$ 开始符号（识别符号）$Z\in V_n$</p><p><strong>语言定义</strong>：$L(G[Z])={x|x\in V_t^*,Z\stackrel + \Rightarrow x}$</p><h3 id="文法和语言分类">文法和语言分类<a class="anchor" href="#文法和语言分类">·</a></h3><p>分为0、1、2、3型，差别在于<strong>对产生式（语法规则）的不同限制</strong></p><h4 id="0型-短语结构文法">0型 短语结构文法<a class="anchor" href="#0型-短语结构文法">·</a></h4><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/24.png" style="zoom:50%;"><h4 id="1型-上下文有关文法">1型 上下文有关文法<a class="anchor" href="#1型-上下文有关文法">·</a></h4><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/25.png" alt="25" style="zoom:50%;"><h4 id="2型-上下文无关文法">2型 上下文无关文法<a class="anchor" href="#2型-上下文无关文法">·</a></h4><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/26.png" alt="26" style="zoom:50%;"><h4 id="3型-正则文法">3型 正则文法<a class="anchor" href="#3型-正则文法">·</a></h4><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/27.png" alt="27" style="zoom:50%;"><ul><li>根据上述讨论，$L0 \supset L1 \supset L2 \supset L3 $</li><li><strong>0型文法</strong>可以产生$L0、L1、L2、L3$，</li><li>但<strong>2型文法</strong>只能产生$L2，L3$ 不能产生$L0，L1$</li><li><strong>3型文法</strong>只能产生$L3$</li></ul><h2 id="作业-2">作业<a class="anchor" href="#作业-2">·</a></h2><p>p29 3,4</p><p>习题2-3：p38 1-9</p><p>习题2-4： P46-47 1,5,6,8,9</p><p>p53 3</p><h1 id="三、词法分析">三、词法分析<a class="anchor" href="#三、词法分析">·</a></h1><h2 id="3-1-词法分析程序的功能及实现方案">3.1 词法分析程序的功能及实现方案<a class="anchor" href="#3-1-词法分析程序的功能及实现方案">·</a></h2><h3 id="功能：识别单词，返回单词的类别和值">功能：识别单词，返回单词的类别和值<a class="anchor" href="#功能：识别单词，返回单词的类别和值">·</a></h3><ul><li>词法分析：根据词法规则<strong>识别及组合</strong>单词，进行<strong>词法检查</strong></li><li><strong>删去</strong>空格字符和注释</li><li>对<strong>数字常数</strong>完成从数字字符串到二进制数值的<strong>转换</strong></li></ul><h3 id="实现方案">实现方案<a class="anchor" href="#实现方案">·</a></h3><ul><li><p>词法分析<strong>单独一遍</strong></p></li><li><p>作为一个<strong>子程序</strong>被语法分析程序调用</p></li></ul><h2 id="3-2-单词的种类及词法分析程序的输出形式">3.2 单词的种类及词法分析程序的输出形式<a class="anchor" href="#3-2-单词的种类及词法分析程序的输出形式">·</a></h2><h3 id="单词种类">单词种类<a class="anchor" href="#单词种类">·</a></h3><p>保留字，标识符（用户定义），常数，分界符(+ - * / …)</p><h3 id="单词内部形式">单词内部形式<a class="anchor" href="#单词内部形式">·</a></h3><h4 id="按单词种类分类">按单词种类分类<a class="anchor" href="#按单词种类分类">·</a></h4><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/31.png" style="zoom:50%;"><h4 id="保留字和分界符采用一符一类">保留字和分界符采用一符一类<a class="anchor" href="#保留字和分界符采用一符一类">·</a></h4><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/32.png" style="zoom:50%;"><h2 id="3-3-正则文法和状态图">3.3 正则文法和状态图<a class="anchor" href="#3-3-正则文法和状态图">·</a></h2><h3 id="左线性文法状态图画法">左线性文法状态图画法<a class="anchor" href="#左线性文法状态图画法">·</a></h3><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/33.png" style="zoom:50%;"><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/34.png" style="zoom:50%;"><h4 id="识别算法">识别算法<a class="anchor" href="#识别算法">·</a></h4><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/35.png" style="zoom:50%;"><h2 id="3-4-词法分析程序的设计与实现">3.4 词法分析程序的设计与实现<a class="anchor" href="#3-4-词法分析程序的设计与实现">·</a></h2><pre class="mermaid">graph LR词法规则-->状态图状态图-->词法分析程序</pre><h2 id="作业-3">作业<a class="anchor" href="#作业-3">·</a></h2><p>P73 1,2,3(词法见65-67页)</p><h1 id="四、语法分析">四、语法分析<a class="anchor" href="#四、语法分析">·</a></h1><h2 id="4-1-语法分析概述">4.1 语法分析概述<a class="anchor" href="#4-1-语法分析概述">·</a></h2><p><strong>功能</strong>：根据文法规则，从源程序单词符号串中<strong>识别出语法成分</strong>，并<strong>进行语法检查</strong>。</p><p><strong>基本任务</strong>：识别符号串S<strong>是否为某语法成分</strong></p><pre class="mermaid">graph LRa[两大类分析方法]a-->b[自顶向下分析]a-->c[自底向上分析]b-->b1[主要解决问题]b1-->b11[左递归问题]b1-->b12[回溯问题]b-->b2[主要方法]b2-->b21[递归子程序法]b2-->b22[LL分析法]c-->c1[主要问题]c1-->c11[句柄的识别问题]c-->c2[主要方法]c2-->c21[算法优先分析法]c2-->c22[LR分析法]</pre><h2 id="4-2-自顶向下分析">4.2 自顶向下分析<a class="anchor" href="#4-2-自顶向下分析">·</a></h2><h3 id="4-2-1-自顶向下分析的一般过程">4.2.1 自顶向下分析的一般过程<a class="anchor" href="#4-2-1-自顶向下分析的一般过程">·</a></h3><p>预测某一符号串为某一语法成分，根据其文法，<strong>为S构造一棵语法树</strong>，若成功，则S被识别为某一语法成分，即</p><p>$S\in L(G[Z])$，否则，$S\notin L(G[Z])$</p><p>分析过程带预测，是试探过程，有时需要回溯</p><h3 id="4-2-2-自顶向下分析存在的问题及解决方法">4.2.2 自顶向下分析存在的问题及解决方法<a class="anchor" href="#4-2-2-自顶向下分析存在的问题及解决方法">·</a></h3><h4 id="1-左递归文法">1.左递归文法<a class="anchor" href="#1-左递归文法">·</a></h4><p>比如<code>E::=E+T|T</code></p><h5 id="消除直接左递归">消除直接左递归<a class="anchor" href="#消除直接左递归">·</a></h5><h6 id="方法1-使用扩充BNF表示改写文法">方法1 使用扩充BNF表示改写文法<a class="anchor" href="#方法1-使用扩充BNF表示改写文法">·</a></h6><p><strong>规则1：提因子</strong></p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/36.png" style="zoom:50%;"><p><strong>规则2</strong></p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/41.png" style="zoom:50%;"><h6 id="方法2-将左递归规则改为右递归规则">方法2 将左递归规则改为右递归规则<a class="anchor" href="#方法2-将左递归规则改为右递归规则">·</a></h6><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/42.png" style="zoom:50%;"><h5 id="消除一般左递归">消除一般左递归<a class="anchor" href="#消除一般左递归">·</a></h5><p><strong>消除所有左递归的算法</strong></p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/43.png" style="zoom:50%;"><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/44.png" style="zoom:50%;"><h4 id="2-回溯问题">2.回溯问题<a class="anchor" href="#2-回溯问题">·</a></h4><p>$FIRST(\alpha_i)={a|\alpha_i\stackrel *\Rightarrow a…,a\in V_t}$</p><p>避免回溯，文法需要满足 $\forall \ i\neq j,FIRST(\alpha_i)\cap FIRST(\alpha_j)=\varnothing$</p><h5 id="改写文法">改写文法<a class="anchor" href="#改写文法">·</a></h5><p>对具有多个右部的规则反复提取左因子</p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/45.png" style="zoom:50%;"><h5 id="超前扫描">超前扫描<a class="anchor" href="#超前扫描">·</a></h5><p>向前多看几个符号</p><h4 id="文法的两个条件">文法的两个条件<a class="anchor" href="#文法的两个条件">·</a></h4><p>为了在<strong>不采取超前扫描的前提下</strong>实现<strong>不带回溯的自顶向下分析</strong>，文法需要满足两个条件</p><ul><li><p>非左递归（递归下降都需要）</p></li><li><p>不含回溯</p></li><li></li></ul>  <img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/46.png" style="zoom:50%;"><h3 id="4-2-3-递归子程序法（递归下降分析法）">4.2.3 递归子程序法（递归下降分析法）<a class="anchor" href="#4-2-3-递归子程序法（递归下降分析法）">·</a></h3><ul><li>检查并改写文法</li><li>检查文法的递归性</li><li>递归调用各个子函数来识别语法成分</li></ul><h2 id="作业-4">作业<a class="anchor" href="#作业-4">·</a></h2><p>p91: 1-3</p><h1 id="五、符号表管理技术">五、符号表管理技术<a class="anchor" href="#五、符号表管理技术">·</a></h1><h2 id="5-1-概述">5.1 概述<a class="anchor" href="#5-1-概述">·</a></h2><p><strong>符号表</strong>：编译程序记录各种名字的特性信息，<strong>名字特性表</strong></p><p>源程序中变量要<strong>先声明，再引用</strong>。引用声明的变量时需要<strong>语法语义正确性检查</strong>以及<strong>生成相应的目标程序</strong></p><h2 id="5-2-符号表的组织与内容">5.2 符号表的组织与内容<a class="anchor" href="#5-2-符号表的组织与内容">·</a></h2><h3 id="符号表内容">符号表内容<a class="anchor" href="#符号表内容">·</a></h3><p><strong>名字域</strong>：标识符字符串</p><p><strong>特性域</strong>：可包括多个子域</p><p>可以有以下内容：</p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/51.png" style="zoom: 33%;"><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/52.png" style="zoom: 33%;"><h3 id="符号表组织方式">符号表组织方式<a class="anchor" href="#符号表组织方式">·</a></h3><ol><li><strong>统一符号表</strong>==&gt;查表方便，<strong>结构简单</strong>，浪费空间</li><li>不同种类名字建立<strong>各种符号表</strong>==&gt;<strong>节省空间</strong>，填表查表不方便</li><li><strong>折中办法</strong>==&gt;大部分共同信息组成<strong>统一格式符号表</strong>，特殊信息<strong>另外附表</strong>，两者指针相连</li></ol><h3 id="5-3-非分程序结构语言的符号表组织">5.3 非分程序结构语言的符号表组织<a class="anchor" href="#5-3-非分程序结构语言的符号表组织">·</a></h3><p>分为<strong>全局</strong>和<strong>局部</strong>符号表，分别管理全局变量函数定义，和局部的变量</p><p>无序符号表，有序符号表，散列符号表</p><h3 id="5-4-分程序结构语言的符号表组织">5.4 分程序结构语言的符号表组织<a class="anchor" href="#5-4-分程序结构语言的符号表组织">·</a></h3><p>分程序结构语言:模块内<strong>可嵌入</strong>子模块</p><p>查表需要从当前层查起，一直往外层查</p><h2 id="作业-5">作业<a class="anchor" href="#作业-5">·</a></h2><p>作业：P115-116 3,5</p><p><strong>非分程序</strong>：名字，类型，维数</p><p><strong>分程序</strong>：序号，名字，属性，外接一个索引的栈</p><h1 id="六、运行时的存储组织及管理">六、运行时的存储组织及管理<a class="anchor" href="#六、运行时的存储组织及管理">·</a></h1><h2 id="6-1-概述">6.1 概述<a class="anchor" href="#6-1-概述">·</a></h2><h3 id="运行时的存储组织及管理">运行时的存储组织及管理<a class="anchor" href="#运行时的存储组织及管理">·</a></h3><p><strong>目标程序</strong>运行时<strong>需要存储空间</strong>的组织管理，<strong>源程序</strong>中<strong>变量存储空间</strong>的分配</p><h4 id="静态存储分配">静态存储分配<a class="anchor" href="#静态存储分配">·</a></h4><p>在<strong>编译阶段</strong>由<strong>编译程序</strong>实现<strong>对存储空间的管理</strong>和<strong>为源程序中的变量分配存储</strong>的方法。</p><p>必须在编译时能够确定<strong>源程序中变量分配存储</strong>的方法</p><h4 id="动态存储分配">动态存储分配<a class="anchor" href="#动态存储分配">·</a></h4><p>在目标程序运行阶段由<strong>目标程序</strong>实现对<strong>存储空间的组织与管理</strong>，和为源程序中的变量<strong>分配存储</strong>的方法。</p><p>需要生成进行动态分配的目标指令</p><h2 id="6-2-静态存储分配">6.2 静态存储分配<a class="anchor" href="#6-2-静态存储分配">·</a></h2><h3 id="FORTRAN子程序典型数据区">FORTRAN子程序典型数据区<a class="anchor" href="#FORTRAN子程序典型数据区">·</a></h3><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/53.png" style="zoom:50%;"><h2 id="6-3-动态存储分配">6.3 动态存储分配<a class="anchor" href="#6-3-动态存储分配">·</a></h2><p>栈式动态存储分配</p><p>整个数据区为<strong>一个堆栈</strong>(1) 当<strong>进入一个过程</strong>时，在<strong>栈顶</strong>为其<strong>分配</strong>一个数据区。(2) <strong>退出</strong>时，<strong>撤消</strong>过程数据区。</p><h3 id="6-3-1-活动记录">6.3.1 活动记录<a class="anchor" href="#6-3-1-活动记录">·</a></h3><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/54.png" style="zoom:50%;"><p><strong>局部数据区</strong>：存放模块中定义各个<strong>局部变量</strong></p><p><strong>参数区</strong>：存放<strong>隐式参数</strong>和<strong>显式参数</strong></p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/55.png" style="zoom:50%;"><p><strong>display区</strong>：存放各<strong>外层模块活动记录</strong>的基地址 =&gt;为了能够利用符号表索引各个块的变量</p><h4 id="C语言运行时存储管理">C语言运行时存储管理<a class="anchor" href="#C语言运行时存储管理">·</a></h4><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/56.png" style="zoom:50%;"><h2 id="作业-6">作业<a class="anchor" href="#作业-6">·</a></h2><p>p119 1P133 2,3</p><h1 id="七、源程序的中间形式">七、源程序的中间形式<a class="anchor" href="#七、源程序的中间形式">·</a></h1><h2 id="7-1-波兰表示">7.1 波兰表示<a class="anchor" href="#7-1-波兰表示">·</a></h2><p>比如<code>a*b*c+d*(e+f)</code> 波兰表示是：<code>abc**def+*+</code></p><p>即中缀转后缀</p><p>操作符栈和操作数栈</p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/71.png" style="zoom:50%;"><p>波兰表示的代码不易于代码优化</p><h3 id="if-语句的波兰表示">if 语句的波兰表示<a class="anchor" href="#if-语句的波兰表示">·</a></h3><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/76.png" style="zoom:50%;"><h2 id="7-2-N元表示">7.2 N元表示<a class="anchor" href="#7-2-N元表示">·</a></h2><p>常用<strong>三元式</strong>和<strong>四元式</strong></p><h3 id="三元式">三元式<a class="anchor" href="#三元式">·</a></h3><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/72.png" style="zoom: 33%;"><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/73.png" style="zoom: 33%;"><h4 id="间接三元式">间接三元式<a class="anchor" href="#间接三元式">·</a></h4><p>执行次序和三元式代码分成两张表进行表示</p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/74.png" style="zoom:33%;"><h3 id="四元式">四元式<a class="anchor" href="#四元式">·</a></h3><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/75.png" style="zoom: 33%;"><h2 id="7-3-抽象机代码">7.3 抽象机代码<a class="anchor" href="#7-3-抽象机代码">·</a></h2><p>许多 <code>pascel</code> 编译器生成的中间代码是称为 <code>Pcode</code> 的抽象代码。<code>P</code> 即为 <code>Pseudo</code></p><p><strong>Pcode</strong>实际上是<strong>波兰表示形式</strong>的中间代码</p><p>Pcode生成后，可以用<strong>解释执行程序</strong>来解释执行Pcode，也可以再把Pcode变成某一机器的目标代码</p><h2 id="作业-7">作业<a class="anchor" href="#作业-7">·</a></h2><p>P144 1,2,3,4</p><h1 id="八、错误处理">八、错误处理<a class="anchor" href="#八、错误处理">·</a></h1><h2 id="8-1-概述">8.1 概述<a class="anchor" href="#8-1-概述">·</a></h2><p>错误的源程序可以通过编译发现并指出错误</p><p>正确则生成目标代码</p><h3 id="错误处理能力">错误处理能力<a class="anchor" href="#错误处理能力">·</a></h3><p>侦察错误、报错及时准确、一次编译找出错误、改正能力、遏制重复报错信息</p><h2 id="8-2-错误分类">8.2 错误分类<a class="anchor" href="#8-2-错误分类">·</a></h2><p><strong>语法错误</strong>：源程序<strong>语法上</strong>不合乎文法</p><p>比如源文法：<code>A::=B{+B} B::=C{*C} C::=a</code></p><p>而出现了 <code>a+*a</code> 这样的句子</p><p><strong>语义错误</strong>：程序<strong>不符合语义</strong>规则或者<strong>超出了计算机系统的限制</strong></p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/81.png" style="zoom:40%;"><h2 id="8-3-错误的诊察和报告">8.3 错误的诊察和报告<a class="anchor" href="#8-3-错误的诊察和报告">·</a></h2><h3 id="错误侦察">错误侦察<a class="anchor" href="#错误侦察">·</a></h3><p><strong>违反语法和语义规则</strong>以及<strong>超出编译系统限制</strong> ==&gt; 语义分析需要<strong>借助符号表</strong></p><p><strong>下标越界</strong> ==&gt; <strong>计算结果溢出</strong>以及<strong>动态存储数据区溢出</strong></p><h3 id="错误报告">错误报告<a class="anchor" href="#错误报告">·</a></h3><p>行号计数器 <code>line_no</code>，单词序号计数器 <code>char_no</code></p><p>显示文字信息，给出错误编码</p><h3 id="报告错误的两种方式">报告错误的两种方式<a class="anchor" href="#报告错误的两种方式">·</a></h3><ul><li>分析完以后再报告(显示或者打印)</li><li>边分析边报告</li></ul><h2 id="8-4-错误处理技术">8.4 错误处理技术<a class="anchor" href="#8-4-错误处理技术">·</a></h2><p><strong>错误改正</strong>：编译侦察出错误，根据文法改正错误</p><p><strong>错误局部化处理</strong>：尽可能把错误影响限制在一个局部范围，避免其扩散影响</p><h3 id="一般原则">一般原则<a class="anchor" href="#一般原则">·</a></h3><p>发现错误，暂停对后面符号分析，跳过错误所在语法成分</p><h3 id="错误局部化处理实现">错误局部化处理实现<a class="anchor" href="#错误局部化处理实现">·</a></h3><p>递归下降实现</p><p>遇到错误，先打印信息，再跳出一段源程序，直到右界符或此语法成分的合法后继符号</p><h3 id="目标程序运行时错误检测与处理">目标程序运行时错误检测与处理<a class="anchor" href="#目标程序运行时错误检测与处理">·</a></h3><ul><li>下标变量下标值越界</li><li>计算结果溢出</li><li>动态存储分配数据区溢出</li></ul><p>目标程序运行检测到这类错误，调用异常处理程序，打印错误信息和运行现场（寄存器和存储器中的值），然后停止程序运行</p><h1 id="九、语法制导翻译技术">九、语法制导翻译技术<a class="anchor" href="#九、语法制导翻译技术">·</a></h1><h2 id="9-1-翻译文法-TG-和语法制导翻译">9.1 翻译文法(TG)和语法制导翻译<a class="anchor" href="#9-1-翻译文法-TG-和语法制导翻译">·</a></h2><h3 id="简单文法引入">简单文法引入<a class="anchor" href="#简单文法引入">·</a></h3><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/91.png" style="zoom:50%;"><p><code>@+ @* @i</code> 为动作符号。@为动作符号标记，后面为字符串</p><p>这个例子里，语义子程序功能是输出<strong>打印动作符号标记后面</strong>的字符串</p><p>比如$E\rightarrow E+T @+$的语义是分析E,+,T，输出+</p><p>比如$i\rightarrow i @i$的语义是分析i，输出i</p><h4 id="输入文法">输入文法<a class="anchor" href="#输入文法">·</a></h4><p>未插入动作符号的文法，可以推出<strong>输入序列</strong></p><h4 id="翻译文法">翻译文法<a class="anchor" href="#翻译文法">·</a></h4><p>插入动作符号的文法</p><p>由翻译文法可以通过推导产生 <strong>活动序列</strong>，包含了<strong>输入序列</strong>和<strong>动作序列</strong></p><h4 id="例子-9">例子<a class="anchor" href="#例子-9">·</a></h4><p>比如用上面的文法推导<code>(i+i)*i</code></p><p>先推导出活动序列</p><p>$E\Rightarrow T \Rightarrow T<em>F@</em>\Rightarrow F<em>F@</em> \Rightarrow (E)<em>F@</em>\Rightarrow (E+T@+)<em>F@</em>$</p><p>$\stackrel *\Rightarrow (i@i+i@i@+)<em>i@i@</em>$</p><p><strong>活动序列</strong>：由<strong>翻译文法</strong>推导出的由<strong>终结符</strong>和<strong>活动符</strong>号组成的<strong>符号串</strong></p><p>抽去动作符号，可得到输入序列</p><p>抽去输入序列，可得动作序列</p><p>执行动作序列，完成翻译任务</p><h3 id="语法制导翻译">语法制导翻译<a class="anchor" href="#语法制导翻译">·</a></h3><p>按<strong>翻译文法</strong>进行的翻译。给定一<strong>输入符号串</strong>，根据翻译文法获得翻译该符号串的<strong>动作序列</strong>，并<strong>执行</strong>该序列所<strong>规定的动作</strong>的过程</p><h4 id="实现方法">实现方法<a class="anchor" href="#实现方法">·</a></h4><p>适当位置<strong>插入语义动作符号</strong>，当按照文法<strong>分析到动作符号</strong>就调用相应的<strong>语义子程序</strong>完成翻译任务</p><h2 id="9-2-属性翻译文法-ATG">9.2 属性翻译文法(ATG)<a class="anchor" href="#9-2-属性翻译文法-ATG">·</a></h2><h3 id="综合属性">综合属性<a class="anchor" href="#综合属性">·</a></h3><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/92.png" style="zoom:40%;"><p>自底向上进行属性计算，所以称为综合属性，用$\uparrow$表示属性计算<strong>从下往上</strong></p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/93.png" style="zoom:40%;"><p>可以改写文法为以下样子</p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/94.png" style="zoom:40%;"><p><font color="blue">综合属性其实就是一个计算数值属性的过程</font></p><h3 id="继承属性">继承属性<a class="anchor" href="#继承属性">·</a></h3><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/95.png" style="zoom:40%;"><p>类型和名字可以设两个综合属性，即</p><p>$Type_{\uparrow t}\ \ t存放类型值$</p><p>$id_{\uparrow n} \ \ n存放变量名$</p><p>填表动作符号也可以有属性</p><p>即$@set_table_{\downarrow t_1,n_1}$  其中 $t_1,n_1$ 是从前面得到的，因此是继承属性，继承了前面的值</p><p>同理有变量表：$&lt;变量表&gt;_{\downarrow t_2}$  <font color="blue">相当于递归的时候能够知道最开始的类型是啥</font></p><p>这样就可以整理成以下的<strong>属性翻译文法</strong></p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/97.png" style="zoom:50%;"><p>这时的语法树和之前有区别了</p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/98.png" style="zoom:40%;"><p>可见，继承属性求值：自左向右，自顶向下</p><p>综合属性求值：自右向左，自底向上</p><h3 id="L-属性翻译文法（L-ATG）">L-属性翻译文法（L-ATG）<a class="anchor" href="#L-属性翻译文法（L-ATG）">·</a></h3><p>较简单的一种属性翻译文法，要求输入文法为<strong>LL(1)文法</strong>，可用<strong>自顶向下分析构造分析器</strong>，分析过程可进行<strong>属性求值</strong></p><h4 id="L属性翻译文法定义">L属性翻译文法定义<a class="anchor" href="#L属性翻译文法定义">·</a></h4><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/99.png" style="zoom:50%;"><h4 id="属性求值规则">属性求值规则<a class="anchor" href="#属性求值规则">·</a></h4><h5 id="继承属性-2">继承属性<a class="anchor" href="#继承属性-2">·</a></h5><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/910.png" style="zoom:50%;"><p>即，<strong>自顶向下，自左向右</strong></p><h5 id="综合属性-2">综合属性<a class="anchor" href="#综合属性-2">·</a></h5><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/911.png" style="zoom:50%;"><p>即，<strong>自底向上，自右向左</strong></p><h4 id="简单赋值形式的L-属性翻译文法-SL-ATG">简单赋值形式的L_属性翻译文法(SL-ATG)<a class="anchor" href="#简单赋值形式的L-属性翻译文法-SL-ATG">·</a></h4><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/912.png" style="zoom:50%;"><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/913.png" style="zoom:50%;"><h4 id="改写L-ATG为SL-ATG">改写L-ATG为SL-ATG<a class="anchor" href="#改写L-ATG为SL-ATG">·</a></h4><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/914.png" style="zoom:50%;"><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/915.png" style="zoom:50%;"><p>改成如下的样子</p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/916.png" style="zoom:50%;"><p>无参函数过程作为常数处理</p><h2 id="9-3-自顶向下语法制导翻译">9.3 自顶向下语法制导翻译<a class="anchor" href="#9-3-自顶向下语法制导翻译">·</a></h2><h3 id="翻译文法的自顶向下语法制导翻译——递归下降翻译器">翻译文法的自顶向下语法制导翻译——递归下降翻译器<a class="anchor" href="#翻译文法的自顶向下语法制导翻译——递归下降翻译器">·</a></h3><p>即在递归下降语法分析程序中加入处理动作符号，输出动作符号字符串的部分</p><h3 id="属性翻译文法的自顶向下语法制导翻译——递归下降属性翻译器">属性翻译文法的自顶向下语法制导翻译——递归下降属性翻译器<a class="anchor" href="#属性翻译文法的自顶向下语法制导翻译——递归下降属性翻译器">·</a></h3><p>对每一个非终结符编写一个翻译子程序</p><p>继承属性==&gt;声明为<strong>赋值形参</strong></p><p>综合属性==&gt;声明为<strong>变量形参</strong>，以<strong>指针或者地址</strong>的形式传参数到函数内，之后在函数内赋值后自然传回调用位置</p><p>属性名约定：产生式<strong>左部同名非终结符</strong>使用<strong>相同的属性名</strong></p><p>具有相同值的属性取相同的属性名。这样可以删除属性求值规则</p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/917.png" style="zoom: 50%;"><h2 id="作业-8">作业<a class="anchor" href="#作业-8">·</a></h2><p>PPT42页例子</p><p>P166 1.(前缀式), 2, 3, 4, 5</p><h1 id="十、语义分析和代码生成">十、语义分析和代码生成<a class="anchor" href="#十、语义分析和代码生成">·</a></h1><h2 id="10-1-语义分析的概念">10.1 语义分析的概念<a class="anchor" href="#10-1-语义分析的概念">·</a></h2><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/101.png" style="zoom:50%;"><h2 id="10-2-栈式抽象机及其汇编指令">10.2 栈式抽象机及其汇编指令<a class="anchor" href="#10-2-栈式抽象机及其汇编指令">·</a></h2><pre class="mermaid">graph LRa[栈式抽象机]a-->a1[指令寄存器]a-->a2[地址寄存器]a1-->一个a2-->多个a-->b[存储器]b-->b1[数据存储器-存放AR的运行栈]b-->b2[操作存储器-操作数栈]b-->b3[指令存储器]</pre><h2 id="10-3-声明的处理">10.3 声明的处理<a class="anchor" href="#10-3-声明的处理">·</a></h2><h2 id="10-4-表达式的处理">10.4 表达式的处理<a class="anchor" href="#10-4-表达式的处理">·</a></h2><h2 id="10-5-赋值语句的处理">10.5 赋值语句的处理<a class="anchor" href="#10-5-赋值语句的处理">·</a></h2><h2 id="10-6-控制语句的处理">10.6 控制语句的处理<a class="anchor" href="#10-6-控制语句的处理">·</a></h2><h2 id="10-7-过程调用和返回">10.7 过程调用和返回<a class="anchor" href="#10-7-过程调用和返回">·</a></h2><h2 id="作业-9">作业<a class="anchor" href="#作业-9">·</a></h2><p>试设计Pascal记录变量（无变体）的属性翻译文法，并构造相应的语义动/作程序。</p><p>写出for语句在执行循环体之前先做循环条件测试的属性翻译文法及其处理动作程序</p><h1 id="十一、词法自动化">十一、词法自动化<a class="anchor" href="#十一、词法自动化">·</a></h1><h2 id="11-1-正则表达式">11.1 正则表达式<a class="anchor" href="#11-1-正则表达式">·</a></h2><p>正则表达式相等&lt;=&gt;这两个正则表达式的语言相等</p><p>正则表达式与3型文法等价</p><h2 id="11-2-自动机">11.2 自动机<a class="anchor" href="#11-2-自动机">·</a></h2><h3 id="11-2-1-DFA">11.2.1 DFA<a class="anchor" href="#11-2-1-DFA">·</a></h3><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/111.png" style="zoom:50%;"><h3 id="11-2-2-NFA">11.2.2 NFA<a class="anchor" href="#11-2-2-NFA">·</a></h3><p>在某个状态下，对于某个输入字符存在多个后继状态</p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/112.png" style="zoom:50%;"><h3 id="11-2-3-NFA的确定化">11.2.3 NFA的确定化<a class="anchor" href="#11-2-3-NFA的确定化">·</a></h3><p>不确定的有穷自动机与确定的有穷自动机<strong>从功能上来说是等价</strong>的</p><h4 id="定义1-集合I的-epsilon-闭包">定义1 集合I的$\epsilon$-闭包<a class="anchor" href="#定义1-集合I的-epsilon-闭包">·</a></h4><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/113.png" style="zoom:67%;"><h4 id="定义2-2">定义2<a class="anchor" href="#定义2-2">·</a></h4><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/114.png" style="zoom:67%;"><h3 id="11-2-4-DFA的最小化">11.2.4 DFA的最小化<a class="anchor" href="#11-2-4-DFA的最小化">·</a></h3><p><strong>消除多余状态</strong>和<strong>合并等价状态</strong></p><h4 id="合并等价状态">合并等价状态<a class="anchor" href="#合并等价状态">·</a></h4><p>先根据终态和非终态拆分成两个区</p><p>再在每个区内分别根据每个符号的状态转移，划分更小的区</p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/115.png" style="zoom: 67%;"><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/116.png" alt="116" style="zoom: 67%;"><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/117.png" alt="117" style="zoom: 67%;"><h3 id="11-2-5-正则表达式与DFA的等价性">11.2.5 正则表达式与DFA的等价性<a class="anchor" href="#11-2-5-正则表达式与DFA的等价性">·</a></h3><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/119.png" style="zoom:67%;"><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/118.png" style="zoom: 50%;"><p>四个都对</p><h2 id="11-3-词法分析程序的自动生成器-—LEX（LEXICAL）">11.3 词法分析程序的自动生成器 —LEX（LEXICAL）<a class="anchor" href="#11-3-词法分析程序的自动生成器-—LEX（LEXICAL）">·</a></h2><p>词法分析程序包含<strong>状态转移矩阵</strong>和<strong>控制执行程序</strong>。</p><h2 id="作业-10">作业<a class="anchor" href="#作业-10">·</a></h2><p>P254-255 1,2,4,5</p><h1 id="十二、语法分析（提高部分）">十二、语法分析（提高部分）<a class="anchor" href="#十二、语法分析（提高部分）">·</a></h1><p>功能：根据<strong>文法规则</strong>，从源程序<strong>单词符号串</strong>中识别出<strong>语法成分</strong>，并进行语法检查。</p><h2 id="自顶向下分析法">自顶向下分析法<a class="anchor" href="#自顶向下分析法">·</a></h2><h3 id="基本思想-2">基本思想<a class="anchor" href="#基本思想-2">·</a></h3><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/121.png" style="zoom:80%;"><h4 id="主要方法">主要方法<a class="anchor" href="#主要方法">·</a></h4><ol><li>递归子程序法</li><li>LL分析法</li></ol><h4 id="一般过程">一般过程<a class="anchor" href="#一般过程">·</a></h4><p>对于一个符号串，预测其为某一语法成分，根据其文法设法构造相应语法树</p><h4 id="特点-2">特点<a class="anchor" href="#特点-2">·</a></h4><ul><li>带预测</li><li>试探过程，可能会有回溯</li><li>最左推导可用程序实现，带回溯自顶向下分析方法实际上价值不大，效率低</li></ul><h3 id="LL分析法">LL分析法<a class="anchor" href="#LL分析法">·</a></h3><p>自左向右<strong>扫描，分析和匹配</strong>输入串。分析过程有<strong>最左推导</strong>的性质。</p><p>三部分组成：分析表，执行程序，符号栈（分析栈）</p><h5 id="分析表：二维矩阵">分析表：二维矩阵<a class="anchor" href="#分析表：二维矩阵">·</a></h5><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/123.png" style="zoom:80%;"><p>$A::=a_i$表示<code>A</code>去匹配输入串且当前输入符号为<code>a</code>时可以用<code>A</code>的第<code>i</code>个选择去匹配</p><p>$a_i\neq \epsilon$ 则 $a_i\Rightarrow a… $</p><p>$a_i= \epsilon$ 则 $a$ 为 $A$ 的后继符号</p><p><code>error</code>表示不能匹配</p><h5 id="符号栈">符号栈<a class="anchor" href="#符号栈">·</a></h5><p><strong>开始、工作、出错、结束</strong>四种状态</p><h4 id="1-执行程序">1.执行程序<a class="anchor" href="#1-执行程序">·</a></h4><ol><li><p>把#和文法识别符号E推进栈, 读入下一个符号， 重复下述过程直到正常结束或出错。</p></li><li><p>测定栈顶符号X和当前输入符号a,执行如下操作:</p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/124.png" style="zoom:80%;"><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/125.png" style="zoom:80%;"></li></ol><h4 id="2-分析表构造">2.分析表构造<a class="anchor" href="#2-分析表构造">·</a></h4><p>需要确定后继符号和能够推导出的符号==&gt;$First$集和$Follow$集</p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/126.png" style="zoom:80%;"><h5 id="构造FIRST集与FOLLOW集">构造FIRST集与FOLLOW集<a class="anchor" href="#构造FIRST集与FOLLOW集">·</a></h5><p>​                                       <img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/128.png" style="zoom:60%;"><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/129.png" alt="129" style="zoom:60%;"></p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1210.png" alt="1210" style="zoom:60%;"><h5 id="根据FIRST和FOLLOW集构造分析表">根据FIRST和FOLLOW集构造分析表<a class="anchor" href="#根据FIRST和FOLLOW集构造分析表">·</a></h5><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1244.png" style="zoom:50%;"><h4 id="3-LL-1-文法">3.LL(1)文法<a class="anchor" href="#3-LL-1-文法">·</a></h4><p>一个文法G，其分析表M<strong>不含多重定义入口</strong>(即分析表中无二条以上规则)，则称它是一个<strong>LL(1)文法</strong>。</p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/127.png" style="zoom: 67%;"><p>可以证明：如果G是<strong>左递归</strong>的,或者是<strong>二义性</strong>的文法,则<strong>至少有一个多重入口</strong>。</p><h2 id="自底向上分析法">自底向上分析法<a class="anchor" href="#自底向上分析法">·</a></h2><h3 id="基本思想-3">基本思想<a class="anchor" href="#基本思想-3">·</a></h3><p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/122.png" alt></p><h4 id="主要方法-2">主要方法<a class="anchor" href="#主要方法-2">·</a></h4><ol><li>算符优先分析法</li><li>LR分析法</li></ol><h4 id="基本算法思想">基本算法思想<a class="anchor" href="#基本算法思想">·</a></h4><p>若采用自左向右的描述和分析输入串,那么自底向上的基本算法是：从输入符号串开始，通过重复查找当前句型的<strong>句柄(最左简单短语)</strong>，并利用有关规则进行<strong>归约</strong>，若能归约为文法的识别符号，则表示分析成功，输入符号串是文法的合法句子，否则有语法错误。</p><h4 id="分析过程">分析过程<a class="anchor" href="#分析过程">·</a></h4><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1211.png" style="zoom: 80%;"><p>关键是找到<strong>句柄</strong></p><h3 id="自底向上分析的一般过程（移进-归约分析）">自底向上分析的一般过程（移进-归约分析）<a class="anchor" href="#自底向上分析的一般过程（移进-归约分析）">·</a></h3><p>建立符号栈记录分析<strong>历史和现状</strong>，根据当前状态，确定下一步<strong>移进</strong>还是<strong>规约</strong>。</p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1212.png" style="zoom:80%;"><p>防止一个终结符可以被两个规则规约成不同句型，引入下列的分析法。</p><h3 id="算符优先分析法">算符优先分析法<a class="anchor" href="#算符优先分析法">·</a></h3><p><strong>预先</strong>规定<strong>相邻终结符</strong>之间的<strong>优先关系</strong>，利用这种关系来确定<strong>句型的句柄</strong>并进行规约</p><h4 id="分析过程-2">分析过程<a class="anchor" href="#分析过程-2">·</a></h4><p>当栈顶(或次栈顶)终结符的优先级大于栈外的终结符的优先级，则进行归约，否则移进。</p><p>分析过程不一定是严格的最左规约（即不一定是规范规约），即每次规约不一定是规约当前句型的句柄，而是句柄的变形，即短语。</p><p><strong>出错情况</strong>:</p><ol><li>相邻终结符之间<strong>无优先关系</strong></li><li>对双目运行符进行<strong>归约时</strong>,符号栈中<strong>无足够元素</strong></li><li><strong>非正常结束</strong>状态</li></ol><h4 id="算符优先分析法的进一步讨论">算符优先分析法的进一步讨论<a class="anchor" href="#算符优先分析法的进一步讨论">·</a></h4><h5 id="1-算符优先文法-OPG">(1) 算符优先文法(OPG)<a class="anchor" href="#1-算符优先文法-OPG">·</a></h5><p>OPG－Operator Precedence Grammar</p><p><strong>算符文法（OG）的定义</strong>：若文法中<strong>无</strong>形如$U∷ = ·¨VW·¨$的规则，这里$V,W∈V_n$ 则称G为<strong>OG文法</strong>，也就是<strong>算符文法</strong>。</p><p><strong>优先关系的定义</strong></p><p>若G是一<strong>OG文法</strong>，$a,b∈V_t , U,V,W∈V_n$ 分别有以下三种情况:</p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1213.png" style="zoom: 80%;"><p><strong>算符优先文法（OPG）的定义</strong></p><p>设有一OG文法，如果在<strong>任意两个终结符</strong>之间，至多只有<strong>上述关系中的一种</strong>，则称该文法为<strong>算符优先文法(OPG)</strong></p><p><strong>几点说明</strong></p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1214.png" style="zoom: 80%;"><h5 id="2-构造优先关系矩阵">(2) 构造优先关系矩阵<a class="anchor" href="#2-构造优先关系矩阵">·</a></h5><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1215.png" style="zoom: 80%;"><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1216.png" style="zoom: 80%;"><p>​                                     <img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1217.png" style="zoom: 80%;"> 具体实现参看P14-第6张PPT</p><p>​                                    <img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1218.png" style="zoom:80%;"> 具体实现参看P15-第2张PPT</p><h6 id="构造优先关系矩阵的算法">构造优先关系矩阵的算法<a class="anchor" href="#构造优先关系矩阵的算法">·</a></h6><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1219.png" style="zoom: 67%;"><h5 id="3-算符优先分析算法的设计">(3) 算符优先分析算法的设计<a class="anchor" href="#3-算符优先分析算法的设计">·</a></h5><p>先定义优先级，在分析过程中通过<strong>比较相邻运算符之间的优先级</strong>来确定句型的**“句柄”<strong>并进行归约。这里的句柄指的是</strong>最左素短语**。</p><p><strong>素短语</strong>：文法G的句型的素短语是一个短语，它<strong>至少包含</strong>有<strong>一个终结符号</strong>，并且除它自身以外<strong>不再包含其他素短语</strong>。</p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1220.png" style="zoom: 67%;"><h6 id="寻找最左素短语">寻找最左素短语<a class="anchor" href="#寻找最左素短语">·</a></h6><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1221.png" style="zoom:67%;"><h5 id="算符优先分析法的实现">算符优先分析法的实现<a class="anchor" href="#算符优先分析法的实现">·</a></h5><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1222.png" style="zoom:80%;"><h3 id="LR分析法">LR分析法<a class="anchor" href="#LR分析法">·</a></h3><h4 id="概述-2">概述<a class="anchor" href="#概述-2">·</a></h4><p><strong>从左到右</strong>扫描(L)自底向上进行归约® (是<strong>规范归约</strong>）, 是自底向上分析方法的高度概括和集中</p><p><strong>三部分</strong>：状态栈，分析表，控制程序</p><p><strong>状态栈</strong>：放置<strong>分析器状态</strong>和<strong>文法符号</strong>。</p><p><strong>分析表</strong>：由两个矩阵组成，其功能是<strong>指示分析器的动作</strong>， 是<strong>移进</strong>还是<strong>归约</strong>，根据不同的文法类要采用不同的构造方法。</p><p><strong>控制程序</strong>：执行分析表所规定的动作，对栈进行操作。</p><h5 id="分析表的种类">分析表的种类<a class="anchor" href="#分析表的种类">·</a></h5><ul><li>SLR分析表(简单LR分析表) 最易实现，高实用价值</li><li>LR分析表(规范LR分析表) 实用价值不大</li><li>LALR分析表(超前LR分析表)  难度介于上述两者之间</li></ul><p><strong>使用SLR分析表进行语法分析</strong>的分析器叫<strong>SLR分析器</strong>。</p><p><strong>使用LALR分析表进行语法分析</strong>的分析器叫<strong>LALR分析器</strong>。</p><p>例如UNIX的YACC，根据文法规则YACC源文件，得到某语言的LALR分析器</p><h5 id="几点说明-2">几点说明<a class="anchor" href="#几点说明-2">·</a></h5><ol><li>三种分析表对应三类文法</li><li>一个SLR文法<strong>必定是</strong>LALR文法和LR文法</li><li>仅讨论SLR分析表的构造方法</li></ol><h4 id="LR分析">LR分析<a class="anchor" href="#LR分析">·</a></h4><h5 id="逻辑结构">逻辑结构<a class="anchor" href="#逻辑结构">·</a></h5><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1223.png" style="zoom:80%;"><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1224.png" style="zoom: 80%;"><p>​规范规约：规约当前的句柄</p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1225.png" style="zoom:80%;"><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1226.png" style="zoom:80%;">                                                                    <h5 id="分析表1-状态转移表-GOTO表">分析表1-状态转移表 (GOTO表)<a class="anchor" href="#分析表1-状态转移表-GOTO表">·</a></h5><p>一个矩阵： 行—分析器的状态 列—文法符号</p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1227.png" style="zoom:80%;"><h5 id="分析表2-分析动作表-ACTION表">分析表2-分析动作表(ACTION表)<a class="anchor" href="#分析表2-分析动作表-ACTION表">·</a></h5><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1229.png" style="zoom:80%;"><p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1230.png" style="zoom: 67%;"><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1231.png" alt="1231" style="zoom:67%;"></p><h5 id="控制程序">控制程序<a class="anchor" href="#控制程序">·</a></h5><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1232.png" style="zoom: 80%;"><h4 id="LR分析过程例子">LR分析过程例子<a class="anchor" href="#LR分析过程例子">·</a></h4> <img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1233.png" style="zoom: 67%;"><p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1234.png" style="zoom: 67%;"><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1235.png" style="zoom:67%;"></p><p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1236.png" alt="1236" style="zoom: 60%;"><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1237.png" alt="1237" style="zoom:67%;"></p><h4 id="构造SLR分析表">构造SLR分析表<a class="anchor" href="#构造SLR分析表">·</a></h4><ul><li>根据文法构造识别规范句型活前缀的<strong>有穷自动机DFA</strong></li><li>由<strong>DFA</strong>构造<strong>分析表</strong></li></ul><h5 id="求LR-0">求LR(0)<a class="anchor" href="#求LR-0">·</a></h5><ol><li><p>列出项目集</p></li><li><p>求出闭包</p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1242.png" style="zoom:80%;"></li><li><p>从初始状态<code>S'--&gt;.S</code>的闭包开始计算得到DFA</p></li></ol><h5 id="得到GOTO表和ACTION表">得到GOTO表和ACTION表<a class="anchor" href="#得到GOTO表和ACTION表">·</a></h5><p>GOTO表就是DFA</p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1243.png" style="zoom:80%;"><p>ACTION根据以下算法求解</p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1238.png" style="zoom:67%;"><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1239.png" alt="1239" style="zoom:67%;"><h2 id="作业-11">作业<a class="anchor" href="#作业-11">·</a></h2><p>p264:1,2,6，补充题</p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1240.png" style="zoom: 67%;"><p>P279 2(2)，4, 5</p><p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1241.png" alt></p><p>P282</p><p>P288</p><p>P297 1，2，6, 9</p><p>P304 1</p><h1 id="十四、代码优化">十四、代码优化<a class="anchor" href="#十四、代码优化">·</a></h1><h2 id="14-0-概述">14.0 概述<a class="anchor" href="#14-0-概述">·</a></h2><p>进行优化必须严格遵循“<strong>不能改变原有程序语义</strong>”原则。</p><p>循环：程序中的8-2原则</p><h3 id="优化方法分类1">优化方法分类1<a class="anchor" href="#优化方法分类1">·</a></h3><h4 id="与机器无关的优化技术">与机器无关的优化技术<a class="anchor" href="#与机器无关的优化技术">·</a></h4><p>数据流分析 ，常量传播，公共子表达式删除，死代码删除，循环交换，代码内联等等</p><h4 id="与机器相关的优化技术">与机器相关的优化技术<a class="anchor" href="#与机器相关的优化技术">·</a></h4><p><strong>面向</strong>超标量超流水线<strong>架构</strong>、VLIW或者EPIC架构的指令调度方法；面向SMP架构的同步负载优化方法；面向SIMD、 MIMD或者SPMD架构的数据级并行优化方法等</p><p>特点：仅在<strong>特定体系结构</strong>下有效</p><h3 id="优化方法分类2">优化方法分类2<a class="anchor" href="#优化方法分类2">·</a></h3><h4 id="局部优化技术">局部优化技术<a class="anchor" href="#局部优化技术">·</a></h4><p>指在<strong>基本块内</strong>进行的优化</p><p>例如，局部公共子表达式删除</p><h4 id="全局优化技术">全局优化技术<a class="anchor" href="#全局优化技术">·</a></h4><p><strong>函数/过程内</strong>进行的优化</p><p>跨越基本块</p><p>例如，全局数据流分析</p><h4 id="跨函数优化技术">跨函数优化技术<a class="anchor" href="#跨函数优化技术">·</a></h4><p>整个程序</p><p>例如，跨函数别名分析 ，逃逸分析等</p><h2 id="14-1-基本块与流图">14.1 基本块与流图<a class="anchor" href="#14-1-基本块与流图">·</a></h2><h3 id="基本块">基本块<a class="anchor" href="#基本块">·</a></h3><p>基本块中代码是连续的语句序列</p><p>程序的执行只能从基本块第一条语句进入</p><p>程序执行只能从基本块最后一条语句离开</p><h4 id="算法14-1-划分基本块">算法14.1 划分基本块<a class="anchor" href="#算法14-1-划分基本块">·</a></h4><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/141.png" style="zoom:50%;"><h4 id="流图">流图<a class="anchor" href="#流图">·</a></h4><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/142.png" style="zoom:50%;"><p>一般，编译器按照以下结构来组织代码，注意这里的<strong>程序</strong>在C语言里其实就是<strong>函数</strong></p><pre class="mermaid">graph LR程序-->流图流图-->基本块基本块-->中间代码</pre><h2 id="14-2-基本块内优化">14.2 基本块内优化<a class="anchor" href="#14-2-基本块内优化">·</a></h2><p>常数合并与传播</p><p>运算强度削减（乘除优化）</p><p>删除冗余代码（死代码，无用代码）</p><h3 id="消除公共子表达式">消除公共子表达式<a class="anchor" href="#消除公共子表达式">·</a></h3><h4 id="基本块的DAG图表示">基本块的DAG图表示<a class="anchor" href="#基本块的DAG图表示">·</a></h4><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/143.png" style="zoom:50%;"><h4 id="DAG图的定义">DAG图的定义<a class="anchor" href="#DAG图的定义">·</a></h4><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/144.png" style="zoom:50%;"><h4 id="算法14-2-构建DAG图的算法-消除公共子表达式">算法14.2 构建DAG图的算法-消除公共子表达式<a class="anchor" href="#算法14-2-构建DAG图的算法-消除公共子表达式">·</a></h4><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/145.png" style="zoom: 50%;"><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/146.png" style="zoom:50%;"><h4 id="算法14-3-从DAG导出中间代码的启发式算法">算法14.3 从DAG导出中间代码的启发式算法<a class="anchor" href="#算法14-3-从DAG导出中间代码的启发式算法">·</a></h4><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/147.png" style="zoom:50%;"><h3 id="窥孔优化">窥孔优化<a class="anchor" href="#窥孔优化">·</a></h3><p>关注在目标指令的一个较短的序列上，删除冗余代码，或者用更高效代码替代</p><h2 id="14-3-全局优化">14.3 全局优化<a class="anchor" href="#14-3-全局优化">·</a></h2><p>受到控制流影响</p><p>消除死代码，变量活性</p><p>主要手段：<strong>数据流分析</strong></p><h3 id="到达定义（reaching-definition）分析">到达定义（reaching definition）分析<a class="anchor" href="#到达定义（reaching-definition）分析">·</a></h3><h4 id="基本块B的到达定义数据流方程">基本块B的到达定义数据流方程<a class="anchor" href="#基本块B的到达定义数据流方程">·</a></h4><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/148.png" style="zoom:50%;"><h4 id="算法">算法<a class="anchor" href="#算法">·</a></h4><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/149.png" style="zoom:50%;"><h3 id="活跃变量分析">活跃变量分析<a class="anchor" href="#活跃变量分析">·</a></h3><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1410.png" style="zoom:50%;"><h4 id="算法-2">算法<a class="anchor" href="#算法-2">·</a></h4><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1411.png" style="zoom:50%;"><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1412.png" style="zoom:50%;"><p>活跃变量分析——死代码删除、寄存器分配</p><p>到达定义分析——变量传播</p><h3 id="定义-使用链、网和冲突图">定义-使用链、网和冲突图<a class="anchor" href="#定义-使用链、网和冲突图">·</a></h3><p>活跃变量到冲突图</p><p>变量的<strong>定义-使用链</strong>，是指变量的<strong>某一定义点</strong>，以及所有可能使用该定义点所定义变量值的使用点所组成的一个链</p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1413.png" style="zoom:50%;"><h2 id="14-4-循环优化">14.4 循环优化<a class="anchor" href="#14-4-循环优化">·</a></h2><h3 id="循环不变式的代码外提">循环不变式的代码外提<a class="anchor" href="#循环不变式的代码外提">·</a></h3><p>循环中不随循环改变的表达式</p><h3 id="循环展开">循环展开<a class="anchor" href="#循环展开">·</a></h3><p>代码重复很多次，省去了条件判断和分支语句还有部分的自增语句</p><h3 id="归纳变量的优化和条件判断的替换">归纳变量的优化和条件判断的替换<a class="anchor" href="#归纳变量的优化和条件判断的替换">·</a></h3><p>归纳变量: 在<strong>每一次执行循环迭代</strong>的过程中，若某变量的值<strong>固定增加（或减少）一个常量值</strong>，则称该变量为<strong>归纳变量</strong>(induction variable)。</p><p>可以利用归纳变量对一些表达式做优化</p><h3 id="inline展开">inline展开<a class="anchor" href="#inline展开">·</a></h3><p>某些函数可以内联形式展开</p><h3 id="其他">其他<a class="anchor" href="#其他">·</a></h3><p>多重循环转单层 多个相同结构循环合并</p><h2 id="作业-12">作业<a class="anchor" href="#作业-12">·</a></h2><p>1到6题</p><h1 id="十五、目标代码生成">十五、目标代码生成<a class="anchor" href="#十五、目标代码生成">·</a></h1><h2 id="15-1-现代微处理器体系结构简介">15.1 现代微处理器体系结构简介<a class="anchor" href="#15-1-现代微处理器体系结构简介">·</a></h2><h3 id="1、栈式指令集架构">1、栈式指令集架构<a class="anchor" href="#1、栈式指令集架构">·</a></h3><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/151.png" style="zoom:50%;"><h3 id="2、累加器式指令集架构">2、累加器式指令集架构<a class="anchor" href="#2、累加器式指令集架构">·</a></h3><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/152.png" style="zoom:50%;"><h3 id="3、寄存器架构">3、寄存器架构<a class="anchor" href="#3、寄存器架构">·</a></h3><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/153.png" style="zoom:50%;"><h4 id="寄存器-寄存器架构">寄存器-寄存器架构<a class="anchor" href="#寄存器-寄存器架构">·</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">load $1 A</span><br><span class="line">load $2 B</span><br><span class="line">add $1 $2 $1</span><br><span class="line">store $1 C</span><br></pre></td></tr></table></figure><h4 id="寄存器-内存架构">寄存器-内存架构<a class="anchor" href="#寄存器-内存架构">·</a></h4><p>即地址可以作为操作数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">load $1 A</span><br><span class="line">add $2 $1 B</span><br><span class="line">store $2 C</span><br></pre></td></tr></table></figure><h2 id="12-2-地址空间">12.2 地址空间<a class="anchor" href="#12-2-地址空间">·</a></h2><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/154.png" style="zoom:50%;"><h2 id="12-4-寄存器的分配和指派作业">12.4 寄存器的分配和指派作业<a class="anchor" href="#12-4-寄存器的分配和指派作业">·</a></h2><h3 id="引用计数">引用计数<a class="anchor" href="#引用计数">·</a></h3><p>给引用次数排序，前面的分配</p><h3 id="图着色寄存器分配">图着色寄存器分配<a class="anchor" href="#图着色寄存器分配">·</a></h3><p>先利用活跃变量分析，每个基本块入口处活跃变量之间定义相互冲突</p><p>建立冲突图之后，使用<strong>Chaitin-Briggs算法</strong>进行图着色寄存器分配。</p><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/155.png" style="zoom:50%;"><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/156.png" alt="156" style="zoom:50%;"><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/157.png" alt="157" style="zoom:50%;"><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/158.png" alt="158" style="zoom:50%;"><img src="/2022/09/19/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/159.png" alt="159" style="zoom:50%;"><p>新编教材第十五章 1,4,5,6</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-Compiler-2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成理论复习</title>
      <link href="2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/"/>
      <url>2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="理论课学习——刘旭东老师">理论课学习——刘旭东老师<a class="anchor" href="#理论课学习——刘旭东老师">·</a></h1><h2 id="第一讲：概述">第一讲：概述<a class="anchor" href="#第一讲：概述">·</a></h2><h3 id="一-计算机组成与结构简介">一.计算机组成与结构简介<a class="anchor" href="#一-计算机组成与结构简介">·</a></h3><h4 id="1-1-计算机的基本组成">1.1 计算机的基本组成<a class="anchor" href="#1-1-计算机的基本组成">·</a></h4><ol><li>硬件（Hardware）计算机的物理部分，可以实现计算机最基本的操作行为。</li><li>软件（Software）使计算机实现各种功能的程序集合。包括系统软件、应用软件两大类。</li></ol><h5 id="计算机的功能">计算机的功能<a class="anchor" href="#计算机的功能">·</a></h5><ul><li>Data Processing (数据处理)</li><li>Data Storage （数据存储）</li><li>Data Movement （数据移动，交换）</li><li>Control （控制）</li><li>计算机的功能结构图</li></ul><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/计算机体系结构图.png" style="zoom:50%;"><h5 id="运算器：实现数据处理的部件">运算器：实现数据处理的部件<a class="anchor" href="#运算器：实现数据处理的部件">·</a></h5><ul><li>完成最基本的算术逻辑运算</li><li>ALU (Arithmetic and Logic Unit） ＋ Registers</li><li><strong>运算器与机器字长（字的概念）的关系(电脑操作系统的位数)</strong></li><li>运算器与机器性能指标：MIPS：Millions of Instructuions Per Second</li><li>简单运算器结构图</li></ul><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/简单运算器结构图.png" style="zoom:50%;"><h5 id="存储器：实现数据存储的部件">存储器：实现数据存储的部件<a class="anchor" href="#存储器：实现数据存储的部件">·</a></h5><ol><li>保存程序和数据（二进制信息）</li><li><strong>存储单元：bit, Byte, Word</strong></li></ol><p>1Byte(字节 <strong>B</strong>)=8bit(位 <strong>b</strong>)</p><p>1word(字)=本电脑操作系统的位数</p><p>$1KB=2<sup>{10}B=2</sup>{10+3}bit$</p><ol start="3"><li><p>地址的概念：每一个字节单元拥有一个<strong>唯一的地址</strong>（索引）</p></li><li><p>存储器的工作方式：读、写</p></li><li><p>存储器结构简图</p></li></ol><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/存储器结构简图.png" style="zoom:50%;"><h5 id="控制器：实现控制功能的部件">控制器：实现控制功能的部件<a class="anchor" href="#控制器：实现控制功能的部件">·</a></h5><ul><li>供各部件工作所需的控制信号，控制计算机其他部件协同工作</li><li>指令部件（Instruction Register ，Instruction Decoder）</li><li>指令顺序控制（Program Counter）</li><li>时序逻辑部件（Clock，Timer ，Sequencing Logic）</li><li>控制信号生成部件（Control Signal Generator or Control Memory）</li><li>Datapath ＋Control ＝CPU（Central Process Unit）or Processor</li><li>控制器结构简图</li></ul><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/控制器结构简图.png" style="zoom:50%;"><h5 id="输入输出：实现数据交换的部件">输入输出：实现数据交换的部件<a class="anchor" href="#输入输出：实现数据交换的部件">·</a></h5><ul><li>实现计算机内部与外界（其他系统或人类）的信息交换</li><li>实现数据交换的设备：输入设备、输出设备</li><li>接口标准与接口部件</li><li>计算机结构简图</li></ul><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/计算机结构简图.png" style="zoom:67%;"><h5 id="冯·诺依曼体系——IAS——该机结构被公认为随后发展起来的通用计算机的原型">冯·诺依曼体系——IAS——该机结构被公认为随后发展起来的通用计算机的原型<a class="anchor" href="#冯·诺依曼体系——IAS——该机结构被公认为随后发展起来的通用计算机的原型">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/IAS.png" style="zoom:50%;"><h5 id="普通PC（Pentium）的内部结构（多总线结构）">普通PC（Pentium）的内部结构（多总线结构）<a class="anchor" href="#普通PC（Pentium）的内部结构（多总线结构）">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/普通PC（Pentium）的内部结构（多总线结构）.png" style="zoom:50%;"><h4 id="1-2-计算机系统层次结构">1.2 计算机系统层次结构<a class="anchor" href="#1-2-计算机系统层次结构">·</a></h4><h5 id="计算机的层次结构的演变">计算机的层次结构的演变<a class="anchor" href="#计算机的层次结构的演变">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/计算机的层次结构的演变.png" style="zoom:50%;"><p><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1.png" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.png" style="zoom:50%;"></p><h5 id="ISA">ISA<a class="anchor" href="#ISA">·</a></h5><p>指令集体系架构，一种规约（Specification），规定了软件如何使用硬件，是对硬件结构和功能的最底层抽象，解决了最基本的软件兼容性问题。每一种广泛采用的指令集背后都有一个强大的生态系统，比如<strong>X86指令集架构</strong>和<strong>ARM指令集架构</strong>。</p><h3 id="二-计算机中数的表示的基本问题">二.计算机中数的表示的基本问题<a class="anchor" href="#二-计算机中数的表示的基本问题">·</a></h3><h4 id="无符号数和有符号数">无符号数和有符号数<a class="anchor" href="#无符号数和有符号数">·</a></h4><h5 id="无符号数">无符号数<a class="anchor" href="#无符号数">·</a></h5><ul><li>数的编码中所有位均为数值位，<strong>没有符号位</strong></li><li>只能表示 &gt;=0 的正整数</li><li>N位无符号数的表示范围： $0-2^{n-1}$</li><li>一般在全部是正数运算且不出现负值结果的场合下，可使用无符号数表示，例如<strong>地址运算</strong>。</li></ul><h5 id="有符号数">有符号数<a class="anchor" href="#有符号数">·</a></h5><h6 id="机器数表示">机器数表示<a class="anchor" href="#机器数表示">·</a></h6><ul><li><p>数的正负问题：设符号位，<strong>“0”表示“正”，“1”表示“负”</strong>，固定为编码的最高位</p></li><li><p>真值0怎么办：正零，负零</p></li><li><p>小数点怎么办：隐含，<strong>小数点位置固定</strong> （即<strong>定点数</strong>）</p><ul><li><p>定点小数：小数点在最高位数值位前，绝对值小于1</p></li><li><p>定点整数：小数点在最低位数值位后，没有小数部分</p></li></ul></li><li><p>带有整数和小数部分的数怎么办：<strong>浮点数</strong>，按<strong>2为基</strong>的<strong>科学表示方法</strong>表示</p></li></ul><h4 id="定点数、浮点数表示">定点数、浮点数表示<a class="anchor" href="#定点数、浮点数表示">·</a></h4><h5 id="定点数表示">定点数表示<a class="anchor" href="#定点数表示">·</a></h5><h6 id="机器数表示及其表示范围">机器数表示及其表示范围<a class="anchor" href="#机器数表示及其表示范围">·</a></h6><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/机器数表示范围.png" style="zoom:50%;"><h6 id="原码">原码<a class="anchor" href="#原码">·</a></h6><ul><li>容易理解</li><li>“0”的表示不唯一，不利于程序员编程</li><li>机器实现加、减运算的方法不统一，需对符号位进行单独处理，不利于硬件设计</li></ul><h6 id="反码——较少使用">反码——较少使用<a class="anchor" href="#反码——较少使用">·</a></h6><h6 id="补码">补码<a class="anchor" href="#补码">·</a></h6><ul><li>“0”的表示唯一</li><li>机器实现加、减运算的方法统一（模运算）</li><li>符号位参加运算，不需要单独处理</li></ul><h6 id="模运算">模运算<a class="anchor" href="#模运算">·</a></h6><ol><li><strong>模</strong>：指一个计数系统<strong>所能表示的数据个数</strong>。有模运算是指运算结果超过模时，模（或模的整数倍）将溢出而只剩下余数。8位二进制的模为$2^8=256$</li><li>假设M为模，若数a，b满足<strong>a + b = M</strong>，则称a，b<strong>互为补数</strong>。</li><li>在有模运算中，<strong>减去一个数</strong>等于<strong>加上这个数对模的补数</strong>。</li></ol><h5 id="浮点数表示">浮点数表示<a class="anchor" href="#浮点数表示">·</a></h5><h6 id="浮点数的一般表示法">浮点数的一般表示法<a class="anchor" href="#浮点数的一般表示法">·</a></h6><p>分为<strong>阶码和尾数</strong>两个部分<strong>阶码</strong>：采用<strong>定点整数</strong>表示<strong>尾数</strong>：采用<strong>定点小数</strong>表示</p><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/阶符数符.png" style="zoom:50%;"><h6 id="IEEE-754标准">IEEE 754标准<a class="anchor" href="#IEEE-754标准">·</a></h6><p>分为符号（<strong>S</strong>ign）、阶码（<strong>E</strong>xponent）和尾数（<strong>M</strong>antissa）。</p><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.3.1.png" style="zoom:50%;"><ul><li><strong>数符 S</strong>： 1位，0表示正数，1表示负数</li><li><strong>阶码 E</strong>：移码表示，n 位阶码偏移量为 $2^{n-1}-1$。如<strong>8位阶码偏移量</strong>为 7FH（ 即<strong>127</strong>），<strong>11位阶码偏移量</strong>3FFH（即<strong>1023</strong>）</li><li><strong>尾数 M</strong>： 原码表示，尾数必须<strong>规格化成小数点左侧一定为1</strong>，并且小数点前面这个1作为隐含位被省略。这样<strong>单精度浮点数尾数实际上为24位。</strong></li><li><strong>规格化数（尾数）形式</strong>：M=<strong>1.m</strong></li></ul><h6 id="浮点数精度">浮点数精度<a class="anchor" href="#浮点数精度">·</a></h6><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.3.2.png" style="zoom:50%;"><h6 id="IEEE-754关于浮点数表示的约定（单精度为例）">IEEE 754关于浮点数表示的约定（单精度为例）<a class="anchor" href="#IEEE-754关于浮点数表示的约定（单精度为例）">·</a></h6><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.3.3.png" style="zoom: 50%;"><h6 id="单精度浮点数表示范围">单精度浮点数表示范围<a class="anchor" href="#单精度浮点数表示范围">·</a></h6><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.3.4.png" style="zoom:50%;"><h4 id="非数值数据的表示">非数值数据的表示<a class="anchor" href="#非数值数据的表示">·</a></h4><h3 id="三．-计算机的基本工作过程">三． 计算机的基本工作过程<a class="anchor" href="#三．-计算机的基本工作过程">·</a></h3><h4 id="指令的含义">指令的含义<a class="anchor" href="#指令的含义">·</a></h4><p><strong>机器指令</strong>：计算机硬件可以执行的表示一种基本操作的<strong>二进制代码</strong>。</p><p><strong>指令格式</strong>：操作码 ＋ 操作数（操作数地址）操作码：指明指令的操作性质操作数（地址）：指令操作数的位置（或操作数本身）</p><p><strong>程序</strong>：在此特指一段<strong>机器指令序列</strong>。</p><p>完成一定的功能，采用某种算法，具备一定的流程；计算机按照程序所规定的流程和指令顺序，一条一条地执行指令，达到完成程序所规定的功能的目的。计算机采用**程序计算器（Program Counter）**来决定指令执行的顺序。</p><h4 id="程序的执行">程序的执行<a class="anchor" href="#程序的执行">·</a></h4><h2 id="第二讲：组合逻辑">第二讲：组合逻辑<a class="anchor" href="#第二讲：组合逻辑">·</a></h2><h3 id="一．-逻辑代数基础">一． 逻辑代数基础<a class="anchor" href="#一．-逻辑代数基础">·</a></h3><h4 id="1-逻辑代数的基本概念">1.逻辑代数的基本概念<a class="anchor" href="#1-逻辑代数的基本概念">·</a></h4><p><strong>逻辑代数</strong>:逻辑代数L是一个封闭的代数系统，它由一个<strong>逻辑变量集K</strong>，常量0和1以及“或”、“与”、“非”三种基本运算所构成，记为 <strong>L={ K,∨,∧,￢,0 ,1 }</strong>。</p><p><strong>“或”运算</strong>：$a\bigwedge b=ab$</p><p><strong>“与”运算</strong>：$a\bigvee b=ab+\overline{a}b+a\overline{b}$</p><p><strong>“异或”运算</strong>：$a\bigoplus b= \overline{a}b+a\overline{b}$</p><p><strong>“同或”运算</strong>：$a⊙b=\overline{a}\overline{b}+ab$</p><h5 id="逻辑运算顺序">逻辑运算顺序<a class="anchor" href="#逻辑运算顺序">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.1逻辑运算顺序.png" style="zoom:50%;"><h5 id="逻辑电路符号表示">逻辑电路符号表示<a class="anchor" href="#逻辑电路符号表示">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.2.png" style="zoom:50%;"><h4 id="2-逻辑代数的公理、定理与规则">2.逻辑代数的公理、定理与规则<a class="anchor" href="#2-逻辑代数的公理、定理与规则">·</a></h4><h5 id="2-1逻辑代数的基本公理">2.1逻辑代数的基本公理<a class="anchor" href="#2-1逻辑代数的基本公理">·</a></h5><ol><li><p>交换律：𝑨 + 𝑩 = 𝑩 + 𝑨, 𝑨 ∙ 𝑩 = 𝑩 ∙ 𝑨</p></li><li><p>结合律： 𝑨 + 𝑩 + 𝑪 = 𝑨 + 𝑩 + 𝑪</p></li></ol><p>(𝑨 ∙ 𝑩) ∙ 𝑪 = 𝑨 ∙ (𝑩 ∙ 𝑪)</p><ol start="3"><li><strong>分配律</strong>：𝐀 ∙ (𝑩 + 𝑪) = 𝑨 ∙ 𝑩 + 𝑨 ∙ 𝑪</li></ol><p><strong>𝑨 + 𝑩 ∙ 𝑪 = (𝑨 + 𝑩) ∙ (𝑨 + 𝑪)</strong></p><ol start="4"><li>0-1律 ：</li></ol><p>𝑨 + 𝟎 = 𝑨, 𝑨 ∙ 𝟏 = 𝑨</p><p>𝐀 + 𝟏 = 𝟏, 𝐀 ∙ 𝟎 = 𝟎</p><ol start="5"><li>互补律</li></ol><p>$A+\overline{A}=1$</p><p>$A\overline{A}=0$</p><h5 id="2-2逻辑代数的基本定理">2.2逻辑代数的基本定理<a class="anchor" href="#2-2逻辑代数的基本定理">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.3.png" style="zoom:50%;"><p>另一种吸收律：$A+\overline A B=A+B$</p><p>包含律第五点推广</p><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.4.png" style="zoom:50%;"><h5 id="2-3逻辑代数的规则">2.3逻辑代数的规则<a class="anchor" href="#2-3逻辑代数的规则">·</a></h5><h6 id="代入规则">代入规则<a class="anchor" href="#代入规则">·</a></h6><h6 id="反演规则">反演规则<a class="anchor" href="#反演规则">·</a></h6><p>将原函数F中的全部 <strong>“•” 换成 “+”，“+” 换成 “•” ，“0” 换 成 “1”，“1” 换成 “0”，原变量换成反变量，反变量换成原变量</strong>，所得到的新函数就是<strong>原函数的反函数</strong>，记作 $\overline{F}$ 。----<strong>用途</strong>：直接求已知逻辑函数的反函数，可用于公式的化简</p><h6 id="对偶规则">对偶规则<a class="anchor" href="#对偶规则">·</a></h6><p>将原函数F中的<strong>全部 “•” 换成 “+”，“+” 换成 “•”，“0”换成 “1”，“1” 换成 “0”</strong>，所得的新函数就是<strong>原函数的对偶式</strong>，<strong>记作F’或F</strong>* 。-----<strong>用途</strong>：已知<strong>某公式成立</strong>，则可以得到<strong>其对偶公式仍成立</strong>。若两个逻辑函数表达式F和G相等，则其对偶式F’和G’也相等</p><h4 id="3-逻辑函数的表达式">3.逻辑函数的表达式<a class="anchor" href="#3-逻辑函数的表达式">·</a></h4><h5 id="逻辑函数的常用表达式">逻辑函数的常用表达式<a class="anchor" href="#逻辑函数的常用表达式">·</a></h5><p>常用表达式包括：与或式、或与式、与或非式</p><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.5.png" style="zoom: 50%;"><h5 id="逻辑函数的标准表达式">逻辑函数的标准表达式<a class="anchor" href="#逻辑函数的标准表达式">·</a></h5><p>逻辑函数的标准表达式建立在<strong>最小项</strong>和<strong>最大项</strong>概念基础上（最小项可以巧记为<strong>占用字符数少</strong>比如:$AB$）</p><p>最小项表达式：全部由最小项构成的<strong>与或式</strong>（积之和式）</p><p>最大项表达式：全部由最大项构成的<strong>或与式</strong>（和之积式）</p><h5 id="最小项">最小项<a class="anchor" href="#最小项">·</a></h5><h6 id="编号">编号<a class="anchor" href="#编号">·</a></h6><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.6.png" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.8.png" style="zoom:50%;"><h5 id="最大项">最大项<a class="anchor" href="#最大项">·</a></h5><h6 id="编号-2">编号<a class="anchor" href="#编号-2">·</a></h6><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.7.png" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.9.png" style="zoom:50%;"><h4 id="4-逻辑函数化简（卡诺图）">4.逻辑函数化简（卡诺图）<a class="anchor" href="#4-逻辑函数化简（卡诺图）">·</a></h4><h5 id="设计优化">设计优化<a class="anchor" href="#设计优化">·</a></h5><ul><li>面积优化——使设计的电路或系统占用的逻辑资源尽量少</li><li>时间优化——使设计的电路或系统的输入信号到达输出的路程尽量短</li></ul><h5 id="逻辑函数化简—代数法">逻辑函数化简—代数法<a class="anchor" href="#逻辑函数化简—代数法">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.10.png" style="zoom: 67%;"><h5 id="卡诺图化简基本规则">卡诺图化简基本规则<a class="anchor" href="#卡诺图化简基本规则">·</a></h5><ul><li>2个相邻项合并为一项，消去1个取值不同的变量</li><li>4个相邻项合并为一项，消去2个取值不同的变量</li><li>8个相邻项合并为一项，消去3个取值不同的变量</li></ul><h3 id="二．-逻辑门电路">二． 逻辑门电路<a class="anchor" href="#二．-逻辑门电路">·</a></h3><h4 id="1-晶体管和MOS管">1.晶体管和MOS管<a class="anchor" href="#1-晶体管和MOS管">·</a></h4><h5 id="二极管">二极管<a class="anchor" href="#二极管">·</a></h5><p>PN结单向导通</p><h5 id="三极管（NPN常用）">三极管（NPN常用）<a class="anchor" href="#三极管（NPN常用）">·</a></h5><p>NPN型：集电极加&gt;0.7V的电压，发射结和集电极就导通，否则就截止</p><p>PNP型：与上面相反</p><h5 id="MOS管（NMOS常用）">MOS管（NMOS常用）<a class="anchor" href="#MOS管（NMOS常用）">·</a></h5><h6 id="NMOS">NMOS<a class="anchor" href="#NMOS">·</a></h6><p>类似NPN型三极管</p><h6 id="PMOS">PMOS<a class="anchor" href="#PMOS">·</a></h6><p>类似PNP型三极管</p><h6 id="CMOS——NMOS和PMOS的集合">CMOS——NMOS和PMOS的集合<a class="anchor" href="#CMOS——NMOS和PMOS的集合">·</a></h6><h5 id="晶体管与MOS管开关特性">晶体管与MOS管开关特性<a class="anchor" href="#晶体管与MOS管开关特性">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.11.png" style="zoom:50%;"><h4 id="2-逻辑门电路实现">2.逻辑门电路实现<a class="anchor" href="#2-逻辑门电路实现">·</a></h4><h5 id="1-门电路">1.门电路<a class="anchor" href="#1-门电路">·</a></h5><h6 id="与门——二极管实现">与门——二极管实现<a class="anchor" href="#与门——二极管实现">·</a></h6><h6 id="或门——二极管实现">或门——二极管实现<a class="anchor" href="#或门——二极管实现">·</a></h6><h6 id="非门——三极管实现-CMOS实现">非门——三极管实现/CMOS实现<a class="anchor" href="#非门——三极管实现-CMOS实现">·</a></h6><h6 id="或非门电路——CMOS实现">或非门电路——CMOS实现<a class="anchor" href="#或非门电路——CMOS实现">·</a></h6><h6 id="与非门电路——CMOS实现">与非门电路——CMOS实现<a class="anchor" href="#与非门电路——CMOS实现">·</a></h6><h5 id="2-各种集成门电路性能比较">2.各种集成门电路性能比较<a class="anchor" href="#2-各种集成门电路性能比较">·</a></h5><p><strong>CMOS</strong>和<strong>TTL</strong>是两个常用集成电路。</p><ul><li>CMOS<strong>功耗相对低、抗干扰能力相对强、带载能力相对强</strong>。</li><li>TTL<strong>功耗相对高，速度相对快、抗干扰能力相对弱</strong>。</li><li>与TTL门电路相比，传统的CMOS门电路特点是集成度高、功耗低，但工作速度较慢、抗静电能力差。不过目前新型的CMOS门电路工作速度已经有了很大提高、抗静电能力也大为改善，基本能够与TTL门电路相媲了。</li><li>CMOS门电路获得了更为广泛的应用，尤其在<strong>大规模集成电路</strong>和<strong>微处理器</strong>中已占据了重要地位。</li></ul><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.12.png" style="zoom:50%;"><h3 id="三．-基本组合逻辑部件设计">三． 基本组合逻辑部件设计<a class="anchor" href="#三．-基本组合逻辑部件设计">·</a></h3><h4 id="组合逻辑设计概述">组合逻辑设计概述<a class="anchor" href="#组合逻辑设计概述">·</a></h4><p>数字电路分类：<strong>组合逻辑电路</strong>和<strong>时序逻辑电路</strong></p><h5 id="组合逻辑电路的设计方法">组合逻辑电路的设计方法<a class="anchor" href="#组合逻辑电路的设计方法">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.13.png" style="zoom:50%;"><h4 id="运算单元电路">运算单元电路<a class="anchor" href="#运算单元电路">·</a></h4><h5 id="1-加法运算电路">1.加法运算电路<a class="anchor" href="#1-加法运算电路">·</a></h5><p>半加器（<strong>不考虑来自低位的进位</strong>） 全加器（<strong>考虑来自低位的进位</strong>）</p><h5 id="2-全加器">2.全加器<a class="anchor" href="#2-全加器">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.14.png" style="zoom:50%;"><h5 id="3-Verilog模块结构">3.Verilog模块结构<a class="anchor" href="#3-Verilog模块结构">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.15.png" style="zoom:50%;"><h5 id="4-全加器的Verilog-HDL">4.全加器的Verilog HDL<a class="anchor" href="#4-全加器的Verilog-HDL">·</a></h5><h6 id="方法一：根据逻辑表达式，用assign语句建模（算法级描述）">方法一：根据逻辑表达式，用assign语句建模（算法级描述）<a class="anchor" href="#方法一：根据逻辑表达式，用assign语句建模（算法级描述）">·</a></h6><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1位全加器Verilog HDL源程序</span></span><br><span class="line"><span class="keyword">module</span> adder_1(A,B,CI,SO,CO);</span><br><span class="line"><span class="keyword">input</span> A,B,CI;</span><br><span class="line"><span class="keyword">output</span> SO,CO;</span><br><span class="line"><span class="keyword">assign</span> SO = (!A&amp;&amp;!B&amp;&amp;CI)||(!A&amp;&amp;B&amp;&amp;!CI)||</span><br><span class="line">(A&amp;&amp;!B&amp;&amp;!CI)||(A&amp;&amp;B&amp;&amp;CI);</span><br><span class="line">    <span class="keyword">assign</span> CO = (!A&amp;&amp;B&amp;&amp;CI)||(A&amp;&amp;!B&amp;&amp;CI)||</span><br><span class="line">    (A&amp;&amp;B&amp;&amp;!CI)||(A&amp;&amp;B&amp;&amp;CI); <span class="comment">//assign 语句描述组合逻辑</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h6 id="方法二：根据逻辑功能定义直接描述，采用行为描述方式的系统级抽象，程序更简洁">方法二：根据逻辑功能定义直接描述，采用行为描述方式的系统级抽象，程序更简洁<a class="anchor" href="#方法二：根据逻辑功能定义直接描述，采用行为描述方式的系统级抽象，程序更简洁">·</a></h6><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> adder_2(A,B,CI,SO,CO);</span><br><span class="line"><span class="keyword">input</span> A,B,CI;</span><br><span class="line"><span class="keyword">output</span> SO,CO;</span><br><span class="line"><span class="keyword">assign</span> &#123;CO,SO&#125; = A+B+CI;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"><span class="comment">//这里用位拼接运算符 “&#123; &#125;”将进位与算术和拼接在一起成为一个2位数</span></span><br></pre></td></tr></table></figure><h5 id="5-加法运算电路—多位加法器">5.加法运算电路—多位加法器<a class="anchor" href="#5-加法运算电路—多位加法器">·</a></h5><h6 id="并行加法器—串行进位">并行加法器—串行进位<a class="anchor" href="#并行加法器—串行进位">·</a></h6><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.17.png" style="zoom:50%;"><h6 id="并行加法器—并行进位（或先行进位）">并行加法器—并行进位（或先行进位）<a class="anchor" href="#并行加法器—并行进位（或先行进位）">·</a></h6><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.18.png" style="zoom:50%;"><h5 id="6-8位加法器的Verilog-HDL">6.8位加法器的Verilog HDL<a class="anchor" href="#6-8位加法器的Verilog-HDL">·</a></h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> adder_8(a,b,cin,sum,cout);</span><br><span class="line">    <span class="keyword">parameter</span> width=<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">input</span> [width-<span class="number">1</span>:<span class="number">0</span>] a,b;</span><br><span class="line">    <span class="keyword">input</span> cin;</span><br><span class="line">    <span class="keyword">output</span> [width-<span class="number">1</span>:<span class="number">0</span>] sum;</span><br><span class="line">    <span class="keyword">output</span> cout;</span><br><span class="line">    <span class="keyword">assign</span> &#123;cout,sum&#125; = a+b+cin;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"><span class="comment">//用parameter常量width表示加法器的位数，通过修改width，可以方便地实现不同位宽的加法器。</span></span><br></pre></td></tr></table></figure><h5 id="7-加法运算电路—减法运算">7.加法运算电路—减法运算<a class="anchor" href="#7-加法运算电路—减法运算">·</a></h5><h6 id="运算原则">运算原则<a class="anchor" href="#运算原则">·</a></h6><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.19.png" style="zoom:50%;"><h6 id="溢出的判断">溢出的判断<a class="anchor" href="#溢出的判断">·</a></h6><p>采用双符号位，“00”表示正，“11”表示负，如果运算结果符号位出现“01”或“10”表示出现溢出。</p><h5 id="8-乘法运算电路：阵列乘法器">8.乘法运算电路：阵列乘法器<a class="anchor" href="#8-乘法运算电路：阵列乘法器">·</a></h5><p>原理类似十进制乘法</p><h5 id="9-4位比较器的Verilog-HDL设计">9.4位比较器的Verilog HDL设计<a class="anchor" href="#9-4位比较器的Verilog-HDL设计">·</a></h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> CT7485(A3, A2, A1, A0, B3, B2, B1, B0, ALBI, AEBI,</span><br><span class="line">              AGBI, ALBO, AEBO, AGBO);</span><br><span class="line">    <span class="keyword">input</span> A3, A2, A1, A0, B3, B2, B1, B0, ALBI, AEBI, AGBI;</span><br><span class="line">    <span class="keyword">output</span> ALBO, AEBO, AGBO;</span><br><span class="line">    <span class="keyword">reg</span> ALBO, AEBO, AGBO;</span><br><span class="line">    <span class="keyword">wire</span>[<span class="number">3</span>:<span class="number">0</span>] A_SIGNAL, B_SIGNAL;</span><br><span class="line">    <span class="keyword">assign</span> A_SIGNAL = &#123;A3,A2,A1,A0&#125;; <span class="comment">//拼接成4位wire型向量</span></span><br><span class="line">    <span class="keyword">assign</span> B_SIGNAL = &#123;B3,B2,B1,B0&#125;; <span class="comment">//拼接成4位wire型向量</span></span><br><span class="line">  <span class="keyword">always</span></span><br><span class="line">    <span class="keyword">begin</span> </span><br><span class="line">        <span class="keyword">if</span> (A_SIGNAL &gt; B_SIGNAL)</span><br><span class="line">            <span class="keyword">begin</span> ALBO = <span class="number">0</span>; AEBO = <span class="number">0</span>; AGBO = <span class="number">1</span>; <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A_SIGNAL &lt; B_SIGNAL)</span><br><span class="line">            <span class="keyword">begin</span> ALBO = <span class="number">1</span>; AEBO = <span class="number">0</span>; AGBO = <span class="number">0</span>; <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// if(A_SIGNAL == B_SIGNAL)可省略</span></span><br><span class="line">            <span class="keyword">begin</span> ALBO = ALBI; AEBO = AEBI; AGBO = AGBI; <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h5 id="10-ALU–1位ALU、32位ALU">10.ALU–1位ALU、32位ALU<a class="anchor" href="#10-ALU–1位ALU、32位ALU">·</a></h5><h4 id="编码器-译码器">编码器/译码器<a class="anchor" href="#编码器-译码器">·</a></h4><h4 id="多路选择器">多路选择器<a class="anchor" href="#多路选择器">·</a></h4><h4 id="组合逻辑电路的竞争冒险">组合逻辑电路的竞争冒险<a class="anchor" href="#组合逻辑电路的竞争冒险">·</a></h4><h2 id="第三讲：时序逻辑">第三讲：时序逻辑<a class="anchor" href="#第三讲：时序逻辑">·</a></h2><h3 id="概述">概述<a class="anchor" href="#概述">·</a></h3><h4 id="时序逻辑电路的特点">时序逻辑电路的特点<a class="anchor" href="#时序逻辑电路的特点">·</a></h4><ul><li>当前输出由当前输入与电路原来状态共同决定（具有记忆功能）</li><li>电路的状态与时间顺序有关</li><li>结构特点：由组合逻辑电路和存储电路构成</li></ul><h4 id="触发器-Flip-Flop，FF">触发器(Flip-Flop，FF)<a class="anchor" href="#触发器-Flip-Flop，FF">·</a></h4><p>一种有记忆功能的器件，是时序逻辑电路的基本器件。记忆电路特征：状态可预置（置0，置1），状态可保持</p><h4 id="双稳态触发器-两个稳定的状态">双稳态触发器(两个稳定的状态)<a class="anchor" href="#双稳态触发器-两个稳定的状态">·</a></h4><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.2.png" style="zoom:50%;"><h3 id="一．-锁存器和触发器">一． 锁存器和触发器<a class="anchor" href="#一．-锁存器和触发器">·</a></h3><h4 id="1-SR-D锁存器">1.SR/D锁存器<a class="anchor" href="#1-SR-D锁存器">·</a></h4><h5 id="1-1基本RS锁存器">1.1基本RS锁存器<a class="anchor" href="#1-1基本RS锁存器">·</a></h5><p>具有两个稳定状态，可自行保持输出状态，是各种触发器的基本构成。<strong>双稳态</strong></p><p><strong>原理</strong></p><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.png" style="zoom:50%;"><h6 id="真值表">真值表<a class="anchor" href="#真值表">·</a></h6><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.4.png" style="zoom:50%;"><h6 id="特性方程：锁存器次态与原态及输入之间的逻辑函数表达式">特性方程：锁存器次态与原态及输入之间的逻辑函数表达式<a class="anchor" href="#特性方程：锁存器次态与原态及输入之间的逻辑函数表达式">·</a></h6><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.5.png" style="zoom:50%;"><h5 id="Verilog-HDL描述-SR锁存器">Verilog HDL描述 SR锁存器<a class="anchor" href="#Verilog-HDL描述-SR锁存器">·</a></h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> RS_FF(Q,QN,SDN,RDN);</span><br><span class="line">    <span class="keyword">input</span> SDN,RDN;</span><br><span class="line">    <span class="keyword">output</span> Q,QN;</span><br><span class="line">    <span class="keyword">assign</span> Q = !(SDN &amp;&amp; QN);</span><br><span class="line">    <span class="keyword">assign</span> QN= !(RDN &amp;&amp; Q);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h5 id="1-2钟控RS锁存器">1.2钟控RS锁存器<a class="anchor" href="#1-2钟控RS锁存器">·</a></h5><h6 id="钟控锁存器">钟控锁存器<a class="anchor" href="#钟控锁存器">·</a></h6><ul><li>数字系统中，为协调各部分电路同步运行，常要求某些锁存器在<strong>时钟信号的控制下</strong>同时动作，需要增加一个<strong>控制端</strong>（时钟信号），只有在<strong>控制端作用脉冲到达时</strong>锁存器才能动作，这种有时钟控制端的锁存器叫做钟控锁存器。</li><li>由于这里时钟信号为高电位（或低电位）时锁存器的状态随输入变化，所以钟控锁存器是<strong>电位触发方式</strong>的锁存器。钟控锁存器在时钟控制下同步工作，所以也称为<strong>同步锁存器。</strong></li></ul><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.6.png" style="zoom:50%;"><h6 id="原理-3">原理<a class="anchor" href="#原理-3">·</a></h6><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.7.png" style="zoom: 50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.7.1.png" style="zoom:50%;"><h5 id="1-3-钟控D锁存器">1.3 钟控D锁存器<a class="anchor" href="#1-3-钟控D锁存器">·</a></h5><p>将钟控RS锁存器输入由R、S双端输入改为单端输入（D），即将其S端改为D输入端，D经过非门接R端（S、R总是互反）！</p><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.7.2.png" style="zoom:50%;"><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> D_FF_1(CP,D,Q,QN);</span><br><span class="line">    <span class="keyword">input</span> CP,D;</span><br><span class="line">    <span class="keyword">output</span> Q,QN;</span><br><span class="line">    <span class="keyword">reg</span> Q,QN;</span><br><span class="line">    <span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (CP == <span class="number">1</span>)<span class="keyword">begin</span> Q = D;QN = ~Q; <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span> Q = Q;QN = QN; <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h4 id="2-D触发器">2.D触发器<a class="anchor" href="#2-D触发器">·</a></h4><p>D触发器：两个反相的D锁存器构成。</p><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.8.1.png" style="zoom:50%;"><h5 id="D锁存器与D触发器的区别">D锁存器与D触发器的区别<a class="anchor" href="#D锁存器与D触发器的区别">·</a></h5><ul><li>D锁存器是电位（电平）触发的，只有在时钟CP有效电平（高电平CP=1或者低电平CP＝0）期间，触发器的状态才有可能发生变化。</li><li>D触发器的状态变化只发生在时钟CP的有效沿（上升沿或者下降沿）期间，CP＝1、CP=0时触发器的状态不会发生变化。</li></ul><h5 id="带使能端的D触发器">带使能端的D触发器<a class="anchor" href="#带使能端的D触发器">·</a></h5><p>增加输入使能信号EN（ENable），用于确定在时钟沿是否能够载入数据。</p><ul><li>EN＝1时，D触发器正常工作</li><li>EN＝0时， D触发器状态不变</li><li>在时钟信号上一般不要设置逻辑，否则可能因延迟导致时序错误</li></ul><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.8.2.png" style="zoom:50%;"><h5 id="带复位功能的D触发器">带复位功能的D触发器<a class="anchor" href="#带复位功能的D触发器">·</a></h5><p>增加输入复位信号RESET。 RESET 有效时（＝1），D触发器复位（Q=0） RESET 无效时（＝0）， D触发器正常工作</p><ul><li><p>复位方式</p><ul><li><p>同步复位：复位信号有效和时钟有效沿同时有效才能复位（置0）</p></li><li><p>异步复位：只要复位信号有效就能复位</p></li></ul></li><li><p>有的触发器还带有置位（SET）功能（Q=1）</p><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.8.3.png" style="zoom:50%;"></li></ul><h5 id="由D触发器构成寄存器">由D触发器构成寄存器<a class="anchor" href="#由D触发器构成寄存器">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.8.4.png" style="zoom:50%;"><h4 id="3-钟控JK触发器">3.钟控JK触发器<a class="anchor" href="#3-钟控JK触发器">·</a></h4><h5 id="原理-4">原理<a class="anchor" href="#原理-4">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.8.5.png" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.8.6.png" style="zoom:50%;"><h5 id="verilog-code">verilog code<a class="anchor" href="#verilog-code">·</a></h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> JK_FF(CP,J, K,Q,QN);</span><br><span class="line">    <span class="keyword">input</span> CP, J, K;</span><br><span class="line">    <span class="keyword">output</span> Q,QN;</span><br><span class="line">    <span class="keyword">reg</span> Q,QN; </span><br><span class="line">    <span class="keyword">always</span> @(CP <span class="keyword">or</span> J <span class="keyword">or</span> K)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (CP==<span class="number">0</span>) <span class="comment">//保持</span></span><br><span class="line">        <span class="keyword">begin</span> Q = Q; QN = QN; <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (CP==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">case</span> (&#123;J,K&#125;)</span><br><span class="line">                <span class="number">2</span>’b00: <span class="keyword">begin</span> Q = Q; QN = QN; <span class="keyword">end</span> <span class="comment">//保持</span></span><br><span class="line">                <span class="number">2</span>’b01: <span class="keyword">begin</span> Q = <span class="number">1</span>’b0; QN = <span class="number">1</span>’b1; <span class="keyword">end</span> <span class="comment">//置0</span></span><br><span class="line">                <span class="number">2</span>’b10: <span class="keyword">begin</span> Q = <span class="number">1</span>’b1; QN = <span class="number">1</span>’b0; <span class="keyword">end</span> <span class="comment">//置1</span></span><br><span class="line">                <span class="number">2</span>’b11: <span class="keyword">begin</span> Q = !Q; QN = !QN; <span class="keyword">end</span> <span class="comment">//翻转</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h5 id="钟控JK触发器比D锁存器新增的功能：">钟控JK触发器比D锁存器新增的功能：<a class="anchor" href="#钟控JK触发器比D锁存器新增的功能：">·</a></h5><p>当JK=11时，输出的波形翻转（可用于计数）； 当JK=00时，触发器保持原来的状态。</p><h5 id="钟控JK触发器的空翻现象分析（初态Q-0，J-1，K-1）">钟控JK触发器的空翻现象分析（初态Q=0，J=1，K=1）<a class="anchor" href="#钟控JK触发器的空翻现象分析（初态Q-0，J-1，K-1）">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.8.7.png" style="zoom: 50%;"><h4 id="4-负边沿触发的JK触发器">4 负边沿触发的JK触发器<a class="anchor" href="#4-负边沿触发的JK触发器">·</a></h4><h5 id="电路结构">电路结构<a class="anchor" href="#电路结构">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.8.8.png" style="zoom:50%;"><h5 id="工作原理">工作原理<a class="anchor" href="#工作原理">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.8.9.png" style="zoom:50%;"><h4 id="小结-7">小结<a class="anchor" href="#小结-7">·</a></h4><ul><li>基本RS锁存器：具有保持、置0、置1功能，其输入信号可以直接控制锁存器的输出；</li><li>钟控RS锁存器：时钟信号CP有效时锁存器的状态随输入变化（约束条件R、S不能同时为1）；</li><li>钟控D锁存器：为消除钟控RS触发器的不定状态，将钟控RS锁存器双端输入改为单端输入（D），即D锁存器；</li><li>D触发器：两个反向钟控D锁存器构成D触发器。时钟信号CP的边沿（上升沿或下降沿）触发。</li><li>D锁存器是电平敏感的，D触发器是边沿触发的；</li><li>寄存器有共享时钟信号CLK的多个D触发器构成。</li></ul><h4 id="触发器应用举例">触发器应用举例<a class="anchor" href="#触发器应用举例">·</a></h4><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.8.10.png" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.8.11.png" alt="3.8.11" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.8.12.png" alt="3.8.12" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.8.13.png" alt="3.8.13" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.8.14.png" alt="3.8.14" style="zoom:50%;"><h3 id="二．-有限状态机">二． 有限状态机<a class="anchor" href="#二．-有限状态机">·</a></h3><h4 id="时序电路特点">时序电路特点<a class="anchor" href="#时序电路特点">·</a></h4><p>将<strong>异步时序电路</strong>转换为<strong>同步时序电路</strong>，避免竞争和冒险</p><h5 id="时序电路实例分析">时序电路实例分析<a class="anchor" href="#时序电路实例分析">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.9.1.png" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.9.2.png" style="zoom:50%;"><h5 id="有限状态机基本介绍">有限状态机基本介绍<a class="anchor" href="#有限状态机基本介绍">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.9.3.png" style="zoom: 67%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.1.png" style="zoom: 67%;"><h4 id="1-Moore型有限状态机">1.Moore型有限状态机<a class="anchor" href="#1-Moore型有限状态机">·</a></h4><h5 id="设计方法和流程图">设计方法和流程图<a class="anchor" href="#设计方法和流程图">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.9.4.png" style="zoom:50%;"><h5 id="Moore型FSM的表示方法">Moore型FSM的表示方法<a class="anchor" href="#Moore型FSM的表示方法">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.9.5.png" style="zoom:50%;"><h5 id="【例】交通信号灯控制器">【例】交通信号灯控制器<a class="anchor" href="#【例】交通信号灯控制器">·</a></h5><p>南北Academic大道，信号灯LA；东西Bravado大道，信号灯LB。信号灯红、绿、黄三色。</p><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.9.8.png" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.9.9.png" alt="3.9.9" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.9.10.png" alt="3.9.10" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.9.11.png" alt="3.9.11" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.9.12.png" alt="3.9.12" style="zoom:50%;"><h4 id="2-Mealy型有限状态机">2.Mealy型有限状态机<a class="anchor" href="#2-Mealy型有限状态机">·</a></h4><h5 id="设计方法和流程图-2">设计方法和流程图<a class="anchor" href="#设计方法和流程图-2">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.9.6.png" style="zoom:50%;"><h5 id="Mealy型FSM的表示方法">Mealy型FSM的表示方法<a class="anchor" href="#Mealy型FSM的表示方法">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.9.7.png" style="zoom:50%;"><h5 id="【例】二进制序列检测器">【例】二进制序列检测器<a class="anchor" href="#【例】二进制序列检测器">·</a></h5><p>检测器接收到二进制序列“1101”时，输出检测标志为1，否则输出检测标志为0。不重复检测，即收到1101输出1后，下一次从下一个输入信号开始检测。</p><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.9.13.png" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.9.14.png" alt="3.9.14" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.9.15.png" alt="3.9.15" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.9.16.png" alt="3.9.16" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.9.17.png" alt="3.9.17" style="zoom:50%;"><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> monitor2_good(clk,clr,data,zo,state);</span><br><span class="line">    <span class="keyword">parameter</span> S0=<span class="number">3</span>’b000, S1=<span class="number">3</span>’b001,</span><br><span class="line">    S2=<span class="number">3</span>’b010, S3=<span class="number">3</span>’b011, S4=<span class="number">3</span>’b100;</span><br><span class="line">    <span class="keyword">input</span> clk,clr,data;</span><br><span class="line">    <span class="keyword">output</span> zo;</span><br><span class="line">    <span class="keyword">output</span>[<span class="number">2</span>:<span class="number">0</span>] state;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] state;</span><br><span class="line">    <span class="keyword">reg</span> zo;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> clr)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (clr) state=S0; <span class="comment">// 复位时回到初始状态</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">case</span> (state) <span class="comment">// 状态的转移</span></span><br><span class="line">                    S0: <span class="keyword">if</span> (data==<span class="number">1</span>’b1) state=S1; <span class="keyword">else</span> state=S0; </span><br><span class="line">                    S1: <span class="keyword">if</span> (data==<span class="number">1</span>’b1) state=S2; <span class="keyword">else</span> state=S0;</span><br><span class="line">                    S2: <span class="keyword">if</span> (data==<span class="number">1</span>’b0) state=S3; <span class="keyword">else</span> state=S2;</span><br><span class="line">                    S3: <span class="keyword">if</span> (data==<span class="number">1</span>’b1) state=S4; <span class="keyword">else</span> state=S0; </span><br><span class="line">                    S4: <span class="keyword">if</span> (data==<span class="number">1</span>’b1) state=S1; <span class="keyword">else</span> state=S0; </span><br><span class="line">                    <span class="keyword">default</span>: state=S0;</span><br><span class="line">                <span class="keyword">endcase</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span> @(state) <span class="comment">// 状态机的输出 输出是内部状态和外部输入的函数</span></span><br><span class="line">        <span class="keyword">begin</span>       </span><br><span class="line">            <span class="keyword">case</span> (state) </span><br><span class="line">                S0: zo=<span class="number">1'b0</span>; </span><br><span class="line">                S1: zo=<span class="number">1'b0</span>; </span><br><span class="line">                S2: zo=<span class="number">1'b0</span>; </span><br><span class="line">                S3: <span class="keyword">if</span> (data==<span class="number">1'b1</span>) zo=<span class="number">1'b1</span>;</span><br><span class="line">                <span class="comment">//在S3时若输入data=1， 则zo置1：</span></span><br><span class="line">                <span class="keyword">else</span> zo=<span class="number">1'b0</span>; </span><br><span class="line">                S4: zo=<span class="number">1'b0</span>; </span><br><span class="line">                <span class="keyword">default</span>: zo=<span class="number">1'b0</span>;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h4 id="有限状态机的状态编码问题">有限状态机的状态编码问题<a class="anchor" href="#有限状态机的状态编码问题">·</a></h4><h5 id="起始状态的选择">起始状态的选择<a class="anchor" href="#起始状态的选择">·</a></h5><p>起始状态指电路复位后所处的初态，选择合适的起始状态将使设计简捷高效。FSM必须有<strong>时钟信号</strong>和<strong>复位信号</strong>。</p><h5 id="状态编码方式的选择（假定FSM有N个状态）">状态编码方式的选择（假定FSM有N个状态）<a class="anchor" href="#状态编码方式的选择（假定FSM有N个状态）">·</a></h5><p><strong>二进制编码</strong>：采用<strong>log2N个触发器</strong>来表示这N个状态，按二进制顺序编码，节省逻辑资源，但<strong>可能产生输出毛刺</strong>。</p><p><strong>格雷编码</strong>：采用<strong>log2N个触发器</strong>来表示这N个状态，但<strong>相邻状态只有一个比特位不同</strong>。节省逻辑资源，降低了输出毛刺的可能，状态转换中，相邻状态只有一个比特位产生变化。</p><p><strong>一位热码状态机编码</strong>（One-Hot State Machine Encoding）：采用<strong>N个触发器来表示这N个状态</strong>。逻辑资源消耗最大，但可以<strong>避免状态机产生错误的输出</strong>，并且有时可简化输出逻辑。</p><h5 id="8个状态三种编码方式的对比">8个状态三种编码方式的对比<a class="anchor" href="#8个状态三种编码方式的对比">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.9.18.png" style="zoom:50%;"><h4 id="有限状态机设计小结">有限状态机设计小结<a class="anchor" href="#有限状态机设计小结">·</a></h4><ol><li>确定输入、输出，以及状态总数</li><li>画出状态转换图</li><li>对于Moore型FSM① 写出状态转换表② 写出输出真值表</li><li>对于Mealy型FSM① 写出组合的状态转换表和输出真值表</li><li>选择状态编码——这个选择将影响硬件设计</li><li>写出次态逻辑和输出逻辑的逻辑表达式</li><li>画出电路图</li><li>进行Verilog HDL设计并仿真测试</li></ol><h3 id="三．-时序逻辑电路设计分析">三． 时序逻辑电路设计分析<a class="anchor" href="#三．-时序逻辑电路设计分析">·</a></h3><h4 id="时序电路的分类">时序电路的分类<a class="anchor" href="#时序电路的分类">·</a></h4><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.1.png" style="zoom:50%;"><h5 id="同步时序电路的分析方法">同步时序电路的分析方法<a class="anchor" href="#同步时序电路的分析方法">·</a></h5><ol><li>写出各触发器的<strong>激励方程(<strong>excitation equation) （也称</strong>驱动方程</strong>）</li><li>把得到的激励方程代入到触发器的<strong>特性方程(<strong>characteristic equation) ，得到</strong>次态方程</strong>(next-state equation)</li><li>按照电路图得到<strong>输出方程</strong>(output equation)</li><li>根据<strong>次态方程</strong>和<strong>输出方程</strong>得到<strong>状态表</strong></li><li>得到时序电路的<strong>状态图</strong></li><li>画出时序图</li><li>确定电路行为</li></ol><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.2.png" style="zoom:50%;"><h4 id="寄存器的分类">寄存器的分类<a class="anchor" href="#寄存器的分类">·</a></h4><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.3.png" style="zoom:50%;"><h4 id="1-数据寄存器">1.数据寄存器<a class="anchor" href="#1-数据寄存器">·</a></h4><h5 id="数据寄存器-2">数据寄存器<a class="anchor" href="#数据寄存器-2">·</a></h5><p>由多位边沿触发器组成的用于保存一组二进制代码的寄存单元。当时钟信号的上升沿或下降沿到来时，将输入端数据打入寄存器，即此时输出信号等于输入信号；在时钟信号的其它时刻，输出端保持刚才输入的数据，即为寄存状态，而不管此时输入信号是否变化。</p><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.4.png" style="zoom:50%;"><p><strong>4位D型寄存器结构</strong>$D_0D_1D_2D_3$：并行数据输入$Q_0Q_1Q_2Q_3$：并行数据输出工作原理： （1）清除（复位）当$\overline {R_D}$ = 0 ， $Q_0Q_1Q_2Q_3$=0000; （2）置数（复位端无效时）当CP上跳沿到达时，$Q_0Q_1Q_2Q_3$= $D_0D_1D_2D_3$</p><h5 id="用always块语句描述的8位数据寄存器">用always块语句描述的8位数据寄存器<a class="anchor" href="#用always块语句描述的8位数据寄存器">·</a></h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> reg_8bit(qout,data,clk,clr);</span><br><span class="line">    <span class="keyword">output</span>[<span class="number">7</span>:<span class="number">0</span>] qout;</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] data;</span><br><span class="line">    <span class="keyword">input</span> clk,clr;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] qout;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> clr) <span class="comment">//沿触发</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(clr) qout=<span class="number">0</span>; <span class="comment">//异步清零</span></span><br><span class="line">            <span class="keyword">else</span> qout= data;</span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h5 id="数据锁存器">数据锁存器<a class="anchor" href="#数据锁存器">·</a></h5><ul><li>由多位电位锁存器组成的用于保存一组二进制代码的寄存单元。</li><li>功能：当输入控制信号（如时钟）为高电平时，门是打开的，输出信号等于输入信号；当输入控制信号为低电平时，门是关闭的，输出端保持刚才输入的数据，即为锁存状态，而不管此时输入信号是否变化。</li><li>通常由电平信号来控制，属于<strong>电平敏感型</strong>，适于<strong>数据有效滞后于控制信号</strong>有效的场合。</li></ul><h5 id="数据寄存器和数据锁存器的区别">数据寄存器和数据锁存器的区别<a class="anchor" href="#数据寄存器和数据锁存器的区别">·</a></h5><ul><li>数据寄存器：由边沿触发的触发器组成。通常由同步时钟信号来控制，属于脉冲敏感型，适于数据有效提前于控制信号（一般为时钟信号）有效、并要求同步操作的场合。</li><li>数据锁存器：由电位触发器（即D锁存器）组成。一般由电平信号来控制，属于电平敏感型，适于数据有效滞后于控制信号有效的场合。</li></ul><h5 id="数据锁存器的Verilog-HDL设计">数据锁存器的Verilog HDL设计<a class="anchor" href="#数据锁存器的Verilog-HDL设计">·</a></h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通的的1位数据锁存器的Verilog HDL</span></span><br><span class="line"><span class="keyword">module</span> latch_1(q,d,clk);</span><br><span class="line">    <span class="keyword">output</span> q;</span><br><span class="line">    <span class="keyword">input</span> d,clk ;</span><br><span class="line">    <span class="keyword">assign</span> q=clk?d:q; <span class="comment">/* 时钟信号为高电平，打入数据，否则锁存原数*/</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//带置位和复位端的1位数据锁存器的Verilog HDL</span></span><br><span class="line"><span class="keyword">module</span> latch_2(q,d,clk,set,reset);</span><br><span class="line">    <span class="keyword">output</span> q;</span><br><span class="line">    <span class="keyword">input</span> d,clk ,set,reset;</span><br><span class="line">    <span class="keyword">assign</span> q= reset ? <span class="number">0</span>: (set ? <span class="number">1</span>:(clk ? d:q)); </span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//8位数据锁存器的Verilog HDL设计</span></span><br><span class="line"><span class="keyword">module</span> latch_8bit(qout,data,clk);</span><br><span class="line">    <span class="keyword">output</span>[<span class="number">7</span>:<span class="number">0</span>] qout;</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] data;</span><br><span class="line">    <span class="keyword">input</span> clk;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] qout;</span><br><span class="line">    <span class="keyword">always</span> @(clk <span class="keyword">or</span> data) <span class="comment">//电平敏感</span></span><br><span class="line">    <span class="keyword">if</span>(clk) qout=data;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h4 id="2-移位寄存器">2.移位寄存器<a class="anchor" href="#2-移位寄存器">·</a></h4><p>具有移位功能的寄存器称为移位寄存器，每来一个时钟脉冲，寄存器中数据就依次向左或向右移一位。</p><p>计算机中经常需要用到移位操作，如乘法运算中的<strong>右移</strong>，除法运算中的<strong>左移</strong>，数据输入输出方式中的<strong>串行并行转换</strong>等。</p><h5 id="移位寄存器分类">移位寄存器分类<a class="anchor" href="#移位寄存器分类">·</a></h5><p>左移移位寄存器、右移移位寄存器、双向移位寄存器、循环移位寄存器</p><h5 id="4位右移移位寄存器">4位右移移位寄存器<a class="anchor" href="#4位右移移位寄存器">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.5.png" style="zoom:50%;"><h5 id="4位右移移位寄存器的工作方式">4位右移移位寄存器的工作方式<a class="anchor" href="#4位右移移位寄存器的工作方式">·</a></h5><h6 id="串入并出">串入并出<a class="anchor" href="#串入并出">·</a></h6><p>串并转换（需要N个CP周期），经过4个CP，串行输入的4位数据全部移入移位寄存器中，并从Q3Q2Q1Q0并行输出1011</p><h6 id="串入串出">串入串出<a class="anchor" href="#串入串出">·</a></h6><p>把最右边的触发器的输出作为电路的输出。经过4个CP后， Q3 输出的是最先串行输入的数据。从每个触发器Q端输出的波形相同，但后级触发器Q端输出波形比前级触发器Q端输出波形滞后一个时钟周期。 把工作于串入串出方式的移位寄存器称为“延迟线” （第N级FF延迟N个CP周期）</p><h5 id="4位串行输入、串-并行输出双向移位寄存器">4位串行输入、串/并行输出双向移位寄存器<a class="anchor" href="#4位串行输入、串-并行输出双向移位寄存器">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.6.png" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.7.png" style="zoom:50%;"><h4 id="3-计数器">3.计数器<a class="anchor" href="#3-计数器">·</a></h4><h5 id="定义，用途，分类">定义，用途，分类<a class="anchor" href="#定义，用途，分类">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.8.png" style="zoom:50%;"><h5 id="例题1：同步十进制加法计数器">例题1：同步十进制加法计数器<a class="anchor" href="#例题1：同步十进制加法计数器">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.9.png" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.10.png" alt="3.3.10" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.11.png" alt="3.3.11" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.12.png" alt="3.3.12" style="zoom:50%;"><h5 id="同步计数器的特点">同步计数器的特点<a class="anchor" href="#同步计数器的特点">·</a></h5><ul><li>所有触发器的时钟端并联在一起，作为计数器的时钟端</li><li>各触发器同时翻转，不存在时钟到各触发器输出的传输延迟的积累</li><li>由于其工作频率只与一个触发器的时钟到输出的传输延迟有关，所以它的工作频率比异步计数器高。</li><li>由于计数器各触发器几乎是同时翻转的，因此，各触发器输出波形的偏移为各触发器时钟到输出的延迟之差，同步计数器输出经译码后所产生的尖峰信号宽度比较小。</li><li>缺点：结构比较复杂（<strong>各触发器的输入由多个Q输出相与得到</strong>），所用元件较多。</li><li><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.13.png" style="zoom:50%;"></li></ul><h5 id="例题2：同步十六进制数加法计数器">例题2：同步十六进制数加法计数器<a class="anchor" href="#例题2：同步十六进制数加法计数器">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.14.png" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.15.png" alt="3.3.15" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.16.png" alt="3.3.16" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.17.png" alt="3.3.17" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.18.png" alt="3.3.18" style="zoom:50%;"><h5 id="异步计数器">异步计数器<a class="anchor" href="#异步计数器">·</a></h5><p>异步计数器也有<strong>二进制、十进制、任意进制</strong>等类型</p><h6 id="异步计数器的特点">异步计数器的特点<a class="anchor" href="#异步计数器的特点">·</a></h6><ul><li>输入系统时钟脉冲只作用于最低位触发器，高位触发器的时钟信号往往是由低一位触发器的输出提供的，高位触发器的翻转有待低一位触发器翻转后才能进行。</li><li>由于每一级触发器都存在传输延迟，因此计数器工作速度慢，而且，位数越多计数越慢。在大型数字设备中较少采用。</li><li>对计数器状态进行译码时，由于触发器不同步，译码器输出会出现尖峰脉冲（位数越多，尖峰信号也就越宽），使仪器设备产生误动作。</li><li>优点：结构比较简单，所用元件较少。</li></ul><h5 id="例题3：分析下图异步二进制（M-16）加法计数器电路（N-4）">例题3：分析下图异步二进制（M=16）加法计数器电路（N=4）<a class="anchor" href="#例题3：分析下图异步二进制（M-16）加法计数器电路（N-4）">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.19.png" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.20.png" alt="3.3.20" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.21.png" alt="3.3.21" style="zoom:50%;"><h5 id="异步计数器——其他类型计数器">异步计数器——其他类型计数器<a class="anchor" href="#异步计数器——其他类型计数器">·</a></h5><h6 id="1-分析异步二进制（模16）减法计数器">1. 分析异步二进制（模16）减法计数器<a class="anchor" href="#1-分析异步二进制（模16）减法计数器">·</a></h6><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.22.png" style="zoom:50%;"><h6 id="2-D触发器（上跳沿触发）构成的异步二进制（模8）加法计数器">2.D触发器（上跳沿触发）构成的异步二进制（模8）加法计数器<a class="anchor" href="#2-D触发器（上跳沿触发）构成的异步二进制（模8）加法计数器">·</a></h6><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.23.png" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.24.png" alt="3.3.24" style="zoom:50%;"><h5 id="异步计数器小结">异步计数器小结<a class="anchor" href="#异步计数器小结">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.25.png" style="zoom:50%;"><h4 id="4-时序电路的时序">4.时序电路的时序<a class="anchor" href="#4-时序电路的时序">·</a></h4><h5 id="寄存器的时序">寄存器的时序<a class="anchor" href="#寄存器的时序">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.4.1.png" style="zoom:50%;"><h5 id="同步时序电路时钟周期">同步时序电路时钟周期<a class="anchor" href="#同步时序电路时钟周期">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.4.2.png" style="zoom: 50%;"><h5 id="保持时间约束">保持时间约束<a class="anchor" href="#保持时间约束">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.4.3.png" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.4.4.png" style="zoom:50%;"><h2 id="第四讲：主存储器">第四讲：主存储器<a class="anchor" href="#第四讲：主存储器">·</a></h2><h3 id="一．-存储系统概述">一． 存储系统概述<a class="anchor" href="#一．-存储系统概述">·</a></h3><h4 id="1-1存储器分类">1.1存储器分类<a class="anchor" href="#1-1存储器分类">·</a></h4><h5 id="按介质分类：">按介质分类：<a class="anchor" href="#按介质分类：">·</a></h5><ul><li>半导体存储器</li><li>磁介质存储器</li><li>光盘存储器</li></ul><h5 id="按访问方式分类：">按访问方式分类：<a class="anchor" href="#按访问方式分类：">·</a></h5><ul><li>随机访问存储器 （Random Access Memory—<strong>RAM</strong>）</li><li>只读存储器 （Read Only Memory—<strong>ROM</strong>）</li><li>顺序访问存储器 （Tape）</li><li>直接访问存储器 （Disk）</li></ul><h5 id="按功能分类：">按功能分类：<a class="anchor" href="#按功能分类：">·</a></h5><ul><li>高速缓冲存储器</li><li>主存储器</li><li>辅助存储器</li><li>控制存储器</li></ul><h4 id="存储器的层次结构">存储器的层次结构<a class="anchor" href="#存储器的层次结构">·</a></h4><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/4.1.15.png" style="zoom:50%;"><p>二级存储系统指：<strong>高速缓冲存储器</strong>（<strong>Cache</strong>）＋<strong>主存储器</strong></p><h4 id="1-2半导体存储器">1.2半导体存储器<a class="anchor" href="#1-2半导体存储器">·</a></h4><h5 id="静态随机访问存储器SRAM（Static-RAM）">静态随机访问存储器SRAM（Static RAM）<a class="anchor" href="#静态随机访问存储器SRAM（Static-RAM）">·</a></h5><ul><li>SRAM：静态存储器，相对动态而言，<strong>集成度低</strong>，<strong>但不必刷新</strong>。</li></ul><h5 id="动态随机访问存储器DRAM（Dynamic-RAM）">动态随机访问存储器DRAM（Dynamic RAM）<a class="anchor" href="#动态随机访问存储器DRAM（Dynamic-RAM）">·</a></h5><ul><li>DRAM：动态存储器，<strong>需要刷新</strong>，相对而言，<strong>集成度高</strong>。</li></ul><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/4.1.16.png" style="zoom:50%;"><h3 id="二．-存储单元电路">二． 存储单元电路<a class="anchor" href="#二．-存储单元电路">·</a></h3><h4 id="存储单元的符号表示">存储单元的符号表示<a class="anchor" href="#存储单元的符号表示">·</a></h4><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/4.1.1.png" style="zoom:50%;"><h3 id="三．-存储器芯片结构">三． 存储器芯片结构<a class="anchor" href="#三．-存储器芯片结构">·</a></h3><h4 id="存储芯片结构（一维地址结构）">存储芯片结构（一维地址结构）<a class="anchor" href="#存储芯片结构（一维地址结构）">·</a></h4><ul><li>1024×2 ：1024 个字单元，每个字单元 2 个二进制位 需要1024个不同的标示。</li><li>地址编码：译码电路使得字选择线 Wi 处于工作状态的输入信号（二进制信号），称为Wi 所选中字单元的地址编码（简称地址）。</li><li>对于每一个字单元，地址是唯一的。</li><li><strong>计组课中，地址往往都和译码器相连</strong>。</li><li><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/4.1.2.png" style="zoom:50%;"></li></ul><h4 id="二维地址结构（SRAM）">二维地址结构（SRAM）<a class="anchor" href="#二维地址结构（SRAM）">·</a></h4><ul><li>一维地址需要的分支太多，不方便光刻</li><li>芯片示例：4096 × 4（4096 个字，每个字 4 位）4096×4 = $2^{14}$ 个位单元</li><li>存储矩阵： $2<sup>7×2</sup>7$ (128行×128列)</li><li>行、列译码：行地址 7位，一行含32个字共128位，任一时刻只有1个字（4位数据线）被选中。一行包括32个字，要进行<strong>32选1</strong>的译码（Y译码），列地址5位</li><li><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/4.1.3.png" style="zoom:50%;"></li></ul><h4 id="DRAM芯片结构">DRAM芯片结构<a class="anchor" href="#DRAM芯片结构">·</a></h4><p>要求体积较小，采用行列译码器复用，时空转换</p><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/4.1.4.png" style="zoom:50%;"><h4 id="存储芯片结构示例">存储芯片结构示例<a class="anchor" href="#存储芯片结构示例">·</a></h4><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/4.1.5.png" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/4.1.6.png" alt="4.1.6" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/4.1.7.png" alt="4.1.7" style="zoom:50%;"><h3 id="四．-存储器扩展">四． 存储器扩展<a class="anchor" href="#四．-存储器扩展">·</a></h3><h4 id="4-1-存储器芯片的扩展（位扩展）">4.1 存储器芯片的扩展（位扩展）<a class="anchor" href="#4-1-存储器芯片的扩展（位扩展）">·</a></h4><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/4.1.8.png" style="zoom: 200%;"><h4 id="4-2-存储器芯片的扩展（字扩展）">4.2 存储器芯片的扩展（字扩展）<a class="anchor" href="#4-2-存储器芯片的扩展（字扩展）">·</a></h4><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/4.1.10.png" alt="4.1.9" style="zoom:50%;"><h6 id="4-3-存储器芯片的扩展（混合扩展）">4.3 存储器芯片的扩展（混合扩展）<a class="anchor" href="#4-3-存储器芯片的扩展（混合扩展）">·</a></h6><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/4.1.11.png" alt="4.1.9" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/4.1.12.png" alt="4.1.9" style="zoom:50%;"><h4 id="CPU与主存的连接（示例）">CPU与主存的连接（示例）<a class="anchor" href="#CPU与主存的连接（示例）">·</a></h4><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/4.1.13.png" style="zoom:200%;"><h4 id="存储器的符号表示">存储器的符号表示<a class="anchor" href="#存储器的符号表示">·</a></h4><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/4.1.14.png" style="zoom:50%;"><h3 id="五．-DRAM的刷新">五． DRAM的刷新<a class="anchor" href="#五．-DRAM的刷新">·</a></h3><h4 id="5-1-DRAM存储单元电路的刷新">5.1 DRAM存储单元电路的刷新<a class="anchor" href="#5-1-DRAM存储单元电路的刷新">·</a></h4><h4 id="5-2-DRAM存储芯片的刷新">5.2 DRAM存储芯片的刷新<a class="anchor" href="#5-2-DRAM存储芯片的刷新">·</a></h4><p>简单来讲，就是让0变纯0，1变纯1</p><h4 id="5-3-DRAM的刷新方式">5.3 DRAM的刷新方式<a class="anchor" href="#5-3-DRAM的刷新方式">·</a></h4><h5 id="集中刷新方式">集中刷新方式<a class="anchor" href="#集中刷新方式">·</a></h5><p>集中刷新间隔 = 刷新周期</p><h5 id="分散刷新方式">分散刷新方式<a class="anchor" href="#分散刷新方式">·</a></h5><h5 id="异步刷新方式（一般使用）">异步刷新方式（一般使用）<a class="anchor" href="#异步刷新方式（一般使用）">·</a></h5><ul><li>结合前两种方式，保证在一个刷新周期内将存储芯片内的所有行刷新一遍，且只刷新一遍。</li><li>异步刷新间隔 = 刷新周期</li><li>以128行为例，在2ms时间内必须轮流对每一行刷新一次，即每隔2ms/128=15.5μs刷新一行。这时假定读/写与刷新操作时间都为0.5μs，则可用前15μs进行正常读/写操作，最后0.5μs完成刷新操作。</li></ul><h4 id="非易失性内存">非易失性内存<a class="anchor" href="#非易失性内存">·</a></h4><ul><li>铁电存储器：FRAM</li><li>电阻式存储器：ReRAM</li><li>磁阻存储器：MRAM，SRAM的告诉读写性能，DRAM的集成度，ROM的非易失性特征，功耗低</li></ul><h2 id="第五讲：指令系统与MIPS汇编语言">第五讲：指令系统与MIPS汇编语言<a class="anchor" href="#第五讲：指令系统与MIPS汇编语言">·</a></h2><h3 id="一、指令格式">一、指令格式<a class="anchor" href="#一、指令格式">·</a></h3><h4 id="1-1指令系统概述">1.1指令系统概述<a class="anchor" href="#1-1指令系统概述">·</a></h4><h5 id="执行指令是CPU的主要工作">执行指令是CPU的主要工作<a class="anchor" href="#执行指令是CPU的主要工作">·</a></h5><h5 id="不同的CPU有不同的指令集">不同的CPU有不同的指令集<a class="anchor" href="#不同的CPU有不同的指令集">·</a></h5><p><strong>指令集架构Instruction Set Architecture (ISA)</strong>：Intel 80x86 (Pentium 4), IBM/Motorola PowerPC (Macintosh), MIPS, Intel IA64, …</p><p>(ARM架构从英国卖到了美国，之后国内的芯片生态问题需要注意)</p><h5 id="指令系统的基本问题">指令系统的基本问题<a class="anchor" href="#指令系统的基本问题">·</a></h5><h6 id="操作类型：应该提供哪些（多少）操作？">操作类型：应该提供哪些（多少）操作？<a class="anchor" href="#操作类型：应该提供哪些（多少）操作？">·</a></h6><p>用LD/ST/INC/BRN已经足够编写任何计算程序，但不实用，程序太长。</p><h6 id="操作对象：如何表示？可以表示多少？">操作对象：如何表示？可以表示多少？<a class="anchor" href="#操作对象：如何表示？可以表示多少？">·</a></h6><p>大多数是双值运算（如A&lt;-B+C)存在单值运算（如A&lt;- ~B)</p><h6 id="指令格式：如何将这些内容编码成一致的格式？">指令格式：如何将这些内容编码成一致的格式？<a class="anchor" href="#指令格式：如何将这些内容编码成一致的格式？">·</a></h6><p>指令长度、字段、编码等问题</p><h4 id="1-2指令格式">1.2指令格式<a class="anchor" href="#1-2指令格式">·</a></h4><h4 id="1-3寻址方式">1.3寻址方式<a class="anchor" href="#1-3寻址方式">·</a></h4><h3 id="二、MIPS指令与汇编语言">二、MIPS指令与汇编语言<a class="anchor" href="#二、MIPS指令与汇编语言">·</a></h3><h4 id="2-1MIPS指令系统">2.1MIPS指令系统<a class="anchor" href="#2-1MIPS指令系统">·</a></h4><h5 id="MIPS-R2000-R3000-寄存器结构">MIPS R2000/R3000 寄存器结构<a class="anchor" href="#MIPS-R2000-R3000-寄存器结构">·</a></h5><h4 id="2-2MIPS汇编语言">2.2MIPS汇编语言<a class="anchor" href="#2-2MIPS汇编语言">·</a></h4><h4 id="2-3MIPS汇编编程">2.3MIPS汇编编程<a class="anchor" href="#2-3MIPS汇编编程">·</a></h4><h3 id="三、8086-8088指令系统">三、8086/8088指令系统<a class="anchor" href="#三、8086-8088指令系统">·</a></h3><h3 id="四、RISC与CISC">四、RISC与CISC<a class="anchor" href="#四、RISC与CISC">·</a></h3><h2 id="第六讲：MIPS处理器设计">第六讲：MIPS处理器设计<a class="anchor" href="#第六讲：MIPS处理器设计">·</a></h2><h3 id="一-处理器设计概述">一.处理器设计概述<a class="anchor" href="#一-处理器设计概述">·</a></h3><h4 id="CPU的功能与组成">CPU的功能与组成<a class="anchor" href="#CPU的功能与组成">·</a></h4><h3 id="二-MIPS模型机">二.MIPS模型机<a class="anchor" href="#二-MIPS模型机">·</a></h3><h3 id="三-MIPS单周期处理器设计">三.MIPS单周期处理器设计<a class="anchor" href="#三-MIPS单周期处理器设计">·</a></h3><h3 id="四-MIPS多周期处理器设计简介">四.MIPS多周期处理器设计简介<a class="anchor" href="#四-MIPS多周期处理器设计简介">·</a></h3><h3 id="五-MIPS流水线处理器设计">五.MIPS流水线处理器设计<a class="anchor" href="#五-MIPS流水线处理器设计">·</a></h3><h2 id="第七讲：高速缓冲存储器">第七讲：高速缓冲存储器<a class="anchor" href="#第七讲：高速缓冲存储器">·</a></h2><h3 id="一．Cache的原理">一．Cache的原理<a class="anchor" href="#一．Cache的原理">·</a></h3><h4 id="Cache产生的动因">Cache产生的动因<a class="anchor" href="#Cache产生的动因">·</a></h4><ul><li>单级存储系统中,主存的存储速度与CPU的速度不匹配，造成CPU资源的浪费；</li><li>程序运行时访问内存存在明显的<strong>局部性特征</strong>；</li><li>存在比主存普遍采用的DRAM速度更快的存储单元电路（SRAM）；</li></ul><h4 id="Cache的工作原理">Cache的工作原理<a class="anchor" href="#Cache的工作原理">·</a></h4><ul><li><p>在CPU和主存间设置一个小容量<strong>访问速度更快</strong>的高速缓存，其中总是保存当前<strong>最活跃（被频繁访问）的程序和数据</strong>，大多数情况下，CPU能直接从这个高速缓存中取得指令和数据，而不必访问主存。这个高速缓存就是<strong>Cache</strong>。（Cache对用户完全透明）</p></li><li><p>Cache与主存之间按照数据块（Block）为单位进行数据交换(块大小一般为16/32/64/128 B)。</p></li></ul><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/701.png" style="zoom:50%;"><h5 id="Cache要解决的问题">Cache要解决的问题<a class="anchor" href="#Cache要解决的问题">·</a></h5><p>① <strong>快速访问</strong>：具备快速访问的能力（采用<strong>SRAM</strong>）；</p><p>② <strong>数据交换</strong>：与主存交换数据的能力，将主存<strong>最活跃单元所在数据</strong>（或指令）块复制到Cache中；</p><p>③ <strong>地址判断</strong>：由于CPU总是以主存地址访问存储器，所以Cache应具备有判断CPU当前要访问的内容是否在Cache中的能力，并具有根据主存地址在Cache中访问相应单元的能力；</p><p>④ <strong>替换决策</strong>：具备在Cache容量不够时替换Cache中某些内容的决策能力。</p><h5 id="Cache的基本结构">Cache的基本结构<a class="anchor" href="#Cache的基本结构">·</a></h5><ul><li>存储机构：保存数据，存取数据，一般采用SRAM构成。以Block（若干字）为单位；</li><li>地址机构：地址比较机制，地址映射机制，地址标记（Tag），一个Block具有一个Tag；</li><li>替换机构：记录Block的使用情况，有效位（v）记录对应数据块中的数据是否有效；替换策略。</li></ul><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/702.png" style="zoom:50%;"><h5 id="Cache的有关术语">Cache的有关术语<a class="anchor" href="#Cache的有关术语">·</a></h5><ul><li>数据块（block）：Cache与主存的基本划分单位，也是主存与Cache一次交换数据的最小单位，由多个字节（字）组成，取决与主存一次读写操作所能完成的数据字节数。也表明主存于Cache之间局部总线的宽度。</li><li>标记（tag）：Cache每一数据块有一个标记字段，用来保存该数据块对应的主存数据块的地址信息。</li><li>有效位（valid bit）：Cache中每一Block有一个有效位，用于指示相应数据块中是否包含有效数据。</li><li>行（line )：Cache中 一个block及其 tag、valid bit构成1行。</li><li>组（set）：若干块(Block)构成一个组，地址比较一般能在组内各块间同时进行。</li><li>路（way）：Cache相关联的等级，每一路具有独立的地址比较机构，各路地址比较能同时进行（一般与组结合），路数即指一组内的块数。</li><li>命中率（hit rate）：目标数据在Cache中的存储访问的比例。</li><li>缺失率（miss rate）：目标数据不在Cache中的存储访问的比例。</li></ul><h5 id="Cache结构示意">Cache结构示意<a class="anchor" href="#Cache结构示意">·</a></h5><ul><li>分S组</li><li>每组E行（相当于Block）</li><li>每数据块包含B个字节</li></ul><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/703.png" style="zoom:50%;"><h5 id="Cache的读操作过程">Cache的读操作过程<a class="anchor" href="#Cache的读操作过程">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/704.png" style="zoom:50%;"><h3 id="二．Cache的映射机制">二．Cache的映射机制<a class="anchor" href="#二．Cache的映射机制">·</a></h3><ul><li>主存按Cache块大小分成若干块（主存块）</li><li>Cache中存放主存块数据的对应单位也称为块（Cache块）或行（line）</li><li>主存块和Cache块的映射方式：<ul><li><strong>全相联</strong>（Full Associate）：每个主存块都可以映射到任一Cache块</li><li><strong>组相联</strong>（Set Associate）：每个主存块只能映射到Cache中某一固定组中的任一Cache块</li><li><strong>直接映射</strong>（Direct）：每个主存块只能映射到某一固定的Cache块</li></ul></li></ul><h4 id="1-全相联映射">1.全相联映射<a class="anchor" href="#1-全相联映射">·</a></h4><ul><li>Cache包含 M 块，主存也按Cache块大小分块，共 N 块，显然 N&gt;&gt;M。</li><li>主存中的某一主存块可以映射到Cache中的任一Cache块。</li><li>主存块到Cache块的映射是 <strong>1:M映射</strong>。</li></ul><h5 id="全相联Cache组织">全相联Cache组织<a class="anchor" href="#全相联Cache组织">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/706.png" style="zoom:50%;"><h5 id="全相联映射的地址">全相联映射的地址<a class="anchor" href="#全相联映射的地址">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/705.png" style="zoom:50%;"><h4 id="2-组相联映射">2.组相联映射<a class="anchor" href="#2-组相联映射">·</a></h4><ul><li>Cache包含M块，分 K 组，每组包含 L 块，M=K*L；</li><li>主存块 J 按 I = J mod K 的规则映射到 Cache 组 I 中的任意块；</li><li>主存可以视为逻辑上也分成 K 组，主存组M内的一个主存块只能映射到Cache组M内，但可以是组M内任意Cache块。</li></ul><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/707.png" style="zoom:50%;"><h4 id="3-直接映射">3.直接映射<a class="anchor" href="#3-直接映射">·</a></h4><ul><li>主存按Cache块大小也分成若干块，Cache包含M块</li><li>主存块 J 按 I = J mod M 的规则映射到 Cache块I 。</li><li>主存可以视为按Cache容量大小分成了若干区，一个区内的主存块分别与对应的Cache块构成映射。</li></ul><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/708.png" style="zoom:50%;"><h4 id="Cache包含M块，主存块-J-的映射">Cache包含M块，主存块 J 的映射<a class="anchor" href="#Cache包含M块，主存块-J-的映射">·</a></h4><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/709.png" style="zoom:50%;"><h3 id="三．Cache的替换策略">三．Cache的替换策略<a class="anchor" href="#三．Cache的替换策略">·</a></h3><p>CPU访问Cache缺失时，CPU必须等待数据装入Cache后才能访问Cache，这期间的时间损失称为缺失损失。</p><p>取出块的时间：第一个字的延迟时间（存储器访问）+ 块的剩余部分的传送时间。</p><p>Cache的存储组织对缺失损失具有很大的影响。</p><h4 id="缺失损失示例">缺失损失示例<a class="anchor" href="#缺失损失示例">·</a></h4><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/710.png" style="zoom:50%;"><h4 id="Cache块的替换">Cache块的替换<a class="anchor" href="#Cache块的替换">·</a></h4><h5 id="替换块的选择">替换块的选择<a class="anchor" href="#替换块的选择">·</a></h5><ul><li>直接映射Cache：访问缺失时，被请求数据所在的块只能进入Cache的一个位置，占用该位置的数据块必须被替换掉；</li><li>组相联Cache：访问缺失时，被请求数据所在块可以进入Cache某一组的任何位置，因此应在Cache对应组内选择一个数据块进行替换；</li><li>全相联Cache：访问缺失时，被请求数据所在块可以进入Cache的任何位置，因此应在Cache中选择一个数据块进行替换。</li></ul><h4 id="Cache的替换策略">Cache的替换策略<a class="anchor" href="#Cache的替换策略">·</a></h4><ul><li>最近最少使用法（<strong>LRU</strong>，Least-Recently Used）：记录每一个数据块的相对使用情况，最近没有被使用的块被替换。</li><li>先进先出法（<strong>FIFO</strong>，First-In-First-Out）：最先装入数据的块被替换；</li><li>最小使用频率法 （<strong>LFU</strong>，Least-Frequently Used）：记录每一个数据块的使用频率，使用次数最少的被替换。</li><li>随机法（<strong>RAND</strong>，Random）：随机选择一个数据块进行替换。</li></ul><h4 id="替换算法的实现">替换算法的实现<a class="anchor" href="#替换算法的实现">·</a></h4><ul><li>LRU的实现（计数器法）<ul><li>缓存的每一块都设置一个计数器；</li><li>被调入或者被替换的块， 其计数器清 0，而其它的计数器则加 1；</li><li>访问命中时，所有块的计数值与命中块的计数值进行比较，如果计数值小于命中块的计数值， 则该块的计数值加 1；如果块的计数值大于命中块的计数值，则数值不变。最后将命中块的计数器清为0。</li><li>需要替换时，则选择计数值最大的块被替换。</li></ul></li><li>FIFO的实现（计数器法）<ul><li>例如Solar－16/65机Cache采用组相联方式，每组4块，每块都设定一个两位的计数器，当某块被装入或被替换时该块的计数器清为0，而同组的其它各块的计数器均加1，当需要替换时就选择计数值最大的块被替换掉。</li></ul></li></ul><h3 id="四．Cache性能分析">四．Cache性能分析<a class="anchor" href="#四．Cache性能分析">·</a></h3><h4 id="Cache的容量">Cache的容量<a class="anchor" href="#Cache的容量">·</a></h4><ul><li>不作特殊申明时，Cache的容量指Cache数据块的容量；</li><li>Cache实际总的存储容量实际上还包含tag和valid bit的位数。</li></ul><h4 id="Cache的性能计算">Cache的性能计算<a class="anchor" href="#Cache的性能计算">·</a></h4><p>假设：CPU访问Cache失效时，直接访问主存直接获得数据，读取主存块并保存到Cache中的时间忽略不计。</p><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/711.png" style="zoom:50%;"><h4 id="命中率对存储器性能的影响">命中率对存储器性能的影响<a class="anchor" href="#命中率对存储器性能的影响">·</a></h4><p>命中率与平均访问时间关系密切！假设：CPU访问Cache失效时，先读取主存块并保存到Cache中，再从Cache读取所需数据。</p><h4 id="Cache与主存的数据一致性">Cache与主存的数据一致性<a class="anchor" href="#Cache与主存的数据一致性">·</a></h4><p><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/712.png" style="zoom:50%;"> <img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/713.png" style="zoom:50%;"></p><h4 id="Cache命中率问题">Cache命中率问题<a class="anchor" href="#Cache命中率问题">·</a></h4><p>命中率与Cache大小和Way的关系</p><ul><li>Cache越大，命中率越高</li><li>Way的数量与命中率成正比</li></ul><p>块的大小与命中率：比较复杂。</p><ul><li>一般而言，增加块大小将降低缺失率（因为空间局部性），但块大小达到一定程度时，缺失率会随块大小的继续增加而上升（因为块数量下降带来块替换的增加）；</li><li>单纯增加块大小带来缺失代价（缺失损失）的增大。</li></ul><h2 id="第八讲：外部存储与虚拟存储">第八讲：外部存储与虚拟存储<a class="anchor" href="#第八讲：外部存储与虚拟存储">·</a></h2><h3 id="一．外部存储设备">一．外部存储设备<a class="anchor" href="#一．外部存储设备">·</a></h3><h4 id="1-磁表面存储器">1.磁表面存储器<a class="anchor" href="#1-磁表面存储器">·</a></h4><h5 id="磁表面存储原理">磁表面存储原理<a class="anchor" href="#磁表面存储原理">·</a></h5><h6 id="磁表面存储器">磁表面存储器<a class="anchor" href="#磁表面存储器">·</a></h6><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/801.png" style="zoom:50%;"><h6 id="记录原理">记录原理<a class="anchor" href="#记录原理">·</a></h6><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/802.png" style="zoom: 50%;"><h5 id="硬磁盘基本结构">硬磁盘基本结构<a class="anchor" href="#硬磁盘基本结构">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/803.png" style="zoom:50%;"><h5 id="磁盘存储结构（恒定角速度，CAV）">磁盘存储结构（恒定角速度，CAV）<a class="anchor" href="#磁盘存储结构（恒定角速度，CAV）">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/804.png" style="zoom:50%;"><h5 id="扇区的地址表示">扇区的地址表示<a class="anchor" href="#扇区的地址表示">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/805.png" style="zoom:50%;"><h5 id="磁盘存储结构（多重区域纪录，multiple-zone-recording）">磁盘存储结构（多重区域纪录，multiple zone recording）<a class="anchor" href="#磁盘存储结构（多重区域纪录，multiple-zone-recording）">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/806.png" style="zoom: 50%;"><h5 id="扇区数据格式示例（Segate-ST506-磁盘扇区格式）">扇区数据格式示例（Segate ST506 磁盘扇区格式）<a class="anchor" href="#扇区数据格式示例（Segate-ST506-磁盘扇区格式）">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/807.png" style="zoom:50%;"><h5 id="磁盘的性能参数">磁盘的性能参数<a class="anchor" href="#磁盘的性能参数">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/808.png" style="zoom:50%;"><h4 id="2-光盘存储器">2.光盘存储器<a class="anchor" href="#2-光盘存储器">·</a></h4><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/809.png" style="zoom:50%;"><h5 id="CD-ROM的数据格式">CD-ROM的数据格式<a class="anchor" href="#CD-ROM的数据格式">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/8010.png" style="zoom:50%;"><h5 id="CD-R（Recordables）">CD-R（Recordables）<a class="anchor" href="#CD-R（Recordables）">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/8011.png" style="zoom:50%;"><h5 id="DVD（Digital-Video-Disk）">DVD（Digital Video Disk）<a class="anchor" href="#DVD（Digital-Video-Disk）">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/8012.png" style="zoom:40%;"><h3 id="二．虚拟存储系统">二．虚拟存储系统<a class="anchor" href="#二．虚拟存储系统">·</a></h3><h4 id="程序员的程序空间">程序员的程序空间<a class="anchor" href="#程序员的程序空间">·</a></h4><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/810.png" style="zoom:50%;"><h4 id="1-概述">1.概述<a class="anchor" href="#1-概述">·</a></h4><h4 id="2-页式虚拟存储系统">2.页式虚拟存储系统<a class="anchor" href="#2-页式虚拟存储系统">·</a></h4><h5 id="基本概念">基本概念<a class="anchor" href="#基本概念">·</a></h5><h6 id="基本思想">基本思想<a class="anchor" href="#基本思想">·</a></h6><ul><li>内存按照固定的大小分页（存储页，实页），每个进程也按相同大小分页（程序页，虚页）；</li><li>内存按页顺序编号（实页号），每个独立编址的程序（进程）空间有自己的页号顺序（虚页号）；</li><li>操作系统将辅助存储器中进程的虚页装入到内存中的实页中；</li><li>进程运行无需占用连续的实页，也无需把所有的虚页都装入内存；</li><li>操作系统为每一个进程维护一个页表（page table），通过页表实现逻辑地址到物理地址的转换。地址转换由CPU中的MMU实现。</li></ul><p><strong>逻辑地址</strong>：程序中指令所使用的地址，也称虚拟地址或虚地址</p><p><strong>物理地址</strong>：内存中存放指令或数据的实际地址，也称实际地址或实地址</p><h6 id="页式调度：按页交换">页式调度：按页交换<a class="anchor" href="#页式调度：按页交换">·</a></h6><p>优点：页内零头小，页表对程序员来说是透明的，地址变换快，调入操作简单；</p><p>缺点：各页不是程序的独立模块，不便于实现程序和数据保护。</p><h5 id="页表">页表<a class="anchor" href="#页表">·</a></h5><p><strong>页表</strong>：记录虚页与实页的映射关系，实现虚实地址的转换，页表建立在内存中，操作系统为每道程序建立一个页表。页表用虚页号作为索引，页表项包括虚页对应的实页号和有效位。</p><p><strong>页表寄存器</strong>：保存页表在内存中的首地址。</p><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/811.png" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/812.png" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/813.png" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/814.png" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/815.png" style="zoom:50%;"><h5 id="加快地址转换，采用快表TLB（Translation-Lookaside-Buffer，转换后备缓冲器）">加快地址转换，采用快表TLB（Translation Lookaside Buffer，转换后备缓冲器）<a class="anchor" href="#加快地址转换，采用快表TLB（Translation-Lookaside-Buffer，转换后备缓冲器）">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/816.png" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/817.png" style="zoom:50%;"><h5 id="完整流程">完整流程<a class="anchor" href="#完整流程">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/818.png" style="zoom:50%;"><h5 id="CPU通过TLB和Cache访问的全过程">CPU通过TLB和Cache访问的全过程<a class="anchor" href="#CPU通过TLB和Cache访问的全过程">·</a></h5><ul><li>TLB和Cache都采用组相联</li><li>以虚拟页号为依据访问TLB获取物理页号</li><li>以物理地址为依据访问Cache获取最终数据</li></ul><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/819.png" style="zoom:70%;"><h5 id="TLB，页表，Cache三种缺失的可能性">TLB，页表，Cache三种缺失的可能性<a class="anchor" href="#TLB，页表，Cache三种缺失的可能性">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/8110.png" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/8111.png" style="zoom:50%;"><h5 id="举例">举例<a class="anchor" href="#举例">·</a></h5><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/8112.png" style="zoom:50%;">]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-CO-2020 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散数学2</title>
      <link href="2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/"/>
      <url>2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/</url>
      
        <content type="html"><![CDATA[<h1 id="离散数学2"><a href="#离散数学2" class="headerlink" title="离散数学2"></a>离散数学2</h1><h1 id="集合论"><a href="#集合论" class="headerlink" title="集合论"></a>集合论</h1><h2 id="第五章-集合"><a href="#第五章-集合" class="headerlink" title="第五章 集合"></a>第五章 集合</h2><h3 id="5-1-集合与元素"><a href="#5-1-集合与元素" class="headerlink" title="5.1 集合与元素"></a>5.1 集合与元素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在python中生成n个元素集合(构建集合)</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createset</span><span class="params">(m,n)</span>:</span></span><br><span class="line">    A=random.sample(range(m), n)</span><br><span class="line">    A=set(A)</span><br><span class="line">    <span class="keyword">return</span> A</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">( )</span>:</span></span><br><span class="line">    m=<span class="number">200</span></span><br><span class="line">    n=<span class="number">100</span></span><br><span class="line">    A=createset(m,n)</span><br><span class="line">    <span class="keyword">return</span> A</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><h4 id="归纳定义法"><a href="#归纳定义法" class="headerlink" title="归纳定义法"></a>归纳定义法</h4><h5 id="1-基本项"><a href="#1-基本项" class="headerlink" title="1) 基本项"></a>1) 基本项</h5><p>非空集 S0 $\subseteq$ A；</p><h5 id="2-归纳项"><a href="#2-归纳项" class="headerlink" title="2) 归纳项"></a>2) 归纳项</h5><p>一组规则，从A中元素出发，依据这些规则 所获得的元素仍然是A中的元素；  </p><h5 id="3-极小化"><a href="#3-极小化" class="headerlink" title="3) 极小化"></a>3) 极小化</h5><p>保证 A中每个元素都可通过有限次使用 1) 或 2) 来获得。如果集合 S $\subseteq$ A 也满足 1)和 2)，则 A $\subseteq$ S 。（如果集合 S $\subseteq$ A 也满足 1)和 2)，则 S = A ）</p><ul><li>极小化保证 A 是满足 1) 和 2) 的<strong>最小集合</strong>。</li></ul><h3 id="5-2-集合间的相等和包含关系"><a href="#5-2-集合间的相等和包含关系" class="headerlink" title="5.2 集合间的相等和包含关系"></a>5.2 集合间的相等和包含关系</h3><h4 id="集合相等"><a href="#集合相等" class="headerlink" title="集合相等"></a>集合相等</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/5.2.1.png" style="zoom: 33%;"></p><h4 id="集合的包含关系（真子集，子集）"><a href="#集合的包含关系（真子集，子集）" class="headerlink" title="集合的包含关系（真子集，子集）"></a>集合的包含关系（真子集，子集）</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/5.2.2.png" style="zoom: 50%;"></p><h4 id="空集是唯一的"><a href="#空集是唯一的" class="headerlink" title="空集是唯一的"></a>空集是唯一的</h4><h3 id="5-3-幂集"><a href="#5-3-幂集" class="headerlink" title="5.3 幂集"></a>5.3 幂集</h3><h4 id="幂集"><a href="#幂集" class="headerlink" title="幂集"></a>幂集</h4><p>集合 A 的全部子集构成的集合称为<strong>A的幂集</strong>, 记作$\rho(A)$。    ρ (A) = { X│X $\subseteq$A }</p><p>$B\subseteq C \Leftrightarrow B\in \rho(C)$</p><h4 id="基数"><a href="#基数" class="headerlink" title="基数"></a>基数</h4><p>有穷集合A中所含有元素的个数称为<strong>A的基数</strong>。 记作<strong>#A</strong></p><h4 id="幂集特征"><a href="#幂集特征" class="headerlink" title="幂集特征"></a>幂集特征</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/5.3.1.png" style="zoom:50%;"></p><h3 id="5-4-集合的运算"><a href="#5-4-集合的运算" class="headerlink" title="5.4 集合的运算"></a>5.4 集合的运算</h3><ul><li>集合运算：∩、∪、~（补，也称绝对补）、$-$（差 ，也称相对补）、$\oplus$（对称差） </li><li>n个集合的∩和∪，集合的聚合上的∩和∪。</li></ul><h4 id="集合族或集合的聚合"><a href="#集合族或集合的聚合" class="headerlink" title="集合族或集合的聚合"></a>集合族或集合的聚合</h4><p>如果一个集合的所有元素都是集合，则称该集合为集合族或集合的聚合。</p><h4 id="等值式模式"><a href="#等值式模式" class="headerlink" title="等值式模式"></a>等值式模式</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/5.4.4.png" style="zoom:50%;"></p><h4 id="集合恒等式"><a href="#集合恒等式" class="headerlink" title="集合恒等式"></a>集合恒等式</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/5.4.1.png" style="zoom:50%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/5.4.2.png" alt="5.4.2" style="zoom:50%;"></p><h4 id="对集合恒等式的说明"><a href="#对集合恒等式的说明" class="headerlink" title="对集合恒等式的说明"></a>对集合恒等式的说明</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/5.4.3.png" style="zoom:50%;"></p><h4 id="其他常用性质"><a href="#其他常用性质" class="headerlink" title="其他常用性质"></a>其他常用性质</h4><ol><li><p>$A-B=A\cap \sim B$</p></li><li><p>设 A 和 B是全集U的子集，$B=\sim A$当且仅当 A $\cup$ B = U 和 A $\cap$ B = $\varnothing$</p></li><li><p>设 A 和 B是全集U的子集，则<strong>下列命题等价</strong>：</p><p>（1）A $\subseteq$ B </p><p>（2）A $\cup$ B = B</p><p>（3）A $\cap$ B = A</p><p>（4）A $-$ B = $\varnothing$</p><p>注：<strong>该定理常用于证明两个集合的包含关系</strong>。</p></li></ol><p>证明（I）两个集合相等常用以下两种方法：<br>1）集合相等定义 (元素分析法）<br>2）集合恒等式 （等式推理）</p><h3 id="5-5-有穷集的计数原理"><a href="#5-5-有穷集的计数原理" class="headerlink" title="5.5 有穷集的计数原理"></a>5.5 有穷集的计数原理</h3><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/5.5.1.png" style="zoom:50%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/5.5.2.png" alt="5.5.2" style="zoom:50%;"></p><h3 id="5-6-集合的归纳定义法"><a href="#5-6-集合的归纳定义法" class="headerlink" title="5.6 集合的归纳定义法"></a>5.6 集合的归纳定义法</h3><h4 id="定义程式"><a href="#定义程式" class="headerlink" title="定义程式"></a>定义程式</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/5.6.1.png" style="zoom:50%;"></p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/5.6.2.png" style="zoom:50%;"></p><h5 id="字符串相等与连接"><a href="#字符串相等与连接" class="headerlink" title="字符串相等与连接"></a>字符串相等与连接</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/5.6.3.png" style="zoom:50%;"></p><h5 id="字符串前缀，后缀，子串，-sum-，-sum"><a href="#字符串前缀，后缀，子串，-sum-，-sum" class="headerlink" title="字符串前缀，后缀，子串，$\sum *$，$\sum +$"></a>字符串前缀，后缀，子串，$\sum *$，$\sum +$</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/5.6.4.png" alt="5.6.4" style="zoom:50%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/5.6.5.png" alt="5.6.5" style="zoom:50%;"></p><h5 id="语言，语言的运算，关系性质"><a href="#语言，语言的运算，关系性质" class="headerlink" title="语言，语言的运算，关系性质"></a>语言，语言的运算，关系性质</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/5.6.6.png" alt="5.6.6" style="zoom:50%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/5.6.7.png" alt="5.6.7" style="zoom:50%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/5.6.8.png" alt="5.6.8" style="zoom:50%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/5.6.9.png" alt="5.6.9" style="zoom:50%;"></p><h3 id="5-7-有序偶和笛卡儿乘积"><a href="#5-7-有序偶和笛卡儿乘积" class="headerlink" title="5.7 有序偶和笛卡儿乘积"></a>5.7 有序偶和笛卡儿乘积</h3><h4 id="有序偶"><a href="#有序偶" class="headerlink" title="有序偶"></a>有序偶</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>任给两个对象 x 和 y，将它们按规定的顺序构成的序列，称之为有序偶，记为<strong>〈 x，y 〉</strong>。</p><p>x 称为有序偶的第一元，y 称为第二元。</p><h5 id="有序偶的集合表示"><a href="#有序偶的集合表示" class="headerlink" title="有序偶的集合表示"></a>有序偶的集合表示</h5><p>〈 x，y 〉= { { x }，{ x，y } }</p><h5 id="n元序偶"><a href="#n元序偶" class="headerlink" title="n元序偶"></a>n元序偶</h5><h4 id="笛卡儿乘积"><a href="#笛卡儿乘积" class="headerlink" title="笛卡儿乘积"></a>笛卡儿乘积</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>A×B = {〈x，y〉| x$\in$A $\wedge$ y $\in$ B }</p><h5 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h5><p>(1) 不满足 交换律<br>(2) 不满足 结合律<br>(3) 当A = $\varnothing$ 或 B = $\varnothing$ 时，A×B = $\varnothing$<br>(4) # (A×B) = #A · #B (A，B 为任意有限集)</p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/5.7.1.png" style="zoom:50%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/5.7.2.png" alt="5.7.2" style="zoom:50%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/5.7.3.png" alt="5.7.3" style="zoom:50%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/5.7.4.png" alt="5.7.4" style="zoom:50%;"></p><h2 id="第六章-关系"><a href="#第六章-关系" class="headerlink" title="第六章 关系"></a>第六章 关系</h2><h3 id="6-1-关系及其性质"><a href="#6-1-关系及其性质" class="headerlink" title="6.1 关系及其性质"></a>6.1 关系及其性质</h3><h4 id="一、关系的定义"><a href="#一、关系的定义" class="headerlink" title="一、关系的定义"></a>一、关系的定义</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/6.1.2.png" style="zoom:50%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/6.1.3.png" style="zoom:50%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/6.1.1.png" style="zoom:50%;"></p><h4 id="二、关系的表示"><a href="#二、关系的表示" class="headerlink" title="二、关系的表示"></a>二、关系的表示</h4><h5 id="关系矩阵"><a href="#关系矩阵" class="headerlink" title="关系矩阵"></a>关系矩阵</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/6.1.4.png" style="zoom:50%;"></p><h5 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/6.1.5.png" style="zoom:50%;"></p><h4 id="三、关系的性质-自反、反自反、对称、反对称、传递"><a href="#三、关系的性质-自反、反自反、对称、反对称、传递" class="headerlink" title="三、关系的性质(自反、反自反、对称、反对称、传递)"></a>三、关系的性质(自反、反自反、对称、反对称、传递)</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/6.1.6.png" style="zoom:50%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/6.1.7.png" alt="6.1.7" style="zoom:50%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/6.1.8.png" alt="6.1.8" style="zoom: 50%;"></p><h5 id="关系图和关系矩阵中五种性质的表述"><a href="#关系图和关系矩阵中五种性质的表述" class="headerlink" title="关系图和关系矩阵中五种性质的表述"></a>关系图和关系矩阵中五种性质的表述</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/6.1.9.png" style="zoom:50%;"></p><h5 id="思考题：设-A-为恰有-n-个元素的有限集A"><a href="#思考题：设-A-为恰有-n-个元素的有限集A" class="headerlink" title="思考题：设 A 为恰有 n 个元素的有限集A"></a>思考题：设 A 为恰有 n 个元素的有限集A</h5><p>可以以3个元素的集合=={1,2,3}==举例</p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/6.1.10.png" style="zoom: 67%;"></p><h3 id="6-2-关系的运算"><a href="#6-2-关系的运算" class="headerlink" title="6.2 关系的运算"></a>6.2 关系的运算</h3><h4 id="关系的交并差补集"><a href="#关系的交并差补集" class="headerlink" title="关系的交并差补集"></a>关系的交并差补集</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/6.2.1.png" style="zoom:50%;"></p><h4 id="复合关系"><a href="#复合关系" class="headerlink" title="复合关系"></a>复合关系</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/6.2.2.png" style="zoom:50%;"></p><h5 id="复合关系的结合律"><a href="#复合关系的结合律" class="headerlink" title="复合关系的结合律"></a>复合关系的结合律</h5><p>设R，S，P分别是X 到 Y、 Y 到 Z、 Z 到 W的关系，则 ( R · S ) · P ＝ R · ( S · P ) 。</p><h5 id="关系的幂运算"><a href="#关系的幂运算" class="headerlink" title="关系的幂运算"></a>关系的幂运算</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/6.2.3.png" style="zoom:50%;"></p><h5 id="用矩阵运算来表示两个关系的复合"><a href="#用矩阵运算来表示两个关系的复合" class="headerlink" title="用矩阵运算来表示两个关系的复合"></a>用矩阵运算来表示两个关系的复合</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/6.2.4.png" style="zoom:50%;"></p><h5 id="关系复合的性质"><a href="#关系复合的性质" class="headerlink" title="关系复合的性质"></a>关系复合的性质</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/6.2.8.png" style="zoom:50%;"></p><h4 id="关系的逆"><a href="#关系的逆" class="headerlink" title="关系的逆"></a>关系的逆</h4><p>将关系R中每个有序偶的第一元和第二元对换所得到的关系, 称为R的逆关系，记作$R^{-1}$，</p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/6.2.5.png" style="zoom:50%;"></p><h5 id="关系的一个逆运算定理"><a href="#关系的一个逆运算定理" class="headerlink" title="关系的一个逆运算定理"></a>关系的一个逆运算定理</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/6.2.9.png" style="zoom:50%;"></p><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/6.2.6.png" style="zoom:50%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/6.2.7.png" style="zoom:50%;"></p><h4 id="二元关系性质的判断条件"><a href="#二元关系性质的判断条件" class="headerlink" title="二元关系性质的判断条件"></a>二元关系性质的判断条件</h4><p>利用<strong>矩阵</strong>思考更方便</p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/6.2.10.png" style="zoom:50%;"></p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>记忆：$r-&gt;reverse,s-&gt;symmetric,t-&gt;transmit$ </p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/6.2.11.png" style="zoom:50%;"></p><h5 id="用闭包来判断是否自反、对称、传递"><a href="#用闭包来判断是否自反、对称、传递" class="headerlink" title="用闭包来判断是否自反、对称、传递"></a>用闭包来判断是否自反、对称、传递</h5><p>1）R是自反的 当且仅当 r(R) ＝ R； </p><p>2）R是对称的 当且仅当 s(R) ＝ R；</p><p>3）R是传递的 当且仅当 t(R) ＝ R 。</p><h5 id="定理-6-3-设-R-是集合A上的关系，则-r-R-＝-R∪I-A-。"><a href="#定理-6-3-设-R-是集合A上的关系，则-r-R-＝-R∪I-A-。" class="headerlink" title="定理 6.3 设 R 是集合A上的关系，则 $r (R) ＝ R∪I_A$。"></a>定理 6.3 设 R 是集合A上的关系，则 $r (R) ＝ R∪I_A$。</h5><h5 id="定理-6-4-设-R-是集合-A-上的关系，则-s-R-＝-R∪R-1-。"><a href="#定理-6-4-设-R-是集合-A-上的关系，则-s-R-＝-R∪R-1-。" class="headerlink" title="定理 6.4 设 R 是集合 A 上的关系，则 $s (R) ＝ R∪R^{-1}$ 。"></a>定理 6.4 设 R 是集合 A 上的关系，则 $s (R) ＝ R∪R^{-1}$ 。</h5><h5 id="定理-6-5-设-R-是集合A上的关系，则-t-R-R∪R-2∪R-3∪…∪R-n"><a href="#定理-6-5-设-R-是集合A上的关系，则-t-R-R∪R-2∪R-3∪…∪R-n" class="headerlink" title="定理 6.5 设 R 是集合A上的关系，则 $t(R) = R∪R^2∪R^3∪…∪R^n$"></a>定理 6.5 设 R 是集合A上的关系，则 $t(R) = R∪R^2∪R^3∪…∪R^n$</h5><h5 id="闭包的性质-注意rs-sr-rt-tr-st-ts"><a href="#闭包的性质-注意rs-sr-rt-tr-st-ts" class="headerlink" title="闭包的性质(注意rs/sr/rt/tr/st/ts)"></a>闭包的性质(注意rs/sr/rt/tr/st/ts)</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/6.2.12.png" style="zoom:50%;"></p><p>巧记结论：有自反的交换顺序后仍然相等</p><p><strong>计算顺序</strong>：比如$st(R)$，先算$s(R)$，再算$t(R)$。</p><p>$R^*=自反传递闭包=rt(R)$</p><p>$R^+=传递闭包=t(R)$</p><h3 id="6-3-次序关系"><a href="#6-3-次序关系" class="headerlink" title="6.3 次序关系"></a>6.3 次序关系</h3><h4 id="偏序（半序）关系"><a href="#偏序（半序）关系" class="headerlink" title="偏序（半序）关系"></a>偏序（半序）关系</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/6.3.1.png" style="zoom:50%;"></p><h4 id="全序关系（也称线序）"><a href="#全序关系（也称线序）" class="headerlink" title="全序关系（也称线序）"></a>全序关系（也称线序）</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/6.3.2.png" style="zoom:50%;"></p><h5 id="可比的"><a href="#可比的" class="headerlink" title="可比的"></a>可比的</h5><p>对于偏序集合〈P , ≤〉，x , y ∈P，如果有 x≤y 或者 y≤x，就说P的元素 x 和 y 是<strong>可比</strong>的。</p><p><strong>例</strong>：〈N , ≤〉,〈N , ≥ 〉都是全序结构。它们中的任意元素 x 和 y 都是可比的，而〈 P(A) , $\subseteq$ 〉,〈 $I^+$ , | 〉都不是 全序结构</p><h4 id="严格偏序关系，又称拟序关系"><a href="#严格偏序关系，又称拟序关系" class="headerlink" title="严格偏序关系，又称拟序关系"></a>严格偏序关系，又称拟序关系</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/6.3.3.png" style="zoom:50%;"></p><h5 id="反自反、传递-gt-反对称"><a href="#反自反、传递-gt-反对称" class="headerlink" title="反自反、传递==&gt;反对称"></a>反自反、传递==&gt;反对称</h5><h4 id="遮盖"><a href="#遮盖" class="headerlink" title="遮盖"></a>遮盖</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/6.3.4.png" style="zoom:50%;"></p><h4 id="哈斯图"><a href="#哈斯图" class="headerlink" title="哈斯图"></a>哈斯图</h4><p>偏序结构通常用简化的关系图来表示，这种关系图称为偏序结构图或哈斯图。</p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/6.3.5.png" style="zoom:50%;"></p><h4 id="偏序结构中的特殊元素（最大元，最小元，极大元，极小元，最大上界，最小下界）"><a href="#偏序结构中的特殊元素（最大元，最小元，极大元，极小元，最大上界，最小下界）" class="headerlink" title="偏序结构中的特殊元素（最大元，最小元，极大元，极小元，最大上界，最小下界）"></a>偏序结构中的特殊元素（最大元，最小元，极大元，极小元，最大上界，最小下界）</h4><p>极大元，极小元——仅仅是不存在比这些更大（小）的元素，可以是因为关系并不是全序产生的</p><p>最大元，最小元，最大上界，最小下界——每个元素（上下界）都要比这个元素（上下界）小（大），条件更强</p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/6.3.6.png" style="zoom:50%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/6.3.7.png" alt="6.3.7" style="zoom:50%;"></p><h4 id="良序结构"><a href="#良序结构" class="headerlink" title="良序结构"></a>良序结构</h4><ul><li>一个偏序结构〈P , ≤〉，如果 P的<strong>每一个非空子集都有一个最小元</strong>，则称<strong>≤</strong>为<strong>良序关系</strong>，〈P , ≤〉为<strong>良序结构</strong>。</li><li>每个良序结构都是全序结构（因为对于任意非空子集都有最小元）</li><li>但<strong>并非每个全序结构都是良序</strong>的，当然<strong>有穷的全序结构</strong>一定是良序的。<ul><li>例子：〈N , ≤〉是全序结构，也是良序结构；〈I , ≤〉是全序结构，但不是良序结构。</li></ul></li></ul><h5 id="良序的充要条件"><a href="#良序的充要条件" class="headerlink" title="良序的充要条件"></a>良序的充要条件</h5><p><strong>定理A</strong> 若≤为集合P上的偏序关系，则 ≤ 为P上良序关系，当且仅当  1）≤为P上的全序关系； 2）P 的每个非空子集都有最小元。</p><p><strong>定理B</strong> 设〈A, ≤〉为全序结构，则〈A, ≤〉是良序结构的充要条件是：不存在 A 中元素的无穷序列 a0 , a1 , a2 , … ,使得对每个 i$\in$N，皆有  $a_{i+1}&lt;a_i$——简单地说就是<strong>不存在 A 中元素的无穷递降序列</strong>。</p><h3 id="6-4-等价关系与划分"><a href="#6-4-等价关系与划分" class="headerlink" title="6.4 等价关系与划分"></a>6.4 等价关系与划分</h3><h4 id="等价关系"><a href="#等价关系" class="headerlink" title="等价关系"></a>等价关系</h4><p>集合A上的关系R是<strong>自反，对称，传递</strong>的，则称R为A上的等价关系。</p><p>对于任意正整数 m，<strong>模m同余关系</strong>是<strong>等价关系</strong>。</p><h4 id="等价类"><a href="#等价类" class="headerlink" title="等价类"></a>等价类</h4><p>设 R 是集合A上的等价关系。对于每个x∈A，<strong>A中与 x 有关系 R 的元素的集合</strong> 称为 <strong>x关于R的等价类</strong>，简称为 x 的等价类，记作 <strong>[ x ] $_R$</strong>，</p><p>[ x ] $_R$ ＝｛ y｜y∈A ∧ x R y ｝</p><h5 id="等价类相关定理"><a href="#等价类相关定理" class="headerlink" title="等价类相关定理"></a>等价类相关定理</h5><p>(1) 对于每个 x∈A，x∈[x] $_R$ ，即 [x]$_R$ 是A的非空子集。 </p><p>(2) [x]$_R$＝[y]$_R$当且仅当 x R y 。</p><p> (3) 若 x, y∈A 且 x$\overline R$y，则 [x]$_R$$\cap$ [y]$_R$ = $\varnothing$ 。</p><p> (4) $\bigcup_{x \in A} [x]_R$＝ A, 其中 [x]$_R$ 表示所有等价类的并集。</p><h4 id="商集（全体元素等价类集合组成的集合）"><a href="#商集（全体元素等价类集合组成的集合）" class="headerlink" title="商集（全体元素等价类集合组成的集合）"></a>商集（全体元素等价类集合组成的集合）</h4><p>定义 设 R是集合A上的等价关系，所有等价类组成的集合称为 A 关于 R 的商集，记作 A / R，即:  A / R ＝｛ [x]$_R$｜ x ∈A ｝</p><h4 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分</h4><p>设 A 是非空集合, π$\subseteq$ρ(A) (即π包含 A 的若干子集)。 若π满足以下三个条件，则称π为 A上的一个划分: (1) 对于每个 S∈π，S ≠ $\varnothing$； (2) 对于任意 B, C ∈π，若 B≠C，则 B $\cap$ C＝$\varnothing$； （若 B $\cap$ C ≠$\varnothing$，则B ＝ C） (3) $\cup \pi$ ＝ A 。</p><p>把π中的元素称为<strong>划分块</strong>，π中<strong>划分块的个数</strong>称为<strong>秩</strong>, 有<strong>有穷个划分块</strong>的划分称为<strong>有穷划分</strong>, 否则称为<strong>无穷划分</strong>.</p><h4 id="等价关系，划分，商集，等价类的关系"><a href="#等价关系，划分，商集，等价类的关系" class="headerlink" title="等价关系，划分，商集，等价类的关系"></a>等价关系，划分，商集，等价类的关系</h4><p>非空集合 A 上的<strong>等价关系 R</strong>, 决定了<strong>A上的一个划分</strong>，这个<strong>划分</strong>就是<strong>商集 A / R</strong> 。</p><h5 id="由π确定的等价关系"><a href="#由π确定的等价关系" class="headerlink" title="由π确定的等价关系"></a>由π确定的等价关系</h5><p>定理 设<strong>π是非空集合 A 上的一个划分</strong>，若令：R$<em>{\pi}$ ＝ {〈x, y〉| 存在 S∈π使得 x, y ∈ S ｝ 即: x R$</em>{\pi}$ y 当且仅当 x 和 y 在π的同一个划分块中，则 R$<em>{\pi}$ 必是 A 上的等价关系 且 A／R$</em>{\pi}$ = π。 称 <strong>R$_{\pi}$</strong> 为 由<strong>π确定的等价关系</strong>。</p><p>上述定理表明，由<strong>等价关系能够产生一个划分</strong>。同样，<strong>由一个划分也可以产生一个等价关系</strong>。</p><p>例: U$_X$, I$_X$ 分别是 X 上的全域关系和恒等关系，则 X / U$_X$ = { X }， X / I$_X$ = { {x} | x$\in$X }</p><p>I/$_{=m}$—代表模m同余的等价关系</p><h2 id="第七章-函数"><a href="#第七章-函数" class="headerlink" title="第七章 函数"></a>第七章 函数</h2><p>==一般考试中函数指全函数==</p><h3 id="7-1-基本概念"><a href="#7-1-基本概念" class="headerlink" title="7.1 基本概念"></a>7.1 基本概念</h3><h4 id="函数的定义和判定"><a href="#函数的定义和判定" class="headerlink" title="函数的定义和判定"></a>函数的定义和判定</h4><p>函数是特殊类型的==二元关系==，关系允许，但函数==不允许一对多==。关系和函数都允许多对一。</p><p>函数概念本质是<strong>约束二义性</strong>，主要<strong>限制</strong>的是关系概念中<strong>一对多</strong>。</p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/7.1.1.png" style="zoom:50%;"></p><h5 id="定义域值域"><a href="#定义域值域" class="headerlink" title="定义域值域"></a>定义域值域</h5><p>定义域——$Domain \ of \ definition$</p><p>值域——$Range$</p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/7.1.2.png" style="zoom:50%;"></p><h5 id="部分函数"><a href="#部分函数" class="headerlink" title="部分函数"></a>部分函数</h5><p>如果从集合 X 到 Y 的二元关系是<strong>单值的</strong></p><p>即 f 满足以下条件： 若〈x，y1〉∈f 且〈x，y2〉∈f，则 y1 = y2 。就称 <strong>f</strong> 为从==X 到 Y 的 部分函数(partial function)==。 若 f 是部分函数且〈x , y〉∈f，则称 y 是 f 在 x处的值（在 f 作用下x的<strong>像点</strong>)，记为 y = f (x)，并称 x 为 y 的一个<strong>源像点</strong>。</p><p>部分函数——<strong>部分有定义</strong>的函数——即  $dom(f)\subseteq X$</p><p>设 <strong>f</strong> 为从<strong>集合 X 到集合 Y</strong> 的 <strong>部分函数</strong>.</p><ul><li>若$dom(f)= X$，则称f为从X到Y的一个<strong>全函数</strong>。记为：$f:X\rightarrow Y$</li><li>若$dom(f)\subset X$，则称f为从X到Y的一个<strong>严格部分函数</strong>。</li><li>若$ran(f)=Y$，则称f为从X到Y==上==的一个部分函数。</li><li>若$ran(f)\subset Y$，则称f为从X到Y==内==的一个部分函数。</li><li>若对任意的 x1，x2∈dom (f ) ， 当 x1 ≠ x2 时, 皆有 f ( x1 ) ≠ f ( x2 )， 即: 当 f ( x1 ) = f ( x2 ) 时, 皆有 x1 = x2 ,当 ƒ 为 X 到 Y 的全函数时, f 既满足单值性，且处处有定义</li></ul><h4 id="函数的限制-即限制定义域"><a href="#函数的限制-即限制定义域" class="headerlink" title="函数的限制(即限制定义域)"></a>函数的限制(即限制定义域)</h4><p>设函数ƒ : X→Y，A $\subseteq$ X，则ƒ∩ (A×Y) 是 从 A 到 Y 的函数，称为 ƒ 在 A上的限制 ，记作 ƒ│$_A$ , 又称 ƒ 为 ƒ│$_A$到 X 的 延拓 。 ƒ│$_A$可表示为：ƒ│$_A$ ＝｛〈x , y〉│〈x , y〉∈ƒ ∧ x∈A｝</p><h4 id="部分函数的像和源像"><a href="#部分函数的像和源像" class="headerlink" title="部分函数的像和源像"></a>部分函数的像和源像</h4><p>设 f 为从集合 X 到集合 Y 的部分函数，A $\subseteq$X 且 B$\subseteq$ Y。</p><p>令f [A] = { y｜有 x ∈A 使 y = f (x) }<br>f$^{-1}$[ B ] = { x ∈X｜有 y ∈B 使 y = f (x) } </p><p>称 f [ A ] 为 <strong>A 在 f 下的像</strong>，f $^{-1}$ [ B ] 为 <strong>B 在 f 下的源像</strong>。</p><p>即： f [A] = { f (x)｜x ∈A 且 f (x)↓ }    f $^{-1}$ [ B ] = { x ∈X ｜ f (x)↓ 且 f (x) $\subseteq$ B }</p><p>dom (f ) = { x ∈X｜有 y ∈Y 使 y = f (x) } = f $^{-1}$[Y]<br>ran (f ) = { y ｜有 x ∈X 使 y = f (x) } = f [X]</p><h4 id="小结：从集合-X-到-Y-的二元关系-f-几个重要知识点"><a href="#小结：从集合-X-到-Y-的二元关系-f-几个重要知识点" class="headerlink" title="小结：从集合 X 到 Y 的二元关系 f 几个重要知识点"></a>小结：从集合 X 到 Y 的二元关系 f 几个重要知识点</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/7.1.3.png" style="zoom:50%;"></p><h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><h5 id="设-f-为从集合-X-到集合-Y-的部分函数"><a href="#设-f-为从集合-X-到集合-Y-的部分函数" class="headerlink" title="设 f 为从集合 X 到集合 Y 的部分函数"></a>设 f 为从集合 X 到集合 Y 的部分函数</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/7.1.4.png" style="zoom: 50%;"></p><h5 id="设-f-为从集合X到Y的部分函数-A-subseteq-ρ-X-В-subseteq-ρ-Y"><a href="#设-f-为从集合X到Y的部分函数-A-subseteq-ρ-X-В-subseteq-ρ-Y" class="headerlink" title="设 f 为从集合X到Y的部分函数, Ａ $\subseteq$ ρ (X), В $\subseteq$ ρ (Y)"></a>设 f 为从集合X到Y的部分函数, Ａ $\subseteq$ ρ (X), В $\subseteq$ ρ (Y)</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/7.1.5.png" style="zoom:50%;"></p><h5 id="定理-若-f-为从集合-X-到-Y-的部分函数-且-A-subseteq-X-，则"><a href="#定理-若-f-为从集合-X-到-Y-的部分函数-且-A-subseteq-X-，则" class="headerlink" title="定理 若 f 为从集合 X 到 Y 的部分函数 且 A $\subseteq$ X ，则"></a>定理 若 f 为从集合 X 到 Y 的部分函数 且 A $\subseteq$ X ，则</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/7.1.6.png" style="zoom:50%;"></p><h4 id="X到Y的全函数集合"><a href="#X到Y的全函数集合" class="headerlink" title="X到Y的全函数集合"></a>X到Y的全函数集合</h4><p>$Y^X=$ {$f|f:X \rightarrow Y$} 从X到Y的函数个数？    $Y^X$个 即：#$Y$^(#$X$)个</p><h4 id="两道例题"><a href="#两道例题" class="headerlink" title="两道例题"></a>两道例题</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/7.1.7.png" style="zoom:50%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/718.png" style="zoom:50%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/719.png" alt="719" style="zoom:50%;"></p><h3 id="7-2-函数的复合"><a href="#7-2-函数的复合" class="headerlink" title="7.2 函数的复合"></a>7.2 函数的复合</h3><h4 id="复合关系与对应函数"><a href="#复合关系与对应函数" class="headerlink" title="复合关系与对应函数"></a>复合关系与对应函数</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/7110.png" style="zoom:50%;"></p><h4 id="函数复合的约定写法"><a href="#函数复合的约定写法" class="headerlink" title="函数复合的约定写法"></a>函数复合的约定写法</h4><p>$h(x)=f(g(x))$</p><p>关系：内层的函数符号$g$在左</p><p>函数：内层的函数符号$g$在右</p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/7111.png" style="zoom:50%;"></p><h4 id="函数复合的定义"><a href="#函数复合的定义" class="headerlink" title="函数复合的定义"></a>函数复合的定义</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/7112.png" style="zoom:50%;"></p><h4 id="复合函数的定义域与值域"><a href="#复合函数的定义域与值域" class="headerlink" title="复合函数的定义域与值域"></a>复合函数的定义域与值域</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/7113.png" style="zoom:50%;"></p><h4 id="函数复合运算的性质"><a href="#函数复合运算的性质" class="headerlink" title="函数复合运算的性质"></a>函数复合运算的性质</h4><h5 id="恒等函数"><a href="#恒等函数" class="headerlink" title="恒等函数"></a>恒等函数</h5><p>集合 X上的恒等关系 $I_X$ = {〈x, x〉| x∈X } 为 X 到 X 的恒等函数。</p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/7114.png" style="zoom:50%;"></p><h5 id="结合律"><a href="#结合律" class="headerlink" title="结合律"></a>结合律</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/7115.png" style="zoom:50%;"></p><h5 id="函数的幂运算"><a href="#函数的幂运算" class="headerlink" title="函数的幂运算"></a>函数的幂运算</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/7116.png" style="zoom:50%;"></p><h3 id="7-3-特殊性质的函数和逆函数"><a href="#7-3-特殊性质的函数和逆函数" class="headerlink" title="7.3 特殊性质的函数和逆函数"></a>7.3 特殊性质的函数和逆函数</h3><h4 id="满射、单射、双射"><a href="#满射、单射、双射" class="headerlink" title="满射、单射、双射"></a>满射、单射、双射</h4><p>全函数：$f:X\rightarrow Y $</p><p>满射：$ran(f)=Y$</p><p>单射：$\forall x_1 \in X ,\forall x_2 \in X (x_1\neq x_2\rightarrow f(x_1)\neq f(x_2))$</p><p>双射：单满射</p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/7.1.8.png" style="zoom: 33%;"></p><p>常值函数：$\forall x\in X,\exists c \in Y,f(x)=c$</p><h4 id="函数与复合函数-之间的性质关系-定理"><a href="#函数与复合函数-之间的性质关系-定理" class="headerlink" title="函数与复合函数 之间的性质关系 定理"></a>函数与复合函数 之间的性质关系 定理</h4><p>$f:X\rightarrow Y ,g:X\rightarrow Y$</p><p>(1) $若f、g是满射,g\circ f也是满射$</p><p>(2) $若f、g是单射,g\circ f也是单射$</p><p>(3) $若f、g是双射,g\circ f也是双射$</p><h5 id="规则：左满-右单"><a href="#规则：左满-右单" class="headerlink" title="规则：左满 右单"></a>规则：左满 右单</h5><p>(1) $若g\circ f是满射,则g是满射$</p><p>(2) $若g\circ f是单射,则f是单射$</p><p>(3) $若g\circ f双射,则g是满射且f是单射$</p><h4 id="左逆、右逆、逆（逆-lt-gt-一个函数同时为左逆和右逆）"><a href="#左逆、右逆、逆（逆-lt-gt-一个函数同时为左逆和右逆）" class="headerlink" title="左逆、右逆、逆（逆&lt;=&gt;一个函数同时为左逆和右逆）"></a>左逆、右逆、逆（逆&lt;=&gt;一个函数同时为左逆和右逆）</h4><h5 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/7.1.9.png" style="zoom:33%;"></p><h5 id="唯一逆"><a href="#唯一逆" class="headerlink" title="唯一逆"></a>唯一逆</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/7.1.11.png" style="zoom:33%;"></p><h5 id="4个可逆的等价条件"><a href="#4个可逆的等价条件" class="headerlink" title="4个可逆的等价条件"></a>4个可逆的等价条件</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/7.1.12.png" alt="7.1.12" style="zoom:33%;"></p><h5 id="复合函数的逆"><a href="#复合函数的逆" class="headerlink" title="复合函数的逆"></a>复合函数的逆</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/7.1.13.png" alt="7.1.13" style="zoom:33%;"></p><h3 id="7-4-集合的特征函数"><a href="#7-4-集合的特征函数" class="headerlink" title="7.4 集合的特征函数"></a>7.4 集合的特征函数</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/741.png" style="zoom: 50%;"></p><h4 id="特征函数的性质"><a href="#特征函数的性质" class="headerlink" title="特征函数的性质"></a>特征函数的性质</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/742.png" style="zoom:33%;"><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/743.png" style="zoom:33%;"></p><h4 id="用特征函数证明集合恒等式"><a href="#用特征函数证明集合恒等式" class="headerlink" title="用特征函数证明集合恒等式"></a>用特征函数证明集合恒等式</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/744.png" style="zoom:33%;"> <img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/745.png" style="zoom:33%;"></p><h2 id="第八章-自然数和基数"><a href="#第八章-自然数和基数" class="headerlink" title="第八章 自然数和基数"></a>第八章 自然数和基数</h2><h3 id="8-1-自然数及数学归纳法"><a href="#8-1-自然数及数学归纳法" class="headerlink" title="8.1 自然数及数学归纳法"></a>8.1 自然数及数学归纳法</h3><p><strong>主要概念</strong>：集合的后继<br><strong>主要方法</strong>：归纳原理、第一归纳法、第二归纳法</p><h4 id="自然数引进方法"><a href="#自然数引进方法" class="headerlink" title="自然数引进方法"></a>自然数引进方法</h4><ul><li>公理化方法：皮亚诺公理</li><li>构造性方法：借助集合论，具体构造出N</li></ul><h4 id="自然数构造的出发点"><a href="#自然数构造的出发点" class="headerlink" title="自然数构造的出发点"></a>自然数构造的出发点</h4><p>1) 自然数的==各种性质==( 运算、大小次序 及 基本定律 ) ,都可以从 Peano 公理一一推导出来；</p><p>2) 证明构造出来的 “自然数” ==满足Peano公理==，因此具有普通自然数的一切性质。</p><h4 id="后继集合"><a href="#后继集合" class="headerlink" title="后继集合"></a>后继集合</h4><ul><li>后继集合<strong>定义</strong>：$A^+=A \cup {A}$</li><li>每个集合都有<strong>唯一的一个后继</strong>。</li></ul><h5 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/811.png" style="zoom: 33%;"></p><h4 id="构造自然数系统"><a href="#构造自然数系统" class="headerlink" title="构造自然数系统"></a>构造自然数系统<N,+,*></N,+,*></h4><h5 id="法1：冯诺依曼（Von-Neumann）方案"><a href="#法1：冯诺依曼（Von-Neumann）方案" class="headerlink" title="法1：冯诺依曼（Von Neumann）方案"></a>法1：冯诺依曼（Von Neumann）方案</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/812.png" style="zoom: 33%;"></p><h5 id="法2：自然数集合-N——归纳定义法"><a href="#法2：自然数集合-N——归纳定义法" class="headerlink" title="法2：自然数集合 N——归纳定义法"></a>法2：自然数集合 N——归纳定义法</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/813.png" style="zoom:33%;"></p><h5 id="“小于”-关系"><a href="#“小于”-关系" class="headerlink" title="“小于” 关系"></a>“小于” 关系</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/814.png" style="zoom: 33%;"></p><h5 id="定义“-”和“×”"><a href="#定义“-”和“×”" class="headerlink" title="定义“+”和“×”"></a>定义“+”和“×”</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/815.png" alt="815" style="zoom:33%;"></p><h5 id="引理2"><a href="#引理2" class="headerlink" title="引理2"></a>引理2</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/816.png" alt="816" style="zoom:33%;"></p><h5 id="Peano公理"><a href="#Peano公理" class="headerlink" title="Peano公理"></a>Peano公理</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/817.png" style="zoom:33%;"> <img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/818.png" style="zoom:33%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/8115.png" style="zoom:33%;"></p><h4 id="作为集合的自然数的性质"><a href="#作为集合的自然数的性质" class="headerlink" title="作为集合的自然数的性质"></a>作为集合的自然数的性质</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/8110.png" style="zoom:33%;"></p><h4 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/8111.png" style="zoom:33%;"><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/8112.png" alt="8112" style="zoom:33%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/8114.png" alt="8114" style="zoom:33%;"><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/8113.png" alt="8113" style="zoom:33%;"></p><h3 id="8-2-基数"><a href="#8-2-基数" class="headerlink" title="8.2 基数"></a>8.2 基数</h3><p>本节讨论度量和比较两个集合大小的方法。</p><h4 id="1-等势"><a href="#1-等势" class="headerlink" title="1.等势"></a>1.等势</h4><p>设 A 和 B 为二集合，若存在从 A 到 B 的<strong>双射</strong>，则称 <strong>A 和 B 对等</strong>，或称 <strong>A 和 B 等势</strong>，记为 <strong>A ～ B</strong>。</p><h5 id="等势关系的性质"><a href="#等势关系的性质" class="headerlink" title="等势关系的性质"></a>等势关系的性质</h5><p>对于任何集合 A , B , C ，均有：<br>(1) A ~ A；<br>(2) 若 A ~ B , 则 B ~ A；<br>(3) 若 A ~ B , B ~ C , 则 A ~ C。 </p><p>即等势关系有自反性 , 对称性和传递性，因此等势是集合族上的等价关系。</p><h5 id="集合有穷（可数）的定义"><a href="#集合有穷（可数）的定义" class="headerlink" title="集合有穷（可数）的定义"></a>集合有穷（可数）的定义</h5><p>集合是有穷（可数）的，当且仅当它<strong>与某个自然数集合等势</strong>，否则就是无穷的。</p><h4 id="2-无限集"><a href="#2-无限集" class="headerlink" title="2.无限集"></a>2.无限集</h4><p>无穷集合可以与它本身的真子集等势</p><p>任何无限集都如此，这正是无限集与有限集之间的<strong>本质区别</strong>，也可以把它作为无限集的定义。</p><h5 id="鸽笼原理（抽屉原理）"><a href="#鸽笼原理（抽屉原理）" class="headerlink" title="鸽笼原理（抽屉原理）"></a>鸽笼原理（抽屉原理）</h5><p>任何有限集都不能与它的真子集对等 =&gt;导出有穷集合与无穷集合的根本差别：=&gt;任何与自身真子集等势的集合均是无穷集合 。</p><p>这个定理也叫抽屉原理，可通俗表述为：“如果把 n+1 本书放进 n 个抽屉里，至少在一个抽屉里有两本或两本以上的书。”</p><h5 id="定理8-1-任意有穷集合-A-唯一地与一个自然数等势-。"><a href="#定理8-1-任意有穷集合-A-唯一地与一个自然数等势-。" class="headerlink" title="定理8.1 任意有穷集合 A 唯一地与一个自然数等势 。"></a>定理8.1 任意有穷集合 A 唯一地与一个自然数等势 。</h5><h5 id="定义8-7-有穷集合的基数"><a href="#定义8-7-有穷集合的基数" class="headerlink" title="定义8.7 ( 有穷集合的基数 )"></a>定义8.7 ( 有穷集合的基数 )</h5><p>对于任意有穷集合 A , 存在唯一的自然数 n , 使得 A ~ n, 称 n 为 A 的基数 , 记为 #A （ card (A) 或｜A｜）</p><p>对于无限集的基数，我们规定特殊的记号，例如令#( N ) = $\aleph_0$  是希伯来语的第一个字母，念作阿列夫。</p><h4 id="3-集合的基数"><a href="#3-集合的基数" class="headerlink" title="3.集合的基数"></a>3.集合的基数</h4><h5 id="基数相等和大小顺序"><a href="#基数相等和大小顺序" class="headerlink" title="基数相等和大小顺序"></a>基数相等和大小顺序</h5><p>定义： 设 A 和 B 为二集合。</p><ul><li>1) 如果 A～B，就称 A 和 B 的基数相等，记为 # (A) = # (B)。</li><li>2) 如果存在从 A 到 B 的单射，<br>   就称 A 的基数小于等于 B 的基数，记为 #(A) $\leq$ #(B)，<br>   或称 B 的基数大于等于 A 的基数， 记为 #(B) $\ge$ #(A) 。</li><li>3) 如果 #(A) $\leq$ #(B) 且 #(A) ≠ #(B)，<br>   就称 A 的基数小于 B 的基数，记为 #(A) &lt; #(B)，<br>   或称 B 的基数大于 A 的基数，记为 #(B) &gt; #(A)。</li></ul><h5 id="任何两个基数都可以比较大小"><a href="#任何两个基数都可以比较大小" class="headerlink" title="任何两个基数都可以比较大小"></a>任何两个基数都可以比较大小</h5><p>设 A 和 B 为任意两个集合，则#(A) $\leq$ #(B) ，或 #(B) $\leq$ #(A) ，二者之中至少有一个成立。</p><h5 id="基数的相等关系-“-”-是等价关系"><a href="#基数的相等关系-“-”-是等价关系" class="headerlink" title="基数的相等关系 “ = ” 是等价关系"></a>基数的相等关系 “ = ” 是等价关系</h5><p>设 A、B 和 C为三集合，则有<br>1） #(A) = #(A)； 2）若 #(A) = #(B)，则 #(B) = #(A)； 3）若 #(A) = #(B) 且 #(B) = #(C)， 则 #(A) = #(C)</p><h5 id="基数的小于等于关系“-leq-”是半序关系"><a href="#基数的小于等于关系“-leq-”是半序关系" class="headerlink" title="基数的小于等于关系“ $\leq$ ”是半序关系"></a>基数的小于等于关系“ $\leq$ ”是半序关系</h5><p>设 A，B 和 C 为三集合，则有</p><p>1) #(A) $\leq$ #(A)；<br>2) 若 #(A) $\leq$ #(B) 且 #(B) $\leq$ #(A)，则#(A) = #(B)；<br>3) 若 #(A) $\leq$ #(B) 且 #(B) $\leq$ #(C)，则#(A) $\leq$ #(C)。<br>   其中， 2）为著名的 Bernstein 定理。</p><h5 id="定义8-8-基数"><a href="#定义8-8-基数" class="headerlink" title="定义8.8 ( 基数 )"></a>定义8.8 ( 基数 )</h5><p>设 F 是集合族 , ~ 是 F 上的等势关系。关系 ~ 在 F 上的等价类 称为 基数。对于 A $\in$ F , A 所属的等价类用 #A 表示 , 称之为 A 的基数。对于 A , B $\in$ F ： #A = #B $&lt;=&gt;$ A ~ B 。</p><h5 id="定义8-9（可数无穷集合）"><a href="#定义8-9（可数无穷集合）" class="headerlink" title="定义8.9（可数无穷集合）"></a>定义8.9（可数无穷集合）</h5><p>任何与自然数集合等势的集合称为可数无穷集合。可数无穷集合的基数 ， 用 $\aleph_0$ 表示 ，读作阿列夫零 。</p><h5 id="定义8-10（可数、不可数集合-）"><a href="#定义8-10（可数、不可数集合-）" class="headerlink" title="定义8.10（可数、不可数集合 ）"></a>定义8.10（可数、不可数集合 ）</h5><p>如果一个集合是有穷集合或是 可数无穷集合 , 就称它为可数集合 ； 如果一个集合是无穷的，而且不是可数的 ，就称它为不可数集合 。</p><h5 id="无穷集的等价条件"><a href="#无穷集的等价条件" class="headerlink" title="无穷集的等价条件"></a>无穷集的等价条件</h5><p>定理：以下三个条件等价：</p><p>1) A 为无穷集；<br>2) A 有可数无穷子集；<br>3) A 有与它对等的真子集。</p><h5 id="定理8-2：任何无穷集合-必含有-可数无穷子集。"><a href="#定理8-2：任何无穷集合-必含有-可数无穷子集。" class="headerlink" title="定理8.2：任何无穷集合 必含有 可数无穷子集。"></a>定理8.2：任何无穷集合 必含有 可数无穷子集。</h5><h5 id="定理8-3：可数无穷集合的无穷子集-必是-可数无穷的。"><a href="#定理8-3：可数无穷集合的无穷子集-必是-可数无穷的。" class="headerlink" title="定理8.3：可数无穷集合的无穷子集 必是 可数无穷的。"></a>定理8.3：可数无穷集合的无穷子集 必是 可数无穷的。</h5><p>可数无穷集合的并集和可数无穷集合的笛卡儿乘积都仍然是可数无穷集合 =&gt;可以证明：偶数集<strong>E ~ N , N$\times$N ~ N , Q~N , Z ~ N</strong><br>可见：偶数集合、平面上整格点的集合、有理数集合、整数集合都是可数无穷集合。</p><h5 id="定理：实数集合-R-是-不可数的-。"><a href="#定理：实数集合-R-是-不可数的-。" class="headerlink" title="定理：实数集合 R 是 不可数的 。"></a>定理：实数集合 R 是 不可数的 。</h5><p>基数的个数也是无限的，且无最大者</p><h5 id="定理8-4：实数集合-R-是不可数的"><a href="#定理8-4：实数集合-R-是不可数的" class="headerlink" title="定理8.4：实数集合 R 是不可数的"></a>定理8.4：实数集合 R 是不可数的</h5><p>与集合 R 等势的集合的基数 , 用 $\aleph$来表示 , 并称为连续统的势 . #$\rho$ (N) 记为 $\aleph$</p><h5 id="定义-8-14：若-A-alpha-B-beta-且-A-lt-B-则称-alpha-小于-beta-记为-alpha-lt-beta"><a href="#定义-8-14：若-A-alpha-B-beta-且-A-lt-B-则称-alpha-小于-beta-记为-alpha-lt-beta" class="headerlink" title="定义 8.14：若#A = $\alpha$ , #B = $\beta$, 且 A $&lt;$ B , 则称 $\alpha$ 小于 $\beta$ , 记为 $\alpha$ &lt; $\beta$ ."></a>定义 8.14：若#A = $\alpha$ , #B = $\beta$, 且 A $&lt;$ B , 则称 $\alpha$ 小于 $\beta$ , 记为 $\alpha$ &lt; $\beta$ .</h5><p>因为自然数集合是实数集合的真子集 , 由定理 8.4的证明 可知 , 有 N $&lt;$ R 和  $\aleph_0$ &lt; C ;又因为任何无穷集合都包含一个可数无穷子集 , 故 $\aleph_0$ 是最小的无穷基数 . 即对于任何无穷集合 A , 有 N$\leq$A ; 对任何无穷基数 k , 有$\aleph_0\leq$k .</p><h5 id="定理-8-5-对于任意集合-A-A-lt-rho-A-rho-A-是-A-的幂集"><a href="#定理-8-5-对于任意集合-A-A-lt-rho-A-rho-A-是-A-的幂集" class="headerlink" title="定理 8.5 对于任意集合 A , A $&lt;\rho$ (A) , $\rho$ (A)是 A 的幂集."></a>定理 8.5 对于任意集合 A , A $&lt;\rho$ (A) , $\rho$ (A)是 A 的幂集.</h5><h4 id="4-常用结论"><a href="#4-常用结论" class="headerlink" title="4.常用结论"></a>4.常用结论</h4><p>$#(N)=#(N^{+})=#(Q)=\aleph_0$</p><p>$#(R)=#(\rho(N))=\aleph$</p><h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><h3 id="第九章其他资料"><a href="#第九章其他资料" class="headerlink" title="第九章其他资料"></a>第九章其他资料</h3><p>Python工具库：networkx</p><p>官网：<a href="https://networkx.org/" target="_blank" rel="noopener">https://networkx.org/</a></p><p>教程：<a href="https://blog.csdn.net/qq_32284189/article/details/80134768" target="_blank" rel="noopener">https://blog.csdn.net/qq_32284189/article/details/80134768</a></p><h3 id="9-1图论的基本概念-9-2-图的基本结构"><a href="#9-1图论的基本概念-9-2-图的基本结构" class="headerlink" title="9.1图论的基本概念  9.2 图的基本结构"></a>9.1图论的基本概念  9.2 图的基本结构</h3><h4 id="无向图、有向图"><a href="#无向图、有向图" class="headerlink" title="无向图、有向图"></a>无向图、有向图</h4><p>$\Psi:E\rightarrow V \times V:边集到点集的笛卡尔积映射$</p><p>注：V是点集，E是边的集合 <img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/910.png" style="zoom: 50%;"></p><h4 id="自圈、平行边、简单图、多重图"><a href="#自圈、平行边、简单图、多重图" class="headerlink" title="自圈、平行边、简单图、多重图"></a>自圈、平行边、简单图、多重图</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/911.png" style="zoom:50%;"></p><p>图的最本质内容：结点和边的对应关系。=&gt; 用几何图形表示图，小圆圈表示结点</p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/912.png" style="zoom:50%;"></p><h4 id="关联、邻接-——-结点和边的关系"><a href="#关联、邻接-——-结点和边的关系" class="headerlink" title="关联、邻接 —— 结点和边的关系"></a>关联、邻接 —— 结点和边的关系</h4><p>关联：边与点相连的关系</p><p>临接：边与边，或点与点相连的关系</p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/913.png" style="zoom:50%;"> <img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/914.png" style="zoom:50%;"></p><h4 id="度"><a href="#度" class="headerlink" title="度"></a>度</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/915.png" style="zoom:50%;"> <img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/916.png" style="zoom:50%;"></p><h4 id="奇结点、偶结点、孤立点、端点"><a href="#奇结点、偶结点、孤立点、端点" class="headerlink" title="奇结点、偶结点、孤立点、端点"></a>奇结点、偶结点、孤立点、端点</h4><ul><li>度为奇数的结点称为奇结点；</li><li>度为偶数的结点称为偶结点。</li><li>度为 0 的结点称为孤立点；</li><li>度为 1 的结点称为端点。</li></ul><h4 id="零图、平凡图、d度正则图、完全图"><a href="#零图、平凡图、d度正则图、完全图" class="headerlink" title="零图、平凡图、d度正则图、完全图"></a>零图、平凡图、d度正则图、完全图</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/917.png" style="zoom:50%;"></p><h4 id="同-构"><a href="#同-构" class="headerlink" title="同 构"></a>同 构</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/918.png" style="zoom:50%;"></p><h5 id="两个图同构的必要条件"><a href="#两个图同构的必要条件" class="headerlink" title="两个图同构的必要条件"></a>两个图同构的必要条件</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/919.png" style="zoom:50%;"></p><p>以上三条同时成立则是充分条件</p><h3 id="9-2子图和图的运算"><a href="#9-2子图和图的运算" class="headerlink" title="9.2子图和图的运算"></a>9.2子图和图的运算</h3><h4 id="子图、真子图、生成子图"><a href="#子图、真子图、生成子图" class="headerlink" title="子图、真子图、生成子图"></a>子图、真子图、生成子图</h4><p>生成子图：点集与母图一样</p><p>其他两个：点集包含于母图点集</p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/930.png" style="zoom:50%;"></p><h4 id="由结点集导出的子图-G-V’-G-V’-G-V-V’"><a href="#由结点集导出的子图-G-V’-G-V’-G-V-V’" class="headerlink" title="由结点集导出的子图 ($G[V’],G-V’=G[V-V’]$)"></a>由结点集导出的子图 ($G[V’],G-V’=G[V-V’]$)</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/931.png" style="zoom:50%;"></p><h4 id="由边集导出的子图"><a href="#由边集导出的子图" class="headerlink" title="由边集导出的子图"></a>由边集导出的子图</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/932.png" style="zoom:50%;">                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      </p><h4 id="子图的几个特点"><a href="#子图的几个特点" class="headerlink" title="子图的几个特点"></a>子图的几个特点</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/933.png" style="zoom:50%;"></p><h4 id="可运算、不相交"><a href="#可运算、不相交" class="headerlink" title="可运算、不相交"></a>可运算、不相交</h4><p>不相交或者边不相交仍然是可运算的</p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/934.png" style="zoom: 50%;"></p><h4 id="交、并、环和"><a href="#交、并、环和" class="headerlink" title="交、并、环和"></a>交、并、环和</h4><p>注意：环合和并仅只有<strong>边集</strong>不同，点集和$\Psi$运算都为两个图的并集</p><p> <img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/935.png" style="zoom:50%;"></p><h4 id="定理：图的唯一性"><a href="#定理：图的唯一性" class="headerlink" title="定理：图的唯一性"></a>定理：图的唯一性</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/936.png" style="zoom:50%;"></p><h4 id="运算-G-–-E’"><a href="#运算-G-–-E’" class="headerlink" title="运算 G – E’"></a>运算 G – E’</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/937.png" style="zoom:50%;"></p><h4 id="运算-G-E’-psi’-（其实就是并运算）"><a href="#运算-G-E’-psi’-（其实就是并运算）" class="headerlink" title="运算 G + E’$_{\psi’}$（其实就是并运算）"></a>运算 G + E’$_{\psi’}$（其实就是并运算）</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/938.png" style="zoom:50%;"></p><h4 id="补图"><a href="#补图" class="headerlink" title="补图"></a>补图</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/939.png" style="zoom:50%;"></p><h4 id="自补图：与其补图同构的简单无向图"><a href="#自补图：与其补图同构的简单无向图" class="headerlink" title="自补图：与其补图同构的简单无向图"></a>自补图：与其补图同构的简单无向图</h4><h4 id="图同构的必要条件"><a href="#图同构的必要条件" class="headerlink" title="图同构的必要条件"></a>图同构的必要条件</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/920.png" style="zoom:50%;"></p><h3 id="9-3路径、回路和连通性"><a href="#9-3路径、回路和连通性" class="headerlink" title="9.3路径、回路和连通性"></a>9.3路径、回路和连通性</h3><h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><h5 id="定义（路径，路径长度，开、闭路径，简单路径，基本路径）"><a href="#定义（路径，路径长度，开、闭路径，简单路径，基本路径）" class="headerlink" title="定义（路径，路径长度，开、闭路径，简单路径，基本路径）"></a>定义（路径，路径长度，开、闭路径，简单路径，基本路径）</h5><p>简单路径——边无重复</p><p>基本路径——点无重复</p><p>开路径——起点$\neq$终点</p><p>闭路径——起点$=$终点</p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/940.png" style="zoom:40%;"></p><h5 id="路径的另一组术语"><a href="#路径的另一组术语" class="headerlink" title="路径的另一组术语"></a>路径的另一组术语</h5><ul><li><strong>链（chain or walk）</strong>：<strong>顶点和边交错出现的序列</strong>称为链，在序列中边的前后两个顶点正好是边的端点，序列的==第一个顶点==和==最后一个顶点==为链的==端点==，其余的点为==内点==。</li><li><strong>迹（trail）</strong>：<strong>边互不相同</strong>的链称为迹。即<strong>迹中无重边</strong>。——迹是简单路径</li><li><strong>路（path）</strong>：内部点互不相同的链称为路。即<strong>路中无重点</strong>。——路是基本路径</li></ul><h5 id="路径的基本性质"><a href="#路径的基本性质" class="headerlink" title="路径的基本性质"></a>路径的基本性质</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/941.png" style="zoom:40%;"></p><h5 id="两个路径的基本定理（7-3-1-7-3-2）"><a href="#两个路径的基本定理（7-3-1-7-3-2）" class="headerlink" title="两个路径的基本定理（7.3.1,7.3.2）"></a>两个路径的基本定理（7.3.1,7.3.2）</h5><p> <img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/942.png" style="zoom:50%;"></p><h6 id="证明7-3-1"><a href="#证明7-3-1" class="headerlink" title="证明7.3.1"></a>证明7.3.1</h6><p> <img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/921.png" style="zoom:40%;"></p><p> <img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/943.png" style="zoom:40%;"></p><h6 id="证明7-3-2"><a href="#证明7-3-2" class="headerlink" title="证明7.3.2"></a>证明7.3.2</h6><p>（ 因为基本路径中的结点互不相同，即最多仅含 n个结点， 所以所经过的边数必定小于 n。）</p><h5 id="可达（注意R-v-——从v可以到达的全体结点的集合）"><a href="#可达（注意R-v-——从v可以到达的全体结点的集合）" class="headerlink" title="可达（注意R(v)——从v可以到达的全体结点的集合）"></a>可达（注意R(v)——从v可以到达的全体结点的集合）</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/944.png" style="zoom:40%;"></p><h5 id="距离（测地线，距离，图的直径）"><a href="#距离（测地线，距离，图的直径）" class="headerlink" title="距离（测地线，距离，图的直径）"></a>距离（测地线，距离，图的直径）</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/945.png" style="zoom:40%;"></p><h4 id="加权图（加权长度，最短路径，加权距离）"><a href="#加权图（加权长度，最短路径，加权距离）" class="headerlink" title="加权图（加权长度，最短路径，加权距离）"></a>加权图（加权长度，最短路径，加权距离）</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/946.png" style="zoom:40%;"></p><h5 id="迪杰斯特拉（Dijkstra）算法"><a href="#迪杰斯特拉（Dijkstra）算法" class="headerlink" title="迪杰斯特拉（Dijkstra）算法"></a>迪杰斯特拉（Dijkstra）算法</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/947.png" style="zoom:40%;"></p><h5 id="Dijkstra的python实现（个人向）"><a href="#Dijkstra的python实现（个人向）" class="headerlink" title="Dijkstra的python实现（个人向）"></a>Dijkstra的python实现（个人向）</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#n--&gt;有n个点 m--&gt;有m条有向边</span></span><br><span class="line"><span class="comment">#s--&gt;起点 t--&gt;终点</span></span><br><span class="line"><span class="comment">#a--&gt;边的起点 b--&gt;边的终点 c--&gt;边的权值</span></span><br><span class="line">n,m,s,t=map(int,input().split()) </span><br><span class="line">cos=[[float(<span class="string">'inf'</span>) <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,n+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n+<span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n+<span class="number">1</span>):</span><br><span class="line">    cos[i][i]=<span class="number">0</span></span><br><span class="line">parent=[s <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n+<span class="number">1</span>)]</span><br><span class="line">ap=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n+<span class="number">1</span>)]</span><br><span class="line">dis=[float(<span class="string">'inf'</span>) <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,n+<span class="number">1</span>)]</span><br><span class="line">dis[s]=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">    a,b,c=map(int,input().split())</span><br><span class="line">    cos[a][b]=c</span><br><span class="line">    <span class="keyword">if</span>(a==s <span class="keyword">and</span> c&lt;dis[b]):</span><br><span class="line">        dis[b]=c</span><br><span class="line">ap[s]=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    mind=float(<span class="string">'inf'</span>)</span><br><span class="line">    mini=<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> dis[i]&lt;mind <span class="keyword">and</span> ap[i]==<span class="number">0</span>:</span><br><span class="line">            mini=i</span><br><span class="line">            mind=dis[i]</span><br><span class="line">    ap[mini]=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span>(mini==<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span>(ap[i]==<span class="number">0</span> <span class="keyword">and</span> dis[i]&gt;dis[mini]+cos[mini][i]):</span><br><span class="line">            parent[i]=mini</span><br><span class="line">            dis[i]=dis[mini]+cos[mini][i]</span><br><span class="line">path=[]</span><br><span class="line">e=t</span><br><span class="line"><span class="keyword">while</span>(e!=s):</span><br><span class="line">    path.append(e)</span><br><span class="line">    e=parent[e]</span><br><span class="line">path.append(s)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> reversed(path):</span><br><span class="line">    print(x,end=<span class="string">" "</span>)</span><br><span class="line">print()</span><br><span class="line">print(dis[t])</span><br></pre></td></tr></table></figure><h4 id="联通"><a href="#联通" class="headerlink" title="联通"></a>联通</h4><h5 id="无向图的联通"><a href="#无向图的联通" class="headerlink" title="无向图的联通"></a>无向图的联通</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/948.png" style="zoom:40%;"></p><h5 id="有向图的联通—基础图（有向图和无向图的联系）把有向边全部改为无向边"><a href="#有向图的联通—基础图（有向图和无向图的联系）把有向边全部改为无向边" class="headerlink" title="有向图的联通—基础图（有向图和无向图的联系）把有向边全部改为无向边"></a>有向图的联通—基础图（有向图和无向图的联系）把有向边全部改为无向边</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/949.png" style="zoom:40%;"></p><h5 id="有向图的联通（强连通，单向联通，弱联通）"><a href="#有向图的联通（强连通，单向联通，弱联通）" class="headerlink" title="有向图的联通（强连通，单向联通，弱联通）"></a>有向图的联通（强连通，单向联通，弱联通）</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/9410.png" style="zoom:40%;"></p><h5 id="极大子图，分支（强分支-rightarrow-单向分支-rightarrow-弱分支）"><a href="#极大子图，分支（强分支-rightarrow-单向分支-rightarrow-弱分支）" class="headerlink" title="极大子图，分支（强分支$\rightarrow$单向分支$\rightarrow$弱分支）"></a>极大子图，分支（强分支$\rightarrow$单向分支$\rightarrow$弱分支）</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/9411.png" style="zoom:40%;"></p><h5 id="关于分支的定理（7-3-4）——无向图"><a href="#关于分支的定理（7-3-4）——无向图" class="headerlink" title="关于分支的定理（7.3.4）——无向图"></a>关于分支的定理（7.3.4）——无向图</h5><p>1) 连通无向图恰有一个分支。（即是原图本身）</p><p>2) 非连通无向图的分支多于一个。</p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/9412.png" style="zoom:40%;"></p><h5 id="关于强、弱、单向分支的定理（7-3-5）——有向图"><a href="#关于强、弱、单向分支的定理（7-3-5）——有向图" class="headerlink" title="关于强、弱、单向分支的定理（7.3.5）——有向图"></a>关于强、弱、单向分支的定理（7.3.5）——有向图</h5><p>1) 强连通 (单向连通，弱连通 ) 有向图恰有一个强分支(单向分支，弱分支)。（即是原图本身）</p><p>2) 非强连通 (非单向连通，非弱连通) 有向图有一个以上强分支 (单向分支，弱分支)。</p><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><p>有向图的每个结点（每条边）是否处于一个强分支中？是否恰处于一个单向分支中？</p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/9413.png" style="zoom:40%;"></p><h5 id="半路径"><a href="#半路径" class="headerlink" title="半路径"></a>半路径</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/9414.png" style="zoom:40%;"></p><h4 id="回路，半回路，有向回路"><a href="#回路，半回路，有向回路" class="headerlink" title="回路，半回路，有向回路"></a>回路，半回路，有向回路</h4><p>1) 连通2度正则图称为回路；</p><p>2) 基础图是回路的有向图称为半回路；</p><p>3) 每个结点的<strong>出度和入度均为 1</strong> 的<strong>弱连通有向图</strong>称为有向回路；</p><p>4) 回路 (半回路，有向回路)边的数目称为回路 (半回路，有向回路)的长度。</p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/950.png" style="zoom:50%;"></p><h5 id="部分概念关系图"><a href="#部分概念关系图" class="headerlink" title="部分概念关系图"></a>部分概念关系图</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/951.png" style="zoom:50%;"></p><h5 id="回路的等价条件"><a href="#回路的等价条件" class="headerlink" title="回路的等价条件"></a>回路的等价条件</h5><p>设v是图G的任意结点，<strong>G是回路</strong>（或有向回路），当且仅当</p><ol><li>G的阶与边数相等，并且</li><li>在G中存在这样一条v到v的闭路径，使得除了v在该闭路径中出现两次外，其余结点和每条边都在该闭路中恰出现一次。（既是基本路径也是简单路径）</li></ol><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/922.png" style="zoom:40%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/923.png" style="zoom:40%;"></p><h4 id="有回路、非循环图"><a href="#有回路、非循环图" class="headerlink" title="有回路、非循环图"></a>有回路、非循环图</h4><p>1) 如果回路 (有向回路，半回路) C 是图 G 的子图，则称G 有回路 (有向回路，半回路) C。</p><p>2) 没有回路的无向图和没有半回路的有向图称为<strong>非循环图</strong>。</p><p><strong>回路</strong>：连通2度正则图</p><p><strong>半回路</strong>：基础图是回路的有向图</p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/952.png" style="zoom:50%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/924.png" style="zoom:50%;"></p><h5 id="W-过程：判断一个有向图是否有有向回路"><a href="#W-过程：判断一个有向图是否有有向回路" class="headerlink" title="W-过程：判断一个有向图是否有有向回路"></a>W-过程：判断一个有向图是否有有向回路</h5><p>设 v 是有向图G的结点且$d_G^+(v)=0$ 或 $d_G^- (v)=0$。</p><p>从G中去掉 v 和与之关联的边得到有向图 $G-{v}$ 的过程称为<strong>W-过程</strong>。</p><ul><li>G有有向回路当且仅当 G – {v} 有有向回路；</li><li>若 n 阶有向图 G 没有有向回路，则经过 n–1 次W-过程得到平凡图。</li></ul><h5 id="判断一个图是否是非循环图"><a href="#判断一个图是否是非循环图" class="headerlink" title="判断一个图是否是非循环图"></a>判断一个图是否是非循环图</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/953.png" style="zoom:50%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/925.png" style="zoom:50%;"></p><h4 id="连通的充分条件"><a href="#连通的充分条件" class="headerlink" title="连通的充分条件"></a>连通的充分条件</h4><p>设 G 为 n 阶简单无向图，</p><p>1) 若 G 的任意两个结点的度数之和大于等于 n – 1 ，则 G 是连通的。</p><p>2) 若对G的任意结点 v, 皆有$d_G$(v) &gt;= (n–1)/2，则G是连通的。</p><p>证明：设u, v是图G中任意两个结点且u,v不临接（否则已经可达），则$d_G(u)+d_G(v)≥n-1$。由于G为简单无向图, 因此 u, v只能与剩下的n-2个结点相连。 由抽屉原理得，至少存在一个结点既与u相连，又与v相连，得u从 v可达。因此，G是连通无向图。</p><h5 id="例：设-G为-n-阶简单无向图，且G有k个分支，m条边-，则至多有多少条边？"><a href="#例：设-G为-n-阶简单无向图，且G有k个分支，m条边-，则至多有多少条边？" class="headerlink" title="例：设 G为 n 阶简单无向图，且G有k个分支，m条边 ，则至多有多少条边？"></a>例：设 G为 n 阶简单无向图，且G有k个分支，m条边 ，则至多有多少条边？</h5><p>$m&lt;=(n-k+1)(n-k)/2$</p><p>即当有k-1个孤立点，且有一个分支有n-k+1个点时</p><p>证明：$若a+b=c，则a(a+1)/2+b(b+1)/2&lt;a(a-1)/2+(b+1)(b+2)/2$ 所以最大为$(c-1)(c-2)/2$</p><h4 id="点割集的定义"><a href="#点割集的定义" class="headerlink" title="点割集的定义"></a>点割集的定义</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/954.png" style="zoom:40%;"></p><h4 id="无向图的点连通度"><a href="#无向图的点连通度" class="headerlink" title="无向图的点连通度"></a>无向图的点连通度</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/955.png" style="zoom:40%;"></p><h4 id="边割集"><a href="#边割集" class="headerlink" title="边割集"></a>边割集</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/956.png" style="zoom:40%;"></p><h5 id="割边必定不存在于一个简单回路中！！！"><a href="#割边必定不存在于一个简单回路中！！！" class="headerlink" title="割边必定不存在于一个简单回路中！！！"></a>割边必定不存在于一个简单回路中！！！</h5><p>当且仅当图 G 的一条边 e 不含在 G 的简单回路中时，e 才是 G 的割边</p><h4 id="边连通度"><a href="#边连通度" class="headerlink" title="边连通度"></a>边连通度</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/957.png" style="zoom:40%;"></p><h4 id="割点割边的充分必要条件"><a href="#割点割边的充分必要条件" class="headerlink" title="割点割边的充分必要条件"></a>割点割边的充分必要条件</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/958.png" style="zoom:40%;"></p><h3 id="9-4欧拉图和哈密顿图"><a href="#9-4欧拉图和哈密顿图" class="headerlink" title="9.4欧拉图和哈密顿图"></a>9.4欧拉图和哈密顿图</h3><h4 id="欧拉路径，欧拉闭路"><a href="#欧拉路径，欧拉闭路" class="headerlink" title="欧拉路径，欧拉闭路"></a>欧拉路径，欧拉闭路</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/959.png" style="zoom:50%;"></p><h4 id="一笔画"><a href="#一笔画" class="headerlink" title="一笔画"></a>一笔画</h4><p>一张连通图能由一笔画出来的充要条件是：</p><p>每个交点处的线条数都是偶数；或 （欧拉闭路）</p><p>恰有两个交点处的线条数是奇数。 （欧拉路径）</p><h4 id="欧拉图，欧拉有向图"><a href="#欧拉图，欧拉有向图" class="headerlink" title="欧拉图，欧拉有向图"></a>欧拉图，欧拉有向图</h4><p>(i) 每个结点都是偶结点的无向图称为欧拉图。</p><p>(ii)每个结点的出度和入度都相等的有向图称为欧拉有向图。</p><h5 id="欧拉图无割边！！！"><a href="#欧拉图无割边！！！" class="headerlink" title="欧拉图无割边！！！"></a>欧拉图无割边！！！</h5><h4 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h4><h5 id="定理7-4-1设-G-是连通无向图，-G是欧拉图-每个结点都是偶结点-当且仅当G有欧拉闭路。"><a href="#定理7-4-1设-G-是连通无向图，-G是欧拉图-每个结点都是偶结点-当且仅当G有欧拉闭路。" class="headerlink" title="定理7.4.1设 G 是连通无向图， G是欧拉图(每个结点都是偶结点)当且仅当G有欧拉闭路。"></a>定理7.4.1设 G 是连通无向图， G是欧拉图(每个结点都是偶结点)<strong>当且仅当</strong>G有欧拉闭路。</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/926.png" style="zoom:50%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/927.png" style="zoom:50%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/928.png" style="zoom:50%;"></p><p>上述定理不仅给出了欧拉图的判定方法，而且也给出了构造欧拉闭路的方法。</p><p> <img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/929.png" style="zoom:50%;"> <img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/100.png" style="zoom:50%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/960.png" style="zoom:40%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/101.png" style="zoom:50%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/961.png" alt="961" style="zoom:40%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/962.png" alt="962" style="zoom:40%;"></p><h4 id="哈密顿回路"><a href="#哈密顿回路" class="headerlink" title="哈密顿回路"></a>哈密顿回路</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/963.png" style="zoom:40%;"></p><h5 id="必要条件：哈密顿图子集"><a href="#必要条件：哈密顿图子集" class="headerlink" title="必要条件：哈密顿图子集"></a>必要条件：哈密顿图子集</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/964.png" style="zoom:40%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/965.png" style="zoom:40%;"></p><h3 id="9-5图的矩阵表示"><a href="#9-5图的矩阵表示" class="headerlink" title="9.5图的矩阵表示"></a>9.5图的矩阵表示</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/966.png" style="zoom:40%;"></p><h5 id="n阶图G和X-G-之间的联系"><a href="#n阶图G和X-G-之间的联系" class="headerlink" title="n阶图G和X(G)之间的联系"></a>n阶图G和X(G)之间的联系</h5><ol><li>无向图G的邻接矩阵 X(G) 是对称的。 </li><li>图G没有平行边 iff X(G)的元素都是0和1。 </li><li>图G有自圈 iff X(G)的对角线有非0元素。 </li><li>图G是简单图 iff X(G)的元素都是0和1，并且对角线元素都 为 0。 </li><li>图G是零图 iff X(G)是零矩阵 (即所有元素都是0的矩阵)。</li></ol><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/967.png" style="zoom:40%;"></p><h5 id="X-m-x-m"><a href="#X-m-x-m" class="headerlink" title="$X^m,x^m$"></a>$X^m,x^m$</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/968.png" style="zoom:40%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/969.png" style="zoom:50%;"></p><h4 id="路径矩阵、可达性矩阵"><a href="#路径矩阵、可达性矩阵" class="headerlink" title="路径矩阵、可达性矩阵"></a>路径矩阵、可达性矩阵</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/970.png" style="zoom:40%;"></p><h5 id="由邻接矩阵求路径矩阵"><a href="#由邻接矩阵求路径矩阵" class="headerlink" title="由邻接矩阵求路径矩阵"></a>由邻接矩阵求路径矩阵</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/971.png" style="zoom:40%;"></p><h4 id="距离矩阵"><a href="#距离矩阵" class="headerlink" title="距离矩阵"></a>距离矩阵</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/972.png" style="zoom:40%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/973.png" style="zoom:40%;"></p><h4 id="几个矩阵的特点"><a href="#几个矩阵的特点" class="headerlink" title="几个矩阵的特点"></a>几个矩阵的特点</h4><ul><li>图的路径矩阵和距离矩阵<strong>不能给出图的全部信息</strong>；</li><li>图的邻接矩阵可以<strong>给出图的全部信息</strong>；</li><li><strong>无自圈图的关联矩阵</strong>可以给出无自圈图的<strong>全部信息</strong>。</li></ul><h4 id="回顾——关联、临接——结点与边的关系"><a href="#回顾——关联、临接——结点与边的关系" class="headerlink" title="回顾——关联、临接——结点与边的关系"></a>回顾——关联、临接——结点与边的关系</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/974.png" style="zoom:40%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/975.png" style="zoom:40%;"></p><h4 id="几个无自圈的图的矩阵举例"><a href="#几个无自圈的图的矩阵举例" class="headerlink" title="几个无自圈的图的矩阵举例"></a>几个无自圈的图的矩阵举例</h4><h5 id="无自圈的无向图的关联矩阵"><a href="#无自圈的无向图的关联矩阵" class="headerlink" title="无自圈的无向图的关联矩阵"></a>无自圈的无向图的关联矩阵</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/976.png" style="zoom:40%;"></p><h5 id="无自圈的有向图的关联矩阵"><a href="#无自圈的有向图的关联矩阵" class="headerlink" title="无自圈的有向图的关联矩阵"></a>无自圈的有向图的关联矩阵</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/977.png" style="zoom:40%;"></p><h5 id="无自圈有m条边的n阶图G与A-G-之间的关系"><a href="#无自圈有m条边的n阶图G与A-G-之间的关系" class="headerlink" title="无自圈有m条边的n阶图G与A(G)之间的关系"></a>无自圈有m条边的n阶图G与A(G)之间的关系</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/978.png" style="zoom:40%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/979.png" style="zoom:40%;"></p><h4 id="主要知识点图"><a href="#主要知识点图" class="headerlink" title="主要知识点图"></a>主要知识点图</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/980.png" style="zoom:40%;"></p><h3 id="9-6树"><a href="#9-6树" class="headerlink" title="9.6树"></a>9.6树</h3><h4 id="树定义（树，平凡树，分支节点）"><a href="#树定义（树，平凡树，分支节点）" class="headerlink" title="树定义（树，平凡树，分支节点）"></a>树定义（树，平凡树，分支节点）</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/9070.png" style="zoom:40%;"></p><h5 id="定理7-6-1-树定义的等价条件"><a href="#定理7-6-1-树定义的等价条件" class="headerlink" title="定理7.6.1 树定义的等价条件"></a>定理7.6.1 树定义的等价条件</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/9071.png" style="zoom:40%;"></p><h5 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/102.png" style="zoom:50%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/103.png" alt="103" style="zoom:50%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/104.png" alt="104" style="zoom:50%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/105.png" alt="105" style="zoom:50%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/106.png" alt="106" style="zoom:50%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/107.png" alt="107" style="zoom:50%;"></p><h5 id="定理7-4-5-如果G1和G2是可运算的欧拉图，则G1-bigoplus-G2（环合）是欧拉图。"><a href="#定理7-4-5-如果G1和G2是可运算的欧拉图，则G1-bigoplus-G2（环合）是欧拉图。" class="headerlink" title="定理7.4.5 如果G1和G2是可运算的欧拉图，则G1 $\bigoplus$ G2（环合）是欧拉图。"></a>定理7.4.5 如果G1和G2是可运算的欧拉图，则G1 $\bigoplus$ G2（环合）是欧拉图。</h5><h5 id="三个基本条件"><a href="#三个基本条件" class="headerlink" title="三个基本条件"></a>三个基本条件</h5><p>i. G是连通的，<br>ii. G是非循环的，<br>iii.有 n – 1 条边。</p><p>给定其中两个条件，可证明第三个条件</p><h5 id="定理-7-6-2-阶大于-1-的树至少有两个端点。"><a href="#定理-7-6-2-阶大于-1-的树至少有两个端点。" class="headerlink" title="定理 7.6.2 阶大于 1 的树至少有两个端点。"></a>定理 7.6.2 阶大于 1 的树至少有两个端点。</h5><h4 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h4><h5 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h5><p>树是非循环的连通无向图，如果去掉对连通性的要求，就得到森林的概念。</p><h5 id="定义7-6-2-每个分支都是树的无向图称为森林。"><a href="#定义7-6-2-每个分支都是树的无向图称为森林。" class="headerlink" title="定义7.6.2 每个分支都是树的无向图称为森林。"></a>定义7.6.2 每个分支都是树的无向图称为森林。</h5><h5 id="定理-7-6-3-如果森林-F-有-n-个结点，m-条边和-k-个分支，-则m-n-k。"><a href="#定理-7-6-3-如果森林-F-有-n-个结点，m-条边和-k-个分支，-则m-n-k。" class="headerlink" title="定理 7.6.3 如果森林 F 有 n 个结点，m 条边和 k 个分支， 则m=n-k。"></a>定理 7.6.3 如果森林 F 有 n 个结点，m 条边和 k 个分支， 则m=n-k。</h5><h4 id="生成树，生成森林"><a href="#生成树，生成森林" class="headerlink" title="生成树，生成森林"></a>生成树，生成森林</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/9072.png" style="zoom:40%;"></p><h5 id="生成树示例"><a href="#生成树示例" class="headerlink" title="生成树示例"></a>生成树示例</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/9073.png" style="zoom:40%;"></p><h5 id="连通图的生成树构造方法"><a href="#连通图的生成树构造方法" class="headerlink" title="连通图的生成树构造方法"></a>连通图的生成树构造方法</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/9074.png" style="zoom:40%;"></p><h5 id="定理：设无向图G连通，则G至少有一个生成树。"><a href="#定理：设无向图G连通，则G至少有一个生成树。" class="headerlink" title="定理：设无向图G连通，则G至少有一个生成树。"></a>定理：设无向图G连通，则G至少有一个生成树。</h5><p>该定理的证明过程实际上是求生成树的算法：</p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/9075.png" style="zoom:40%;"></p><h5 id="用破圈法求图G的生成树"><a href="#用破圈法求图G的生成树" class="headerlink" title="用破圈法求图G的生成树"></a>用破圈法求图G的生成树</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/9076.png" style="zoom:40%;"></p><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/9077.png" style="zoom:40%;"></p><h5 id="最小生成树求法（避圈法、破圈法）"><a href="#最小生成树求法（避圈法、破圈法）" class="headerlink" title="最小生成树求法（避圈法、破圈法）"></a>最小生成树求法（避圈法、破圈法）</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/9078.png" style="zoom:40%;"></p><h5 id="Prim’s-Algorithm-Robert-Clay-Prim-1957"><a href="#Prim’s-Algorithm-Robert-Clay-Prim-1957" class="headerlink" title="Prim’s Algorithm (Robert Clay Prim, 1957)"></a>Prim’s Algorithm (Robert Clay Prim, 1957)</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/9079.png" style="zoom:50%;"></p><h5 id="最小生成树求法（prim算法）"><a href="#最小生成树求法（prim算法）" class="headerlink" title="最小生成树求法（prim算法）"></a>最小生成树求法（prim算法）</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/90710.png" style="zoom: 50%;"></p><h5 id="Kruskal’s-Algorithm-Joseph-Bernard-Kruskal-1956"><a href="#Kruskal’s-Algorithm-Joseph-Bernard-Kruskal-1956" class="headerlink" title="Kruskal’s Algorithm (Joseph Bernard Kruskal, 1956)"></a>Kruskal’s Algorithm (Joseph Bernard Kruskal, 1956)</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/90711.png" style="zoom:40%;"></p><h5 id="Kruskal算法要点"><a href="#Kruskal算法要点" class="headerlink" title="Kruskal算法要点"></a>Kruskal算法要点</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/90712.png" style="zoom:40%;"></p><h4 id="枝、弦"><a href="#枝、弦" class="headerlink" title="枝、弦"></a>枝、弦</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/90713.png" style="zoom:50%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/90714.png" style="zoom:40%;"></p><h4 id="圈秩、余圈秩"><a href="#圈秩、余圈秩" class="headerlink" title="圈秩、余圈秩"></a>圈秩、余圈秩</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/90715.png" style="zoom:40%;"></p><h4 id="基本回路（圈）"><a href="#基本回路（圈）" class="headerlink" title="基本回路（圈）"></a>基本回路（圈）</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/90716.png" style="zoom:40%;"></p><h4 id="有向树"><a href="#有向树" class="headerlink" title="有向树"></a>有向树</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/90717.png" style="zoom:40%;"></p><h5 id="定理7-6-7-设-v0-是有向图-D-的结点。-D-是以-v0-为根的有向树当且仅当从-v0-至-D-的任意结点恰有一条路径。"><a href="#定理7-6-7-设-v0-是有向图-D-的结点。-D-是以-v0-为根的有向树当且仅当从-v0-至-D-的任意结点恰有一条路径。" class="headerlink" title="定理7.6.7 设 v0 是有向图 D 的结点。 D 是以 v0 为根的有向树当且仅当从 v0 至 D 的任意结点恰有一条路径。"></a>定理7.6.7 设 v0 是有向图 D 的结点。 D 是以 v0 为根的有向树当且仅当从 v0 至 D 的任意结点恰有一条路径。</h5><h5 id="有向树的定义"><a href="#有向树的定义" class="headerlink" title="有向树的定义"></a>有向树的定义</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/90718.png" style="zoom:40%;"></p><h4 id="有向森林"><a href="#有向森林" class="headerlink" title="有向森林"></a>有向森林</h4><h5 id="定义7-6-10-每个弱分支都是有向树的有向图，称为有向森林。"><a href="#定义7-6-10-每个弱分支都是有向树的有向图，称为有向森林。" class="headerlink" title="定义7.6.10 每个弱分支都是有向树的有向图，称为有向森林。"></a>定义7.6.10 每个弱分支都是有向树的有向图，称为有向森林。</h5><h5 id="m元有向树"><a href="#m元有向树" class="headerlink" title="m元有向树"></a>m元有向树</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/90719.png" style="zoom:40%;"></p><h4 id="两个问题"><a href="#两个问题" class="headerlink" title="两个问题"></a>两个问题</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/90720.png" style="zoom: 40%;"></p><h5 id="叶加权二叉树——算法的平均执行时间"><a href="#叶加权二叉树——算法的平均执行时间" class="headerlink" title="叶加权二叉树——算法的平均执行时间"></a>叶加权二叉树——算法的平均执行时间</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/90721.png" style="zoom:40%;"></p><h5 id="求解最优二叉树的算法—Huffman算法"><a href="#求解最优二叉树的算法—Huffman算法" class="headerlink" title="求解最优二叉树的算法—Huffman算法"></a>求解最优二叉树的算法—Huffman算法</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/90722.png" style="zoom:50%;"></p><h6 id="最优二叉树求取"><a href="#最优二叉树求取" class="headerlink" title="最优二叉树求取"></a>最优二叉树求取</h6><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/90723.png" style="zoom:40%;"></p><h6 id="定位有序树"><a href="#定位有序树" class="headerlink" title="定位有序树"></a>定位有序树</h6><p>定义7.6.15 为每个分支结点的儿子规定了位置的有序树称为定位有序树。</p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/90724.png" style="zoom:40%;"></p><h6 id="最优二叉树"><a href="#最优二叉树" class="headerlink" title="最优二叉树"></a>最优二叉树</h6><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/90725.png" style="zoom:40%;"></p><h5 id="例：在计算机通信中要传输A-B-C-D-E-F-G-H八个字母，他们出现频率为A-30-B-20-C-15-D-10-E-10-F-6-G-5-H-4-。给出一个最佳编码，使得通讯中出现的二进制数字尽可能少。"><a href="#例：在计算机通信中要传输A-B-C-D-E-F-G-H八个字母，他们出现频率为A-30-B-20-C-15-D-10-E-10-F-6-G-5-H-4-。给出一个最佳编码，使得通讯中出现的二进制数字尽可能少。" class="headerlink" title="例：在计算机通信中要传输A, B, C, D, E, F, G, H八个字母，他们出现频率为A:30%, B:20%, C:15%, D:10%, E:10%, F:6%, G:5%, H:4%。给出一个最佳编码，使得通讯中出现的二进制数字尽可能少。"></a>例：在计算机通信中要传输A, B, C, D, E, F, G, H八个字母，他们出现频率为A:30%, B:20%, C:15%, D:10%, E:10%, F:6%, G:5%, H:4%。给出一个最佳编码，使得通讯中出现的二进制数字尽可能少。</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/90726.png" style="zoom:40%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/90727.png" alt="90727" style="zoom:40%;"></p><h4 id="有序树，有序森林"><a href="#有序树，有序森林" class="headerlink" title="有序树，有序森林"></a>有序树，有序森林</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/90728.png" style="zoom:40%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/90729.png" style="zoom:40%;"></p><h5 id="借用家族树的名称来称呼有序树的结点。"><a href="#借用家族树的名称来称呼有序树的结点。" class="headerlink" title="借用家族树的名称来称呼有序树的结点。"></a>借用家族树的名称来称呼有序树的结点。</h5><p>称v1是v2和v3的父亲，v2是v1的长子，v2是v3的哥哥，v6是 v5的弟弟等等。</p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/90730.png" style="zoom:40%;"></p><h5 id="定位有序树-1"><a href="#定位有序树-1" class="headerlink" title="定位有序树"></a>定位有序树</h5><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/90731.png" style="zoom: 40%;"></p><ul><li>G与G’是相同的有序树，因为同一级上结点的次序相同。 </li><li>如果考虑结点之间的相对位置，G与G’不相同</li><li>G与G’是不同的定位有序树</li></ul><h5 id="有序森林与有序树的关系"><a href="#有序森林与有序树的关系" class="headerlink" title="有序森林与有序树的关系"></a>有序森林与有序树的关系</h5><p>可以用定位二元有序树 表示有序森林。 </p><p>有序森林和定位二元有序树之间建立一一对应关系。</p><p>• 称位于左边的有序树之根为位于右边的有序树之根的哥哥</p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/90732.png" style="zoom:40%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/90733.png" style="zoom:40%;"></p><h4 id="概念图谱"><a href="#概念图谱" class="headerlink" title="概念图谱"></a>概念图谱</h4><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/90734.png" style="zoom:40%;"></p><p><img src="/2022/09/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/../../../Learn/大二上/2020年秋季学期课程学习/离散数学2/picture/90735.png" style="zoom:40%;"></p><h1 id="期末专项复习"><a href="#期末专项复习" class="headerlink" title="期末专项复习"></a>期末专项复习</h1><p>二叉树定义——即完全二叉树，每个结点的分支非0即2</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>概率统计</title>
      <link href="2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/"/>
      <url>2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="概率统计A"><a href="#概率统计A" class="headerlink" title="概率统计A"></a>概率统计A</h1><h1 id="概率论-第1章—第6章"><a href="#概率论-第1章—第6章" class="headerlink" title="概率论(第1章—第6章)"></a>概率论(第1章—第6章)</h1><h2 id="一、随机事件的概率"><a href="#一、随机事件的概率" class="headerlink" title="一、随机事件的概率"></a>一、随机事件的概率</h2><h3 id="1-1-随机事件与样本空间"><a href="#1-1-随机事件与样本空间" class="headerlink" title="1.1 随机事件与样本空间"></a>1.1 随机事件与样本空间</h3><h4 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h4><p><strong>试验：</strong>各种各样的科学试验或对某一事物的某种特性的观察。</p><p><strong>随机试验</strong>：有如下特点的试验（用E表示）：</p><ul><li>可在相同的条件下重复进行   </li><li>试验的可能结果不止一个，但能明确所有可能的结果</li><li>试验前不能预知出现哪种结果、</li></ul><p><strong>样本空间</strong>：随机试验E 所有可能的结果组成的<strong>集合</strong>，记为<strong>S</strong> 或者<strong>$\Omega$</strong>.</p><p><strong>基本事件</strong>：随机试验的<strong>每一个可能结果</strong>；常记为e ；是样本空间的元素；  S = {e}.</p><p><strong>随机事件</strong> ：是在随机试验中可能发生也可能不发生的事情；样本空间的子集，常记为 A ,B ,…</p><p><strong>必然事件</strong>：所有样本点所组成的事件，S， 每次试验必定发生的事件</p><p><strong>不可能事件</strong>：每次试验必定不发生的事情，不包含任何样本点的事件 , 记为$\varnothing$</p><h4 id="随机事件的关系和运算"><a href="#随机事件的关系和运算" class="headerlink" title="随机事件的关系和运算"></a>随机事件的关系和运算</h4><p>$AB$或$A\cap B$——事件A 与事件B 的积事件</p><p>A - B 差事件</p><p>$A+B$或$A\cup B$——事件A 与事件B 的和事件</p><p>事件A 与事件B <strong>互斥</strong>(<strong>互不相容</strong>)  ——AB=$\varnothing$ </p><p>事件A 与事件B <strong>互相对立（互逆）</strong>——AB=$\varnothing$ 且 $A\cup B=S$  即：$B=\overline A$</p><h3 id="1-2-概率的定义及其性质"><a href="#1-2-概率的定义及其性质" class="headerlink" title="1.2 概率的定义及其性质"></a>1.2 概率的定义及其性质</h3><h4 id="古典概率模型"><a href="#古典概率模型" class="headerlink" title="古典概率模型"></a>古典概率模型</h4><p>设 <em>E</em> 是一随机试验，如果它具有下列条件： </p><ul><li>q 基本事件的个数有限 <em>S</em> = {e1 ,e2 ,…,en } </li><li>q每个基本事件发生的可能性大小相同 </li><li><em>P</em>(e1 ) = <em>P</em>(e2 ) =…= <em>P</em>(en ) </li></ul><p>则称 E 为 <strong>古典概型</strong></p><h4 id="几何概型"><a href="#几何概型" class="headerlink" title="几何概型"></a>几何概型</h4><p>设样本空间是一个有限区域S （如：<strong>线段， 平面有界区域，空间有界区域</strong>等等。） ，做随机试验：向区域S内投一质点M，若质点M 落入S内任何子区域<em>A</em>中的概率<strong>与区域<em>A</em> 的度 量</strong>成正比，而与<em>A</em> 的位置和形状无关，则称此试验为几何型随机试验，简称<strong>几何概型</strong> </p><h4 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h4><p>设在 n 次试验中，事件 A 发生了$n_A$次， 则称 $f_n(A)=\frac{n_A}{n}$为事件A 在这 <em>n</em> 次试验中发生的频率。$f_n(A)$定义为概率P(A)</p><h4 id="频率的性质"><a href="#频率的性质" class="headerlink" title="频率的性质"></a>频率的性质</h4><ol><li>$0&lt;=f_n(A)&lt;=1$——<strong>非负</strong>性</li><li>$f_n(S)=1$——<strong>规范</strong>性</li><li>事件 <em>A</em>, <em>B</em>互斥，则 $f_n(A\cup B)=f_n(A)+f_n(B)$——<strong>可加</strong>性</li></ol><h3 id="1-3-概率的公理化定义及概率的性质"><a href="#1-3-概率的公理化定义及概率的性质" class="headerlink" title="1.3 概率的公理化定义及概率的性质"></a>1.3 概率的公理化定义及概率的性质</h3><h4 id="1-事件域"><a href="#1-事件域" class="headerlink" title="1.事件域"></a>1.事件域</h4><p> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/131.png" style="zoom:50%;"></p><p>则F为事件域</p><h4 id="2-概率的公理化定义"><a href="#2-概率的公理化定义" class="headerlink" title="2.概率的公理化定义"></a>2.概率的公理化定义</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/132.png" style="zoom: 33%;"><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/133.png" alt="133" style="zoom: 33%;"></p><h4 id="3-概率的性质"><a href="#3-概率的性质" class="headerlink" title="3.概率的性质"></a>3.概率的性质</h4><ol><li>$P(\varnothing)=0$</li><li>有限可加性：设A1, A2…An为两两互斥事件 <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/134.png" style="zoom:33%;"></li><li>$P(\overline A)=1-P(A)$</li><li>若$A\subset B,则P(B-A)=P(B)-P(A) $   且$P(A)&lt;=P(B)$</li><li>加法公式：对任意两个事件A, B, 有<img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/135.png" style="zoom: 33%;"><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/136.png" style="zoom: 33%;"></li></ol><h3 id="1-4-条件概率与概率的乘法公式"><a href="#1-4-条件概率与概率的乘法公式" class="headerlink" title="1.4 条件概率与概率的乘法公式"></a>1.4 条件概率与概率的乘法公式</h3><h4 id="条件概率定义"><a href="#条件概率定义" class="headerlink" title="条件概率定义"></a>条件概率定义</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/137.png" style="zoom: 33%;"></p><h4 id="条件概率的常用性质"><a href="#条件概率的常用性质" class="headerlink" title="条件概率的常用性质"></a>条件概率的常用性质</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/138.png" style="zoom:33%;"></p><h4 id="概率的乘法公式"><a href="#概率的乘法公式" class="headerlink" title="概率的乘法公式"></a>概率的乘法公式</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/139.png" style="zoom:33%;"></p><h4 id="概率的乘法公式的推广结果"><a href="#概率的乘法公式的推广结果" class="headerlink" title="概率的乘法公式的推广结果"></a>概率的乘法公式的推广结果</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/140.png" style="zoom: 33%;"></p><h3 id="1-5-全概率公式与Bayes-贝叶斯）公式"><a href="#1-5-全概率公式与Bayes-贝叶斯）公式" class="headerlink" title="1.5 全概率公式与Bayes (贝叶斯）公式"></a>1.5 全概率公式与Bayes (贝叶斯）公式</h3><h4 id="全概率公式"><a href="#全概率公式" class="headerlink" title="全概率公式"></a>全概率公式</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/150.png" style="zoom:33%;">   $\rightarrow$   <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/151.png" alt="151" style="zoom:33%;">   <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/152.png" style="zoom:33%;"></p><h4 id="Bayes公式！！！"><a href="#Bayes公式！！！" class="headerlink" title="Bayes公式！！！"></a>Bayes公式！！！</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/153.png" style="zoom: 33%;"></p><h3 id="1-6-事件的独立性"><a href="#1-6-事件的独立性" class="headerlink" title="1.6 事件的独立性"></a>1.6 事件的独立性</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>设A与B是两个随机事件，如果成立==P(AB)=P(A)*P(B)== ， 则称事件A与B依概率==相互独立==，简称独立</p><h4 id="几个定理和性质"><a href="#几个定理和性质" class="headerlink" title="几个定理和性质"></a>几个定理和性质</h4><h5 id="特殊事件的相互独立的性质"><a href="#特殊事件的相互独立的性质" class="headerlink" title="特殊事件的相互独立的性质"></a>特殊事件的相互独立的性质</h5><ul><li>若P(A)=0 或 P(A)=1，则对任意事件B， 有A与B独立； </li><li>反之，若对任意事件B，A与B独立， 则 P(A)=0 或 P(A)=1。</li></ul><h5 id="几个相互独立的定理"><a href="#几个相互独立的定理" class="headerlink" title="几个相互独立的定理"></a>几个相互独立的定理</h5><ul><li><p>四对事件，任何一对相互独立，则<strong>其它三对也相互独立</strong>：$A, \overline B; \overline A, B; \overline A, \overline B; A, B$ 。</p></li><li><p>P(A)&gt;0 P(B)&gt;0 则“事件 A 与 事件 B 相互独立”和 “事件 A 与 事件 B 互斥” ==不能同时成立==, 相互独立的时候一定有==交集==。即：P(A)*P(B)&gt;0</p></li><li><p>三事件 A, B, C 相互独立是指下面的关系式同时成立：<img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/154.png" style="zoom:33%;"></p><p>注：</p><p>1) 不能由关系式(1)推出关系式(2), 反之亦然 </p><p>2)仅满足(1)式时,称 A, B, C 两两独立</p><p>3)A, B, C 相互独立 $\Rightarrow$ A, B, C 两两独立</p></li><li><p>n 个事件 A1, A2, …, An 相互独立是指下面的关系式同时成立：<img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/155.png" style="zoom:33%;"></p></li></ul><h4 id="独立的性质"><a href="#独立的性质" class="headerlink" title="独立的性质"></a>独立的性质</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/156.png" style="zoom: 25%;"></p><h4 id="！！！很常用-P-A-B-1-P-overline-A-overline-B"><a href="#！！！很常用-P-A-B-1-P-overline-A-overline-B" class="headerlink" title="！！！很常用$P(A+B)=1-P(\overline A \overline B)$"></a>！！！很常用$P(A+B)=1-P(\overline A \overline B)$</h4><h2 id="二、随机变量及其分布"><a href="#二、随机变量及其分布" class="headerlink" title="二、随机变量及其分布"></a>二、随机变量及其分布</h2><h3 id="2-1-随机变量概念-分类"><a href="#2-1-随机变量概念-分类" class="headerlink" title="2.1 随机变量概念/分类"></a>2.1 随机变量概念/分类</h3><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/210.png" style="zoom:33%;"></p><ul><li>离散型：随机变量的取值只有有限个或可列个 </li><li>连续性随机变量</li><li>非离散非连续随机变量</li></ul><h3 id="2-2-随机变量的分布函数"><a href="#2-2-随机变量的分布函数" class="headerlink" title="2.2 随机变量的分布函数"></a>2.2 随机变量的分布函数</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/211.png" style="zoom:33%;"></p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/212.png" alt="212" style="zoom: 33%;"></p><h4 id="分布函数的性质"><a href="#分布函数的性质" class="headerlink" title="分布函数的性质"></a>分布函数的性质</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/213.png" style="zoom: 50%;"><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/214.png" style="zoom: 50%;"><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/215.png" style="zoom:50%;"><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/157.png" style="zoom: 33%;"></p><h3 id="2-3-离散型随机变量及其概率分布"><a href="#2-3-离散型随机变量及其概率分布" class="headerlink" title="2.3 离散型随机变量及其概率分布"></a>2.3 离散型随机变量及其概率分布</h3><h4 id="离散型随机变量的概念"><a href="#离散型随机变量的概念" class="headerlink" title="离散型随机变量的概念"></a>离散型随机变量的概念</h4><p>若随机变量 X 的可能取值是<strong>有限多个</strong>或<strong>无穷可列</strong>多个，则称 X 为离散型随机变量</p><h4 id="离散型随机变量X的分布律"><a href="#离散型随机变量X的分布律" class="headerlink" title="离散型随机变量X的分布律"></a>离散型随机变量X的分布律</h4><h5 id="表示方法"><a href="#表示方法" class="headerlink" title="表示方法"></a>表示方法</h5><p>(1)公式法<img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/158.png" style="zoom: 33%;"></p><p>(2)列表法或矩阵法 <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/159.png" style="zoom: 25%;"></p><h5 id="分布律的基本性质"><a href="#分布律的基本性质" class="headerlink" title="分布律的基本性质"></a>分布律的基本性质</h5><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1510.png" style="zoom:33%;"></p><h3 id="2-4-常见的离散型随机变量的分布"><a href="#2-4-常见的离散型随机变量的分布" class="headerlink" title="2.4 常见的离散型随机变量的分布"></a>2.4 常见的离散型随机变量的分布</h3><h4 id="1-0-–-1-分布"><a href="#1-0-–-1-分布" class="headerlink" title="(1) 0 – 1 分布"></a>(1) 0 – 1 分布</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/240.png" style="zoom:33%;"></p><h5 id="分布律"><a href="#分布律" class="headerlink" title="分布律"></a>分布律</h5><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/241.png" style="zoom:33%;"></p><h5 id="贝努利试验与0、1分布"><a href="#贝努利试验与0、1分布" class="headerlink" title="贝努利试验与0、1分布"></a>贝努利试验与0、1分布</h5><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/242.png" style="zoom: 25%;"></p><h4 id="2-二项分布-B-n-p-（伯努利分布）"><a href="#2-二项分布-B-n-p-（伯努利分布）" class="headerlink" title="(2) 二项分布 B(n, p) （伯努利分布）"></a>(2) 二项分布 B(n, p) （伯努利分布）</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/244.png" style="zoom: 30%;"><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/243.png" style="zoom: 30%;"></p><p>此处，类似的用二项式定理可以用于解决一些求期望的问题</p><h5 id="二项分布中最可能出现次数的定义与推导"><a href="#二项分布中最可能出现次数的定义与推导" class="headerlink" title="二项分布中最可能出现次数的定义与推导"></a>二项分布中最可能出现次数的定义与推导</h5><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/245.png" style="zoom:33%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/246.png" style="zoom:33%;"></p><h5 id="泊松定理"><a href="#泊松定理" class="headerlink" title="泊松定理"></a>泊松定理</h5><p>一般在$n&gt;=10,且p&lt;=0.1时可以这样近似$</p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/247.png" style="zoom:40%;"></p><h4 id="3-超几何分布"><a href="#3-超几何分布" class="headerlink" title="(3) 超几何分布"></a>(3) 超几何分布</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/248.png" style="zoom: 40%;"></p><h4 id="4-Poisson-分布"><a href="#4-Poisson-分布" class="headerlink" title="(4) Poisson 分布"></a>(4) Poisson 分布</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/249.png" style="zoom: 40%;"></p><h4 id="三个分布的关系"><a href="#三个分布的关系" class="headerlink" title="三个分布的关系"></a>三个分布的关系</h4><p>超几何分布的极限分布是二项分布， 二项分布的极限分布是 Poisson 分布</p><h3 id="2-5-连续型随机变量"><a href="#2-5-连续型随机变量" class="headerlink" title="2.5 连续型随机变量"></a>2.5 连续型随机变量</h3><h4 id="连续型随机变量的概念（与概率密度函数绑定）"><a href="#连续型随机变量的概念（与概率密度函数绑定）" class="headerlink" title="连续型随机变量的概念（与概率密度函数绑定）"></a>连续型随机变量的概念（与概率密度函数绑定）</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/250.png" style="zoom:33%;"></p><h4 id="f-x-（概率密度函数）的基本性质"><a href="#f-x-（概率密度函数）的基本性质" class="headerlink" title="f ( x )（概率密度函数）的基本性质"></a>f ( x )（概率密度函数）的基本性质</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/251.png" style="zoom:33%;"></p><p>f ( $x_0$ ) 描述了X 在 x0 附近<strong>单位长度的区间</strong>内<strong>取值的概率</strong>。</p><p>对于连续型随机变量X , ==P ( X = a) = 0==  这里 a 可以是随机变量 X 的一个==可能的取值==，但==概率为1 (零) 的事件未必发生 (不发生)==。</p><h3 id="2-6-常见的连续性随机变量的分布"><a href="#2-6-常见的连续性随机变量的分布" class="headerlink" title="2.6 常见的连续性随机变量的分布"></a>2.6 常见的连续性随机变量的分布</h3><h4 id="1-均匀分布"><a href="#1-均匀分布" class="headerlink" title="(1) 均匀分布"></a>(1) 均匀分布</h4><p>类似几何概型</p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/252.png" style="zoom:33%;"><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/260.png" style="zoom: 33%;"></p><h4 id="2-指数分布"><a href="#2-指数分布" class="headerlink" title="(2) 指数分布"></a>(2) 指数分布</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/261.png" style="zoom:33%;"></p><h3 id="2-7-正态分布"><a href="#2-7-正态分布" class="headerlink" title="2.7 正态分布"></a>2.7 正态分布</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/270.png" style="zoom:33%;"></p><h5 id="欧拉-泊松积分推导正态分布公式"><a href="#欧拉-泊松积分推导正态分布公式" class="headerlink" title="欧拉-泊松积分推导正态分布公式"></a>欧拉-泊松积分推导正态分布公式</h5><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/271.png" style="zoom:33%;"></p><h4 id="f-x-的性质"><a href="#f-x-的性质" class="headerlink" title="f (x) 的性质"></a>f (x) 的性质</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/272.png" style="zoom:33%;"></p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/273.png" style="zoom:33%;"></p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/274.png" style="zoom:33%;"></p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/275.png" alt="275" style="zoom:33%;"></p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/276.png" alt="276" style="zoom: 33%;"></p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/277.png" style="zoom: 33%;"></p><h4 id="一种重要的正态分布：N-0-1-—-标准正态分布"><a href="#一种重要的正态分布：N-0-1-—-标准正态分布" class="headerlink" title="一种重要的正态分布：N (0,1) — 标准正态分布"></a>一种重要的正态分布：N (0,1) — 标准正态分布</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/278.png" style="zoom:33%;"></p><h5 id="几个重要结论"><a href="#几个重要结论" class="headerlink" title="几个重要结论"></a>几个重要结论</h5><p>$\Phi(0)=\frac 1 2$</p><p>$\Phi(-x)=1-\Phi(x)$</p><p>$P(|X|&lt;a)=2\Phi(a)-1$ （$即2(\Phi(a)-{1\over 2})$）</p><h4 id="一般的正态分布！！！！重要"><a href="#一般的正态分布！！！！重要" class="headerlink" title="一般的正态分布！！！！重要"></a>一般的正态分布！！！！重要</h4><p>$X—N(\mu,\sigma^2)$   $\Rightarrow$ <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/279.png" style="zoom:40%;"> $\Rightarrow$  <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/2710.png" style="zoom:40%;"></p><h4 id="alpha-分位点"><a href="#alpha-分位点" class="headerlink" title="$\alpha$分位点"></a>$\alpha$分位点</h4><p>$其他分布的\alpha分位点与这个定义一致$</p><h5 id="分位点的性质-0-lt-α-lt-1"><a href="#分位点的性质-0-lt-α-lt-1" class="headerlink" title="分位点的性质: (0 &lt; α &lt; 1)"></a>分位点的性质: (0 &lt; α &lt; 1)</h5><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/2.7.1.png" style="zoom:40%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/2.7.2.png" alt="2.7.2" style="zoom:40%;"></p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/2.7.3.png" alt="2.7.3" style="zoom:40%;"></p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/2.7.4.png" alt="2.7.4" style="zoom:40%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/2.7.5.png" alt="2.7.5" style="zoom:40%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/2.7.6.png" alt="2.7.6" style="zoom:40%;"></p><h2 id="三、二维随机变量"><a href="#三、二维随机变量" class="headerlink" title="三、二维随机变量"></a>三、二维随机变量</h2><h3 id="3-1二维随机变量及其分布"><a href="#3-1二维随机变量及其分布" class="headerlink" title="3.1二维随机变量及其分布"></a>3.1二维随机变量及其分布</h3><h4 id="一-二维随机变量及其分布函数"><a href="#一-二维随机变量及其分布函数" class="headerlink" title="一.二维随机变量及其分布函数"></a>一.二维随机变量及其分布函数</h4><h5 id="1-二维随机变量的定义"><a href="#1-二维随机变量的定义" class="headerlink" title="1.二维随机变量的定义"></a>1.二维随机变量的定义</h5><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/310.png" style="zoom:33%;"></p><h5 id="2-分布函数的定义"><a href="#2-分布函数的定义" class="headerlink" title="2.分布函数的定义"></a>2.分布函数的定义</h5><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/311.png" style="zoom: 33%;"></p><h5 id="3-分布函数的性质"><a href="#3-分布函数的性质" class="headerlink" title="3.分布函数的性质"></a>3.分布函数的性质</h5><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/312.png" style="zoom:33%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/313.png" style="zoom:33%;"></p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/314.png" style="zoom:33%;">   重要结论  $\Rightarrow$  <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/315.png" style="zoom:33%;"></p><p>注：可以证明:凡满足上述性质1-4的二元函数 F(x,y) 必定是某个二维随机变量的分布函数</p><h5 id="4-二维随机变量的分类"><a href="#4-二维随机变量的分类" class="headerlink" title="4.二维随机变量的分类"></a>4.二维随机变量的分类</h5><ul><li>二维离散型随机变量及其分布：分布律、分布函数 </li><li>二维连续型随机变量及其分布：分布密度、分布函数</li></ul><p>注：对于二维随机变量，==$F(X&gt;a,Y&gt;c)\neq 1-F(a,c)$== ！！！</p><p>$F(X&gt;a,Y&gt;c)= 1-(F(a)+F(c)-F(a,c))$</p><h4 id="二-二维离散型随机变量及其分布"><a href="#二-二维离散型随机变量及其分布" class="headerlink" title="二.二维离散型随机变量及其分布"></a>二.二维离散型随机变量及其分布</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>若二维随机变量 ( X, Y ) 所取的可能值是==有限对或无限可列多对==,则称 ( X, Y ) 为二维离散型随机变量</p><h5 id="分布律-1"><a href="#分布律-1" class="headerlink" title="分布律"></a>分布律</h5><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/316.png" style="zoom:33%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/318.png" style="zoom:33%;"><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/317.png" style="zoom:33%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/319.png" style="zoom:33%;"></p><h5 id="联合分布函数"><a href="#联合分布函数" class="headerlink" title="联合分布函数"></a>联合分布函数</h5><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/3110.png" style="zoom:33%;"></p><h4 id="三-二维连续型随机变量及其分布"><a href="#三-二维连续型随机变量及其分布" class="headerlink" title="三.二维连续型随机变量及其分布"></a>三.二维连续型随机变量及其分布</h4><h5 id="联合概率密度"><a href="#联合概率密度" class="headerlink" title="联合概率密度"></a>联合概率密度</h5><h6 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h6><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/321.png" style="zoom:33%;"></p><h6 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h6><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/3111.png" style="zoom:33%;"></p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/3112.png" style="zoom: 33%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/3113.png" style="zoom:33%;"></p><h5 id="常见的连续型二维随机变量的分布"><a href="#常见的连续型二维随机变量的分布" class="headerlink" title="常见的连续型二维随机变量的分布"></a>常见的连续型二维随机变量的分布</h5><h6 id="二维均匀分布"><a href="#二维均匀分布" class="headerlink" title="二维均匀分布"></a>二维均匀分布</h6><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/3114.png" style="zoom:33%;"><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/3115.png" alt="3115" style="zoom:33%;"></p><h6 id="二维正态分布"><a href="#二维正态分布" class="headerlink" title="二维正态分布"></a>二维正态分布</h6><p>若二维随机变量( X ,Y ) 的联合密度为</p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/3116.png" style="zoom:33%;"><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/3117.png" alt="3117" style="zoom:33%;"><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/3118.png" alt="3118" style="zoom:33%;"> </p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/3119.png" style="zoom:33%;"></p><h3 id="3-2二维随机变量的边缘分布函数"><a href="#3-2二维随机变量的边缘分布函数" class="headerlink" title="3.2二维随机变量的边缘分布函数"></a>3.2二维随机变量的边缘分布函数</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/325.png" style="zoom: 50%;">    <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/326.png" style="zoom:33%;">      </p><h4 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/3.2.1.png" style="zoom: 33%;"></p><h3 id="3-3-二维离散型随机变量的边缘分布律"><a href="#3-3-二维离散型随机变量的边缘分布律" class="headerlink" title="3.3 二维离散型随机变量的边缘分布律"></a>3.3 二维离散型随机变量的边缘分布律</h3><h4 id="二维离散型随机变量的边缘分布律"><a href="#二维离散型随机变量的边缘分布律" class="headerlink" title="二维离散型随机变量的边缘分布律"></a>二维离散型随机变量的边缘分布律</h4><h5 id="1-二维离散型随机变量的边缘分布律的概念及求法"><a href="#1-二维离散型随机变量的边缘分布律的概念及求法" class="headerlink" title="(1) 二维离散型随机变量的边缘分布律的概念及求法"></a>(1) 二维离散型随机变量的边缘分布律的概念及求法</h5><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/322.png" style="zoom: 33%;"></p><h5 id="2-离散型二维随机向量的边缘分布的表格表示"><a href="#2-离散型二维随机向量的边缘分布的表格表示" class="headerlink" title="(2) 离散型二维随机向量的边缘分布的表格表示"></a>(2) 离散型二维随机向量的边缘分布的表格表示</h5><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/327.png" style="zoom:33%;"></p><h3 id="3-4二维连续型随机变量边缘概率密度函数"><a href="#3-4二维连续型随机变量边缘概率密度函数" class="headerlink" title="3.4二维连续型随机变量边缘概率密度函数"></a>3.4二维连续型随机变量边缘概率密度函数</h3><h4 id="二维连续型随机变量的边缘密度的计算公式"><a href="#二维连续型随机变量的边缘密度的计算公式" class="headerlink" title="二维连续型随机变量的边缘密度的计算公式"></a>二维连续型随机变量的边缘密度的计算公式</h4><p>​                                                    <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/341.png" style="zoom:33%;"> </p><p>已知联合概率密度可以求得边缘概率密度； 反之则不能确定，或者不能唯一确定</p><h4 id="常见二维随机变量边缘分布函数性质"><a href="#常见二维随机变量边缘分布函数性质" class="headerlink" title="常见二维随机变量边缘分布函数性质"></a>常见二维随机变量边缘分布函数性质</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/324.png" style="zoom: 33%;"></p><h3 id="3-5-条件分布"><a href="#3-5-条件分布" class="headerlink" title="3.5 条件分布"></a>3.5 条件分布</h3><h4 id="一-、离散型随机变量的条件分布律"><a href="#一-、离散型随机变量的条件分布律" class="headerlink" title="一 、离散型随机变量的条件分布律"></a>一 、离散型随机变量的条件分布律</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/351.png" style="zoom:33%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/352.png" style="zoom:33%;"></p><h4 id="二、二维连续型随机变量的条件分布函数和条件密度函数"><a href="#二、二维连续型随机变量的条件分布函数和条件密度函数" class="headerlink" title="二、二维连续型随机变量的条件分布函数和条件密度函数"></a>二、二维连续型随机变量的条件分布函数和条件密度函数</h4><h5 id="１、条件分布函数"><a href="#１、条件分布函数" class="headerlink" title="１、条件分布函数"></a>１、条件分布函数</h5><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/353.png" style="zoom:33%;"><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/355.png" style="zoom:33%;"></p><h6 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h6><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/354.png" style="zoom:33%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/356.png" style="zoom:33%;"></p><p>​          <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/357.png" style="zoom:33%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/358.png" style="zoom:33%;"></p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/359.png" style="zoom:33%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/3510.png" alt="3510" style="zoom:33%;"></p><h3 id="3-6-随机变量的独立性"><a href="#3-6-随机变量的独立性" class="headerlink" title="3.6 随机变量的独立性"></a>3.6 随机变量的独立性</h3><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/361.png" style="zoom:33%;"></p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/362.png" style="zoom:33%;"><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/363.png" alt="363" style="zoom:33%;"></p><h4 id="二维离散型随机变量-X-Y-相互独立"><a href="#二维离散型随机变量-X-Y-相互独立" class="headerlink" title="二维离散型随机变量( X, Y ) 相互独立"></a>二维离散型随机变量( X, Y ) 相互独立<img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/364.png" style="zoom:33%;"></h4><h4 id="二维连续型随机变量-X-Y-相互独立"><a href="#二维连续型随机变量-X-Y-相互独立" class="headerlink" title="二维连续型随机变量 ( X, Y ) 相互独立"></a>二维连续型随机变量 ( X, Y ) 相互独立<img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/365.png" style="zoom:33%;"></h4><h4 id="正态分布两个变量相互独立-lt-gt-rho-0"><a href="#正态分布两个变量相互独立-lt-gt-rho-0" class="headerlink" title="正态分布两个变量相互独立$&lt;=&gt;\rho=0$"></a>正态分布两个变量相互独立$&lt;=&gt;\rho=0$</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/366.png" style="zoom:33%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/367.png" style="zoom:33%;"></p><h4 id="判断连续型二维随机变量相互独立的两个结论"><a href="#判断连续型二维随机变量相互独立的两个结论" class="headerlink" title="判断连续型二维随机变量相互独立的两个结论"></a>判断连续型二维随机变量相互独立的两个结论</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/368.png" style="zoom:33%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/369.png" style="zoom:33%;"><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/3610.png" style="zoom:33%;"></p><h2 id="四、随机变量的函数的分布"><a href="#四、随机变量的函数的分布" class="headerlink" title="四、随机变量的函数的分布"></a>四、随机变量的函数的分布</h2><h3 id="4-1离散型随机变量函数的分布"><a href="#4-1离散型随机变量函数的分布" class="headerlink" title="4.1离散型随机变量函数的分布"></a>4.1离散型随机变量函数的分布</h3><h4 id="1-一维离散型随机变量函数的分布"><a href="#1-一维离散型随机变量函数的分布" class="headerlink" title="1.一维离散型随机变量函数的分布"></a>1.一维离散型随机变量函数的分布</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/402.png" style="zoom: 33%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/403.png" alt="403" style="zoom: 33%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/404.png" alt="404" style="zoom: 33%;"></p><h4 id="2-二维离散型随机变量函数的分布"><a href="#2-二维离散型随机变量函数的分布" class="headerlink" title="2.二维离散型随机变量函数的分布"></a>2.二维离散型随机变量函数的分布</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/405.png" style="zoom:40%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/406.png" style="zoom:40%;"></p><h4 id="关于二项分布和泊松分布有如下的重要结论"><a href="#关于二项分布和泊松分布有如下的重要结论" class="headerlink" title="关于二项分布和泊松分布有如下的重要结论"></a>关于二项分布和泊松分布有如下的重要结论</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/401.png" style="zoom: 33%;"></p><h3 id="4-2一维连续型随机变量函数的分布"><a href="#4-2一维连续型随机变量函数的分布" class="headerlink" title="4.2一维连续型随机变量函数的分布"></a>4.2一维连续型随机变量函数的分布</h3><p>已知随机变量 X 的概率密度函数 f (x) (或分布函数),求 Y = g( X ) 的概率密度函数或分布函数, 其中y = g( x )为连续函数</p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/420.png" style="zoom:40%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/421.png" style="zoom:40%;"></p><h4 id="两个例子"><a href="#两个例子" class="headerlink" title="两个例子"></a>两个例子</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/422.png" style="zoom:33%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/423.png" style="zoom: 33%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/424.png" style="zoom:33%;"></p><h3 id="4-3二维连续型随机变量函数的分布"><a href="#4-3二维连续型随机变量函数的分布" class="headerlink" title="4.3二维连续型随机变量函数的分布"></a>4.3二维连续型随机变量函数的分布</h3><p>问题：已知二维随机变量( X ,Y )的密度函数， g(x,y)为已知的二元函数，Z = g( X ,Y ) 求：Z 的密度函数  </p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/430.png" style="zoom: 50%;"></p><p>在本节中，我们重点讨论两种特殊的函数关系： (a) Z = X+Y (b) Z = max{ X,Y } 和 Z = min{ X,Y }, 其中 X 与 Y 相互独立.</p><h4 id="1-和的分布：Z-X-Y-（可以推广至差的分布）"><a href="#1-和的分布：Z-X-Y-（可以推广至差的分布）" class="headerlink" title="(1) 和的分布：Z = X + Y （可以推广至差的分布）"></a>(1) 和的分布：Z = X + Y （可以推广至差的分布）</h4><p>遇到$Z=kX+mY,|kX+mY|$ 的情况，先求出$f(x,y)$，再根据线性规划的思想方法根据公式$f<em>Z(z)=\int</em>{-\infty}^{+\infty}f(x,z-x)dx$ 分类讨论计算出概率密度</p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/425.png" style="zoom: 50%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/426.png" alt="426" style="zoom: 50%;"></p><h4 id="独立正态随机变量之和的情形"><a href="#独立正态随机变量之和的情形" class="headerlink" title="独立正态随机变量之和的情形"></a>独立正态随机变量之和的情形</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/431.png" style="zoom:50%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/432.png" style="zoom:50%;"></p><h4 id="2-平方和的分布：-Z-X-2-Y-2"><a href="#2-平方和的分布：-Z-X-2-Y-2" class="headerlink" title="(2) 平方和的分布： Z = X$^2$+Y$^2$"></a>(2) 平方和的分布： Z = X$^2$+Y$^2$</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/436.png" style="zoom:40%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/437.png" alt="437" style="zoom:40%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/438.png" alt="438" style="zoom:40%;"></p><h4 id="3-极值分布：即极大值，极小值的分布"><a href="#3-极值分布：即极大值，极小值的分布" class="headerlink" title="(3) 极值分布：即极大值，极小值的分布"></a>(3) 极值分布：即极大值，极小值的分布</h4><h5 id="X，Y相互独立情况下-最常见，求概率密度一般从概率分布函数入手"><a href="#X，Y相互独立情况下-最常见，求概率密度一般从概率分布函数入手" class="headerlink" title="X，Y相互独立情况下 最常见，求概率密度一般从概率分布函数入手"></a>X，Y相互独立情况下 最常见，求概率密度一般从概率分布函数入手</h5><p>对于连续型随机变量， 设 X ,Y 相互独立, X ~ F$_X$ (x), Y ~ F$_Y$ (y), M = max{ X ,Y }, N = min{ X ,Y }, 求 M , N 的分布函数.</p><h6 id="MAX-X-Y"><a href="#MAX-X-Y" class="headerlink" title="MAX(X,Y)"></a>MAX(X,Y)</h6><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/439.png" style="zoom:50%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/4311.png" style="zoom: 50%;"></p><h6 id="MIN-X-Y"><a href="#MIN-X-Y" class="headerlink" title="MIN(X,Y)"></a>MIN(X,Y)</h6><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/4310.png" style="zoom:50%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/4312.png" alt="4312" style="zoom:50%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/4313.png" alt="4313" style="zoom:40%;"></p><h5 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h5><p> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/4314.png" alt="4314" style="zoom:50%;"></p><h4 id="另一种计算方法"><a href="#另一种计算方法" class="headerlink" title="另一种计算方法"></a>另一种计算方法</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/4315.png" style="zoom:50%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/4316.png" alt="4316" style="zoom:50%;"></p><h2 id="五、随机变量的数字特征"><a href="#五、随机变量的数字特征" class="headerlink" title="五、随机变量的数字特征"></a>五、随机变量的数字特征</h2><h3 id="5-1-随机变量的数学期望"><a href="#5-1-随机变量的数学期望" class="headerlink" title="5.1 随机变量的数学期望"></a>5.1 随机变量的数学期望</h3><h4 id="数学期望的定义"><a href="#数学期望的定义" class="headerlink" title="数学期望的定义"></a>数学期望的定义</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/510.png" style="zoom:50%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/511.png" style="zoom:50%;"></p><h4 id="常见随机变量的数学期望"><a href="#常见随机变量的数学期望" class="headerlink" title="常见随机变量的数学期望"></a>常见随机变量的数学期望</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/512.png" style="zoom:50%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/513.png" alt="513" style="zoom:50%;"></p><p>超几何分布：$X—H(n,N,M)$ 取n次 一共N件产品，其中有M件次品</p><p>$EX=n*{M \over N}$ </p><p>$DX=n<em>{M \over N}</em>(1-{M \over N})*\frac {N-n}{N-1}$ 很类似二项分布</p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/514.png" alt="514" style="zoom:50%;"></p><h4 id="一般随机变量函数的数学期望"><a href="#一般随机变量函数的数学期望" class="headerlink" title="一般随机变量函数的数学期望"></a>一般随机变量函数的数学期望</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/515.png" style="zoom:50%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/516.png" alt="516" style="zoom:50%;"></p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/517.png" alt="517" style="zoom:50%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/518.png" alt="518" style="zoom:50%;"></p><h4 id="几个重要的随机变量函数的数学期望——包括：原点矩，中心矩，协方差，相关系数"><a href="#几个重要的随机变量函数的数学期望——包括：原点矩，中心矩，协方差，相关系数" class="headerlink" title="几个重要的随机变量函数的数学期望——包括：原点矩，中心矩，协方差，相关系数"></a>几个重要的随机变量函数的数学期望——包括：原点矩，中心矩，协方差，相关系数</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/519.png" style="zoom:33%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/5110.png" alt="5110" style="zoom:33%;"></p><h4 id="数学期望的性质"><a href="#数学期望的性质" class="headerlink" title="数学期望的性质"></a>数学期望的性质</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/5.1.1.png" style="zoom:50%;"></p><h3 id="5-2-方差"><a href="#5-2-方差" class="headerlink" title="5.2 方差"></a>5.2 方差</h3><h4 id="方差的概念，定义"><a href="#方差的概念，定义" class="headerlink" title="方差的概念，定义"></a>方差的概念，定义</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/520.png" style="zoom:50%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/521.png" style="zoom:50%;"></p><h4 id="常用的计算方差的公式-（很常用）"><a href="#常用的计算方差的公式-（很常用）" class="headerlink" title="常用的计算方差的公式 （很常用）"></a>常用的计算方差的公式 （很常用）</h4><p>$D(X)=E(X^2)-E^2(x)$</p><h4 id="方差的性质"><a href="#方差的性质" class="headerlink" title="方差的性质"></a>方差的性质</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/522.png" style="zoom:50%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/523.png" style="zoom:50%;"></p><h4 id="常见随机变量的方差"><a href="#常见随机变量的方差" class="headerlink" title="常见随机变量的方差"></a>常见随机变量的方差</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/524.png" style="zoom:50%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/525.png" style="zoom: 50%;"></p><h4 id="标准化随机变量"><a href="#标准化随机变量" class="headerlink" title="标准化随机变量"></a>标准化随机变量</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/526.png" style="zoom:50%;"></p><h4 id="仅知随机变量的期望与方差并不能确定其分布"><a href="#仅知随机变量的期望与方差并不能确定其分布" class="headerlink" title="仅知随机变量的期望与方差并不能确定其分布"></a>仅知随机变量的期望与方差并不能确定其分布</h4><h4 id="但若已知分布的类型，及期望和方差，常能确定分布"><a href="#但若已知分布的类型，及期望和方差，常能确定分布" class="headerlink" title="但若已知分布的类型，及期望和方差，常能确定分布"></a>但若已知分布的类型，及期望和方差，常能确定分布</h4><h3 id="5-4-协方差和相关系数"><a href="#5-4-协方差和相关系数" class="headerlink" title="5.4 协方差和相关系数"></a>5.4 协方差和相关系数</h3><h4 id="协方差和相关系数的定义"><a href="#协方差和相关系数的定义" class="headerlink" title="协方差和相关系数的定义"></a>协方差和相关系数的定义</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/540.png" style="zoom: 50%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/541.png" alt="541" style="zoom:50%;"></p><h4 id="协方差和相关系数的计算"><a href="#协方差和相关系数的计算" class="headerlink" title="协方差和相关系数的计算"></a>协方差和相关系数的计算</h4><p>利用==函数的期望==或==方差==计算协方差 </p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/542.png" style="zoom:50%;"></p><h4 id="协方差和相关系数的性质"><a href="#协方差和相关系数的性质" class="headerlink" title="协方差和相关系数的性质"></a>协方差和相关系数的性质</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/543.png" style="zoom:50%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/544.png" alt="544" style="zoom:50%;"></p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/545.png" alt="545" style="zoom:50%;"></p><h3 id="5-5-矩、协方差矩阵"><a href="#5-5-矩、协方差矩阵" class="headerlink" title="5.5 矩、协方差矩阵"></a>5.5 矩、协方差矩阵</h3><h4 id="1-矩的概念来源和矩的定义"><a href="#1-矩的概念来源和矩的定义" class="headerlink" title="1.矩的概念来源和矩的定义"></a>1.矩的概念来源和矩的定义</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/550.png" style="zoom:50%;">       <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/551.png" style="zoom:50%;"></p><h4 id="2-说明"><a href="#2-说明" class="headerlink" title="2.说明"></a>2.说明</h4><p>(1)以上数字特征都是随机变量函数的数学期望 ; </p><p>(2) 随机变量 X 的数学期望 E(X) 是 X 的一阶原点矩,方差为二阶中心矩 , 协方差 Cov(X,Y) 是 X 与 Y 的二阶混合中心矩; </p><p>(3) 在实际应用中,高于 4 阶的矩很少使用. 三阶中心矩$E{|X - E(X)|^3 }$主要用来衡量随机变量的分布==是否有偏==. 四阶中心矩 $E{|X - E(X)|^4 }$主要用来衡量随机变量的==分布==在==均值附近的陡峭程度==如何.</p><h4 id="3-协方差矩阵"><a href="#3-协方差矩阵" class="headerlink" title="3.协方差矩阵"></a>3.协方差矩阵</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/552.png" style="zoom: 50%;"></p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/553.png" style="zoom:50%;"></p><h5 id="协方差矩阵的应用"><a href="#协方差矩阵的应用" class="headerlink" title="协方差矩阵的应用"></a>协方差矩阵的应用</h5><p>协方差矩阵可用来表示多维正态随机变量的概率密度，从而可通过协方差矩阵达到对多维正态随机变量的研究。</p><h4 id="4-二维正态随机变量的概率密度函数表示形式"><a href="#4-二维正态随机变量的概率密度函数表示形式" class="headerlink" title="4.二维正态随机变量的概率密度函数表示形式"></a>4.二维正态随机变量的概率密度函数表示形式</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/554.png" style="zoom:50%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/555.png" alt="555" style="zoom:50%;"></p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/556.png" alt="556" style="zoom:50%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/557.png" alt="557" style="zoom:50%;"></p><h4 id="5-n维正态随机变量的定义"><a href="#5-n维正态随机变量的定义" class="headerlink" title="5.n维正态随机变量的定义"></a>5.n维正态随机变量的定义</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/558.png" style="zoom:50%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/559.png" alt="559" style="zoom:50%;"></p><h4 id="6-n-维正态随机变量的性质"><a href="#6-n-维正态随机变量的性质" class="headerlink" title="6.n 维正态随机变量的性质"></a>6.n 维正态随机变量的性质</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/5510.png" style="zoom:50%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/5511.png" alt="5511" style="zoom:50%;"></p><h2 id="六、大数定律与中心极限定理"><a href="#六、大数定律与中心极限定理" class="headerlink" title="六、大数定律与中心极限定理"></a>六、大数定律与中心极限定理</h2><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/600.png" style="zoom:50%;"></p><h3 id="6-1切比雪夫-Chebyshev-不等式"><a href="#6-1切比雪夫-Chebyshev-不等式" class="headerlink" title="6.1切比雪夫 (Chebyshev )不等式"></a>6.1切比雪夫 (Chebyshev )不等式</h3><h4 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h4><p>非常重要！！！可用于证很多极限</p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/610.png" style="zoom:50%;"></p><p>注：Chebyshev 不等式对于 $\epsilon^2&lt;\sigma^2$无实际意义</p><h3 id="6-2-大数定律"><a href="#6-2-大数定律" class="headerlink" title="6.2 大数定律"></a>6.2 大数定律</h3><h4 id="切比雪夫（Chebyshev）-大数定律"><a href="#切比雪夫（Chebyshev）-大数定律" class="headerlink" title="切比雪夫（Chebyshev） 大数定律"></a>切比雪夫（Chebyshev） 大数定律</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/620.png" style="zoom:50%;"></p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/621.png" style="zoom:50%;"></p><p>​                                                         <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/622.png" style="zoom:40%;"> </p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/623.png" alt="623" style="zoom:50%;"></p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/624.png" alt="624" style="zoom:40%;"></p><h5 id="切比雪夫大数定律推论的意义"><a href="#切比雪夫大数定律推论的意义" class="headerlink" title="切比雪夫大数定律推论的意义"></a>切比雪夫大数定律推论的意义</h5><p>具有相同数学期望和方差的独立随机变量序列的算术平均值依概率收敛于数学期望. 当 n 足够大时，算术平均值几乎就是一个常数, 可以用算术平均值近似地代替数学期望.</p><h4 id="伯努利（Bernoulli）-大数定律"><a href="#伯努利（Bernoulli）-大数定律" class="headerlink" title="伯努利（Bernoulli） 大数定律"></a>伯努利（Bernoulli） 大数定律</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/625.png" style="zoom:50%;"></p><h5 id="伯努利（Bernoulli）-大数定律的意义"><a href="#伯努利（Bernoulli）-大数定律的意义" class="headerlink" title="伯努利（Bernoulli） 大数定律的意义"></a>伯努利（Bernoulli） 大数定律的意义</h5><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/626.png" style="zoom:50%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/627.png" style="zoom:50%;"></p><h4 id="辛钦大数定律（即上面的切比雪夫大数定律的推论）"><a href="#辛钦大数定律（即上面的切比雪夫大数定律的推论）" class="headerlink" title="辛钦大数定律（即上面的切比雪夫大数定律的推论）"></a>辛钦大数定律（即上面的切比雪夫大数定律的推论）</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/628.png" style="zoom:50%;"></p><p><strong>6.1、6.2做题模式</strong>：利用切比雪夫不等式，证明辛奇大数定律或者切比雪夫大数定律</p><h3 id="6-3-中心极限定理"><a href="#6-3-中心极限定理" class="headerlink" title="6.3 中心极限定理"></a>6.3 中心极限定理</h3><h4 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/630.png" style="zoom:50%;"></p><h4 id="定理1-独立同分布的中心极限定理"><a href="#定理1-独立同分布的中心极限定理" class="headerlink" title="定理1 独立同分布的中心极限定理"></a>定理1 独立同分布的中心极限定理</h4><p>这里的$Y_n也可以写成Y^*$</p><p>类似之前的标准向量$X^*$</p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/631.png" style="zoom:40%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/632.png" style="zoom:40%;"></p><h4 id="定理2-德莫佛-—-拉普拉斯定理-（DeMoivre-Laplace-）"><a href="#定理2-德莫佛-—-拉普拉斯定理-（DeMoivre-Laplace-）" class="headerlink" title="定理2 德莫佛 — 拉普拉斯定理 （DeMoivre-Laplace ）"></a>定理2 德莫佛 — 拉普拉斯定理 （DeMoivre-Laplace ）</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/633.png" style="zoom:50%;"></p><h1 id="数理统计-第7章—第9章"><a href="#数理统计-第7章—第9章" class="headerlink" title="数理统计(第7章—第9章)"></a>数理统计(第7章—第9章)</h1><h2 id="七、数理统计的基本概念"><a href="#七、数理统计的基本概念" class="headerlink" title="七、数理统计的基本概念"></a>七、数理统计的基本概念</h2><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/634.png" style="zoom:50%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/635.png" alt="635" style="zoom:50%;"></p><h3 id="7-1-基本概念"><a href="#7-1-基本概念" class="headerlink" title="7.1 基本概念"></a>7.1 基本概念</h3><h4 id="总体和个体"><a href="#总体和个体" class="headerlink" title="总体和个体"></a>总体和个体</h4><p>总体 —— 研究对象全体元素组成的集合——在实际中通常指所研究的对象的某个(或某些)数量指标的全体,它是随机变量，可记为X</p><p><strong>总体</strong>—— <strong>随机变量X</strong>。X 的==分布函数==和==数字特征==称为总体的==分布函数==和==数字特征==。</p><p><strong>个体</strong> —— <strong>组成总体的每一个元素</strong>。即总体的==每个数量指标==,可以看作随机变量 X 的==某个取值==。</p><h4 id="样本与样本值"><a href="#样本与样本值" class="headerlink" title="样本与样本值"></a>样本与样本值</h4><p><strong>随机抽样</strong> —— 从客观存在的总体中,按照==机会均等==的原则随机的抽取一些个体进行观测的过程</p><p><strong>样本观测值</strong>—— 从一总体X中,随机的抽取n个个体(有放回的抽取),得到n个观测值$x_1,x_2…x_n$ 称它们为总体 X 的一个容量为n 的样本观测 值,或称==样本的一个实现==。</p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/710.png" style="zoom: 33%;"><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/711.png" alt="711" style="zoom: 33%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/712.png" alt="712" style="zoom: 33%;"></p><h3 id="7-2-样本矩与统计量"><a href="#7-2-样本矩与统计量" class="headerlink" title="7.2 样本矩与统计量"></a>7.2 样本矩与统计量</h3><h4 id="统计量定义"><a href="#统计量定义" class="headerlink" title="统计量定义"></a>统计量定义</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/720.png" style="zoom:50%;"></p><h4 id="常用的统计量"><a href="#常用的统计量" class="headerlink" title="常用的统计量"></a>常用的统计量</h4><h5 id="1-4-样本矩"><a href="#1-4-样本矩" class="headerlink" title="(1)-(4)样本矩"></a>(1)-(4)样本矩</h5><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/721.png" style="zoom:40%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/722.png" alt="722" style="zoom:40%;"></p><h5 id="5-顺序统计量"><a href="#5-顺序统计量" class="headerlink" title="(5)顺序统计量"></a>(5)顺序统计量</h5><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/723.png" style="zoom: 40%;"></p><h4 id="经验分布函数"><a href="#经验分布函数" class="headerlink" title="经验分布函数"></a>经验分布函数</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/724.png" style="zoom:40%;"></p><h4 id="注意：样本方差和样本中心矩不同-（还需理解）"><a href="#注意：样本方差和样本中心矩不同-（还需理解）" class="headerlink" title="注意：样本方差和样本中心矩不同   （还需理解）"></a>注意：样本方差和样本中心矩不同   （还需理解）</h4><p>这里的$S_n^2$其实就是样本二阶中心矩$B_2$，也是前面<strong>方差</strong>的定义式</p><p>而$S^2$则是样本方差</p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/725.png" style="zoom:40%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/726.png" style="zoom:40%;"></p><h3 id="7-3-统计量的分布"><a href="#7-3-统计量的分布" class="headerlink" title="7.3 统计量的分布"></a>7.3 统计量的分布</h3><h4 id="统计中常用分布"><a href="#统计中常用分布" class="headerlink" title="统计中常用分布"></a>统计中常用分布</h4><h5 id="1-正态总体样本的线性函数的分布"><a href="#1-正态总体样本的线性函数的分布" class="headerlink" title="(1) 正态总体样本的线性函数的分布"></a>(1) 正态总体样本的线性函数的分布</h5><h6 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h6><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/730.png" style="zoom:40%;"></p><h5 id="2-chi-2-n-分布-n为自由度-！！！！"><a href="#2-chi-2-n-分布-n为自由度-！！！！" class="headerlink" title="(2) $\chi^2(n)$ 分布 ( n为自由度 )！！！！"></a>(2) $\chi^2(n)$ 分布 ( n为自由度 )！！！！</h5><h6 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h6><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/731.png" style="zoom:40%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/732.png" alt="732" style="zoom:40%;"></p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/733.png" alt="733" style="zoom:40%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/734.png" alt="734" style="zoom:40%;"></p><h6 id="chi-2-n-分布的性质"><a href="#chi-2-n-分布的性质" class="headerlink" title="$\chi^2(n)$ 分布的性质"></a>$\chi^2(n)$ 分布的性质</h6><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/735.png" style="zoom:40%;"></p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/7.3-1.png" style="zoom:40%;"></p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/7.3-2.png" style="zoom:40%;"></p><h5 id="3-t-分布！！！！"><a href="#3-t-分布！！！！" class="headerlink" title="(3) t 分布！！！！"></a>(3) t 分布！！！！</h5><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/736.png" style="zoom:40%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/737.png" alt="737" style="zoom:40%;"></p><h6 id="t-分布的性质"><a href="#t-分布的性质" class="headerlink" title="t 分布的性质"></a>t 分布的性质</h6><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/738.png" style="zoom:40%;"></p><h6 id="alpha-分位点​"><a href="#alpha-分位点​" class="headerlink" title="$\alpha $分位点​"></a>$\alpha $分位点​</h6><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/739.png" style="zoom:40%;"></p><h6 id="两个相关定理"><a href="#两个相关定理" class="headerlink" title="两个相关定理"></a>两个相关定理</h6><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/7310.png" style="zoom:40%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/7311.png" alt="7311" style="zoom:40%;"></p><h5 id="4-F-分布！！！！"><a href="#4-F-分布！！！！" class="headerlink" title="(4) F 分布！！！！"></a>(4) F 分布！！！！</h5><h6 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h6><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/7312.png" style="zoom:40%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/7313.png" alt="7313" style="zoom: 33%;"></p><h6 id="F-分布的性质"><a href="#F-分布的性质" class="headerlink" title="F 分布的性质"></a>F 分布的性质</h6><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/7314.png" style="zoom:40%;"></p><h2 id="八、参数估计"><a href="#八、参数估计" class="headerlink" title="八、参数估计"></a>八、参数估计</h2><h4 id="统计推断的基本问题"><a href="#统计推断的基本问题" class="headerlink" title="统计推断的基本问题"></a>统计推断的基本问题</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/8-7.png" style="zoom:50%;"></p><h3 id="8-1参数的点估计"><a href="#8-1参数的点估计" class="headerlink" title="8.1参数的点估计"></a>8.1参数的点估计</h3><h4 id="矩估计法"><a href="#矩估计法" class="headerlink" title="矩估计法"></a>矩估计法</h4><p>==总体分布类型未知==</p><p>先根据概率密度$f(x,\theta)$，求出$EX,EX^2,DX…$等总体矩（但是为了求出$\theta$，需要让求出的结果包含$\theta$)</p><p>再根据求得的总体矩和$\theta$的关系，利用样本矩反推出$\theta$</p><h4 id="极大似然估计法"><a href="#极大似然估计法" class="headerlink" title="极大似然估计法"></a>极大似然估计法</h4><p>极大似然估计法是在==总体的分布类型已知==的条件下所使用的一种参数估计方法。</p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/801.png" style="zoom:33%;"></p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/802.png" alt="802" style="zoom:33%;"></p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/803.png" alt="803" style="zoom:33%;"></p><h5 id="求未知参数的极大似然估计值-量-的方法"><a href="#求未知参数的极大似然估计值-量-的方法" class="headerlink" title="求未知参数的极大似然估计值(量)的方法"></a>求未知参数的极大似然估计值(量)的方法</h5><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/804.png" style="zoom:40%;"></p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/805.png" style="zoom:40%;"></p><h5 id="极大似然估计值的不变性原理"><a href="#极大似然估计值的不变性原理" class="headerlink" title="极大似然估计值的不变性原理"></a>极大似然估计值的不变性原理</h5><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/806.png" style="zoom:40%;"></p><h3 id="8-2点估计量的优良性"><a href="#8-2点估计量的优良性" class="headerlink" title="8.2点估计量的优良性"></a>8.2点估计量的优良性</h3><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/8.2.1.png" style="zoom:50%;"></p><h4 id="1-无偏估计"><a href="#1-无偏估计" class="headerlink" title="1.无偏估计"></a>1.无偏估计</h4><h5 id="无偏性"><a href="#无偏性" class="headerlink" title="无偏性"></a>无偏性</h5><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/8.2.2.png" style="zoom:40%;"></p><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/8.2.3.png" style="zoom:40%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/8.2.4.png" alt="8.2.4" style="zoom:40%;"></p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/825.png" style="zoom:30%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/826.png" alt="826" style="zoom:30%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/827.png" alt="827" style="zoom:40%;"></p><h4 id="2-最小方差无偏估计"><a href="#2-最小方差无偏估计" class="headerlink" title="2.最小方差无偏估计"></a>2.最小方差无偏估计</h4><h5 id="有效性"><a href="#有效性" class="headerlink" title="有效性"></a>有效性</h5><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/828.png" style="zoom:40%;"></p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/829.png" style="zoom:40%;"></p><h4 id="3-一致-或相合-估计"><a href="#3-一致-或相合-估计" class="headerlink" title="3.一致(或相合)估计"></a>3.一致(或相合)估计</h4><h5 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h5><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/830.png" style="zoom:40%;"></p><h3 id="8-3区间估计与置信区间"><a href="#8-3区间估计与置信区间" class="headerlink" title="8.3区间估计与置信区间"></a>8.3区间估计与置信区间</h3><h4 id="置信区间基本概念与求法"><a href="#置信区间基本概念与求法" class="headerlink" title="置信区间基本概念与求法"></a>置信区间基本概念与求法</h4><h5 id="置信区间的意义"><a href="#置信区间的意义" class="headerlink" title="置信区间的意义"></a>置信区间的意义</h5><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/831.png" style="zoom:30%;"></p><h5 id="置信区间的定义"><a href="#置信区间的定义" class="headerlink" title="置信区间的定义"></a>置信区间的定义</h5><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/832.png" style="zoom:40%;"></p><h5 id="几点说明"><a href="#几点说明" class="headerlink" title="几点说明"></a>几点说明</h5><pre class="mermaid">graph LRA[α降低]-->B[置信区间长度增大]A-->C[估计精度高]A-->D[之前拒绝的现在不一定拒绝]</pre><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/833.png" style="zoom:40%;"></p><h5 id="求置信区间的步骤"><a href="#求置信区间的步骤" class="headerlink" title="求置信区间的步骤"></a>求置信区间的步骤</h5><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/834.png" style="zoom:40%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/835.png" style="zoom:40%;"></p><h4 id="置信区间常用公式"><a href="#置信区间常用公式" class="headerlink" title="置信区间常用公式"></a>置信区间常用公式</h4><h5 id="一-一个正态总体-X—N-mu-sigma-2-的情形"><a href="#一-一个正态总体-X—N-mu-sigma-2-的情形" class="headerlink" title="(一) 一个正态总体$X—N ( \mu ,\sigma ^2)$的情形"></a>(一) 一个正态总体$X—N ( \mu ,\sigma ^2)$的情形</h5><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/836.png" style="zoom:40%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/837.png" alt="837" style="zoom:40%;"></p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/838.png" alt="838" style="zoom:40%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/840.png" alt="840" style="zoom:40%;"></p><p>  <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/839.png" alt="839" style="zoom:40%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/841.png" alt="841" style="zoom:40%;"></p><h5 id="二-单侧置信区间"><a href="#二-单侧置信区间" class="headerlink" title="(二) 单侧置信区间"></a>(二) 单侧置信区间</h5><p> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/842.png" style="zoom:40%;"></p><h2 id="九、假设检验"><a href="#九、假设检验" class="headerlink" title="九、假设检验"></a>九、假设检验</h2><h3 id="9-1-假设检验的基本概念"><a href="#9-1-假设检验的基本概念" class="headerlink" title="9.1 假设检验的基本概念"></a>9.1 假设检验的基本概念</h3><h4 id="何为假设检验"><a href="#何为假设检验" class="headerlink" title="何为假设检验?"></a>何为假设检验?</h4><p>假设是指施加于一个或多个总体的<strong>概率分布或参数的判断</strong>. 所作的假设可以是正确的, 也可以是错误的. </p><p>为判断所作的假设是否正确, <strong>从总体中抽取样本</strong>, 根据样本的取值, 按一定的原则进行检验, 然后, 作出<strong>接受或拒绝</strong>所作假设的决定.</p><h4 id="假设检验的内容"><a href="#假设检验的内容" class="headerlink" title="假设检验的内容"></a>假设检验的内容</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/901.png" style="zoom:40%;"></p><h4 id="假设检验的理论依据"><a href="#假设检验的理论依据" class="headerlink" title="假设检验的理论依据"></a>假设检验的理论依据</h4><p>假设检验所以可行，其理论背景为实际推断原理，即“小概率原理”</p><h4 id="假设检验的两类错误"><a href="#假设检验的两类错误" class="headerlink" title="假设检验的两类错误"></a>假设检验的两类错误</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/907.png" style="zoom:40%;"></p><p>希望所用的检验方法尽量少犯错误,但不能完全排除犯错误的可能性.理想的检验方法应使犯两类错误的概率都很小,但在样本的容量给定的情形下, 不可能使两者都很小,降低一个, 往往使另一个增大. </p><p>假设检验的<strong>指导思想</strong>是控制犯第一类错误的概率不超过$\alpha$,然后, 若有必要,通过增大<strong>样本容量</strong>的方法,减少 $\beta$</p><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>拒绝 H0的概率为$\alpha$ , $\alpha$又称为显著性水 平, $\alpha$越小,犯第一类错误的概率越小</p><p>$H_0$：原假设或零假设</p><p>原假设的对立面$H_1$：备择假设——备择假设可以为单侧或双侧</p><h4 id="假设检验的步骤"><a href="#假设检验的步骤" class="headerlink" title="假设检验的步骤"></a>假设检验的步骤</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/902.png" style="zoom:40%;"></p><h3 id="9-2-正态总体的参数检验"><a href="#9-2-正态总体的参数检验" class="headerlink" title="9.2 正态总体的参数检验"></a>9.2 正态总体的参数检验</h3><h4 id="关于-mu-的检验-sigma-2-已知"><a href="#关于-mu-的检验-sigma-2-已知" class="headerlink" title="关于$\mu$ 的检验($\sigma^2$已知)"></a>关于$\mu$ 的检验($\sigma^2$已知)</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/903.png" style="zoom:40%;"></p><h4 id="关于-mu-的检验-sigma-2-未知"><a href="#关于-mu-的检验-sigma-2-未知" class="headerlink" title="关于$\mu$ 的检验($\sigma^2$未知)"></a>关于$\mu$ 的检验($\sigma^2$未知)</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/904.png" style="zoom:40%;"></p><h4 id="关于-sigma-2-的检验-mu-未知"><a href="#关于-sigma-2-的检验-mu-未知" class="headerlink" title="关于$\sigma^2$的检验($\mu$ 未知)"></a>关于$\sigma^2$的检验($\mu$ 未知)</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/905.png" style="zoom:40%;"></p><h4 id="关于-sigma-2-的检验-mu-已知"><a href="#关于-sigma-2-的检验-mu-已知" class="headerlink" title="关于$\sigma^2$的检验($\mu$ 已知)"></a>关于$\sigma^2$的检验($\mu$ 已知)</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/906.png" style="zoom:40%;"></p><h1 id="随机过程-第10章—第12章"><a href="#随机过程-第10章—第12章" class="headerlink" title="随机过程(第10章—第12章)"></a>随机过程(第10章—第12章)</h1><h2 id="十、随机过程的基本概念"><a href="#十、随机过程的基本概念" class="headerlink" title="十、随机过程的基本概念"></a>十、随机过程的基本概念</h2><p>随机变量$X(t)—&gt;$对于每一个t来说的</p><p>随机变量族——随机过程${N(t),t\in [0,+\infty]}$</p><h3 id="10-1随机过程的定义"><a href="#10-1随机过程的定义" class="headerlink" title="10.1随机过程的定义"></a>10.1随机过程的定义</h3><h4 id="随机过程定义"><a href="#随机过程定义" class="headerlink" title="随机过程定义"></a>随机过程定义</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1001.png" style="zoom:30%;"></p><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1006.png" style="zoom:40%;"></p><h5 id="对定义的理解"><a href="#对定义的理解" class="headerlink" title="对定义的理解"></a>对定义的理解</h5><p>固定t——随机变量——n维分布</p><p>固定e——样本函数</p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1002.png" style="zoom:40%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1003.png" style="zoom:40%;"></p><h4 id="随机过程分类"><a href="#随机过程分类" class="headerlink" title="随机过程分类"></a>随机过程分类</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1004.png" style="zoom:40%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1005.png" style="zoom:40%;"></p><h3 id="10-2随机过程的概率分布"><a href="#10-2随机过程的概率分布" class="headerlink" title="10.2随机过程的概率分布"></a>10.2随机过程的概率分布</h3><h4 id="单个随机过程有限维分布"><a href="#单个随机过程有限维分布" class="headerlink" title="单个随机过程有限维分布"></a>单个随机过程有限维分布</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1007.png" style="zoom:30%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1008.png" style="zoom:30%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1009.png" style="zoom:30%;"></p><h4 id="两个随机过程有限维联合分布及独立性"><a href="#两个随机过程有限维联合分布及独立性" class="headerlink" title="两个随机过程有限维联合分布及独立性"></a>两个随机过程有限维联合分布及独立性</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1010.png" style="zoom:30%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1011.png" style="zoom:30%;"></p><h3 id="10-3随机过程的数字特征"><a href="#10-3随机过程的数字特征" class="headerlink" title="10.3随机过程的数字特征"></a>10.3随机过程的数字特征</h3><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1012.png" style="zoom:30%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1013.png" alt="1013" style="zoom:30%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1014.png" alt="1014" style="zoom:30%;"> </p><p>均值、均方值、方差和均方差是刻划随机过程在各个状态的统计特性的； 过程的任何两个不同状态的统计特性的。 </p><p>这五个数字特征之间，具有如下关系：</p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1015.png" style="zoom:30%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1016.png" style="zoom:30%;"></p><h2 id="十一、平稳过程"><a href="#十一、平稳过程" class="headerlink" title="十一、平稳过程"></a>十一、平稳过程</h2><h3 id="11-1-严平稳过程"><a href="#11-1-严平稳过程" class="headerlink" title="11.1 严平稳过程"></a>11.1 严平稳过程</h3><h4 id="定义-11"><a href="#定义-11" class="headerlink" title="定义"></a>定义</h4><p> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1100.png" style="zoom:40%;"></p><h4 id="严平稳过程的一维、二维分布函数的性质"><a href="#严平稳过程的一维、二维分布函数的性质" class="headerlink" title="严平稳过程的一维、二维分布函数的性质"></a>严平稳过程的一维、二维分布函数的性质</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1105.png" style="zoom:50%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1106.png" alt="1106" style="zoom:50%;"></p><h4 id="严平稳过程的等价条件"><a href="#严平稳过程的等价条件" class="headerlink" title="严平稳过程的等价条件"></a>严平稳过程的等价条件</h4><p> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1107.png" style="zoom:40%;"></p><h4 id="严平稳过程的数字特征的性质"><a href="#严平稳过程的数字特征的性质" class="headerlink" title="严平稳过程的数字特征的性质"></a>严平稳过程的数字特征的性质</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1108.png" style="zoom:50%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1109.png" alt="1109" style="zoom:50%;"></p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1110.png" alt="1110" style="zoom:50%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1111.png" alt="1111" style="zoom:50%;"></p><h3 id="11-2-广义平稳过程"><a href="#11-2-广义平稳过程" class="headerlink" title="11.2 广义平稳过程"></a>11.2 广义平稳过程</h3><h4 id="广义平稳过程的定义"><a href="#广义平稳过程的定义" class="headerlink" title="广义平稳过程的定义"></a>广义平稳过程的定义</h4><p> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1101.png" style="zoom:40%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1104.png" style="zoom:40%;"></p><h4 id="广义平稳过程的数字特征的性质"><a href="#广义平稳过程的数字特征的性质" class="headerlink" title="广义平稳过程的数字特征的性质"></a>广义平稳过程的数字特征的性质</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1102.png" style="zoom:40%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1103.png" style="zoom:40%;"></p><h4 id="严平稳过程与广义平稳过程的关系"><a href="#严平稳过程与广义平稳过程的关系" class="headerlink" title="严平稳过程与广义平稳过程的关系"></a>严平稳过程与广义平稳过程的关系</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1112.png" style="zoom:40%;"></p><h4 id="两个平稳过程的关系"><a href="#两个平稳过程的关系" class="headerlink" title="两个平稳过程的关系"></a>两个平稳过程的关系</h4><p>广义平稳过程通常简称为平稳过程</p><h3 id="11-3正态平稳过程"><a href="#11-3正态平稳过程" class="headerlink" title="11.3正态平稳过程"></a>11.3正态平稳过程</h3><h4 id="正态过程，正态序列"><a href="#正态过程，正态序列" class="headerlink" title="正态过程，正态序列"></a>正态过程，正态序列</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1131.png" style="zoom:40%;"></p><h4 id="正态平稳过程"><a href="#正态平稳过程" class="headerlink" title="正态平稳过程"></a>正态平稳过程</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1132.png" style="zoom:40%;"></p><h3 id="11-4遍历过程-历经过程"><a href="#11-4遍历过程-历经过程" class="headerlink" title="11.4遍历过程(历经过程)"></a>11.4遍历过程(历经过程)</h3><h4 id="一-时间均值和时间相关函数"><a href="#一-时间均值和时间相关函数" class="headerlink" title="一.时间均值和时间相关函数"></a>一.时间均值和时间相关函数</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1141.png" style="zoom:40%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1142.png" style="zoom:40%;"></p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1143.png" style="zoom:40%;"></p><h4 id="二-各态遍历性"><a href="#二-各态遍历性" class="headerlink" title="二. 各态遍历性"></a>二. 各态遍历性</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1144.png" style="zoom:40%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1145.png" style="zoom:40%;"></p><h4 id="经典例题"><a href="#经典例题" class="headerlink" title="经典例题"></a>经典例题</h4><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1146.png" style="zoom:50%;"></p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1147.png" style="zoom:60%;"></p><h2 id="十二、马尔可夫链"><a href="#十二、马尔可夫链" class="headerlink" title="十二、马尔可夫链"></a>十二、马尔可夫链</h2><p>马尔可夫过程是一类特殊的随机过程, 马尔可夫链是离散状态的马尔可夫过程</p><h3 id="12-1马尔可夫链的定义"><a href="#12-1马尔可夫链的定义" class="headerlink" title="12.1马尔可夫链的定义"></a>12.1马尔可夫链的定义</h3><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1201.png" style="zoom:35%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1202.png" style="zoom:35%;"></p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1203.png" style="zoom:35%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1204.png" style="zoom:40%;"></p><h3 id="12-2参数离散的齐次马尔可夫链"><a href="#12-2参数离散的齐次马尔可夫链" class="headerlink" title="12.2参数离散的齐次马尔可夫链"></a>12.2参数离散的齐次马尔可夫链</h3><p>一、转移概率矩阵</p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1205.png" style="zoom:35%;"> <img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1206.png" style="zoom:35%;"></p><p><img src="/2022/09/19/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/1207.png" style="zoom:35%;"></p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Probability Statistics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学分析</title>
      <link href="2022/09/19/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/"/>
      <url>2022/09/19/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="工科数学分析1"><a href="#工科数学分析1" class="headerlink" title="工科数学分析1"></a>工科数学分析1</h1><h2 id="数列与数列极限基本定义"><a href="#数列与数列极限基本定义" class="headerlink" title="数列与数列极限基本定义"></a>数列与数列极限基本定义</h2><p>按自然数编号依次排列的一列数</p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920164851709.png" alt="image-20220920164851709" style="zoom: 67%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920165036128.png" alt="image-20220920165036128" style="zoom: 67%;"></p><h2 id="收敛数列的性质"><a href="#收敛数列的性质" class="headerlink" title="收敛数列的性质"></a>收敛数列的性质</h2><h3 id="收敛数列的性质-唯一性、有界性、不等式性质"><a href="#收敛数列的性质-唯一性、有界性、不等式性质" class="headerlink" title="收敛数列的性质 唯一性、有界性、不等式性质"></a>收敛数列的性质 唯一性、有界性、不等式性质</h3><p>定理2.1：若数列<strong>收敛</strong>, 则其<strong>极限唯一</strong></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920165213800.png" alt="image-20220920165213800" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920165239768.png" alt="image-20220920165239768" style="zoom:50%;"></p><h3 id="夹逼定理"><a href="#夹逼定理" class="headerlink" title="夹逼定理"></a>夹逼定理</h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920165508895.png" alt="image-20220920165508895" style="zoom:50%;"></p><h3 id="极限四则运算"><a href="#极限四则运算" class="headerlink" title="极限四则运算"></a>极限四则运算</h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920165303984.png" alt="image-20220920165303984" style="zoom:50%;"></p><h3 id="子列极限"><a href="#子列极限" class="headerlink" title="子列极限"></a>子列极限</h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920165338489.png" alt="image-20220920165338489" style="zoom:50%;"></p><h3 id="无穷小"><a href="#无穷小" class="headerlink" title="无穷小"></a>无穷小</h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920165417744.png" alt="image-20220920165417744" style="zoom:50%;"></p><h2 id="单调有界定理及其应用"><a href="#单调有界定理及其应用" class="headerlink" title="单调有界定理及其应用"></a>单调有界定理及其应用</h2><h3 id="确界存在定理"><a href="#确界存在定理" class="headerlink" title="确界存在定理"></a>确界存在定理</h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920165823624.png" alt="image-20220920165823624" style="zoom: 67%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920165912780.png" alt="image-20220920165912780" style="zoom: 67%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920165926753.png" alt="image-20220920165926753" style="zoom: 67%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920165957847.png" alt="image-20220920165957847" style="zoom: 67%;"></p><h3 id="单调有界定理"><a href="#单调有界定理" class="headerlink" title="单调有界定理"></a>单调有界定理</h3><p>单调有界数列必有极限</p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920170214056.png" alt="image-20220920170214056" style="zoom: 67%;"></p><h3 id="闭区间套定理"><a href="#闭区间套定理" class="headerlink" title="闭区间套定理"></a>闭区间套定理</h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920170406786.png" alt="image-20220920170406786" style="zoom: 67%;"></p><h2 id="实数的完备性：Cauchy收敛定理"><a href="#实数的完备性：Cauchy收敛定理" class="headerlink" title="实数的完备性：Cauchy收敛定理"></a>实数的完备性：Cauchy收敛定理</h2><h3 id="列紧性定理"><a href="#列紧性定理" class="headerlink" title="列紧性定理"></a>列紧性定理</h3><p>定理5.1 任意有界数列中必有收敛子列</p><h3 id="基本列"><a href="#基本列" class="headerlink" title="基本列"></a>基本列</h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920170651841.png" alt="image-20220920170651841" style="zoom: 67%;"></p><h3 id="柯西收敛准则"><a href="#柯西收敛准则" class="headerlink" title="柯西收敛准则"></a>柯西收敛准则</h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920170811007.png" alt="image-20220920170811007" style="zoom:67%;"></p><h3 id="有限覆盖定理"><a href="#有限覆盖定理" class="headerlink" title="有限覆盖定理"></a>有限覆盖定理</h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920170850056.png" alt="image-20220920170850056" style="zoom:67%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920170945850.png" alt="image-20220920170945850" style="zoom:50%;"></p><h2 id="上极限和下极限"><a href="#上极限和下极限" class="headerlink" title="上极限和下极限"></a>上极限和下极限</h2><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920171547823.png" alt="image-20220920171547823" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920171640994.png" alt="image-20220920171640994" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920171706672.png" alt="image-20220920171706672" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920171733714.png" alt="image-20220920171733714" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920171851417.png" alt="image-20220920171851417" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920171909640.png" alt="image-20220920171909640" style="zoom:50%;"></p><h2 id="函数极限的定义与基本性质"><a href="#函数极限的定义与基本性质" class="headerlink" title="函数极限的定义与基本性质"></a>函数极限的定义与基本性质</h2><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920172009409.png" alt="image-20220920172009409" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920172112377.png" alt="image-20220920172112377" style="zoom:67%;"></p><h3 id="函数极限的性质"><a href="#函数极限的性质" class="headerlink" title="函数极限的性质"></a>函数极限的性质</h3><p>极限唯一性 局部有界性（x0的邻域有界） 保序性 保号性 夹逼定理</p><h4 id="海涅定理和柯西定理"><a href="#海涅定理和柯西定理" class="headerlink" title="海涅定理和柯西定理"></a>海涅定理和柯西定理</h4><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920172422809.png" alt="image-20220920172422809" style="zoom: 67%;"></p><p>建立了<strong>数列极限和函数极限的联系</strong></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920172618296.png" alt="image-20220920172618296" style="zoom:67%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920172810025.png" alt="image-20220920172810025" style="zoom:50%;"></p><h2 id="连续函数"><a href="#连续函数" class="headerlink" title="连续函数"></a>连续函数</h2><h3 id="函数连续定义"><a href="#函数连续定义" class="headerlink" title="函数连续定义"></a>函数连续定义</h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920172920967.png" alt="image-20220920172920967" style="zoom: 67%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920173038793.png" alt="image-20220920173038793" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920173057865.png" alt="image-20220920173057865" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920173119153.png" alt="image-20220920173119153" style="zoom:50%;"></p><h3 id="函数的间断点"><a href="#函数的间断点" class="headerlink" title="函数的间断点"></a>函数的间断点</h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920173252617.png" alt="image-20220920173252617" style="zoom:67%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920173308920.png" alt="image-20220920173308920" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920173317816.png" alt="image-20220920173317816" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920173354402.png" alt="image-20220920173354402" style="zoom:67%;"></p><h2 id="无穷小与无穷大的阶的比较"><a href="#无穷小与无穷大的阶的比较" class="headerlink" title="无穷小与无穷大的阶的比较"></a>无穷小与无穷大的阶的比较</h2><p>无穷小-某个点极限为0</p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920184648562.png" alt="image-20220920184648562" style="zoom:67%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920184806123.png" alt="image-20220920184806123" style="zoom:67%;"></p><p>无穷大-某个点极限为无穷</p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920184905571.png" alt="image-20220920184905571" style="zoom:67%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920184919146.png" alt="image-20220920184919146" style="zoom:67%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920185046058.png" alt="image-20220920185046058" style="zoom:67%;"></p><h2 id="函数的一致连续"><a href="#函数的一致连续" class="headerlink" title="函数的一致连续"></a>函数的一致连续</h2><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920185218593.png" alt="image-20220920185218593" style="zoom:67%;"></p><h3 id="有限闭区间上连续函数的性质"><a href="#有限闭区间上连续函数的性质" class="headerlink" title="有限闭区间上连续函数的性质"></a>有限闭区间上连续函数的性质</h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920185255826.png" alt="image-20220920185255826" style="zoom:67%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920185640201.png" alt="image-20220920185640201" style="zoom:67%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920185658769.png" alt="image-20220920185658769" style="zoom:67%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920185710428.png" alt="image-20220920185710428" style="zoom:67%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920185722279.png" alt="image-20220920185722279" style="zoom:67%;"></p><h2 id="4-1-导数的定义"><a href="#4-1-导数的定义" class="headerlink" title="4.1 导数的定义"></a>4.1 导数的定义</h2><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920185823188.png" alt="image-20220920185823188" style="zoom:67%;"></p><p>可导等价于左导数=右导数</p><p>可导函数都是连续函数 反之不一定</p><h2 id="4-2-导数的运算法则"><a href="#4-2-导数的运算法则" class="headerlink" title="4.2 导数的运算法则"></a>4.2 导数的运算法则</h2><p>四则运算 复合求导 反函数求导（反函数的导数等于直接函数导数的倒数）</p><h2 id="4-3-高阶导数"><a href="#4-3-高阶导数" class="headerlink" title="4.3 高阶导数"></a>4.3 高阶导数</h2><p>导数的导数</p><h3 id="莱布尼兹公式"><a href="#莱布尼兹公式" class="headerlink" title="莱布尼兹公式"></a>莱布尼兹公式</h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920190327641.png" alt="image-20220920190327641" style="zoom:67%;"></p><h2 id="4-4-隐函数和参数方程的求导"><a href="#4-4-隐函数和参数方程的求导" class="headerlink" title="4.4 隐函数和参数方程的求导"></a>4.4 隐函数和参数方程的求导</h2><h2 id="4-5-微分中值定理"><a href="#4-5-微分中值定理" class="headerlink" title="4.5 微分中值定理"></a>4.5 微分中值定理</h2><p><img src="/2022/09/19/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90/Users/fzc/AppData/Roaming/Typora/typora-user-images/image-20220920190654107.png" alt="image-20220920190654107" style="zoom:67%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920190725049.png" alt="image-20220920190725049" style="zoom:67%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920190741737.png" alt="image-20220920190741737" style="zoom:67%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920190826073.png" alt="image-20220920190826073" style="zoom:67%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/shuxuefenxi1image-20220920190940938.png" alt="image-20220920190940938" style="zoom:67%;"></p><h2 id="4-6-利用导数研究函数的性质"><a href="#4-6-利用导数研究函数的性质" class="headerlink" title="4.6 利用导数研究函数的性质"></a>4.6 利用导数研究函数的性质</h2><p>单调性，严格单调性</p><h1 id="工科数学分析2"><a href="#工科数学分析2" class="headerlink" title="工科数学分析2"></a>工科数学分析2</h1>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mathematical Analysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数</title>
      <link href="2022/09/18/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
      <url>2022/09/18/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="工科高等代数"><a href="#工科高等代数" class="headerlink" title="工科高等代数"></a>工科高等代数</h1><h2 id="0-空间解析几何"><a href="#0-空间解析几何" class="headerlink" title="0.空间解析几何"></a>0.空间解析几何</h2><h3 id="向量及其线性运算"><a href="#向量及其线性运算" class="headerlink" title="向量及其线性运算"></a>向量及其线性运算</h3><h4 id="向量的线性运算"><a href="#向量的线性运算" class="headerlink" title="向量的线性运算"></a>向量的线性运算</h4><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918142454049.png" alt="image-20220918142454049" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918142510342.png" alt="image-20220918142510342" style="zoom:50%;"></p><h5 id="两非零向量的关系"><a href="#两非零向量的关系" class="headerlink" title="两非零向量的关系"></a>两非零向量的关系</h5><p>相等：大小相等方向相同</p><p>平行或共线：方向相同或相反的两个非零向量</p><p>垂直：方向成90度夹角</p><p>共面：若干个向量起点放在一起，终点和公共起点在同一平面上</p><p>向量加法与数乘统称为向量的线性运算  单位向量的表示</p><p>向量$\vec b$平行于向量$\vec a$等价于存在唯一实数$\lambda$ 使得$\vec b=\lambda \vec a$</p><h4 id="空间直角坐标系"><a href="#空间直角坐标系" class="headerlink" title="空间直角坐标系"></a>空间直角坐标系</h4><p>右手系 当右手的四个手指从正向 x轴 以 $\frac \pi 2$角度转向正向 y轴 时，大拇指的指向就是 z 轴的正向</p><p>点 向量 坐标 向量的模 两点间距离公式 </p><p>方向角和方向余弦 向量在轴上的投影</p><h3 id="向量的内积外积混合积"><a href="#向量的内积外积混合积" class="headerlink" title="向量的内积外积混合积"></a>向量的内积外积混合积</h3><p>内积：$\vec a\cdot \vec b=|\vec a||\vec b|\cos\theta$</p><p>外积：$\vec a\times \vec b=|\vec a||\vec b|\sin \theta$  $\vec a\times\vec b=-\vec a\times \vec b$ </p><p>$\vec a\times \vec b=(a_yb_z-a_zb_y)\vec i+(a_zb_x-a_xb_z)\vec j+(a_xb_y-a_yb_x)\vec k$</p><p>混合积：$(\vec a,\vec b,\vec c)=(\vec a\times \vec b)\cdot\vec c=\left | \begin{matrix} a_x&amp; a_y&amp; a_z\b_x&amp; b_y&amp; b_z\c_x&amp; c_y&amp; c_z\end{matrix}\right |$</p><h3 id="曲面及其方程"><a href="#曲面及其方程" class="headerlink" title="曲面及其方程"></a>曲面及其方程</h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918144324069.png" alt="image-20220918144324069" style="zoom:50%;"></p><p>一条<strong>平面曲线</strong> 绕其平面上<strong>一条定直线旋转一周</strong>所形成的曲面叫做<strong>旋转曲面</strong>.该<strong>定直线</strong>称为<strong>旋转轴</strong></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918144512855.png" alt="image-20220918144512855" style="zoom:50%;"></p><h4 id="柱面"><a href="#柱面" class="headerlink" title="柱面"></a>柱面</h4><p>平行定直线并沿定曲线 C 移动的直线 l 形成的轨迹叫做柱面 C 叫做准线, l 叫做母线</p><h4 id="二次曲面"><a href="#二次曲面" class="headerlink" title="二次曲面"></a>二次曲面</h4><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918144628202.png" alt="image-20220918144628202" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918144735462.png" alt="image-20220918144735462" style="zoom:50%;"></p><h3 id="空间曲线及其方程"><a href="#空间曲线及其方程" class="headerlink" title="空间曲线及其方程"></a>空间曲线及其方程</h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918144906089.png" alt="image-20220918144906089" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918144924686.png" alt="image-20220918144924686" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918145010692.png" alt="image-20220918145010692" style="zoom:50%;"></p><h3 id="平面及其方程"><a href="#平面及其方程" class="headerlink" title="平面及其方程"></a>平面及其方程</h3><p>一个非零向量垂直一平面，称为法线向量 记为$\vec n$</p><p>平面的点法式方程：$A(x-x_0)+B(y-y_0)+C(z-z_0)=0$</p><p>$(A,B,C)$是法向量，$(x_0,y_0,z_0)$是平面上一个已知的点</p><p>一般方程：$AX+BY+CZ+D=0$</p><p>截距式方程：$\frac x a+\frac y b+\frac z c=1$</p><p>两平面法向量间的夹角——两平面的夹角</p><p>$\cos\theta=\frac {\vec n_1\cdot \vec n_2} {|\vec n_1||\vec n_2|}$</p><h3 id="空间直线方程"><a href="#空间直线方程" class="headerlink" title="空间直线方程"></a>空间直线方程</h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918145720307.png" alt="image-20220918145720307" style="zoom:50%;"></p><p>一个非零向量平行于一条已知直线，则称为这条直线的方向向量 记为$\vec s=(m,n,p)$</p><p>直线点向式方程/对称式方程：$\frac {x-x_0} m=\frac {y-y_0} n=\frac {z-z_0} p$</p><p>直线的参数方程：$\begin{cases} x=x_0+mt\y=y_0+nt\z=z_0+pt\end{cases} (m^2+n^2+p^2\neq 0)$</p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918150416558.png" alt="image-20220918150416558" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918150429414.png" alt="image-20220918150429414" style="zoom:50%;"></p><h4 id="平面束"><a href="#平面束" class="headerlink" title="平面束"></a>平面束</h4><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918150509828.png" alt="image-20220918150509828" style="zoom:50%;"></p><h2 id="1-线性方程组的解法"><a href="#1-线性方程组的解法" class="headerlink" title="1.线性方程组的解法"></a>1.线性方程组的解法</h2><p>n元线性方程组 齐次，非齐次（常数项不全为0）</p><p>线性方程组的解，解集合</p><p>方程组的线性组合 初等变换（同解变形）</p><p>矩阵的初等行变换解方程</p><p>数环与数域</p><h2 id="2-向量空间"><a href="#2-向量空间" class="headerlink" title="2.向量空间"></a>2.向量空间</h2><h3 id="线性相关与线性无关"><a href="#线性相关与线性无关" class="headerlink" title="线性相关与线性无关"></a>线性相关与线性无关</h3><h4 id="n维向量的定义与运算"><a href="#n维向量的定义与运算" class="headerlink" title="n维向量的定义与运算"></a>n维向量的定义与运算</h4><p>数域：是一个含0和1,且对加，减，乘，除（0不为除数）封闭的数集. 例如：有理数域Q，实数域R，复数域C</p><p>n维向量：任意数域上的n个有顺序的数组成的数组$\alpha=(a_1,a_2,…,a_n)$</p><p>运算：相等 零向量 线性运算 数乘 负向量 减法 行向量 列向量 转置</p><p>向量内积：$[\alpha,\beta]=a_1b_1+…+a_nb_n$  对称性 齐次性 分配性 非负性（向量和本身做内积）不等式$[\alpha,\beta]^2\leq [\alpha,\alpha]*[\beta,\beta]$</p><p>向量范数 $||\alpha||=\sqrt{[\alpha,\alpha]}=\sqrt{a_1^2+…+a_n^2}$  非负性 正齐次性 </p><p>三角不等式：$||\alpha+\beta||^2\leq (||\alpha||+||\beta||)^2$</p><p>夹角：$\theta=\arccos{\frac {[\alpha,\beta]}{||\alpha||*||\beta||}} $ </p><p>正交：$[\alpha,\beta]=0$ </p><p>线性组合：$\alpha=k_1\alpha_1+k_2\alpha_2+…+k_m\alpha_m$ </p><ul><li>$\alpha$是$\alpha_1,…,\alpha_m$的<strong>线性组合</strong> </li><li>$k_1,..,k_m$是组合系数 </li><li>$\alpha可由\alpha_1,…,\alpha_m$<strong>线性表示</strong></li></ul><p>向量可否由另一组向量线性表示——转化成<strong>非齐次线性方程组是否有解</strong></p><p>线性方程组解的向量表示：</p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918095131152.png" alt="image-20220918095131152" style="zoom: 67%;"></p><h4 id="线性相关和线性无关"><a href="#线性相关和线性无关" class="headerlink" title="线性相关和线性无关"></a>线性相关和线性无关</h4><p>若有一组不全为0的数，使得$k_1\alpha_1+…+k_m\alpha_m=0$ 则称向量组$\alpha_1,…,\alpha_m$ 线性相关，否则线性无关</p><ul><li>对于单个向量 $\alpha=0$线性相关，否则无关</li><li>一组包含零向量的同维向量线性相关</li><li>判断数字向量组<strong>线性相关或无关的方法</strong>——齐次线性方程组<strong>是否有非零解</strong></li></ul><ul><li>如果矩阵A的<strong>子矩阵A0的各行（列）线性无关</strong>，则由A0的这些行（列）<strong>扩充得到</strong>的A的行（列）<strong>线性无关</strong>。 </li><li>对于向量而言：<strong>短无关，则长无关；长相关，则短相关</strong>。</li></ul><h4 id="线性相关性判定定理"><a href="#线性相关性判定定理" class="headerlink" title="线性相关性判定定理"></a>线性相关性判定定理</h4><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918100014786.png" alt="image-20220918100014786" style="zoom:67%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918100038911.png" alt="image-20220918100038911" style="zoom: 67%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918100053816.png" alt="image-20220918100053816" style="zoom:67%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918100104712.png" alt="image-20220918100104712" style="zoom: 50%;"></p><h3 id="向量组的秩"><a href="#向量组的秩" class="headerlink" title="向量组的秩"></a>向量组的秩</h3><ol><li>向量组T有r个向量线性无关（r&gt;=1)</li><li>任意r+1个向量都线性相关</li><li>$a_1,a_2,…,a_r$是T的一个极大线性无关组 <strong>r</strong>是<strong>向量组的秩</strong></li></ol><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li>秩唯一</li><li>T只含零向量时 r=0</li><li>任意r个线性无关向量都组成T的一个极大无关组，可能不止一个</li><li>如果T的向量个数=秩r，则T本身就是唯一一个极大无关组</li><li>秩r&lt;=向量维数n</li></ul><h5 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h5><p><strong>矩阵A初等行变换得到的B，与A的任意个数列向量线性相关性相同</strong></p><p><strong>矩阵A初等列变换得到的C，与A的任意个数行向量线性相关性相同</strong></p><p>将列向量组成的矩阵经过初等行变换转换为行最简型</p><h4 id="等价向量组及其秩的关系"><a href="#等价向量组及其秩的关系" class="headerlink" title="等价向量组及其秩的关系"></a>等价向量组及其秩的关系</h4><p>每个$\alpha_i$都可以由$\beta_1,…,\beta_s$线性表示 则称$T_1$可以有$T_2$线性表示</p><p>如果$T_1,T_2$可以互相线性表示，则$T_1$和$T_2$等价</p><p>等价三公理：反身 对称 传递</p><p><strong>定理2</strong>：<strong>向量组和任何一个极大无关组等价</strong> ==&gt; 向量组的任意两个极大无关组等价  向量组S是它的任意极大线性无关组T的线性组合</p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918102312636.png" alt="image-20220918102312636" style="zoom:50%;"></p><p>推论：</p><ul><li>设向量组$T_1$秩为r 向量组$T_2$秩为s 若$T_1$可由$T_2$线性表示,则$r\leq s$</li><li>等价向量组秩相等</li></ul><h3 id="基"><a href="#基" class="headerlink" title="基"></a>基</h3><h4 id="向量空间定义"><a href="#向量空间定义" class="headerlink" title="向量空间定义"></a>向量空间定义</h4><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918103003114.png" alt="image-20220918103003114" style="zoom:50%;"></p><p>若V是向量空间，则V必含有零向量</p><h4 id="向量组生成的向量空间"><a href="#向量组生成的向量空间" class="headerlink" title="向量组生成的向量空间"></a>向量组生成的向量空间</h4><p>$V={x=k_1\alpha_1+…+k_2\alpha_m|k_j\in R,j=1,2,…,m}$  记为$L(\alpha_1,\alpha_2,…,\alpha_m)$ 或 $span (\alpha_1,\alpha_2,…,\alpha_m)$</p><p>子空间：两个n维向量集合$V_1$和$V_2$，如果$V_1\subset V_2$，且$V_1,V_2$都是向量空间，则$V_1$是$V_2$的子空间</p><p>$L(\alpha_1,\alpha_2,…,\alpha_m)$ 可以由任意一个极大无关组生成</p><h4 id="基的概念"><a href="#基的概念" class="headerlink" title="基的概念"></a>基的概念</h4><p>设V为向量空间，如果：</p><ul><li>V中r个向量$\alpha_1,\alpha_2,…,\alpha_r$线性无关</li><li>V中任意向量都可由$\alpha_1,…,\alpha_r$线性表示，则称$\alpha_1,…,\alpha_r$是V的一个<strong>基</strong>，则称<strong>r是V的维数</strong>，dimV=r</li></ul><p>向量空间维数：基的向量个数</p><p>向量维数：向量所含坐标个数</p><h4 id="基的性质"><a href="#基的性质" class="headerlink" title="基的性质"></a>基的性质</h4><p>设V 是由 n 维向量构成的 r 维向量空间</p><ul><li>V 的任意r+1个向量必定线性相关.</li><li>V的基是向量组T的一个极大无关组，从而dimV=r(T)</li><li>V中任意r个线性无关向量都可作为V的一个基.</li><li>dimV&lt;=n<ul><li>任意n+1个向量线性相关</li><li>$V_1$是$V_2$子空间时，$dim V_1\leq dim V_2$</li></ul></li></ul><h4 id="正交基"><a href="#正交基" class="headerlink" title="正交基"></a>正交基</h4><p>一个基满足$[\alpha_i,\alpha_j]=0(\forall i\neq j)$ 即$\alpha_1,…,\alpha_r$两两正交</p><p>如果任意$||\alpha_i||=1$，则称为标准正交基 </p><p><strong>两两正交</strong>的非零向量组必定<strong>线性无关</strong></p><h4 id="基变换与坐标变换"><a href="#基变换与坐标变换" class="headerlink" title="基变换与坐标变换"></a>基变换与坐标变换</h4><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918110626067.png" alt="image-20220918110626067" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918110652869.png" alt="image-20220918110652869" style="zoom:50%;"></p><h4 id="坐标变换公式"><a href="#坐标变换公式" class="headerlink" title="坐标变换公式"></a>坐标变换公式</h4><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918110818851.png" alt="image-20220918110818851" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918110833924.png" alt="image-20220918110833924" style="zoom:50%;"></p><h3 id="线性方程组解的结构"><a href="#线性方程组解的结构" class="headerlink" title="线性方程组解的结构"></a>线性方程组解的结构</h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918111021145.png" alt="image-20220918111021145" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918111032931.png" alt="image-20220918111032931" style="zoom:50%;"></p><h4 id="解空间"><a href="#解空间" class="headerlink" title="解空间"></a>解空间</h4><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918111454857.png" alt="image-20220918111454857" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918111509305.png" alt="image-20220918111509305" style="zoom:50%;"></p><h5 id="解空间的维数dimS"><a href="#解空间的维数dimS" class="headerlink" title="解空间的维数dimS"></a>解空间的维数dimS</h5><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918111605795.png" alt="image-20220918111605795" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918111630261.png" alt="image-20220918111630261" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918111859652.png" alt="image-20220918111859652" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918111910916.png" alt="image-20220918111910916" style="zoom:50%;"></p><p>解法步骤:</p><p>(1)求齐次方程基础解系;<br>(2)求非齐次特解;<br>(3)写出通解.</p><h3 id="线性空间"><a href="#线性空间" class="headerlink" title="线性空间"></a>线性空间</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918140334589.png" alt="image-20220918140334589" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918140350129.png" alt="image-20220918140350129" style="zoom:50%;"></p><ol><li>凡满足以上八条规律的加法及乘数运算，称为<strong>线性运算</strong></li><li>线性空间中的向量<strong>不一定是有序数组</strong></li><li>判别线性空间的方法：一个集合，对于定义的加法和数乘运算不封闭，或者运算不满足八条性质的任一条，则此集合就不能构成线性空间</li><li>一个集合，如果定义的加法和乘数运算是通常的实数间的加乘运算，则只需检验对运算的封闭性</li><li>一个集合，如果定义的加法和乘数运算不是通常的实数间的加乘运算，则必需检验是否满足八条线性运算规律</li></ol><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ul><li>零元素是唯一的</li><li>负元素是唯一的</li><li>$0\alpha=0$  $(-1)\alpha=-\alpha$  $\lambda0=0$</li><li>如果$\lambda\alpha=0$，则$\lambda =0或\alpha=0$</li></ul><h4 id="子空间"><a href="#子空间" class="headerlink" title="子空间"></a>子空间</h4><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918141130218.png" alt="image-20220918141130218" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918141206582.png" alt="image-20220918141206582" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918141230567.png" alt="image-20220918141230567" style="zoom:50%;"></p><h4 id="维数、基与坐标"><a href="#维数、基与坐标" class="headerlink" title="维数、基与坐标"></a>维数、基与坐标</h4><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918141315338.png" alt="image-20220918141315338" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918141352109.png" alt="image-20220918141352109" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918141438735.png" alt="image-20220918141438735" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918141528126.png" alt="image-20220918141528126" style="zoom:50%;"></p><h4 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h4><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918141615700.png" alt="image-20220918141615700" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918141636598.png" alt="image-20220918141636598" style="zoom:50%;"></p><h4 id="线性变换的矩阵"><a href="#线性变换的矩阵" class="headerlink" title="线性变换的矩阵"></a>线性变换的矩阵</h4><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918141933944.png" alt="image-20220918141933944" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918141953543.png" alt="image-20220918141953543" style="zoom:50%;"></p><h4 id="子空间的直和"><a href="#子空间的直和" class="headerlink" title="子空间的直和"></a>子空间的直和</h4><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918142046269.png" alt="image-20220918142046269" style="zoom:50%;"></p><h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><p>$V_1+V_2$为直和$\Leftrightarrow V_1\cap V_2=L(0)$</p><h2 id="3-行列式"><a href="#3-行列式" class="headerlink" title="3.行列式"></a>3.行列式</h2><h3 id="对角线法则"><a href="#对角线法则" class="headerlink" title="对角线法则"></a>对角线法则</h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918152026735.png" alt="image-20220918152026735" style="zoom:50%;"></p><h3 id="三角行列式的值"><a href="#三角行列式的值" class="headerlink" title="三角行列式的值"></a>三角行列式的值</h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918152119139.png" alt="image-20220918152119139" style="zoom:50%;"></p><h3 id="范德蒙行列式"><a href="#范德蒙行列式" class="headerlink" title="范德蒙行列式"></a>范德蒙行列式</h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918152138579.png" alt="image-20220918152138579" style="zoom:50%;"></p><h3 id="行列式基本性质"><a href="#行列式基本性质" class="headerlink" title="行列式基本性质"></a>行列式基本性质</h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918152232688.png" alt="image-20220918152232688" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918152332955.png" alt="image-20220918152332955" style="zoom:50%;"></p><h3 id="行列式按行（列）展开定理"><a href="#行列式按行（列）展开定理" class="headerlink" title="行列式按行（列）展开定理"></a>行列式按行（列）展开定理</h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918152356281.png" alt="image-20220918152356281" style="zoom:67%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918152411611.png" alt="image-20220918152411611" style="zoom:50%;"></p><h3 id="有关行列式的重要公式"><a href="#有关行列式的重要公式" class="headerlink" title="有关行列式的重要公式"></a>有关行列式的重要公式</h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918152525265.png" alt="image-20220918152525265" style="zoom:50%;"></p><h3 id="Cramer法则"><a href="#Cramer法则" class="headerlink" title="Cramer法则"></a>Cramer法则</h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918152710297.png" alt="image-20220918152710297" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918152725050.png" alt="image-20220918152725050" style="zoom:50%;"></p><h3 id="行列式计算"><a href="#行列式计算" class="headerlink" title="行列式计算"></a>行列式计算</h3><p>常采用性质5对行列式进行恒等变形，从而能出现较多0元素，从而转换为三角行列式或者按照行列展开</p><h2 id="4-矩阵"><a href="#4-矩阵" class="headerlink" title="4.矩阵"></a>4.矩阵</h2><h3 id="矩阵的定义"><a href="#矩阵的定义" class="headerlink" title="矩阵的定义"></a>矩阵的定义</h3><p>m*n的数表 实矩阵/复矩阵 方阵 行/列矩阵 零矩阵 对角矩阵（主对角线元素不全为0，其他元素均为0）单位矩阵（主对角线元素全为1的对角矩阵）</p><h3 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h3><p>同型 相等 </p><p>线性运算：加法，数乘 负矩阵 减法 </p><h4 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h4><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918153641139.png" alt="image-20220918153641139" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918153745251.png" alt="image-20220918153745251" style="zoom:50%;"></p><h4 id="方阵的多项式"><a href="#方阵的多项式" class="headerlink" title="方阵的多项式"></a>方阵的多项式</h4><p>A为n阶方阵，规定A的k次方为$A^k=A\cdot A… A$  $A^0=E$ </p><p>$f(A)=a_mA^m+…+a_1A+a_0E$ 为A的m次多项式</p><h4 id="矩阵的转置"><a href="#矩阵的转置" class="headerlink" title="矩阵的转置"></a>矩阵的转置</h4><p>$(AB)^T=B^TA^T$</p><p>对称矩阵：$A^T=A$</p><p>反对称矩阵：$A^T=-A$</p><h4 id="方阵行列式"><a href="#方阵行列式" class="headerlink" title="方阵行列式"></a>方阵行列式</h4><p>$\det A$ 或 $|A|$</p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918154330074.png" alt="image-20220918154330074" style="zoom:50%;"></p><h4 id="伴随矩阵"><a href="#伴随矩阵" class="headerlink" title="伴随矩阵"></a>伴随矩阵</h4><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918154413493.png" alt="image-20220918154413493" style="zoom: 50%;"></p><p>$AA^<em>=A^</em>A=(\det A)E$</p><h4 id="共轭矩阵"><a href="#共轭矩阵" class="headerlink" title="共轭矩阵"></a>共轭矩阵</h4><p>共轭：实部相等，虚部互为相反数的两个复数</p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918154534628.png" alt="image-20220918154534628" style="zoom:50%;"></p><h4 id="厄米特矩阵-Hermitian-Matrix"><a href="#厄米特矩阵-Hermitian-Matrix" class="headerlink" title="厄米特矩阵(Hermitian Matrix)"></a>厄米特矩阵(Hermitian Matrix)</h4><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918154709523.png" alt="image-20220918154709523" style="zoom:50%;"></p><h3 id="矩阵乘法与线性变换"><a href="#矩阵乘法与线性变换" class="headerlink" title="矩阵乘法与线性变换"></a>矩阵乘法与线性变换</h3><p>坐标变换：平移 旋转</p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918155641414.png" alt="image-20220918155641414" style="zoom:50%;"></p><p>线性变换 乘法、加法、数乘、线性变换的逆</p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918160218906.png" alt="image-20220918160218906" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918160231131.png" alt="image-20220918160231131" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918160309056.png" alt="image-20220918160309056" style="zoom:50%;"></p><h3 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h3><h4 id="子式"><a href="#子式" class="headerlink" title="子式"></a>子式</h4><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918160724131.png" alt="image-20220918160724131" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918160852880.png" alt="image-20220918160852880" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918160937016.png" alt="image-20220918160937016" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918161043578.png" alt="image-20220918161043578" style="zoom:50%;"></p><h4 id="矩阵的秩-1"><a href="#矩阵的秩-1" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h4><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918161151672.png" alt="image-20220918161151672" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918161223475.png" alt="image-20220918161223475" style="zoom:50%;"></p><p>行满秩矩阵 列满秩矩阵 行秩 列秩</p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918161537045.png" alt="image-20220918161537045" style="zoom:50%;"></p><p>矩阵的秩=矩阵的行秩＝矩阵的列秩</p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918161711106.png" alt="image-20220918161711106" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918161725317.png" alt="image-20220918161725317" style="zoom:50%;"></p><p>矩阵的初等变换：对调两行（列），数乘，倍加（某一行/列所有元素的k倍加到另一行/列的对应元素上</p><p>矩阵A经过有限次初等变换得到B，则$A\cong B$ 或 $A\rightarrow B$ </p><p>定理：$A\cong B\Rightarrow rankA=rank B$</p><p>求矩阵的秩：</p><ul><li>非零子式的最大级数</li><li>求出行/列向量组的秩</li><li>用初等变换化 A 为阶梯阵 J，R(A) 等于中非零行的行数</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918162520828.png" alt="image-20220918162520828" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918162549880.png" alt="image-20220918162549880" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918162623824.png" alt="image-20220918162623824" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918162643437.png" alt="image-20220918162643437" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918162709855.png" alt="image-20220918162709855" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918162724757.png" alt="image-20220918162724757" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918162807029.png" alt="image-20220918162807029" style="zoom:50%;"></p><h4 id="矩阵的秩和极大无关组的关系"><a href="#矩阵的秩和极大无关组的关系" class="headerlink" title="矩阵的秩和极大无关组的关系"></a>矩阵的秩和极大无关组的关系</h4><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918162925042.png" alt="image-20220918162925042" style="zoom:50%;"></p><h4 id="矩阵的秩和方程组解的关系"><a href="#矩阵的秩和方程组解的关系" class="headerlink" title="矩阵的秩和方程组解的关系"></a>矩阵的秩和方程组解的关系</h4><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918163044974.png" alt="image-20220918163044974" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918163157671.png" alt="image-20220918163157671" style="zoom:50%;"></p><h3 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h3><p>n阶方阵A,B，AB=BA=E 则A是可逆的，B是A的逆矩阵</p><h4 id="求矩阵的逆"><a href="#求矩阵的逆" class="headerlink" title="求矩阵的逆"></a>求矩阵的逆</h4><p><strong>待定系数法</strong> 计算量太大</p><p>可逆的充要条件是$detA\neq 0$  即秩为n </p><p><strong>伴随矩阵法</strong>：$A^{-1}=\frac 1 {detA}A^*$</p><ul><li>$(AB)^{-1}=B^{-1}A^{-1}$</li><li>$(A^T)^{-1}=(A^{-1})^T$</li><li>$det(A^{-1})=(detA)^{-1}$</li><li>$A可逆\Rightarrow A^<em>也可逆$  且$(A^</em>)^{-1}=\frac A {detA}$ </li><li>$A可逆\Rightarrow (A^<em>)^{-1}=(A^{-1})^</em>$</li><li>$detA^*=(detA)^{n-1}$</li><li>$(A^<em>)^</em>=(detA)^{n-2}A$</li><li>同阶方阵A，B均可逆$\Rightarrow(AB)^<em>=B^</em>A^*$</li></ul><h4 id="逆矩阵应用"><a href="#逆矩阵应用" class="headerlink" title="逆矩阵应用"></a>逆矩阵应用</h4><p>n阶线性方程组的求解 $x=A^{-1}b$</p><p>求线性变换的逆变换</p><p>矩阵方程求解</p><h3 id="初等方阵"><a href="#初等方阵" class="headerlink" title="初等方阵"></a>初等方阵</h3><p>单位矩阵E经过一次初等变换的到的方阵</p><p>两行/列互换 E(i,j)</p><p>第i行/列乘以非零数k E(i(k))</p><p>第j行/列的k倍加到第i行/列 E(i,j(k))</p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918165159855.png" alt="image-20220918165159855" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918165226143.png" alt="image-20220918165226143" style="zoom:50%;"></p><p>n阶方阵可逆$\Leftrightarrow$ A能表示为若干个初等方阵的乘积</p><h4 id="新的逆矩阵计算方式"><a href="#新的逆矩阵计算方式" class="headerlink" title="新的逆矩阵计算方式"></a>新的逆矩阵计算方式</h4><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918165558282.png" alt="image-20220918165558282" style="zoom:50%;"></p><h4 id="关于方阵可逆性的等价命题"><a href="#关于方阵可逆性的等价命题" class="headerlink" title="关于方阵可逆性的等价命题"></a>关于方阵可逆性的等价命题</h4><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918165807326.png" alt="image-20220918165807326" style="zoom: 50%;"></p><h3 id="分块矩阵"><a href="#分块矩阵" class="headerlink" title="分块矩阵"></a>分块矩阵</h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220918211433485.png" alt="image-20220918211433485" style="zoom:50%;"></p><h3 id="正交矩阵"><a href="#正交矩阵" class="headerlink" title="正交矩阵"></a>正交矩阵</h3><p>$A^TA=E$  </p><p>$AA^T=E$</p><p>$A^{-1}=A^T$</p><p>A的n个行（列）向量是两两正交的单位向量</p><h2 id="5-欧氏空间"><a href="#5-欧氏空间" class="headerlink" title="5.欧氏空间"></a>5.欧氏空间</h2><h3 id="欧式空间"><a href="#欧式空间" class="headerlink" title="欧式空间"></a>欧式空间</h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220919162916964.png" alt="image-20220919162916964" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220919162927014.png" alt="image-20220919162927014" style="zoom:50%;"></p><h4 id="内积的性质"><a href="#内积的性质" class="headerlink" title="内积的性质"></a>内积的性质</h4><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220919163116253.png" alt="image-20220919163116253" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220919163049958.png" alt="image-20220919163041056" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220919163153392.png" alt="image-20220919163153392" style="zoom:50%;"></p><h4 id="向量夹角-正交向量-勾股定理"><a href="#向量夹角-正交向量-勾股定理" class="headerlink" title="向量夹角 正交向量 勾股定理"></a>向量夹角 正交向量 勾股定理</h4><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220919164033154.png" alt="image-20220919164033154" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220919164359650.png" alt="image-20220919164359650" style="zoom:50%;"></p><h4 id="内积的矩阵表示"><a href="#内积的矩阵表示" class="headerlink" title="内积的矩阵表示"></a>内积的矩阵表示</h4><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220919164410411.png" alt="image-20220919164410411" style="zoom:50%;"></p><p>度量矩阵是实对称矩阵 也是正定矩阵</p><h3 id="正交化"><a href="#正交化" class="headerlink" title="正交化"></a>正交化</h3><h4 id="标准正交基"><a href="#标准正交基" class="headerlink" title="标准正交基"></a>标准正交基</h4><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220919164601050.png" alt="image-20220919164601050" style="zoom:50%;"></p><p>施密特正交变换法</p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220919164911650.png" alt="image-20220919164911650" style="zoom:50%;"></p><h3 id="欧氏空间同构"><a href="#欧氏空间同构" class="headerlink" title="欧氏空间同构"></a>欧氏空间同构</h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220919164945674.png" alt="image-20220919164945674" style="zoom:50%;"></p><h3 id="正交变换-子空间"><a href="#正交变换-子空间" class="headerlink" title="正交变换 子空间"></a>正交变换 子空间</h3><h3 id="相似矩阵"><a href="#相似矩阵" class="headerlink" title="相似矩阵"></a>相似矩阵</h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220919165149683.png" alt="image-20220919165149683" style="zoom:50%;"></p><h3 id="方阵的特征值和特征向量"><a href="#方阵的特征值和特征向量" class="headerlink" title="方阵的特征值和特征向量"></a>方阵的特征值和特征向量</h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220919165329661.png" style="zoom:50%;"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220919165410229.png" alt="image-20220919165410229" style="zoom:50%;"></p><h4 id="求特征向量，特征值"><a href="#求特征向量，特征值" class="headerlink" title="求特征向量，特征值"></a>求特征向量，特征值</h4><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220919165523029.png" alt="image-20220919165523029" style="zoom:50%;">、</p><h4 id="特征向量线性无关"><a href="#特征向量线性无关" class="headerlink" title="特征向量线性无关"></a>特征向量线性无关</h4><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220919165614721.png" alt="image-20220919165614721"></p><h3 id="相似对角化"><a href="#相似对角化" class="headerlink" title="相似对角化"></a>相似对角化</h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220919165720097.png" alt="image-20220919165720097" style="zoom:50%;"></p><h3 id="实对称矩阵的相似矩阵"><a href="#实对称矩阵的相似矩阵" class="headerlink" title="实对称矩阵的相似矩阵"></a>实对称矩阵的相似矩阵</h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220919165834752.png" alt="image-20220919165834752" style="zoom:50%;"></p><h2 id="6-二次型"><a href="#6-二次型" class="headerlink" title="6.二次型"></a>6.二次型</h2><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220919171923895.png" alt="image-20220919171923895" style="zoom:50%;"></p><p>$f=x^TAx$ A为实对称矩阵</p><h3 id="化二次型为标准型"><a href="#化二次型为标准型" class="headerlink" title="化二次型为标准型"></a>化二次型为标准型</h3><p>寻求一个可逆的线性变换x=Py使之化为只含平方项的形式：$f=k_1y_1^2+…+k_ny_n^2$</p><p>称只含平方项的形式为二次型的标准形</p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220919172543741.png" alt="image-20220919172543741" style="zoom:50%;"></p><h3 id="正交变换法化实二次型为标准型"><a href="#正交变换法化实二次型为标准型" class="headerlink" title="正交变换法化实二次型为标准型"></a>正交变换法化实二次型为标准型</h3><p>求对称矩阵A的特征向量，单位化后得到正交矩阵Q</p><p>令x=Qy</p><h3 id="矩阵相合"><a href="#矩阵相合" class="headerlink" title="矩阵相合"></a>矩阵相合</h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220919173049673.png" alt="image-20220919173049673" style="zoom:50%;"></p><h3 id="正定二次型"><a href="#正定二次型" class="headerlink" title="正定二次型"></a>正定二次型</h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220919173007455.png" alt="image-20220919173007455" style="zoom:50%;"></p><h2 id="7-奇异值分解"><a href="#7-奇异值分解" class="headerlink" title="7.奇异值分解"></a>7.奇异值分解</h2><p>$A=UDV^T$</p><p>A可以是m*n的，不需要方阵</p><p>对角阵D的对角线上元素是奇异值 U的列向量是左奇异向量</p><p>V的列向量是右奇异向量</p><p>A的左奇异向量是$AA^T$的特征向量 A的右奇异向量是$A^TA$的特征向量</p><p>A的非零奇异值是$A^TA$特征值的平方根，同时也是$AA^T$特征值的平方根</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linear Algebra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈工大OS课程笔记</title>
      <link href="2022/08/30/hitos-note/"/>
      <url>2022/08/30/hitos-note/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统基础">操作系统基础<a class="anchor" href="#操作系统基础">·</a></h1><h2 id="L1-什么是操作系统">L1 什么是操作系统<a class="anchor" href="#L1-什么是操作系统">·</a></h2><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220907103122241.png" alt="image-20220907103122241" style="zoom: 67%;"><p>操作系统是计算机硬件和应用之间的一层软件</p><p>管理哪些硬件？CPU 内存 终端 磁盘 文件 网络 电源 多核</p><p>学习OS的三个层次</p><ul><li>学习计算机接口，从软件出发用OS</li><li>从应用软件出发进入OS</li><li>设计并实现OS</li></ul><h2 id="Lab0-准备工作">Lab0 准备工作<a class="anchor" href="#Lab0-准备工作">·</a></h2><h3 id="相关链接">相关链接<a class="anchor" href="#相关链接">·</a></h3><p>github：https://github.com/DeathKing/hit-oslab</p><p>mooc地址：https://www.icourse163.org/course/HIT-1002531008</p><p>实践平台：https://www.lanqiao.cn/courses/115</p><p>GDB调试器教程：https://www.lanqiao.cn/courses/496</p><p>Bocus虚拟机主页：https://www.lanqiao.cn/courses/496</p><p>linux内核完全注释：http://www.oldlinux.org/</p><h3 id="配置-3">配置<a class="anchor" href="#配置-3">·</a></h3><p>准备好ubuntu20.04的机器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装环境</span></span><br><span class="line">git clone https://github.com/Wangzhike/HIT-Linux-0.11.git ~/hit-oslab</span><br><span class="line">cd hit-oslab</span><br><span class="line">./setup.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">可能还需要安装这几个32位版本的软件</span></span><br><span class="line">sudo apt-get install libsm6:i386 </span><br><span class="line">sudo apt-get install libx11-6:i386</span><br><span class="line">sudo apt-get install libxpm4:i386</span><br><span class="line"><span class="meta">#</span><span class="bash">编译</span></span><br><span class="line">cd ~/code</span><br><span class="line">tar -zxvf hit-oslab-linux-20110823.tar.gz</span><br><span class="line">cd ~/code/oslab/linux-0.11</span><br><span class="line">make all </span><br><span class="line"><span class="meta">#</span><span class="bash"> make自动跳过未被修改的文件，链接时直接使用上次编译生成的目标文件，从而节约编译时间</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make -j 2 多处理器加速并行编译</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> make clean &amp;&amp; make all</span></span><br><span class="line">cd ..</span><br><span class="line">./run</span><br></pre></td></tr></table></figure><h3 id="调试">调试<a class="anchor" href="#调试">·</a></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">汇编调试</span></span><br><span class="line">./dbg-asm</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">help</span>查看基本命令，更详细查看Bochs使用手册</span></span><br><span class="line"><span class="meta">#</span><span class="bash">C语言调试</span></span><br><span class="line">./dbg-c</span><br><span class="line">./rungdb</span><br></pre></td></tr></table></figure><h3 id="文件交换">文件交换<a class="anchor" href="#文件交换">·</a></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">挂载hdc</span></span><br><span class="line">sudo ./mount-hdc</span><br><span class="line">cd hdc</span><br><span class="line">ls -al</span><br><span class="line">vi hello.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">卸载hdc文件系统</span></span><br><span class="line">sudo umount hdc</span><br></pre></td></tr></table></figure><h2 id="L2-开始揭开钢琴的盖子">L2 开始揭开钢琴的盖子<a class="anchor" href="#L2-开始揭开钢琴的盖子">·</a></h2><p>计算机本质：计算模型 类似人-笔-纸 给一张纸，人用笔不断地按顺序算每一道题</p><p>图灵机就是一个控制器+一个纸袋</p><p>通用图灵机是复杂的控制器控制复杂的纸带，纸带上地数据包含设置控制器动作和状态的指令以及数据对象</p><p>冯诺依曼存储程序思想：将数据和程序存放在计算机内部的存储器中，计算机在程序的控制下一步步处理</p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220907103759295.png" alt="image-20220907103759295"></p><h3 id="打开电源">打开电源<a class="anchor" href="#打开电源">·</a></h3><p>x86 PC：</p><p>(1)x86 PC刚开机时CPU处于<strong>实模式</strong>（寻址方式为CS左移四位+IP，CS是段地址，和保护模式不一样）</p><p>(2)开机时，CS=0xFFFF; IP=0x0000</p><p>(3)寻址0xFFFF0(<strong>ROM BIOS映射区</strong>)</p><p>(4)检查RAM，键盘，显示器，软硬磁盘</p><p>(5)将磁盘0磁道0扇区读入0x7c00处</p><p>(6)设置cs=0x07c0，ip=0x0000</p><h3 id="0x7c00处存放的代码">0x7c00处存放的代码<a class="anchor" href="#0x7c00处存放的代码">·</a></h3><p>是从磁盘引导扇区读入的512个字节，也就是启动设备的第一个扇区</p><p>启动设备信息被设置在CMOS（互补金属氧化物半导体，用来存储实时钟和硬件配置信息）中</p><p>硬盘<strong>第一个扇区上</strong>存放着开机后<strong>执行的第一段</strong>可以控制的程序</p><p>bootsect.s载入setup（四个扇区）模块和system模块（OS代码）</p><p>之后跳到setup执行</p><h2 id="L3-操作系统启动">L3 操作系统启动<a class="anchor" href="#L3-操作系统启动">·</a></h2><h3 id="setup-s">setup.s<a class="anchor" href="#setup-s">·</a></h3><p>完成OS启动前的设置</p><p>取出光标位置以及其他硬件参数，比如扩展内存大小</p><p>将system模块移到0地址</p><p><strong>进入保护模式</strong>，用<strong>GDT</strong>将cs:ip变成物理地址</p><p>保护模式下有专门的<strong>地址翻译表</strong>和<strong>中断处理函数入口</strong></p><p>之后跳到system模块执行</p><h3 id="head-s">head.s<a class="anchor" href="#head-s">·</a></h3><p>设置各种数据结构，比如数据段，系统栈，内存管理的必要数据结构，且此时是32位汇编代码，和之前16位8086不一样</p><p>设置idt，gdt</p><p>函数调用设置页表，之后进入main函数</p><h3 id="main函数">main函数<a class="anchor" href="#main函数">·</a></h3><p>main的工作就是xx_init: 内存、中断、设备、 时钟、CPU等内容的初始化…</p><h3 id="关于汇编">关于汇编<a class="anchor" href="#关于汇编">·</a></h3><h4 id="1-as86汇编：能产生16位代码的Intel-8086-386-汇编">(1) as86汇编：能产生16位代码的Intel 8086(386)汇编<a class="anchor" href="#1-as86汇编：能产生16位代码的Intel-8086-386-汇编">·</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax, cs &#x2F;&#x2F;cs--&gt;ax, 目标操作数在前</span><br></pre></td></tr></table></figure><h4 id="2-GNU-as汇编：产生32位代码，使用AT-T系统V语法">(2) GNU as汇编：产生32位代码，使用AT&amp;T系统V语法<a class="anchor" href="#2-GNU-as汇编：产生32位代码，使用AT-T系统V语法">·</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movl var, %eax&#x2F;&#x2F;(var)--&gt;%eax</span><br><span class="line">movb -4(%ebp), %al &#x2F;&#x2F;取出一字节</span><br></pre></td></tr></table></figure><p>AT&amp;T美国电话电报公司， 包含贝尔实验室等，1983年AT&amp;T UNIX支持组发布了系统V</p><h4 id="3-内嵌汇编，gcc编译x-c会产生中间结果as汇编文件x-s">(3) 内嵌汇编，gcc编译x.c会产生中间结果as汇编文件x.s<a class="anchor" href="#3-内嵌汇编，gcc编译x-c会产生中间结果as汇编文件x-s">·</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__asm__(“汇编语句”</span><br><span class="line">: 输出</span><br><span class="line">: 输入</span><br><span class="line">: 破坏部分描述);</span><br><span class="line"></span><br><span class="line">__asm__(“movb </span><br><span class="line">%%fs:%2, %%al”</span><br><span class="line">:”&#x3D;a”(_res)</span><br><span class="line">:”0”(seg),”m”(*(addr))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>0或空表示使用与 相应输出一样的 寄存器</p><p>a表示使用eax， 并编号%0</p><p>%2表示addr，m 表示使用内存</p><h2 id="Lab1-操作系统的引导">Lab1 操作系统的引导<a class="anchor" href="#Lab1-操作系统的引导">·</a></h2><h3 id="实验介绍">实验介绍<a class="anchor" href="#实验介绍">·</a></h3><p>此次实验的基本内容是：</p><ol><li>阅读《Linux 内核完全注释》的第 6 章，对计算机和 Linux 0.11 的引导过程进行初步的了解；</li><li>按照下面的要求改写 0.11 的引导程序 bootsect.s</li><li>有兴趣同学可以做做进入保护模式前的设置程序 setup.s。</li></ol><p>改写 <code>bootsect.s</code> 主要完成如下功能：</p><ol><li>bootsect.s 能在屏幕上打印一段提示信息“XXX is booting…”，其中 XXX 是你给自己的操作系统起的名字，例如 LZJos、Sunix 等（可以上论坛上秀秀谁的 OS 名字最帅，也可以显示一个特色 logo，以表示自己操作系统的与众不同。）</li></ol><p>改写 <code>setup.s</code> 主要完成如下功能：</p><ol><li>bootsect.s 能完成 setup.s 的载入，并跳转到 setup.s 开始地址执行。而 setup.s 向屏幕输出一行&quot;Now we are in SETUP&quot;。</li><li>setup.s 能获取至少一个基本的硬件参数（如内存参数、显卡参数、硬盘参数等），将其存放在内存的特定地址，并输出到屏幕上。</li><li>setup.s 不再加载 Linux 内核，保持上述信息显示在屏幕上即可。</li></ol><h3 id="编译与运行bootsect-s">编译与运行bootsect.s<a class="anchor" href="#编译与运行bootsect-s">·</a></h3><p>汇编+链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">as86 -0 -a -o bootsect.o bootsect.s</span><br><span class="line">ld86 -0 -s -o bootsect bootsect.o</span><br><span class="line">dd bs=1 if=bootsect of=Image skip=32 #跳过最开始的32字节的文件头信息</span><br><span class="line">cp ./Image ../Image</span><br></pre></td></tr></table></figure><p>其中 <code>-0</code>（注意：这是数字 0，不是字母 O）表示生成 8086 的 16 位目标程序，<code>-a</code> 表示生成与 GNU as 和 ld 部分兼容的代码，<code>-s</code> 告诉链接器 ld86 去除最后生成的可执行文件中的符号信息。</p><h2 id="L4-操作系统接口">L4 操作系统接口<a class="anchor" href="#L4-操作系统接口">·</a></h2><p>接口：连接两个东西，信号转换，屏蔽细节</p><p>操作系统接口：连接上层用户和操作系统软件</p><p>用户使用计算机：命令行，图形按钮，应用程序</p><p>命令行其实就是一段程序 shell是/bin/sh</p><p>图形界面是包含画图的C程序  消息框架程序+消息处理程序</p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220907160608658.png" alt="image-20220907160608658" style="zoom: 67%;"><p>OS接口：普通C代码加上一些重要的函数，OS提供这些函数 也就是操作系统接口，表现为函数调用，由系统提供，称为系统调用</p><p>POSIX: Portable Operating System Interface of Unix(IEEE制定的一个标准族)</p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220907160816856.png" alt="image-20220907160816856"></p><h2 id="L5-系统调用的实现">L5 系统调用的实现<a class="anchor" href="#L5-系统调用的实现">·</a></h2><p>需要将内核程序和用户程序隔离 区分内核态和用户态</p><p>用CS最低两位表示执行在什么态 0是内核态，3是用户态</p><p>必须CPL（CS）RPL（DS）&lt;=DPL时才允许访问</p><p>硬件提供主动进入内核方式，对于x86：int指令 将CS中CPL改成0，从而进入内核</p><p>系统调用核心：</p><ul><li>用户程序中包含一段包含int指令的代码</li><li>操作系统写中断处理，获取想调程序的编号</li><li>操作系统根据编号执行相应代码</li></ul><p>先设置好eax系统调用号，ebx,ecx,edx都可以存放参数，eax还存放返回值</p><p>进入set_system_gate函数，设置0x80的中断处理</p><p>进入system_call中断处理程序 找到相应系统调用处理函数入口（全局数组_sys_call_table中寻找）</p><p>之后调用相应系统调用处理函数</p><h2 id="L6-操作系统历史">L6 操作系统历史<a class="anchor" href="#L6-操作系统历史">·</a></h2><h3 id="上古神机IBM7094-1955-1965">上古神机IBM7094(1955-1965)<a class="anchor" href="#上古神机IBM7094-1955-1965">·</a></h3><p>计算机昂贵 造价在250万美元以上</p><ul><li>专注于计算</li><li>批处理操作系统</li></ul><p>一个作业完成，自动读入下一个作业</p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220907161921309.png" alt="image-20220907161921309"></p><h3 id="从IBSYS到OS-360-1965-1980">从IBSYS到OS/360(1965-1980)<a class="anchor" href="#从IBSYS到OS-360-1965-1980">·</a></h3><p>计算机开始进入多个行业：科学计算(IBM 7094)，银行(IBM 1401)</p><p>需要干多件事 多道程序</p><p>作业的切换和调度成为核心 既有IO任务，又有计算任务，需要让CPU忙碌</p><p>IBM OS/360 表示全方位服务，开发周期 5000人年</p><h3 id="从OS-360到MULTICS-1965-1980">从OS/360到MULTICS(1965-1980)<a class="anchor" href="#从OS-360到MULTICS-1965-1980">·</a></h3><p>使用人数增加 作业之间需要快速切换</p><p>分时系统产生 代表：MIT MULTICS (MULTiplexed Information and Computer Service)</p><p>核心仍然是任务切换</p><h3 id="从MULTICS到UNIX-1980-1990">从MULTICS到UNIX(1980-1990)<a class="anchor" href="#从MULTICS到UNIX-1980-1990">·</a></h3><p>小型计算机出现</p><p>1969年：贝尔实验室的Ken Thompson、 Dennis Ritchi等在一 台没人使用的PDP-7上开发一个简化MULTICS，就是后来的UNIX</p><p>UNIX是一个简化的MULTICS，核心概念差不多，但更灵活和成功</p><h3 id="从UNIX到Linux-1990-2000">从UNIX到Linux(1990-2000)<a class="anchor" href="#从UNIX到Linux-1990-2000">·</a></h3><p>1981，IBM推出IBM PC；个人计算机开始普及</p><p>1987年Andrew Tanenbaum发布了MINIX(非常类似UNIX)用于教学</p><p>Linus Torvalds在386sx兼容微机上学习minix，作出小Linux于1991年发布</p><p>1994年，Linux 1.0发布并采用GPL协议，1998年以后互联网世界里展开了一场历史性的Linux产业化运动</p><h3 id="IBSY-OS-360-MULTICS-Unix-Linux">IBSY ==&gt; OS/360 ==&gt; MULTICS ==&gt; Unix ==&gt; Linux<a class="anchor" href="#IBSY-OS-360-MULTICS-Unix-Linux">·</a></h3><h4 id="核心思想、技术">核心思想、技术<a class="anchor" href="#核心思想、技术">·</a></h4><ul><li>用户通过<strong>执行程序</strong>来使用计算机(吻合冯诺依曼的思想)</li><li>作为管理者，操作系统要让<strong>多个程序合理推进</strong>，就是<strong>进程管理</strong></li><li>多进程(用户)推进时需要<strong>内存复用</strong>等等</li></ul><h4 id="软件实现">软件实现<a class="anchor" href="#软件实现">·</a></h4><ul><li>对于操作系统，实现很重要OS/360==&gt;UNIX</li><li>需要真正的群体智慧 UNIX==&gt;Linux</li></ul><p>多进程结构是操作系统基本图谱 对于OS 实现概念比理解概念更重要</p><h3 id="PC与DOS">PC与DOS<a class="anchor" href="#PC与DOS">·</a></h3><p>1975年Digital Research为Altair 8800开发了操作系统<strong>CP/M</strong></p><p>CP/M：<strong>写命令</strong>让用户用，<strong>执行命令对应的程序</strong>，单任务执行</p><p>1980出现了<strong>8086 16位芯片</strong>，从<strong>CP/M基础</strong>上开发了<strong>QDOS</strong>(Quick and Dirty OS)</p><h3 id="从QDOS到MS-DOS">从QDOS到MS-DOS<a class="anchor" href="#从QDOS到MS-DOS">·</a></h3><p>1975年，22岁的Paul Allen和20岁的 Bill Gates为Altair 8800开发了<strong>BASIC解释器</strong>，据此开创了微软</p><p>1977年Bill Gates开发FAT管理磁盘</p><p>QDOS的成功在于以CP/M为基础将BASIC和FAT包含了进来 <strong>文件管理和编程环境…都是用户关心</strong>的!</p><p>1980年IBM想和Digital Research协议授权使用CP/M，但没有达成，转向和微软合作；1981微软买下QDOS，改名为MS-DOS(Disk OS)，和IBM PC打包一起出售</p><h3 id="从MS-DOS到Windows">从MS-DOS到Windows<a class="anchor" href="#从MS-DOS到Windows">·</a></h3><p>MS-DOS的磁盘、文件、命令让用方便，但似乎可以更方便</p><p>1989年，MS-DOS 4.0出现， 支持了鼠标和键盘，此时微软已经决定要放弃MS-DOS</p><p>不久后Windows 3.0大获成功</p><p>后来就是一发不可收拾了，95，XP，Vista，Win 7，Win 8…</p><p><strong>文件、开发环境、图形界面</strong>对于OS的重要性</p><h3 id="Mac-OS与iOS">Mac OS与iOS<a class="anchor" href="#Mac-OS与iOS">·</a></h3><p>1984年，苹果推出PC(麦金塔机，Macintosh)， 简称Mac机，其处理器使用IBM、Intel或AMD等，核心在于屏幕、能耗等</p><p>与Mac机一起发布System X系统，一上来就是GUI</p><p>在System 7以后改名为Mac OS 8</p><p>2007年发布iOS，核心仍然是Mac OS，专为移动设备，如手势等</p><p>Mac OS核心是UNIX，专注于界面、文件、媒体等和用户有关的内容</p><h3 id="CP-M-QDOS-MS-DOS-Windows-Unix-System-Mac-OS-iOS">CP/M ==&gt; QDOS ==&gt; MS-DOS ==&gt; Windows ==&gt; Unix ==&gt; System ==&gt; Mac OS ==&gt; iOS<a class="anchor" href="#CP-M-QDOS-MS-DOS-Windows-Unix-System-Mac-OS-iOS">·</a></h3><h4 id="核心思想、技术-2">核心思想、技术<a class="anchor" href="#核心思想、技术-2">·</a></h4><ul><li>仍然是程序执行、多进程、程序执行带动其他设备使用的基本结构</li><li>但用户的使用感觉倍加重视了：各种文件、编程环境、图形界面</li></ul><h4 id="软件实现-2">软件实现<a class="anchor" href="#软件实现-2">·</a></h4><ul><li>如何通过文件存储代码、执行代码、操作屏幕…</li><li>如何让文件和操作变成图标、点击或触碰…</li></ul><p>掌握、实现操作系统的<strong>多进程图谱</strong></p><p>掌握、实现操作系统的<strong>文件操作</strong>视图</p><h2 id="L7-学习任务">L7 学习任务<a class="anchor" href="#L7-学习任务">·</a></h2><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220907163625373.png" alt="image-20220907163625373" style="zoom:67%;"><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220907163658377.png" alt="image-20220907163658377" style="zoom:67%;"><h2 id="Lab2-系统调用">Lab2 系统调用<a class="anchor" href="#Lab2-系统调用">·</a></h2><h1 id="进程与线程">进程与线程<a class="anchor" href="#进程与线程">·</a></h1><h2 id="L8-CPU-管理的直观想法">L8 CPU 管理的直观想法<a class="anchor" href="#L8-CPU-管理的直观想法">·</a></h2><p>让CPU工作：取指执行</p><p>让CPU充分利用：启动多个程序，交替执行</p><p>一个CPU上交替的执行多个程序：并发。让IO和计算利用率都提升</p><p>记录每个程序的信息的结构：PCB 这样才能正常切换程序</p><p>运行的程序：进程，和静态程序不一样</p><h2 id="L9-多进程图像">L9 多进程图像<a class="anchor" href="#L9-多进程图像">·</a></h2><p>main中的fork创建了第一个进程，init执行了shell（windows桌面），shell再根据命令启动其他基本进程，返回shell再启动其他进程</p><p>Process Control Block：记录进程信息的数据结构</p><p>PCB的列表：一些进程在执行（运行），一些进程在等待执行（就绪队列），一些进程在等待某事件（硬件等待队列…）</p><pre class="mermaid">graph LRa[新建态]-->b[就绪态]b-->c[运行态]c-->d[终止态]c-->e[阻塞态]e-->bc-->b</pre><p>交替的三个部分：队列操作+调度（选择下一个进程）+切换（PCB信息存储和切换 <strong>schedule函数</strong>）</p><p>通过内存管理来隔绝多个进程的地址空间，地址映射，每个进程的地址被映射到特定的一块物理内存</p><p>多个进程合作：进程同步（合理的推进） 给共享变量上锁</p><h3 id="如何形成多进程图像？">如何形成多进程图像？<a class="anchor" href="#如何形成多进程图像？">·</a></h3><ul><li>读写PCB，OS中最重要结构</li><li>操作寄存器完成切换（L10,L11,L12）</li><li>写调度程序（L13,L14）</li><li>进程同步与合作（L16,L17）</li><li>地址映射（L20）</li></ul><h2 id="Lab3-进程运行轨迹的跟踪与统计">Lab3 进程运行轨迹的跟踪与统计<a class="anchor" href="#Lab3-进程运行轨迹的跟踪与统计">·</a></h2><h2 id="L10-用户级线程">L10 用户级线程<a class="anchor" href="#L10-用户级线程">·</a></h2><p>User Threads</p><p>是否可以资源不动切换指令序列</p><p>进程=资源+指令执行序列 1个资源+多个指令执行序列</p><p>线程：保留了并发特点，避免了进程切换代价</p><p>例子：访问网站，所有图片，文字都显示在同一屏幕，需要共享资源。多个线程分别处理不同的事。比如先下载图片，在等待图片数据的时候切换到获得文字的线程</p><p>两个线程一个栈会出现问题，需要每个线有一个栈</p><p>Yield函数先切换栈指针，再直接函数结束返回栈顶地址，不用主动jmp切换PC。需要TCB（Thread Control Block），有栈指针</p><p><strong>两个线程</strong>：两个TCB，两个栈，切换的PC在栈中</p><p>用户级线程不会进入内核，当遇到硬件阻塞时就丧失作用。内核级线程是系统调用，会进入内核，内核知道TCB</p><h2 id="L11-内核级线程">L11 内核级线程<a class="anchor" href="#L11-内核级线程">·</a></h2><p>多处理器：每个cpu有相应的Cache和MMU</p><p>多核：多个CPU使用相同的Cache核MMU</p><p>多进程适用于多处理器的情况，核心级线程适用于多核</p><p>核心级线程：一个栈到一套栈，包含<strong>用户栈，代码和数据，内核栈，线程控制块</strong>。TCB关联内核栈</p><p>用户栈在有中断时启动内核栈，通过TCB切换到另一个线程的TCB，再切换到B的内核栈，并通过中断返回iret到相应的B用户栈和用户代码。从一套栈切换到另一套栈</p><h3 id="内核线程switch-to的五段论">内核线程switch_to的五段论<a class="anchor" href="#内核线程switch-to的五段论">·</a></h3><p>中断入口：进入切换</p><p>中断处理：引发切换</p><p>找到目的TCB，线程调度</p><p>完成内核栈切换</p><p>完成第二级切换，切换用户栈和用户执行地址</p><h2 id="L12-核心级线程实现实例">L12 核心级线程实现实例<a class="anchor" href="#L12-核心级线程实现实例">·</a></h2><p>tss：task structure segment</p><p>长跳转至TSS段选择符造成CPU执行任务切换操作，相当于把当前所有寄存器内容放在当前TR寄存器所在的段中，之后将TR切换到新的描述符，从而同时切换所有的寄存器值</p><p>fork中的函数copy_process，创建栈：申请内存空间，创建TCB，创建内核栈和用户栈，填写两个stack，关联栈和TCB</p><p>fork是父进程创建子进程/子内核级线程 可以共用用户栈</p><p>子进程中fork返回值为0，父进程不为0 修改%eax的值！！</p><h2 id="L13-操作系统的那棵树">L13 操作系统的那棵树<a class="anchor" href="#L13-操作系统的那棵树">·</a></h2><p>研究复杂系统：从一个小点出发，做成一颗大树。从一个小想法开始，提出新问题，解决新问题并不断完善。</p><p>运转CPU：取指执行。</p><p>没有好好运转？交替执行，引入多进程。切换跳转需要使用栈来实现。</p><p>一个栈进行切换造成了混乱？采用2个栈+2个TCB，Yield找到下一个TCB，找到新的栈，切换新的栈</p><p>遇到中断阻塞就麻烦了，引入内核栈的切换。</p><p>实现idea，从一个简单清晰目标出发，交替打印A和B</p><p>发散思维适合创新，线性思维适合执行工作</p><h2 id="L14-CPU调度策略">L14 CPU调度策略<a class="anchor" href="#L14-CPU调度策略">·</a></h2><p>获得next进程</p><p>FIFO 先进先出：简单有效 银行食堂常用</p><p>需要优先级，任务很短/很长的应该怎么调度</p><p>要让进程满意：</p><ul><li>尽快结束任务：<strong>周转时间</strong>短（任务进入到任务结束）</li><li>操作尽快响应：<strong>响应时间</strong>短（从操作发生到响应）</li><li>系统内耗时间少：<strong>吞吐量</strong>（完成的任务量）</li></ul><p>原则：专注于任务执行，又能合理调配任务</p><p>吞吐量和响应时间有矛盾（响应时间小，切换时间多，系统内耗大，吞吐量小）</p><p>前台任务和后台任务关注点不同（前台关注响应时间，后台关注周转时间）</p><p>IO约束型任务和CPU约束型任务有各自特点</p><h3 id="First-Come-First-Served-FCFS-先来先服务">First Come First Served FCFS 先来先服务<a class="anchor" href="#First-Come-First-Served-FCFS-先来先服务">·</a></h3><p>类似FIFO</p><h3 id="SJF-短作业优先">SJF 短作业优先<a class="anchor" href="#SJF-短作业优先">·</a></h3><p>平均周转时间最短</p><h3 id="考虑响应时间：RR-按照时间片来轮转调度">考虑响应时间：RR 按照时间片来轮转调度<a class="anchor" href="#考虑响应时间：RR-按照时间片来轮转调度">·</a></h3><p>时间片大响应时间太长，时间片小，吞吐量小</p><h3 id="同时考虑响应时间和周转时间">同时考虑响应时间和周转时间<a class="anchor" href="#同时考虑响应时间和周转时间">·</a></h3><p>定义前台任务和后台任务两个队列，前台RR，后台SJF 前台任务没有时才调度后台任务</p><p>后台有可能一直分配不到</p><h2 id="L15-一个实际的schedule函数">L15 一个实际的schedule函数<a class="anchor" href="#L15-一个实际的schedule函数">·</a></h2><p>counter既用来表示优先级，也表示时间片</p><p>经过IO以后，counter变大，IO时间越长，counter越大，照顾了IO进程。IO进程每次中断阻塞时，会被设置成counter初值+当前counter的一半，从而越来越大，从而提高优先级</p><p>后台进程一直按照counter轮转，近似了SJF调度。每次时间片用完才重置，因为<strong>没有IO，不需要阻塞</strong>！</p><h2 id="Lab4-基于内核栈切换的进程切换">Lab4 基于内核栈切换的进程切换<a class="anchor" href="#Lab4-基于内核栈切换的进程切换">·</a></h2><h2 id="L16-进程同步与信号量">L16 进程同步与信号量<a class="anchor" href="#L16-进程同步与信号量">·</a></h2><p>进程合作：多进程共同完成一个任务</p><p>生产者消费者实例</p><p>核心：等待</p><p>利用信息量决定睡眠和唤醒</p><p>例子：一种资源的数量是8，这个资源对应的信号量的当前值是2，说明<strong>有2个资源可以使用</strong></p><p>如果是-2，说明有2个进程在等待这个资源</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;<span class="comment">//记录资源个数</span></span><br><span class="line">    PCB* <span class="built_in">queue</span>;<span class="comment">//记录等待在该信号量上的进程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P(semaphore s)<span class="comment">//消费资源</span></span><br><span class="line">&#123;</span><br><span class="line">    s.value--;</span><br><span class="line">    <span class="keyword">if</span>(s.value&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        sleep(s.<span class="built_in">queue</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V(semaphore s)<span class="comment">//产生资源</span></span><br><span class="line">&#123;</span><br><span class="line">    s.value++;</span><br><span class="line">    <span class="keyword">if</span>(s.value&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        wakeup(s.<span class="built_in">queue</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生产者消费者模式实例">生产者消费者模式实例<a class="anchor" href="#生产者消费者模式实例">·</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">semaphore full = <span class="number">0</span>; </span><br><span class="line">semaphore empty = BUFFER_SIZE;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Producer(item) </span><br><span class="line">&#123;</span><br><span class="line">    P(empty);</span><br><span class="line">    P(mutex); </span><br><span class="line">    读入in;将item写入到in的位置上;</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(full); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Consumer() </span><br><span class="line">&#123;</span><br><span class="line">    P(full); </span><br><span class="line">    P(mutex);</span><br><span class="line">    读入out;从文件中的out位置读出到item;打印item;</span><br><span class="line">    V(mutex);</span><br><span class="line">    V(empty); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="L17-对信号量的临界区保护">L17 对信号量的临界区保护<a class="anchor" href="#L17-对信号量的临界区保护">·</a></h2><p>多个生产者共同修改信号量可能会出问题</p><p>解决竞争条件：给共享变量上锁</p><p>一段代码一次只允许一个进程进入 原子操作</p><p>临界区：一次只允许一个进程进入的一段代码</p><p>进出上锁，退出开锁</p><p>基本原则：互斥进入</p><p>好的保护原则：</p><ul><li>有空让进</li><li>有限等待</li></ul><p>以下代码<strong>临界区表示进入条件</strong></p><h3 id="进入临界区一个尝试：轮换法">进入临界区一个尝试：轮换法<a class="anchor" href="#进入临界区一个尝试：轮换法">·</a></h3><p>一个跑完了修改标志让另一个可以进入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A</span></span><br><span class="line"><span class="comment">//临界区</span></span><br><span class="line"><span class="keyword">while</span> (turn!=<span class="number">0</span>); </span><br><span class="line"><span class="comment">//剩余区</span></span><br><span class="line">turn = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//B</span></span><br><span class="line"><span class="comment">//临界区</span></span><br><span class="line"><span class="keyword">while</span> (turn!=<span class="number">1</span>);</span><br><span class="line"><span class="comment">//剩余区</span></span><br><span class="line">turn = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="改进：标记法">改进：标记法<a class="anchor" href="#改进：标记法">·</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A</span></span><br><span class="line"><span class="comment">//临界区</span></span><br><span class="line">flag[<span class="number">0</span>]=<span class="literal">true</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//剩余区</span></span><br><span class="line">flag[<span class="number">0</span>]=<span class="literal">false</span>;</span><br><span class="line"><span class="comment">//B</span></span><br><span class="line"><span class="comment">//临界区</span></span><br><span class="line">flag[<span class="number">1</span>]=<span class="literal">true</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//剩余区</span></span><br><span class="line">flag[<span class="number">1</span>]=<span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>再一次尝试：非对称标记</p><h3 id="进入临界区Peterson算法">进入临界区Peterson算法<a class="anchor" href="#进入临界区Peterson算法">·</a></h3><p>结合标记和轮状两种思想</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//临界区</span></span><br><span class="line">flag[i]=<span class="literal">true</span></span><br><span class="line">turn=j</span><br><span class="line"><span class="keyword">while</span>(flag[j]&amp;&amp;turn==j);</span><br><span class="line"><span class="comment">//剩余区</span></span><br><span class="line">flag[i]=<span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="多个进程：面包店算法">多个进程：面包店算法<a class="anchor" href="#多个进程：面包店算法">·</a></h3><p>轮转：每个进程都获得一个序号，序号最小的进入</p><p>标记：进程离开时序号为0，不为0的序号即为标记</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">choosing[i] = <span class="literal">true</span>; num[i] = max(num[<span class="number">0</span>], …, num[n<span class="number">-1</span>])+<span class="number">1</span>;</span><br><span class="line">choosing[i] = <span class="literal">false</span>; </span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;n; j++) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">while</span>(choosing[j]);</span><br><span class="line"><span class="keyword">while</span> ((num[j] != <span class="number">0</span>) &amp;&amp; (num[j], j)&lt;(num[i], i])); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">num[i] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="临界区保护的另一类解法">临界区保护的另一类解法<a class="anchor" href="#临界区保护的另一类解法">·</a></h3><p>硬件实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//临界区</span></span><br><span class="line">cli(); </span><br><span class="line"><span class="comment">//剩余区</span></span><br><span class="line">sti();</span><br></pre></td></tr></table></figure><p>多CPU不能使用</p><p>控制能否产生中断，阻止被调度</p><h3 id="硬件原子指令法">硬件原子指令法<a class="anchor" href="#硬件原子指令法">·</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">boolean <span class="title">TestAndSet</span><span class="params">(boolean &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    boolean rv = x;</span><br><span class="line">    x = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125; <span class="comment">//一次执行完毕 不管是什么都设置成true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(TestAndSet(&amp;lock)) ;</span><br><span class="line"><span class="comment">//临界区</span></span><br><span class="line">lock = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//剩余区</span></span><br></pre></td></tr></table></figure><h2 id="L18-信号量的代码实现">L18 信号量的代码实现<a class="anchor" href="#L18-信号量的代码实现">·</a></h2><p>if lock导致只能逐个唤醒</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sys_sem_wait(<span class="keyword">int</span> sd)&#123;</span><br><span class="line">    cli();</span><br><span class="line">    <span class="keyword">if</span>(semtable[sd].value -- &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        设置自己为阻塞;</span><br><span class="line">        将自己加入semtable[sd].<span class="built_in">queue</span>中;</span><br><span class="line">        schedule();</span><br><span class="line">    &#125;</span><br><span class="line">    sti(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>while lock可以让许多进程一起竞争，同时唤醒 因为中断返回可以继续竞争锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lock_buffer(buffer_head*bh)</span><br><span class="line">&#123;</span><br><span class="line">cli();</span><br><span class="line">    <span class="keyword">while</span>(bh-&gt;b_lock)</span><br><span class="line">    sleep_on(&amp;bh-&gt;b_wait);</span><br><span class="line">    bh-&gt;b_lock = <span class="number">1</span>;</span><br><span class="line">    sti(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="L19-死锁处理">L19 死锁处理<a class="anchor" href="#L19-死锁处理">·</a></h2><p><strong>互相等待对方持有的资源</strong>造成所有进程<strong>都无法执行</strong>的情况</p><p>死锁必要条件：互斥使用 不可抢占（只能资源放弃） 请求和保持（占有资源了，再去申请其他资源） 循环等待</p><p>处理方法：死锁预防（破坏死锁出现的条件） 死锁避免（检测每个资源请求，如果造成死锁就拒绝） 死锁检测+恢复（检测到，让一些进程回滚，让出资源）  死锁忽略</p><h3 id="死锁预防">死锁预防<a class="anchor" href="#死锁预防">·</a></h3><ul><li>一次性申请所有需要的资源，不会占有资源再申请其他资源<ul><li>需要预知未来，编程困难</li><li>许多资源分配后很长时间才使用，资源利用率低</li></ul></li><li>对资源类型进行排序，资源申请必须按序进行，不会出现环路等待<ul><li>仍然造成资源浪费</li></ul></li></ul><h3 id="死锁避免">死锁避免<a class="anchor" href="#死锁避免">·</a></h3><p>如果系统中所有进程存在一个可完成的执行序列P1，P2…,Pn，则称系统处于安全状态</p><p>安全序列：执行序列P1…Pn</p><h4 id="找安全序列的银行家算法">找安全序列的银行家算法<a class="anchor" href="#找安全序列的银行家算法">·</a></h4><p>每次根据每种资源剩余数量和每个进程需要资源数量，寻找一个可以完成的进程，并把它的资源释放，再观察是否有可以完成的，直到找不到或者全部进程完成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Available[<span class="number">1.</span>.m]; <span class="comment">//每种资源剩余数量</span></span><br><span class="line"><span class="keyword">int</span> Allocation[<span class="number">1.</span>.n,<span class="number">1.</span>.m]; <span class="comment">//已分配资源数量</span></span><br><span class="line"><span class="keyword">int</span> Need[<span class="number">1.</span>.n,<span class="number">1.</span>.m];<span class="comment">//进程还需的各种资源数量</span></span><br><span class="line"><span class="keyword">int</span> Work[<span class="number">1.</span>.m]; <span class="comment">//工作向量</span></span><br><span class="line"><span class="keyword">bool</span> Finish [<span class="number">1.</span>.n]; <span class="comment">//进程是否结束</span></span><br><span class="line">Work = Available; Finish[<span class="number">1.</span>.n] = <span class="literal">false</span>; </span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123; </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Finish[i]==<span class="literal">false</span> &amp;&amp; Need[i]£Work)&#123;</span><br><span class="line">            Work = Work + Allocation[i];</span><br><span class="line">            Finish[i] = <span class="literal">true</span>; </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">goto</span> <span class="built_in">end</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">End: <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line"><span class="keyword">if</span>(Finish[i]==<span class="literal">false</span>) <span class="keyword">return</span> “deadlock”;</span><br></pre></td></tr></table></figure><p>实际使用：每次有新进程进入，就将它和当前其他进程做计算。每次都是$O(mn^2)$复杂度</p><h3 id="死锁检测-恢复：发现问题再处理">死锁检测+恢复：发现问题再处理<a class="anchor" href="#死锁检测-恢复：发现问题再处理">·</a></h3><p>发现问题再处理。定时检测或者发现资源利用率低时检测</p><p>实现回滚比较困难</p><p>许多通用操作系统上都采用死锁忽略方法，可以用重新启动的方式解决死锁问题</p><h2 id="Lab5-信号量的实现和应用">Lab5 信号量的实现和应用<a class="anchor" href="#Lab5-信号量的实现和应用">·</a></h2><h1 id="内存管理">内存管理<a class="anchor" href="#内存管理">·</a></h1><h2 id="L20-内存使用与分段">L20 内存使用与分段<a class="anchor" href="#L20-内存使用与分段">·</a></h2><p>内存使用：程序放在内存中，执行程序</p><p>程序中的地址是逻辑地址（相对地址） 需要<strong>转换为</strong>内存中<strong>真实的物理地址</strong> 也就是<strong>重定位</strong></p><p>什么时候完成重定位？编译时（嵌入式，静态硬件设备） 载入时（更加灵活）</p><p><strong>编译时重定位</strong>：程序只能放在内存固定位置，效率高</p><p><strong>载入时重定位</strong>：程序一旦载入内存就不能动了，但需要修改地址，稍微慢一些</p><p>但程序载入后还需要移动，因为内存有限，可能某个阻塞的进程需要和磁盘中的进程<strong>交换</strong></p><p>重定位最佳时机：<strong>运行时重定位</strong>  每执行一条指令都要从逻辑地址算出物理地址：地址翻译</p><p>PCB中存储着base基址 执行指令时第一步先从PCB中取出基址</p><p>每个进程寻找一段空闲内存，将基址放在PCB中 每次取址执行，需要找到PCB中的基址 切换进程时根据PCB切换，一起切换基地址</p><p>整个程序一起载入内存？不太可能 程序由若干段组成，每个段有各自的特点用途</p><p>比如程序段（只读） 数据段（可写） 堆栈</p><p>分段：程序的各个段分别放入内存</p><p>PCB中要存储<strong>进程段表（LDT）</strong> OS对应的进程段表也就是<strong>GDT表</strong></p><p>包含 段号 基址 长度 允许操作（读/写）</p><p>ldtr 段表寄存器</p><h2 id="L21-内存分区与分页">L21 内存分区与分页<a class="anchor" href="#L21-内存分区与分页">·</a></h2><p>如何找到空闲的区域？</p><p>程序分段，找到空闲分区，PCB中存储映射段和内存地址的映射表</p><p>固定分区：OS初始化时，内存等分成k个分区  但需求不一样</p><p><strong>可变分区</strong>：大小不一样，动态变化</p><p>可变分区管理：请求分配 包含空闲分区表（起始地址和长度）和已分配分区表（起始地址，长度，分配给的段标志）</p><p>OS中<strong>没有非黑即白</strong>的东西，要分析优缺点</p><p>有多个空闲分区时，选择空闲分区的方式：首先适配（复杂度低），最佳适配（容易产生小间隙），最差适配（分区均匀）</p><p>引入<strong>分页</strong>：解决内存分区导致的<strong>内存效率问题</strong></p><p>分区其实和虚拟内存对应，物理内存使用分页管理</p><p>可变分区造成有很多内存碎片 将空闲分区合并，需要移动一个段：内存紧缩（无法执行用户进程，相当于死机） 实际使用不可行</p><p>从连续到离散：让内存没有碎片 类似将面包切成片，将<strong>内存分成页</strong></p><p>针对每个段内存请求，系统一页一页的分配给这个段 （物理内存按照每4K作为一页）</p><p>根据<strong>页表</strong>来查 页表寄存器 cr3</p><p>包含：页号（逻辑页号） 页框号（物理页号） 保护标记（读写）</p><p>利用mmu将逻辑地址转换为页号（物理实现）</p><p><strong>逻辑地址向右移12位得到页号，查表得到页框号，利用页框号和逻辑地址低12位相拼接得到物理地址</strong></p><p>每个段放在多个页</p><h2 id="L22-多级页表和快表">L22 多级页表和快表<a class="anchor" href="#L22-多级页表和快表">·</a></h2><p>页比较小则页表就大了</p><p>页表放置成了问题 <strong>基本想法</strong>：<strong>连续存放所有逻辑页</strong>号对应的物理页号</p><p>大部分逻辑地址根本不会使用 <strong>第一种尝试</strong>：只存放用到的页 <strong>用到的逻辑页</strong>才有页表项</p><p>页表中的页号不连续可以折半，但是需要查多次内存</p><p>大页表占用内存，造成浪费 既要连续也要让页表占用内存少==&gt;<strong>使用多级页表</strong>  借鉴书籍的章节思想</p><p>即逻辑地址划分为<strong>页目录号(10bits)</strong> <strong>页号(10bits)</strong> <strong>地址偏移(12bits)</strong></p><p>每个页目录项指向一个4M的空间（指向1K个页表项），每个页表项指向4KB的空间</p><p>提高空间效率，时间上每增加一级，访问内存次数增加一次</p><p>快表TLB：组相联快速存储，寄存器  包含<strong>有效标记 页号 修改标记 保护 页框号</strong></p><p>利用物理电路将<strong>页号直接映射到物理页号</strong>，速度快</p><p>有效访问时间=HitR*(TLB+MA)+(1-HitR)*(TLB+2MA) HitR命中率</p><p>程序地址访问存在局部性 空间局部性，每次对某一段内存访问率高</p><h2 id="L23-段页结合的实际内存管理">L23 段页结合的实际内存管理<a class="anchor" href="#L23-段页结合的实际内存管理">·</a></h2><p>程序段映射到地址空间 地址空间再映射到物理页</p><p>也就是将<strong>程序段和虚拟内存映射</strong>，再将<strong>虚拟内存和物理内存映射</strong>（多级页表机制）</p><p>段面向用户，页面向硬件</p><p>代码中的cs:ip是虚拟内存</p><p>用户眼里包含操作系统段，用户数据段，用户代码段，用户堆栈段</p><h3 id="地址翻译">地址翻译<a class="anchor" href="#地址翻译">·</a></h3><p>用户：cs:ip 段号+偏移</p><p>映射到段表，段表中包含<strong>段号 基址 长度 保护标记</strong> 获得了<strong>基址之后加上偏移</strong>得到了<strong>虚拟地址</strong></p><p>再将<strong>虚拟地址</strong>用<strong>多级页表映射</strong>到<strong>物理内存地址</strong></p><h3 id="实际内存管理">实际内存管理<a class="anchor" href="#实际内存管理">·</a></h3><p>分配段 建段表 找到空闲物理页 分配页 页表映射</p><p>进程带动内存使用</p><p>段表和页表设置好，执行指令时MMU自动完成地址翻译</p><p>fork：将一段新的虚拟内存分配给子进程（LDT），同时和父进程的物理内存完成映射，复制父进程页表</p><h2 id="L24-内存换入-请求调页">L24 内存换入-请求调页<a class="anchor" href="#L24-内存换入-请求调页">·</a></h2><p>为了实现虚拟内存，需要实现换入换出</p><p>换入换出实现大内存 比如虚拟内存是4G，物理内存为2G</p><p>将不同的虚拟内存地址映射到相同地址的物理内存 请求的时候才映射（换入）</p><p>请求一个地址，地址缺页，对页做标记，需要中断来调入页面 即<strong>页错误处理程序</strong></p><p>从<strong>磁盘中找到</strong>相应程序，将<strong>程序载入</strong>换入对应的物理内存页中，<strong>设置好页表中的映射</strong></p><p>实际的<strong>请求调页</strong></p><h2 id="L25-内存换出（页表置换）">L25 内存换出（页表置换）<a class="anchor" href="#L25-内存换出（页表置换）">·</a></h2><p>如果找不到空闲的物理页，则需要选择一页进行淘汰，换出到磁盘</p><p>实例：分配3个页框，页面引用序列为：A B C A B D A D B C B</p><h3 id="FIFO-最简单">FIFO 最简单<a class="anchor" href="#FIFO-最简单">·</a></h3><p>A AB ABC ABC ABC DBC DAC DAC DAB CAB CAB</p><p>每次换出<strong>最早来</strong>的页面</p><p>存在7次缺页</p><h3 id="MIN-最优">MIN 最优<a class="anchor" href="#MIN-最优">·</a></h3><p>A AB ABC ABC ABC ABD ABD ABD ABD CBD CBD</p><p>选<strong>最远将使用的页</strong>淘汰，是最优方案</p><p>存在5次缺页</p><h3 id="LRU-折中最优">LRU 折中最优<a class="anchor" href="#LRU-折中最优">·</a></h3><p>用过去的历史预测未来 LRU：选取<strong>最近最长一段时间没有使用</strong>的页<strong>淘汰</strong>（最近最少使用）</p><p>A AB ABC ABC ABC ABD ABD ABD ABD CBD CBD</p><p>LRU是对局部性的认识和归纳</p><p>5次缺页</p><h3 id="LRU-准确实现-用时间戳">LRU 准确实现 用时间戳<a class="anchor" href="#LRU-准确实现-用时间戳">·</a></h3><p>每页维护一个时间戳</p><p>每个时间周期使用某一页时将这个页的时间戳更新为当前时间</p><p>之后需要替换时，将时间戳最小的淘汰</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">D</th><th style="text-align:center">A</th><th style="text-align:center">D</th><th style="text-align:center">B</th><th style="text-align:center">C</th></tr></thead><tbody><tr><td style="text-align:center">A</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">4</td><td style="text-align:center">4</td><td style="text-align:center">4</td><td style="text-align:center">7</td><td style="text-align:center">7</td><td style="text-align:center">7</td><td style="text-align:center">7</td></tr><tr><td style="text-align:center">B</td><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">5</td><td style="text-align:center">5</td><td style="text-align:center">5</td><td style="text-align:center">5</td><td style="text-align:center">9</td><td style="text-align:center">9</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">6</td><td style="text-align:center">6</td><td style="text-align:center">8</td><td style="text-align:center">8</td><td style="text-align:center">8</td></tr></tbody></table><p>每次地址访问都需要修改时间戳，需要维护一个全局时钟，需要找到最小值，实现代价很大</p><h3 id="LRU-准确实现-用页面栈">LRU 准确实现 用页面栈<a class="anchor" href="#LRU-准确实现-用页面栈">·</a></h3><p>维护一个页码队列</p><p>每次淘汰队头</p><p>每次地址访问需要修改栈（比如修改指针）</p><h3 id="LRU近似实现-将时间计数变为是和否">LRU近似实现-将时间计数变为是和否<a class="anchor" href="#LRU近似实现-将时间计数变为是和否">·</a></h3><p>每页增加一个引用位（reference bit）</p><p>每次访问一页时，硬件自动设置该位</p><p>选择淘汰页：扫描该位，是1时清零，并继续扫描，是0时淘汰该页</p><p>组织成循环队列</p><p>再给一次机会（second chance replacement）算法</p><p>更改为最近没有使用</p><h3 id="clock算法的分析和改造">clock算法的分析和改造<a class="anchor" href="#clock算法的分析和改造">·</a></h3><p><strong>缺页很少</strong>，就会导致所有的R=1，从而退化成FIFO</p><p>不能记录太长的历史信息 定时清除R位 再来一个扫描指针</p><p>清除R位的移动速度快</p><p>选择淘汰页的指针移动速度慢</p><h3 id="给进程分配多少页框（帧frame）">给进程分配多少页框（帧frame）<a class="anchor" href="#给进程分配多少页框（帧frame）">·</a></h3><p>分配太多，请求调页导致内存高效利用就没用了</p><p>分配太少，缺页太多，系统颠簸</p><p>计算工作集，设置进程的页框</p><p>进程数量，页框数量都要进行限制</p><h3 id="补充：Clock算法">补充：Clock算法<a class="anchor" href="#补充：Clock算法">·</a></h3><p>是一种LRU的近似算法，是一种性能和开销较均衡的算法。由于LRU算法需要较多的硬件支持，采用CLOCK置换算法只需相对较少的硬件支持。又称为最近未用算法（NRU）</p><h4 id="简单的CLOCK置换算法">简单的CLOCK置换算法<a class="anchor" href="#简单的CLOCK置换算法">·</a></h4><p>实现方法：</p><p>（1）为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列</p><p>（2）当某页被访问时，其访问位置为1</p><p>（3）当需要淘汰一个页面时，只需检查页的访问位：如果是0，选择此页换出；如果是1，将它置0，暂不换出，继续检查下一个页面</p><p>（4）若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0，再进行第二轮扫描，第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描</p><h4 id="改进型的CLOCK置换算法">改进型的CLOCK置换算法<a class="anchor" href="#改进型的CLOCK置换算法">·</a></h4><ol><li><p>引入：简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行I/O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。</p></li><li><p>思想：因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免I/O操作。这就是改进型的时钟置换算法的思想。</p></li><li><p>实现方法：修改位=0，表示页面没有被修改过；修改位=1，表示页面被修改过。为方便讨论，用（访问位，修改位）的形式表示各页面状态。</p></li><li><p>算法规则：将所有可能被置换的页面排成一个循环队列</p></li></ol><p>第一轮:从当前位置开始扫描到第一个（0,0）的帧用于替换。本轮扫描不修改任何标志位</p><p>第二轮:若第一轮扫描失败，则重新扫描，查找第一个（0,1）的帧用于替换。本轮将所有扫描过的帧访问位设为0</p><p>第三轮:若第二轮扫描失败，则重新扫描，查找第一个（0,0）的帧用于替换。本轮扫描不修改任何标志位</p><p>第四轮:若第三轮扫描失败，则重新扫描，查找第一个(0,1）的帧用于替换</p><p>注意：由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此改进型CLOCK置换算法选择一个淘汰页面最多会进行四轮扫描</p><h2 id="Lab6-地址映射与共享">Lab6 地址映射与共享<a class="anchor" href="#Lab6-地址映射与共享">·</a></h2><h1 id="设备驱动与文件系统">设备驱动与文件系统<a class="anchor" href="#设备驱动与文件系统">·</a></h1><h2 id="L26-I-O-与显示器">L26 I/O 与显示器<a class="anchor" href="#L26-I-O-与显示器">·</a></h2><p>让外设工作起来 发出写命令到总线上，显卡或硬件驱动设备收到就进行相应操作 也就是向设备控制器的寄存器写（out指令）</p><ul><li>发出写命令（输出）</li><li>向CPU发出中断（输入）</li><li>读数据到内存</li></ul><p>操作系统要形成简单的视图-<strong>文件视图</strong></p><p>一段操作外设的程序</p><p>不管什么设备都是open read write close</p><p>根据设备文件名进行相应处理 open(“/dev/xxx”) 找到控制器的地址、内容格式等等</p><p>系统调用-相应文件的处理程序-具体设备的操作</p><h3 id="open系统调用">open系统调用<a class="anchor" href="#open系统调用">·</a></h3><p>解析目录，找到inode 文件信息</p><p>PCB中的filp列表对应于一个文件指针列表，每个文件指针对应了一个文件的信息</p><h3 id="向屏幕输出">向屏幕输出<a class="anchor" href="#向屏幕输出">·</a></h3><p>sys_write判断是否为字符设备 转到rw_char函数</p><p>crw_table字符接口设备中找到相应读写函数地址tty_write 实现输出的核心函数</p><p>往缓冲区写字符 最终读入缓冲区内容 放入tty的队列中</p><p>最后通过con_write方法 将字符放到显存的寄存器中 统一编址用mov，独立编址使用out</p><h2 id="L27-键盘">L27 键盘<a class="anchor" href="#L27-键盘">·</a></h2><p>从键盘中断开始</p><p>inb指令读入扫描码 即对应了哪个按键</p><p>跳转到相应函数，根据相应函数得到key_map</p><p>从key_map中取出ASCII码 将ASCII码放入缓冲队列头部 con.read_q</p><p>键盘中断处理程序 再将ASCII码回写</p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220913100129347.png" alt="image-20220913100129347" style="zoom: 67%;"><h2 id="Lab7-终端设备的控制">Lab7 终端设备的控制<a class="anchor" href="#Lab7-终端设备的控制">·</a></h2><h2 id="L28-生磁盘的使用">L28 生磁盘的使用<a class="anchor" href="#L28-生磁盘的使用">·</a></h2><p>移动<strong>机械臂</strong>到相应<strong>柱面（磁道）</strong> 旋转磁盘将<strong>扇区和磁头</strong>对应，之后<strong>确定缓存位置</strong> 磁生电读，电生磁写</p><p>head：其实是磁盘圆柱的横截面中的每个扇形的标志（很多个圆）</p><p>cyl：是柱面，也就是一个圆柱体的侧面（展开是矩形）</p><p>sec：扇区</p><h3 id="通过盘块号读写磁盘（一层抽象）">通过盘块号读写磁盘（一层抽象）<a class="anchor" href="#通过盘块号读写磁盘（一层抽象）">·</a></h3><p>磁盘驱动将block计算出cyl head sec</p><p><strong>磁盘访问时间=写入控制器时间+寻道时间+旋转时间+传输时间</strong>  <strong>寻道时间最长，且无法显著提升</strong></p><p>block相邻的盘块应该可以快速读出 ==&gt; 相邻盘块尽量在同一个磁道上</p><p>磁盘读写扇区 单位是扇区 但是每次读入多个扇区，也就是一个盘块block</p><p>应用读入的单位是盘块 OS将盘块转为连续的若干个扇区CHS，从而读入连续的多个扇区，连续的扇区数是固定的，相当于一个盘块=n个扇区</p><p>block=C*(Heads*Sectors)+H*Sectors+S</p><p>S=block%Sectors</p><h3 id="多个进程通过队列使用磁盘（二层抽象）">多个进程通过队列使用磁盘（二层抽象）<a class="anchor" href="#多个进程通过队列使用磁盘（二层抽象）">·</a></h3><p>多个请求将盘块号放在请求队列上</p><p>磁盘中断从队列中取出</p><h4 id="磁盘调度">磁盘调度<a class="anchor" href="#磁盘调度">·</a></h4><p>调度目标是平均访问延迟小 寻道时间是主要矛盾</p><p>对磁道进行考查 看总的磁道移动数量</p><ul><li>FCFS</li><li>SSTF 短寻道优先 每次访问离得最近的磁道 不适合读写频繁的程序，存在饥饿</li><li>SCAN=SSTF+中途不回折 找到一个最近的磁道往那个方向处理完所有请求，再往回</li><li>C-SCAN=SCAN+直接移到另一端：两端请求都能很快处理</li></ul><p>从简单算法出发，用主要矛盾和指标着手，发现如何改进</p><p>(1) 进程“得到盘块号”，算出扇区号(sector)</p><p>(2) 用扇区号make req，用电梯算法add_request</p><p>(3) 进程sleep_on</p><p>(4) 磁盘中断处理，唤醒进程</p><p>(5) do_hd_request算出cyl,head,sector</p><p>(6) hd_out调用outp(…)完成端口写</p><h2 id="L29-从生磁盘到文件">L29 从生磁盘到文件<a class="anchor" href="#L29-从生磁盘到文件">·</a></h2><h3 id="引入文件，对磁盘使用的第三层抽象">引入文件，对磁盘使用的第三层抽象<a class="anchor" href="#引入文件，对磁盘使用的第三层抽象">·</a></h3><p>文件抽象成一个<strong>字符流</strong>，按照行和列的形式组织成书-文件</p><p>建立字符流到盘块集合的映射关系</p><h3 id="连续结构来实现文件">连续结构来实现文件<a class="anchor" href="#连续结构来实现文件">·</a></h3><p>文件的FCB：文件名 起始块 块数</p><p>将文件中的某个字符和某一块中的某个数据做映射</p><h3 id="链式结构实现文件">链式结构实现文件<a class="anchor" href="#链式结构实现文件">·</a></h3><p>文件FCB：文件名 起始块</p><p>文件长度增减容易，顺序访问慢</p><h3 id="索引结构实现文件">索引结构实现文件<a class="anchor" href="#索引结构实现文件">·</a></h3><p>inode==&gt;文件FCB：文件名 索引块</p><p>索引块处有文件的每个块的索引</p><p>先读入索引块位置，再找在哪个具体的位置查</p><h3 id="实际系统是多级索引">实际系统是多级索引<a class="anchor" href="#实际系统是多级索引">·</a></h3><p>重要且少的文件直接读，有的文件有一阶，二阶，三阶间接索引</p><p>很小的文件高效访问，也可以表示很大的文件</p><h2 id="L30-文件使用磁盘的实现">L30 文件使用磁盘的实现<a class="anchor" href="#L30-文件使用磁盘的实现">·</a></h2><p>file_write(inode,file,buf,count)</p><p>inode==&gt;FCB 找到盘块号</p><p>file==&gt;有一个读写指针，是开始地址，再加上count（fseek就是修改这个指针）</p><p>用盘块号，buf等形成request放入队列</p><p>设备文件的inode和普通文件不一样 包含文件类型属性</p><p>从文件/路径名找到inode  根据inode找到盘块号 根据盘块号放入请求队列 根据请求队列算出CHS 根据out发到磁盘驱动器上</p><p>第一条路 读写磁盘 第二条路 输出到显示器</p><h2 id="L31-目录与文件系统">L31 目录与文件系统<a class="anchor" href="#L31-目录与文件系统">·</a></h2><p>文件，抽象一个磁盘块集合 建立字符流到盘块集合的映射</p><h3 id="文件系统抽象整个磁盘-第四层抽象">文件系统抽象整个磁盘 第四层抽象<a class="anchor" href="#文件系统抽象整个磁盘-第四层抽象">·</a></h3><p>所有文件一层 太乱</p><p>引入目录树 k次划分后，每次集合中的文件数为$O(log_kN)$ 引入目录，表示一个文件集合</p><p>目录树中完成从路径名到FCB的映射</p><p>目录树中存储FCB的指针==&gt;编号</p><p>磁盘分为 引导块 超级块 inode节点位图+盘块位图（表示是否空闲） inode节点+数据区</p><p>也可以分为 引导快 超级块 位图 FCB数组 数据盘块</p><p>目录项：文件名+对应FCB地址</p><p>根据某个目录的FCB找到数据盘块中的目录项，又对应相对应的FCB，继续找数据盘块中的目录项，直到找到文件</p><p>FCB数组第一个是根目录 “/” 找到数据块，匹配里面的每个文件名，再找到相应的FCB，循环往复一直找到对应的文件</p><p>inode位图：哪些inode空闲，哪些被占用 盘块位图：哪些盘块空闲，硬盘大小不同这个位图大小不同 空闲位图：位向量</p><p>超级块：记录两个位图有多大等信息</p><h2 id="L32-目录解析代码实现">L32 目录解析代码实现<a class="anchor" href="#L32-目录解析代码实现">·</a></h2><p>其实目录解析就是如何open 找到inode读入内存</p><p>get_dir完成目录解析</p><p>初始化将根目录挂载进来</p><h3 id="操作系统全图">操作系统全图<a class="anchor" href="#操作系统全图">·</a></h3><p><strong>多进程视图</strong> 多进程交替执行程序 CPU忙碌起来 取指执行</p><p>程序执行需要操作内存，从而对内存进行管理 段页合作</p><p>程序执行还需要操作磁盘或者其他外设，需要将他们抽象成文件 <strong>文件视图</strong></p><h2 id="Lab8-proc文件系统的实现">Lab8 proc文件系统的实现<a class="anchor" href="#Lab8-proc文件系统的实现">·</a></h2>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软工尾声-提问回顾与个人总结</title>
      <link href="2022/06/24/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E6%8F%90%E9%97%AE%E5%9B%9E%E9%A1%BE%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
      <url>2022/06/24/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E6%8F%90%E9%97%AE%E5%9B%9E%E9%A1%BE%E4%B8%8E%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="软工尾声-提问回顾与个人总结">软工尾声-提问回顾与个人总结<a class="anchor" href="#软工尾声-提问回顾与个人总结">·</a></h1><table><thead><tr><th>项目</th><th>内容</th></tr></thead><tbody><tr><td>这个作业属于哪个课程</td><td><a href="https://bbs.csdn.net/forums/BH-SE" target="_blank" rel="noopener">2022春季软件工程（罗杰 任健）</a></td></tr><tr><td>这个作业的要求在哪里</td><td><a href="https://bbs.csdn.net/topics/607080413" target="_blank" rel="noopener">个人作业-提问回顾与个人总结</a></td></tr></tbody></table><h2 id="Part1-提问回顾">Part1 提问回顾<a class="anchor" href="#Part1-提问回顾">·</a></h2><p><a href="https://blog.csdn.net/weixin_45783724/article/details/123366232" target="_blank" rel="noopener">以前问题的博客</a></p><h3 id="1-专业软件开发师仅需要按照流程理性地工作？-2">1.专业软件开发师仅需要按照流程理性地工作？<a class="anchor" href="#1-专业软件开发师仅需要按照流程理性地工作？-2">·</a></h3><h4 id="问题-8">问题<a class="anchor" href="#问题-8">·</a></h4><ul><li><p>仅仅按部就班地理性工作，真的能保证大部分工程师有所成就吗？</p></li><li><p>个人认为对于著名的艺术家或者成功人士来说，他们本身就已经具有了很高的天赋或者很高的热情，因此对他们来说，也许只要按部就班进行工作就已经可以完成很高质量的代码，但是对于一般的工程师来说，每天重复差不多低质量的工作，没有任何激情和推动，可能最后只能带来较低质量的产品。而且对于一些重大复杂的算法问题或者架构问题，很多时候依赖于突发奇想或者灵机一动，如果单纯仅仅是机械做一样的工作，能解决这样的问题吗？同时这样的工作模式也很难催生新的问题发现和技术创新</p></li><li><p>因此这一点我个人认为更适合的是大多时候理性，但该有激情的时候需要热情投入。</p></li></ul><h4 id="解答-2">解答<a class="anchor" href="#解答-2">·</a></h4><ul><li>实际开发的时候，除了日常的按部就班工作，还需要给出一些方向目标上的激励，比如需要让每个人从软件开发中收获资源，收获荣誉，得到成长，单纯理性地枯燥工作是不能维持每个人的工作质量的</li></ul><h3 id="2-结对编程能更加灵活吗？-2">2.结对编程能更加灵活吗？<a class="anchor" href="#2-结对编程能更加灵活吗？-2">·</a></h3><h4 id="问题-9">问题<a class="anchor" href="#问题-9">·</a></h4><ul><li><p>能否有两个人先讨论好然后再一起写不同模块或者同一个文件中不同代码，之后再互相测试？</p></li><li><p>形式能否更加灵活？</p></li><li><p>原文中的结对编程描述貌似必须有一个人是领航，一个人是驾驶，但是事实上对于太复杂的需求，驾驶员在写代码的时候被监视就好比是面试中做算法题一样难受，甚至发挥失常（虽然这个和人的心理素质和代码能力密不可分）。而面对过于简单的需求，大部分时候不太需要领航员一直检查和review或者帮助理解文档，这个时候领航员似乎就无所事事了</p></li><li><p>结对编程能不能采用两个人先一起研究需求，并行编程，写微小的模块，之后一起检查测试代码的模式？这样似乎也可以提高效率，而且每个人负责的微小部分代码更精细，同时两个人互相测试也能测试效率更高。</p></li></ul><h4 id="解答-3">解答<a class="anchor" href="#解答-3">·</a></h4><ul><li>根据个人结对编程经验，是可以更加灵活的，不一定需要死板的遵守某个人领航，某个人写代码的形式，对于不复杂的需求，只需要某个人自己写就好，这时另一位同学可以同步进行相应开发</li></ul><h3 id="3-团队的强弱与scrum-2">3.团队的强弱与scrum<a class="anchor" href="#3-团队的强弱与scrum-2">·</a></h3><h4 id="问题-10">问题<a class="anchor" href="#问题-10">·</a></h4><ul><li><p>如何衡量一个团队的强弱？从技术角度还是从努力角度还是综合起来？如果是参差不齐的队伍呢？</p></li><li><p>强大的个人组合成的队伍就不需要scrum来开发软件了吗？</p></li><li><p>首先这里的团队的强弱本身是一个很主观而且很难给出答案的定义。比如一个队伍可能每个人技术上都很强，甚至每个人都做过全栈开发。但是他们的团队合作能力和意识不一定好，以及可能有些人在这次开发中与团队愿景不一致，那又如何定义这样的队伍的强弱呢？同时一个队伍可能技术比较平均甚至平庸，但每个人的学习能力较强，愿景类似，而且能投入的精力都很多，那这个团队是强还是弱呢。同时参差不齐的队伍又该如何计算？个人认为大多数队伍都可以实现scrum，只是可能对于不同队伍，目标和具体细节做出相应改动罢了。</p></li><li><p>假设已经满足了作者关于强的team的定义，那这个scrum流程就不需要了，那大家敏捷开发就一锅乱炖，看心情来完成代码吗？显然不太合理吧，所以要么有相应的简化处理，要么就换一种方法论，但显然似乎也不是完全不需要scrum了</p></li></ul><h4 id="解答-4">解答<a class="anchor" href="#解答-4">·</a></h4><ul><li>经过实际的团队开发实践，个人认为scrum是一种高效地推进项目的手段，不仅是对个人能力强的团队，也对一般的团队有着重要价值。只有经常的更新自己的工作计划和事项，不断进行开会，集成，测试，才能稳步快速推进项目。</li></ul><h3 id="4-敏捷仅仅适用于简单的应用？-2">4.敏捷仅仅适用于简单的应用？<a class="anchor" href="#4-敏捷仅仅适用于简单的应用？-2">·</a></h3><h4 id="问题-11">问题<a class="anchor" href="#问题-11">·</a></h4><ul><li><p>只有简单的变化多的网站适合敏捷，而复杂且稳定软件就不适合甚至不需要吗？</p></li><li><p>当下的很多项目都需要开发者在短时间内开发集成了众多AI算法且质量很高的软件，这时候如果不使用敏捷思想的话难道需要磨洋工吗，显然也不太可能。这个时候如果单纯用本书提到的scrum不行的话，能不能采用相似的或者以本书的敏捷方法为内核的稍加修改后的方法呢？笔者认为可以分配更多的角色，比如算法工程师，模型部署测试等角色来扩充现有的模型。</p></li><li><p>像开发底层正则表达式解析模块其实也需要不断做测试以及迅速交付，如果恰恰有项目需要做一个底层的库而用户还需要定期检查呢？那似乎这个时候敏捷也没什么不好。而且很多bug都必须在真实的大量场景测试才能找到问题</p></li></ul><h4 id="解答-5">解答<a class="anchor" href="#解答-5">·</a></h4><ul><li>我们的项目是一个以unity作为前端的社交app，需要处理前端后端的很多问题，同时作为一个合作项目，我们需要处理和中传同学的沟通。我们实际只有6周时间开发，且还需要考虑考试和疫情带来的影响，那么可以预见这个项目是很复杂困难的。然而实际上我们还是较好的完成了既定目标。可见并不是说敏捷仅适合简单的应用，比如一个简易小程序或网站，也能适合这种具有较大体量的比较困难的app的开发。只是具体开发过程中要明确优先级，决定好哪些事项需要优先处理，同时对一些短期内无法解决的任务，可以考虑搁置，或干脆放弃，有舍才有得。</li></ul><h3 id="5-人类学调查的具体方式？-2">5.人类学调查的具体方式？<a class="anchor" href="#5-人类学调查的具体方式？-2">·</a></h3><h4 id="问题-12">问题<a class="anchor" href="#问题-12">·</a></h4><ul><li>真实世界这么大，我们该走到哪，走多深呢？</li><li>很多时候我们进入生活就迷茫了，这么大的世界，随便走走就眼花缭乱了，具体的真实需求可能就找不到了。具体操作时似乎不能泛泛的撒网了解真实世界，而是寻找其中的若干个有意思的点深入挖掘探索才会更有效率一些。而具体应该探索哪些行业，做哪些具体的事情呢？我个人认为最好的方式是和真实世界中的用户或者客户直接对话或者体验他们的应用场景，这样似乎比出去走走要更加具体实在一些。</li></ul><h4 id="解答-6">解答<a class="anchor" href="#解答-6">·</a></h4><ul><li>这里的调查更多的是指进入生活，发现真实的需求，了解周围的人们的所思所想，以及缺少的内容，从而更好地和自己的实践相结合。同时，也需要进行详尽的调研，了解用户需要什么，哪些功能他们会认真使用。</li></ul><h3 id="6-赢者真的能通吃吗？-2">6.赢者真的能通吃吗？<a class="anchor" href="#6-赢者真的能通吃吗？-2">·</a></h3><h4 id="问题-13">问题<a class="anchor" href="#问题-13">·</a></h4><ul><li>软件行业赢家真的可以通吃吗？</li><li>比如：360vs电脑管家vs鲁大师，饿了吗vs美团外卖，腾讯视频vs爱奇艺vs优酷，至今都没有分出胜负，而最近的统计似乎也显示这些公司互有胜负，所以赢者通吃这种说法似乎有待商榷，这个游戏的合理性似乎也需要讨论。似乎很多时候并不能做到作者说的赢家通吃。</li></ul><h4 id="解答-7">解答<a class="anchor" href="#解答-7">·</a></h4><ul><li>很多时候的确不是赢者通吃，但是这个和具体的领域细分有关，在一些具体的划分上，确实存在赢者通吃的现象。比如虽然QQ音乐和网易云音乐存在竞争，但是QQ音乐在全年龄段具有优势，基本通吃，而网易云在原创，说唱方面基本做到了通吃。</li></ul><h3 id="7-手工写代码和银弹-2">7.手工写代码和银弹<a class="anchor" href="#7-手工写代码和银弹-2">·</a></h3><h4 id="问题-14">问题<a class="anchor" href="#问题-14">·</a></h4><ul><li><p>自动代码平台与软工似乎越来越普及，如何看待？</p></li><li><p>随着AI发展，未来自动写软工的机器人和低代码甚至0代码平台会成为银弹吗？</p></li><li><p>似乎在当下2022年和未来非手工写代码或者自动软件工程渐渐成为现实，包括腾讯和华为在内的很多公司的云服务都提供了低代码甚至自动部署的云建站服务，这些服务很多时候已经可以满足用户的需求了，那么这是不是认为就可以取代手工写代码了呢？</p></li><li><p>最近 <code>Alphacode</code> 在很多算法平台获得了突破，以后的AI是否也可以在软工领域取得突破呢，包括甚至有机器人模拟scrum的过程，完整地进行高效编码，那这会不会成为软工领域的银弹呢？</p></li></ul><h4 id="解答-8">解答<a class="anchor" href="#解答-8">·</a></h4><ul><li>经过软工实践，发现银弹确实不容易，在我们调研测试工具时，一直找不到一个合适的能够方便自动测试APP的工具，现有工具都存在一些问题。包括我们选用的开发平台coding，也存在一些缺陷。可以预见，人们的需求总是在变化，总有东西是平台考虑不到的，所以很难出现银弹。</li></ul><h2 id="Part2-新的问题">Part2 新的问题<a class="anchor" href="#Part2-新的问题">·</a></h2><h3 id="如何权衡公平与效率？">如何权衡公平与效率？<a class="anchor" href="#如何权衡公平与效率？">·</a></h3><p>实际开发过程中，作为PM，有时候我会希望项目进度得到快速稳步推进，有时候会过于独断。对于一些认为不重要的事务，没有征得每个人同意。然而如果每件事都要征得他人同意，那么可以想象效率会非常低下。那么真正开发中，这样的平衡点应该如何寻找？怎么样才能让公平与效率达到完美平衡？</p><h2 id="Part3-做中学">Part3 做中学<a class="anchor" href="#Part3-做中学">·</a></h2><h3 id="1-需求">1.需求<a class="anchor" href="#1-需求">·</a></h3><p>在获取需求时，我们本次课程主要采用和外部合作的方式。一开始的时候，看到了中传同学提出的这个很棒的点子，我们马上联系，并得到了合作机会。Alpha阶段，中传同学主要是客户和市场分析者，需求主要由他们提出，经过我们双方的商议，分析和定义完整具体的需求，并在不断的迭代中完善和验证需求。Beta阶段，我们在项目的参与中越来越深入，于是渐渐将需求的分析和我们自身相结合，通过我们自己的观察、发放调查问卷、收集用户反馈建议等方式，不断增加和完善需求。</p><p>同时，在两次需求分析文档中，我们使用了NABCD方式，即需求，做法，好处，竞争，推广五个方面进行分析。也定义了杀手级功能。</p><h3 id="2-设计">2.设计<a class="anchor" href="#2-设计">·</a></h3><p>对于设计而言，简单的需求，并不一定需要完备的设计文档。但是对于系统整体的设计，以及一些比较复杂的功能，文档的设计很有必要。在Beta阶段，我们主要要求每个同学需要在完成某个特定任务时，编写任务描述，实现策略和测试计划。这样有助于让每个同学在实现之前先有清晰的设计，也让流程管理和代码设计很自然连接在一起。同时，在前期的设计中，我们也通过技术规格说明书，技术博客的方式进行了详尽的技术调研，框架选择，数据库设计等。</p><h3 id="3-实现">3.实现<a class="anchor" href="#3-实现">·</a></h3><p>实现过程应当首先遵循基本的代码规范和文件组织规范。比如Unity中的脚本文件、资源文件放在什么具体的位置。后端的实体类，用户视图类，接口视图类需要放在哪些位置，整体的架构是什么样的，这些都需要进行明确的定义。</p><p>遵循了代码规范后，开始实现时尽量对所有内容做到解耦，尽可能多的复用中间件，让路由过滤，鉴权控制，控制器，接口，接口实现，工具类相互隔离，互不影响。对一些常用的辅助类做好完善的封装供多次复用。</p><p>同时，不管是代码自动生成，还是已有资源利用，需要满足不重复造轮子和最佳实践两个条件，最大限度地利用框架本身带来的便利。</p><h3 id="4-测试">4.测试<a class="anchor" href="#4-测试">·</a></h3><p>测试主要包含前端，后端两部分。对于前端来说，经过我们的调研，app只有少量的工具可以使用，并且只能是以图像识别的基础来进行，模拟相关的点击操作。Unity本身也带有相关的测试框架，可以进行C#代码的单元测试，逻辑测试等。对于后端而言，测试手段比较多，包含压力测试，单元测试，功能测试多个维度。</p><p>测试应当是持续进行的。我们要求每个同学在开发完自己的功能之后，都需要进行自己的正确性测试，至少提供一个测试正例，之后提交给测试人员进行更深入测试。测试人员发现问题后，提出缺陷，让开发人员进行修复。</p><p>发布前的一段时间，需要全员深入参与测试，并提出相关问题，而不能只有几名测试人员，或者自己对自己的功能进行测试。</p><h3 id="5-发布">5.发布<a class="anchor" href="#5-发布">·</a></h3><p>我们认为，发布并不只是发一篇博客这么简单，更多的还在于各个平台的宣传，我们在Alpha，Beta两次迭代结束后，都在微信朋友圈，QQ空间，B站进行了一定程度的宣传，从而对于吸引积累用户起到了良好效果。截止此时，我们已经拥有200名用户，日活最高可以达到100人，基本达到了我们最开始定下的目标。这和我们的大力推广发布是离不开的。</p><p>同时，我们在发布过程中学到的是，尽量让用户以最简单最直接的方式，获取到我们的产品。比如通过直链下载，或者简便的某个公测链接。同时，发布尽量提前，不然可能会出现类似苹果官网挂了这种意外情况导致发布延期。</p><h3 id="6-维护">6.维护<a class="anchor" href="#6-维护">·</a></h3><p>产品发布之后，项目就结束了吗？当然不是。我们还需要通过一些手段，让项目持续生存下去，比如通过外围的比赛，活动参与，投资引入，让项目继续生存。同时，对于用户提出的问题，及时整理，及时处理，及时反馈，让软件质量得到不断提升。</p><p>我们提供了团队邮箱stulingjing@126.com，也提供了团队博客地址，官网地址，用户可以很轻易联系我们提出建议。</p><h2 id="Part4-个人总结">Part4 个人总结<a class="anchor" href="#Part4-个人总结">·</a></h2><h3 id="作为Developer">作为Developer<a class="anchor" href="#作为Developer">·</a></h3><h4 id="团队项目">团队项目<a class="anchor" href="#团队项目">·</a></h4><p>本次软工我主要负责后端和前端的聊天功能开发。在一开始的技术选型中，可靠稳定的SpringBoot进入了我们的视野，同时与之相关的自动部署打包我也进行了相关研究，并让后端的持续集成部署完美实现。我们采用的SpringBoot+Mybatis-Plus+Netty+Websocket+Redis+Swagger后端组合，让我们的整个开发流程十分顺利，后端没有遇到太大的开发问题，效率，稳定性都相对较高。这也让我们意识到，<strong>好的技术框架选型</strong>能节省很多不必要的时间，能让我们把精力放在核心业务逻辑上，而不用处理太多和环境，部署，工具相关的问题上。同时，实际开发让我知道<strong>Warm Up的重要性</strong>，后端开发虽然不存在太强的接口之间的依赖关系，但是一开始的接口往往是比较困难的，因为没有太多参考。而这就需要在开发之初，先进行初期的一些简单接口编写，让后端先运行起来，之后不断发现问题，从而让后端的其他接口能渐渐顺利开发。</p><p>具体代码设计上，我们没有<strong>遵循某种特定的代码规范</strong>，这也带来一些显而易见的问题，比如前后端接口对接上出现一些争议，后端的部分类设计的不统一。虽然对于本次项目没有产生太大的影响，但是后续如果要迭代开发，需要解决相关的问题。</p><p><strong>和前端的沟通</strong>对接是后端开发的一个必然工作，我们采用的做法是，先由前端同学大致提出接口需求和数据需求，如果已经足够清晰，那么直接由后端同学实现，如果不够清晰，由双方进行直接的电话或者面对面交流，对需求进行完善的描述，对接口进行清晰的定义，再由后端同学根据接口定义进行相应数据库设计，接口实现。很多时候，打字半天不如直接电话交流。前后端人员其实是统一的，只有两部分人员对于同一个接口，同一个功能逻辑都有一致的认知，才能把功能实现的比较好。</p><p>前端的聊天功能开发。由于我个人对unity的兴趣，以及后期unity开发难度的提升，我在Beta阶段在前端也担任了聊天功能设计。由于我之前没有完整学习实践过unity项目开发，因此我在资源商店找到了聊天的UI界面，并直接在此基础上，融合网络层设计，对消息收发进行了补充，再经过我自己和其他同学的页面修改，最后得到了现在的聊天室。整个过程，可以概括为，demo开发，集成开发，预制体封装，测试完善，每个过程都看着聊天室一步步更加完整。通过这个实践也让我感觉到在客户端开发中，可以<strong>先建立demo，再进行不断完善，之后再集成</strong>的思路。</p><h4 id="结对项目">结对项目<a class="anchor" href="#结对项目">·</a></h4><p>结对过程中，我最大的体会是，两个人共行确实可以大幅提升效率。而且结对编程不仅仅是两人合作，而更像是两人合作达到1+1&gt;2的目的开发。遇到困难问题，一起讨论，集两人之所长解决，很少出现反工现象。简单问题，各自开发，互不干扰。这样的合作方式也适用于很多其他的项目。</p><h3 id="作为Project-Manager">作为Project Manager<a class="anchor" href="#作为Project-Manager">·</a></h3><p>PM的工作，可以概括为，<strong>前期规划磨合，中期日常管理，后期维护运营</strong>。</p><h4 id="前期">前期<a class="anchor" href="#前期">·</a></h4><p>在我们的开发实践中，采用了2位PM，1名测试人员，2名后端开发，4名前端开发的组织结构。我们充分考虑了每个同学的兴趣，技能点，通过两次会议明确了每个同学的职责。</p><p>我作为主要负责测试和后端的PM，主要带领tsq和xwq进行后端开发，软件测试的工作。在前期主要精力放在了服务器的数据库搭建，后端持续集成部署，对象存储选用上，同时和xwq进行后端开发的磨合，和tsq商议好后端测试，前端测试的基本方式。</p><p>同时，我还负责协作平台的维护与外部对接。平台方面，根据之前经验，我初期就认为可以选用coding，并在上面进行了较多尝试，帮助同学们快速上手，提升开发效率。外部对接上，开始的时候和中传的同学确立好了每周一发布的计划，制定了每周一次的全员会议，及时发现需求和实现的问题。和用户，客户，市场营销同学的深度合作和不断联系，是我们本次软工项目的亮点。</p><h4 id="中期">中期<a class="anchor" href="#中期">·</a></h4><p>日常管理中，我在第一次博客的时候编写了<strong>会议记录生成和数据分析脚本</strong>，帮助我们高效的完成会议记录以及实现对大家完成事项的追踪。</p><p>平时的会议中，我和yrb交替主持会议和会议记录。基本的流程是每个人轮流描述自己的工作和之后两天计划，并提出自己的疑问，直接找相关人员交流，提升效率。个人认为每个人的进度及时让他人知道对于敏捷开发是必须的，对于项目进度和自己的开发质量都有很大促进作用。</p><p>任务分配上，我们在Alpha和Beta阶段试验了两种方式。</p><p><strong>Alpha阶段</strong>，由会议主持者在会后进行任务分配，这样的问题是PM有时候不知道具体要做哪些任务，分配的粒度不好把控。同时，我们没有使用缺陷和用户故事这两个coding的功能。</p><p><strong>Beta阶段</strong>，我们采用了<strong>开发需求-任务-测试需求-缺陷-任务完成-开发需求完成</strong>的工作流程，并让每个同学绑定coding公众号，及时接收雄安锡推送。让整体效率有了一定提升，但是实际上仍然有些不足。我们主要由PM划分开发需求，之后由成员自己给自己分配任务，完成后再给测试人员提出测试需求，这样就出现了有些成员不会及时查看和更新自己任务的情况，也会懒得去发测试需求。同时，缺陷无法和需求绑定，整体流程稍显奇怪。</p><p>现在回想，可能更好的方式是，将所有的需要测试的功能需求全部用用户故事提出，由每个同学自行划分子工作项。这样缺陷提出时也可以和需求绑定。测试人员也可以直接查看需求就可以知道哪些任务需要测试。而类似文档，服务器维护，项目部署之类的工作，调研这一类的工作，可以安排在任务中，和功能需求的实现隔离开。也就是<strong>任务主要是和具体的需求无关的杂活</strong>，而用户故事主要是用来<strong>核心的开发，测试</strong>。</p><p><strong>完整的流程</strong>应当是，PM在例会之后<strong>分配开发需求</strong>，每个成员<strong>对开发需求进行具体</strong>化，并<strong>给自己划分子任务项</strong>。之后每个子任务完成后，给测试人员发布一个<strong>测试任务</strong>，对整个需求进行测试，有问题提出缺陷，<strong>缺陷和具体的开发需求相关联</strong>。而和用户使用没有具体关系的调研，文档，部署等各种任务需要使用任务进行提出。保证用户故事是和用户直接打交道。同时，整个过程的开发需求，任务，缺陷的提出都需要遵循特定的规范。</p><p>而整个流程也是没有最优解，需要不断尝试和思考，才能得到更优的解决方案。再次证明了，软工没有银弹！</p><p>而资源平衡，团队日常协调等，就需要在每天的开发中，根据实际情况，灵活调整，之前听过一个大佬讲过，只有深度参与开发，才能成为真正的leader，而不是口头上的巨人，行动上的矮子。只要有能力，每个人都应当勤恳的参与到各个方面的工作中。</p><h4 id="后期">后期<a class="anchor" href="#后期">·</a></h4><p>虽然这里使用了后期的表述，但是实际上一些工作也贯穿整个生命周期。</p><p>后期的一个工作就是<strong>发布和维护</strong>。发布过程中，需要在初期根据用户建议，迅速修改重大缺陷，发布新版本。稳定之后，要及时统计日活，做好宣传，吸引更多用户的使用，并产生相应的价值，而不能出现做完即扔的工作态度。同时，也要不断使用自己的产品，提出新的需求和缺陷。此外，也需要给出具体方便的产品获取方式，官方联系方式。包括不限于官网，邮箱，用户群等。</p><p>后期的另一个工作就是<strong>运营</strong>。对于本科生软工团队来说，很容易遇到的就是<strong>没法坚持</strong>。项目结束了，没有参与比赛，没有资源支持，大多数人都不会有动力继续坚持。因此我们在本学期的实践中，积极的参与各种比赛，和中传同学合作交流，参加大创计划，参加创业比赛，申请软著，诚然，一味追求这些是功利的，但是一味的埋头苦干，也是百害而无一利的。我们的目的是让大家在软工这样一个团队工程，社会工程中，得到个人软件开发能力，团队协作能力，资源人脉等多个方面的综合提升，而不仅仅只是，我写了一堆没人用的代码。同时，最关键的是，收获快乐，当我们自己在利用我们的app团建时，当我们在看到有不少用户给出了好评时，我们内心的快乐，是软工课程的最大收获！</p><p>后期的最后一项工作就是总结提升，我们在Alpha和Beta的会议上都畅所欲言，对项目的未来进行了深入讨论。值得一提的是，一定要有组内互评的环节。我们在Beta阶段的总结会议上，每个同学都对其他的6位同学做出了批评和表扬，让彼此深刻理解了自己的优点和缺点，同时也让大家敞开了心扉，增进了感情。</p><h4 id="经验教训-2">经验教训<a class="anchor" href="#经验教训-2">·</a></h4><p>对于我个人来说，最大的问题就是有时候比较急躁，尤其面临产品发布等一些重大时间点时，会偶尔无能狂怒，不够冷静，对一些同学造成了伤害，在之后的软件开发中，我还是要不断保持平和的心态，在任何时候，都采用最和谐，最适当的方式进行解决。</p><p>同时，这次合作中，我也暴露出有时候会稍显独断的弱点，对于一些事项，我无法把握公平与效率，过程正义与结果正义的权衡，导致了很多问题。之后的项目我都要以此为戒，找到最舒服的平衡点，真正尊重每个同学，让大家都能做项目的主人，而不是时不时的独断专权。</p><p>软件工程，说到底是一个关于人的工程，我们平时每一次的交流，每一次的表决，每一次的开发，都需要和人合作，最终的产品，一定是每个人智慧和勤劳的结晶，只有充分尊重每个人的劳动成果，及时和每个人沟通，我们才能真正的做好软工。</p><h2 id="Part5-最后，也是开始">Part5 最后，也是开始<a class="anchor" href="#Part5-最后，也是开始">·</a></h2><p>回顾这一学期，我不仅对于软件工程的整个流程有了深入认识和实践，更重要的是认识了一群有着同样抱负、同样爱好的极客朋友们，从他们身上，我知道了如何与人更好地交流沟通，学到了更多的知识技能，收获了鼓励和关心，这些都是宝贵的财富。也许课程已经结束了，但是我们的软件开发道路才刚刚开始，我们的友谊，也正扬帆起航，飘向远方！希望未来，能够和志同道合的小伙伴们互相鼓励，共同进步，实现各自的理想！</p><p>以灵境产品展示视频作为结束吧！！</p><center><iframe src="//player.bilibili.com/player.html?aid=897568627&bvid=BV1jA4y1d7gq&cid=750449374&page=1" scrolling="no" border="0" height="600" width="60%" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></center>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>信号处理与信息推断</title>
      <link href="2022/06/04/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8E%A8%E6%96%AD/"/>
      <url>2022/06/04/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8E%A8%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="信号处理与信息推断">信号处理与信息推断<a class="anchor" href="#信号处理与信息推断">·</a></h1><p>期末70% 平时不会连续三节课点名</p><h2 id="课程大纲">课程大纲<a class="anchor" href="#课程大纲">·</a></h2><img src="/2022/06/04/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8E%A8%E6%96%AD/6.jpg" style="zoom:50%;"><h1 id="一、背景知识">一、背景知识<a class="anchor" href="#一、背景知识">·</a></h1><h2 id="1-1-信息推断">1.1 信息推断<a class="anchor" href="#1-1-信息推断">·</a></h2><p>定义：从观察到的现象，推测出现象<strong>背后隐藏</strong>的信息</p><h3 id="信息推断是⼀个逆过程">信息推断是⼀个逆过程<a class="anchor" href="#信息推断是⼀个逆过程">·</a></h3><img src="/2022/06/04/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8E%A8%E6%96%AD/1.png" style="zoom:50%;"><h3 id="黑白推断和概率思维">黑白推断和概率思维<a class="anchor" href="#黑白推断和概率思维">·</a></h3><p><strong>⿊⽩思维</strong>：⼀件事情背后的<strong>可能原因只有⼀个</strong>，并且就是我说的那⼀个</p><img src="/2022/06/04/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8E%A8%E6%96%AD/3.png" style="zoom:50%;"><p><strong>问题</strong>：一元论，证据无用（一开始的结论就是最后的结论），⽆法接收新信息</p><p><strong>概率思维</strong>：</p><ul><li>看到了⼀个现象;</li><li>尽可能找到这件事情背后<strong>所有可能的原因</strong>;</li><li>尽可能<strong>收集所有的相关证据</strong>;</li><li>根据证据，给每⼀个可能的原因<strong>⼀个概率</strong>。那个<strong>概率最⼤</strong>的，作为最终的原因。</li></ul><img src="/2022/06/04/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8E%A8%E6%96%AD/4.png" style="zoom:50%;"><p><strong>好处</strong>：认知随着事实的改变⽽改变，信息量更大，不会遗漏可能的原因</p><h3 id="概率思维的一种方式：最大似然估计">概率思维的一种方式：最大似然估计<a class="anchor" href="#概率思维的一种方式：最大似然估计">·</a></h3><p>观察到现象推测背后的原因：</p><ul><li>列举所有可能的原因;</li><li>找出每⼀个原因产⽣该现象的概率;</li><li>选择那个概率最⼤的（也就是最有可能产⽣该现象的原因）做为最终的结论。</li></ul><p>按照似然概率进行排序选择概率最大的 即 $P(观测的现象|原因i)$</p><h3 id="例子-2">例子<a class="anchor" href="#例子-2">·</a></h3><h4 id="挑选西瓜">挑选西瓜<a class="anchor" href="#挑选西瓜">·</a></h4><p>观测的<strong>现象</strong>：听见了“嘭嘭嘭”的声音</p><p>可能的<strong>原因</strong>：(1) 西瓜没熟，(2) 西瓜刚好熟，(3) 西瓜熟过了</p><p>其中当西瓜刚好的时候出现这个声音的概率最大，因此选择（2）作为估计的原因</p><h4 id="飞机颠簸">飞机颠簸<a class="anchor" href="#飞机颠簸">·</a></h4><p><strong>现象</strong>：飞机剧烈颠簸</p><p><strong>原因</strong>：（1）飞机出事了;（2）飞机很安全，只是遇见气流而已。</p><p>飞机出事时一定会有颠簸，但遇见七六不一定会剧烈颠簸，因此选择（1），即飞机出事了！</p><h4 id="血液病检查结果为阳性">血液病检查结果为阳性<a class="anchor" href="#血液病检查结果为阳性">·</a></h4><p><strong>现象</strong>：检查结果为阳性</p><p><strong>原因</strong>：（1）得病了;（2）没得病，仪器误报</p><p>假设仪器精度很高（100 %检出率，1%误报率）</p><p>那么认为得病了</p><h4 id="学计算机的比学经济的有更大概率不修边幅？？">学计算机的比学经济的有更大概率不修边幅？？<a class="anchor" href="#学计算机的比学经济的有更大概率不修边幅？？">·</a></h4><h4 id="她该拒绝找好的工作吗-习题">她该拒绝找好的工作吗 习题<a class="anchor" href="#她该拒绝找好的工作吗-习题">·</a></h4><ul><li>一个大城市的电影学院毕业的学生，参加海选试镜。</li><li>在等结果时，她面试了一家很好的公司并且幸运通过了。</li><li>她收到了电影公司的邮件通知。上面写着:“恭喜你，你通过 了!”</li><li>电影公司的第二封邮件:“非常抱歉，我们已经将结果通知了所有参加试镜的人员，但是有 1% 的通知书是错误的”。</li><li>她应该推掉这份工作吗?</li></ul><h4 id="解答">解答<a class="anchor" href="#解答">·</a></h4><ul><li><strong>现象</strong>：“收到了试镜通过”</li><li><strong>背后的原因</strong>: (1) 通过了试镜，(2) 未通过试镜，公司发错 了。</li><li>在原因1前提下，有 99% 的可能性拿到该通知书。原因2的前提下， 1% 拿到了通知书。</li><li>也就是说，第一个原因导致“拿到试镜合格通知书”这个事实的概率，要远远 大于第二个原因。</li><li>她拒绝了公司的工作。</li></ul><h1 id="二、贝叶斯的定义和理解">二、贝叶斯的定义和理解<a class="anchor" href="#二、贝叶斯的定义和理解">·</a></h1><p>最大似然估计<strong>忽略</strong>了⼀个因素：<strong>不同的原因</strong>本身<strong>发⽣的概率是不同</strong>的。</p><p>引申出<strong>图解法</strong></p><img src="/2022/06/04/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8E%A8%E6%96%AD/1.jpg" style="zoom:33%;"><img src="/2022/06/04/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8E%A8%E6%96%AD/2.jpg" alt="2" style="zoom:33%;"><img src="/2022/06/04/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8E%A8%E6%96%AD/3.jpg" alt="3" style="zoom:33%;"><img src="/2022/06/04/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8E%A8%E6%96%AD/4.jpg" style="zoom: 33%;"><h2 id="基本公式">基本公式<a class="anchor" href="#基本公式">·</a></h2><p>$P(A|B)=\frac {P(B|A)P(A)} {P(B)}$</p><p>$P(原因i|观测的现象)=\frac {P(观测的现象|原因i)P(原因i)} {P(观测的现象)}$</p><h2 id="解释-8">解释<a class="anchor" href="#解释-8">·</a></h2><p>$P(观测的现象|原因i)$ ：似然概率 解释力度</p><p>$P(观测的现象)$：该观测现象总体发生的概率</p><p>$P(原因i)$：先验概率，观测现象之前，对于原因i本身成立的概率的估计</p><p>后验概率 = 先验概率 · 标准化后的似然概率</p><h2 id="例子-3">例子<a class="anchor" href="#例子-3">·</a></h2><h3 id="飞机颠簸-2">飞机颠簸<a class="anchor" href="#飞机颠簸-2">·</a></h3><p>原因1：飞机出事</p><p>先验概率：$2.23\times 10^{-7}$</p><p>似然概率：1</p><p>原因2：遇见气流</p><p>先验概率：P（遇见气流）=0.9</p><p>似然概率：P（剧烈颠簸|遇见气流）=0.1</p><p>前者的后验概率显然小于后者</p><h3 id="药检阳性">药检阳性<a class="anchor" href="#药检阳性">·</a></h3><p>原因1：真的患病了</p><p>先验概率：0.0001</p><p>似然概率：1</p><p>原因2：没患病但误检了</p><p>先验概率：0.9999</p><p>似然概率：0.001</p><p>后验概率0.0001&lt;0.001</p><h2 id="贝叶斯定理与奥卡姆剃刀">贝叶斯定理与奥卡姆剃刀<a class="anchor" href="#贝叶斯定理与奥卡姆剃刀">·</a></h2><p>如非必需，勿增实体（More things should not be used than are necessary)</p><h3 id="类似思想">类似思想<a class="anchor" href="#类似思想">·</a></h3><img src="/2022/06/04/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8E%A8%E6%96%AD/5.jpg" style="zoom:50%;"><p>关于一个现象，有许多理论都可以做出<strong>同样准确的解释</strong>，则应该挑选其中使用<strong>假定最少</strong>的</p><p>最简单的原因：其实也是先验概率最大的原因</p><h3 id="例子-4">例子<a class="anchor" href="#例子-4">·</a></h3><p>树倒了：容易推测是风吹倒了而不是陨石坠落</p><p>医生诊断：流鼻涕最可能推断成普遍疾病比如感冒而不是罕见病</p><p>医学院学生被告诫：当你听到马蹄声的时候，要想到马，而不是斑马</p><p>关于金属燃烧质量增加：燃素说（神秘的负能量）和氧化说</p><p>地心说和日心说：前者需要画40-60个小圆套大圆，后者只需要8-10个圆</p><h1 id="三、贝叶斯的两个要素">三、贝叶斯的两个要素<a class="anchor" href="#三、贝叶斯的两个要素">·</a></h1><h2 id="3-1-先验概率">3.1 先验概率<a class="anchor" href="#3-1-先验概率">·</a></h2><p>先验概率是拿到证据前对该原因发生概率的判断，很多场合重要性超过似然概率</p><p>例子：扑点球 现场假动作太多，且速度太快来不及推测射门方向，还不如根据射门的球员的历史特点进行先验概率预测</p><h3 id="贝叶斯与外部视角">贝叶斯与外部视角<a class="anchor" href="#贝叶斯与外部视角">·</a></h3><p><strong>外部视角</strong>得到<strong>先验概率</strong>，<strong>内部视角</strong>得到<strong>似然概率</strong></p><p>有时候外部视角得到信息，就比较接近真实的后验概率</p><h4 id="内部视角例子">内部视角例子<a class="anchor" href="#内部视角例子">·</a></h4><p>董明珠做格力手机，认为内部条件满足，但没考虑倒市场竞争和其他巨头</p><p>规划谬误：一个完全不切实际的计划</p><p>哈佛教授/美国前财政部长<strong>萨摩斯</strong>对雇员给出的<strong>某个任务完成的时间的估计进行调整</strong>：</p><p>雇员的估计时间乘以2，再用更高一级的时间单位表示，预估1小时，调整为2天，预估1天，调整为2周</p><h3 id="用外部视角看问题">用外部视角看问题<a class="anchor" href="#用外部视角看问题">·</a></h3><p><strong>Bent Flyvbjerg</strong>提出的外部视角解决问题方法：</p><ul><li>识别对应参考类别</li><li>获取参考类别统计数据，做出基准预测</li><li>如果有特别原因说明这个项目比同类项目乐观偏差更为明显，可使用此例的具体信息对基准预测进行调整</li></ul><p>需要克服<strong>思维陷阱</strong>：绝大多数下标准化的似然概率=1，即和大部分人并没有什么不同</p><h3 id="锚定效应">锚定效应<a class="anchor" href="#锚定效应">·</a></h3><p>人们对某个事件做定量估测时，会将某些特定数值作为起始值，这个值<strong>像锚一样制约着最后的估测值</strong>，从而导致做决策时会<strong>不自觉给予</strong>最初获得的信息<strong>过多的重视</strong>。</p><h4 id="例子-5">例子<a class="anchor" href="#例子-5">·</a></h4><p>电商平台的划掉的价格虚高</p><p>房地产销售先带客户看贵的房子，再看便宜的</p><p>黑珍珠为啥值钱？最开始卖不掉，之后放在珠宝店橱窗展示，最终价格媲美钻石</p><p>锚定效应其实对应于<strong>贝叶斯</strong>的<strong>先验概率</strong>，商家通过一些小技巧改变先验概率，从而对物品价格产生偏差</p><h3 id="贝叶斯与汉隆剃刀">贝叶斯与汉隆剃刀<a class="anchor" href="#贝叶斯与汉隆剃刀">·</a></h3><p>汉隆剃刀：能用<strong>愚蠢解释</strong>的，不要解释为<strong>恶意</strong></p><p>愚蠢：无知的，偶然的，非故意的原因。忘了，错了，误会了，累了</p><p>恶意：有针对性地，刻意针对自己的谋划</p><h4 id="贝叶斯解释">贝叶斯解释<a class="anchor" href="#贝叶斯解释">·</a></h4><p>愚蠢和恶意的解释力度都很强，似然概率相当，因此主要看<strong>先验概率</strong></p><p>而愚蠢是大概率事件，恶意是小概率事件，因此尽量用愚蠢解释</p><h4 id="汉隆剃刀的推广">汉隆剃刀的推广<a class="anchor" href="#汉隆剃刀的推广">·</a></h4><p>能解释为愚蠢的，不要解释为恶意——原定理</p><p>能解释为无知的，不要解释为愚蠢——不知道某个定理可能只是没学过，和智商不一定有关系</p><p>能解释为可原谅的错误的，不要解释为无知——手艺活做错了一点</p><p>能用未知的其他原因解释的，不要解释为错误</p><p>能用一群人在复杂系统中的互动解释的，不要解释为恶意或愚蠢</p><p>能解释为情绪的，不要解释为策略</p><h2 id="3-2-观测">3.2 观测<a class="anchor" href="#3-2-观测">·</a></h2><p>如何求先验概率？</p><h3 id="方法1：根据当前对象的历史记录得到先验概率">方法1：根据当前对象的历史记录得到先验概率<a class="anchor" href="#方法1：根据当前对象的历史记录得到先验概率">·</a></h3><p>例子：莱曼扑点球</p><p>很多时候没办法拿到一个对象的历史统计</p><h3 id="方法2：将当前特定的对象扩展到同类对象，根据同类对象历史统计数据找到先验概率">方法2：将当前特定的对象扩展到同类对象，根据同类对象历史统计数据找到先验概率<a class="anchor" href="#方法2：将当前特定的对象扩展到同类对象，根据同类对象历史统计数据找到先验概率">·</a></h3><p>火柴：只需要测试火柴盒里的几根火柴能否用就可以大概判断这个盒子里的火柴能不能用</p><h3 id="观测的信息量">观测的信息量<a class="anchor" href="#观测的信息量">·</a></h3><p>信息量=出乎意料的程度</p><p>改变认知越大，越出乎意料，信息量就越大</p><p>$P(H_i|A)=P(H_i)\times\frac {P(A|H_i)} {P(A)}$</p><p><strong>先验概率</strong>是<strong>拿到观测 $A$ 之前</strong>对原因 $H_i$ 的认知，<strong>后验概率</strong>是<strong>拿到该观测后</strong>对原因 $H_i$ 的认知</p><p>后验概率在先验概率基础上，<strong>用当前观测</strong>做出了<strong>调整</strong></p><p>如果先验概率调整幅度很大，则<strong>先验概率和后验概率差距大</strong>，则<strong>观测的信息量大</strong>，因为改变了对 $H_i$ 的认知</p><p><strong>信息量大小</strong>体现在<strong>似然概率</strong>中</p><h4 id="信息量大小的具体情况">信息量大小的具体情况<a class="anchor" href="#信息量大小的具体情况">·</a></h4><p>情况1：$H_i$ 完全不能解释 $A$，即$P(A|H_i)\approx0$</p><p>情况2：除了 $H_i$ 之外其他原因都不能解释 $A$ 即 $P(A|H_j)\approx0(j\neq i)$</p><p>情况2也是<strong>排他性证据</strong>，即信息量大，即实锤</p><p>当所有的原因解释力度差不多时，$P(A|H_1)\approx P(A|H_2)\approx…\approx P(A|H_n)\approx \alpha$</p><p>此时$P(H_i|A)=P(H_i)\frac {P(A|H_i)}{P(A)}=\frac {P(H_i)}{P(H_1)+…+P(H_n)}=P(H_i)$</p><h4 id="成功学底层逻辑">成功学底层逻辑<a class="anchor" href="#成功学底层逻辑">·</a></h4><p>成功学人士共有特点当作观测A。成功当做原因H，所以$P(A|H)$很高</p><p>虚伪论断：$P(A|H)$很高则$P(H|A)$很高</p><p>没有考虑失败者的特点</p><p>$P(H|A)=\frac {P(H)P(A|H)}{P(A|H)P(H)+P(A| \overline H)P(\overline H)}$</p><p>必须要$P(A|\overline H)$也很小才行</p><p>真正的成功学应该是挖掘成功者具备但失败者不具备的特点</p><p>信息量大的观测具有<strong>排他性</strong></p><h3 id="解释之易和排他性之难">解释之易和排他性之难<a class="anchor" href="#解释之易和排他性之难">·</a></h3><p>能<strong>被一个观点解释</strong>的证据<strong>非常容易</strong>，但是<strong>价值不大</strong></p><p>只能用一观点来解释的排他性证据<strong>价值极大</strong>，但<strong>很难</strong>找到</p><p>人们往往<strong>高估</strong>了<strong>解释的难度</strong>，<strong>低估</strong>了<strong>找到排他性证据</strong>的难度</p><h4 id="改变观念为什么这么难？">改变观念为什么这么难？<a class="anchor" href="#改变观念为什么这么难？">·</a></h4><p>如果对某个对象已经有了比较笃定的认识，要扭转观念很难</p><ul><li>人会主动收集加强其观念的证据，并裁剪</li><li>因为之前认知过于笃定，这些新证据很难改变认知</li></ul><p>改变幅度 $\frac {P(A|H)} {P(A)} = \frac 1 {1-(1-P(H))(1-R)}$</p><p>$R=\frac {P(A|\overline H)} {P(A|H)}$ 观测A在 $\overline H$ 和 $H$ 下的似然比</p><p>$R&lt;1$ 时，$H$更能解释观测A（后验概率大于先验概率）</p><p>$R\approx 1$ 时，$\overline H$ 和 $H$ 观测力度相当（后验概率不变）</p><p>$R&gt;1$ 时，$\overline H$ 更能解释观测A（后验概率小于先验概率）</p><p>$1-P(H)$ 是调节器，如果开始很小，那么A所起的提升作用大大削弱</p><h4 id="启发1">启发1<a class="anchor" href="#启发1">·</a></h4><p>不要完全笃定之前的认知，至少给认知相反的其他认知一些可能性</p><h4 id="启发2">启发2<a class="anchor" href="#启发2">·</a></h4><p>接受不支持认知的证据，并让他们来改变原有的认知，让你的认知观点随着新的证据发生改变</p><p><strong>成长型思维</strong></p><h3 id="巴纳姆效应">巴纳姆效应<a class="anchor" href="#巴纳姆效应">·</a></h3><p>每个人都会很容易相信一个笼统的，一般性的人格描述特别适合自己，即使这个描述很空洞。仍然认为反映了自己的人格面貌，哪怕自己根本不是这种人</p><p><strong>星座学，算命先生</strong></p><p>这些性格描述排他性很小，适合很多人</p><h1 id="四、多个观测下的贝叶斯">四、多个观测下的贝叶斯<a class="anchor" href="#四、多个观测下的贝叶斯">·</a></h1><h2 id="4-1-基础篇">4.1 基础篇<a class="anchor" href="#4-1-基础篇">·</a></h2><h3 id="条件独立">条件独立<a class="anchor" href="#条件独立">·</a></h3><p>事件A与事件B关于事件C独立，则$P(A,B|C)=P(A|C)*P(B|C)$</p><p>即，事件C成立的前提下，A和B<strong>同时出现的概率</strong>等于在C成立前提下A发生的概率<strong>乘以</strong>C成立前提下B发生的概率</p><p>也可以更好地理解为：$P(A|B,C)=P(A|C)$ $P(B|A,C)=P(B|C)$</p><p>一旦C发生了，A(B)是否发生这个信息对于判断B(A)是否发生没有作用</p><p>很多事件看似相关，实则条件独立</p><h3 id="ABC理论">ABC理论<a class="anchor" href="#ABC理论">·</a></h3><pre class="mermaid">graph LRA-->BB-->C</pre><p>情绪ABC理论由Albert Ellis提出的情绪调节法</p><ul><li>A代表激发时间</li><li>B代表信念</li><li>C代表结果</li></ul><p>事物对于我们而言所具有的意义，让我们感到幸福或者不幸，不是由它们本来的面貌决定，而是<strong>取决于我们如何看待它们</strong></p><p>比如：成绩 心态 反应</p><p>很多时候，两个事件从统计意义上相关，但它们都是关于背后的另一个事件条件独立</p><h3 id="多个观测下的贝叶斯定理">多个观测下的贝叶斯定理<a class="anchor" href="#多个观测下的贝叶斯定理">·</a></h3><p>现实中，人们往往会通过多个观测进行推断</p><p>$P(H_i|A_1,A_2,…,A_n)=P(H_i)*\frac {P(A_1,…,A_n|H_i)} {P(A_1,…,A_n)}=\frac {P(原因i)*P(观测1,观测2,…,观测N|原因i)} {P(观测1,…,观测N)}$</p><p>若两个观测在 $H_1,H_2,…,H_n$ 下都条件独立，则$P(A_1,A_2)=\sum_{k=1}^nP(A_1|H_k)P(A_2|H_k)P(H_k)$</p><p>$P(H_i|A_1,A_2)=P(H_i)*\frac {P(A_1|H_i)*P(A_2|H_i)} {\sum_{k=1}^nP(A_1|H_k)P(A_2|H_k)P(H_k)}$</p><p>大部分都只能假设是<strong>条件独立</strong></p><p>一般不存在<strong>独立</strong></p><h2 id="4-2-进阶篇">4.2 进阶篇<a class="anchor" href="#4-2-进阶篇">·</a></h2><p>多个观测按照时间顺序先后到来，希望来一个预测就根据迄今为止的所有观测得到一个估计</p><p>每次都计算现有的所有观测开销较大，更合适的是每次在之前的后验概率基础上，用最新的观测进行更新，即<strong>在线贝叶斯</strong></p><p>用新的观测来更新旧的后验概率=用所有的观测重新计算后验概率</p><h3 id="三个观测的迭代形式">三个观测的迭代形式<a class="anchor" href="#三个观测的迭代形式">·</a></h3><img src="/2022/06/04/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8E%A8%E6%96%AD/7.jpg" style="zoom:50%;"><h3 id="一般情况下的迭代形式">一般情况下的迭代形式<a class="anchor" href="#一般情况下的迭代形式">·</a></h3><img src="/2022/06/04/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8E%A8%E6%96%AD/8.jpg" style="zoom:50%;"><p>在某⼀个时刻基于<strong>包括当前以及所有的历史信息</strong>得到的<strong>后验概率</strong>，都是<strong>下⼀个时刻的先验概率</strong>。</p><p><strong>先验概率</strong>，是对<strong>所有历史积累信息</strong>的<strong>沉淀</strong>和<strong>总结</strong>。</p><h3 id="在线贝叶斯的启发1-在线算法vs离线算法">在线贝叶斯的启发1 在线算法vs离线算法<a class="anchor" href="#在线贝叶斯的启发1-在线算法vs离线算法">·</a></h3><h4 id="在线算法-ONLINE-ALGORITHMS-—流式算法-stream-algorithms">在线算法(ONLINE ALGORITHMS)—流式算法 (stream algorithms)<a class="anchor" href="#在线算法-ONLINE-ALGORITHMS-—流式算法-stream-algorithms">·</a></h4><p>最初时刻，根据最初的一个或几个数据得到一个初步结果</p><p>每次来一个数据，用这个新的数据更新上一次的结果</p><p>这个更新的结果和用此前的所有数据得到的结果一致</p><h4 id="离线算法-OFF-LINE-ALGORITHMS-—batch-algorithm">离线算法(OFF-LINE ALGORITHMS)—batch algorithm<a class="anchor" href="#离线算法-OFF-LINE-ALGORITHMS-—batch-algorithm">·</a></h4><p>对于新来的数据，总是把他加到前面的数据重新计算得到结果</p><p><strong>最大区别</strong>在于<strong>是否要重新全部计算，还是只需要在原有基础上更新</strong></p><p>在线算法优势：即时反馈，计算量小，存储量小</p><h3 id="在线贝叶斯的启发2-精益求精-V-S-步步为营">在线贝叶斯的启发2 精益求精 V.S. 步步为营<a class="anchor" href="#在线贝叶斯的启发2-精益求精-V-S-步步为营">·</a></h3><p>精益求精：一开始不追求完美，先得到一个结果，之后不断接收新信息对原结果进行改进，达到最优的目标，和在线算法类似</p><p>步步为营：每一步都要得到一个正确结果，最后一步之前不知道正确答案</p><p>敏捷模型—精益求精，不断完善MVP</p><p>瀑布模型—步步为营</p><h3 id="在线贝叶斯的启发3-观点随着事实的改变而改变">在线贝叶斯的启发3 观点随着事实的改变而改变<a class="anchor" href="#在线贝叶斯的启发3-观点随着事实的改变而改变">·</a></h3><p>狼来了</p><h3 id="总结">总结<a class="anchor" href="#总结">·</a></h3><ul><li>在线贝叶斯所揭示出来的另外⼀个核⼼思想，就是观点要随着事实的改变⽽改变。</li><li>在很多情况下，初始的先验概率并不那么重要。只要我们能够不断的通过新的证据去调整自己的认知，最终也能够有正确的认识。</li><li>在证据比较少的时候要保持谨慎，切忌根据少量证据来盖棺定论。<strong>让子弹飞一会儿</strong></li></ul><h2 id="4-3-高级篇">4.3 高级篇<a class="anchor" href="#4-3-高级篇">·</a></h2><h3 id="实际中的问题">实际中的问题<a class="anchor" href="#实际中的问题">·</a></h3><h4 id="养狗的例子">养狗的例子<a class="anchor" href="#养狗的例子">·</a></h4><p>有⼀家⼈ 5 ⼝⼈，⽗亲 35 岁，⺟亲 30 岁，⼩孩⼦6 岁刚上⼩学，⼩孩的姥姥姥爷帮忙照顾⼩孩，他们住北京海淀区世纪城⼩区⾥。请问，这家养狗的概率是多少?</p><h4 id="梳理现象">梳理现象<a class="anchor" href="#梳理现象">·</a></h4><img src="/2022/06/04/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8E%A8%E6%96%AD/9.jpg" style="zoom: 67%;"><p><strong>贝叶斯计算所需概率不知道</strong></p><h3 id="解决问题思路">解决问题思路<a class="anchor" href="#解决问题思路">·</a></h3><p>所有观测分为两组，一组放在先验概率中，另外一组放在似然概率</p><p>统计数据找到先验概率，并忽略似然概率</p><img src="/2022/06/04/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8E%A8%E6%96%AD/10.jpg" style="zoom:50%;"><h4 id="关键词">关键词<a class="anchor" href="#关键词">·</a></h4><img src="/2022/06/04/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8E%A8%E6%96%AD/11.jpg" style="zoom:50%;"><h4 id="分组核心原则">分组核心原则<a class="anchor" href="#分组核心原则">·</a></h4><p>先验好估计：$P(Hi|A)$ 的统计数据很容易拿到</p><p>尽可能将信息量大的观测放在集合A中</p><p>在能找到统计数据的前提下，尽量把信息量⼤的观测放⼊先验概率中</p><h3 id="两个观测的贝叶斯定理解决问题">两个观测的贝叶斯定理解决问题<a class="anchor" href="#两个观测的贝叶斯定理解决问题">·</a></h3><img src="/2022/06/04/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8E%A8%E6%96%AD/12.jpg" style="zoom: 80%;"><h4 id="数学推导">数学推导<a class="anchor" href="#数学推导">·</a></h4><img src="/2022/06/04/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8E%A8%E6%96%AD/13.jpg" style="zoom:67%;"><h4 id="目标">目标<a class="anchor" href="#目标">·</a></h4><img src="/2022/06/04/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8E%A8%E6%96%AD/14.jpg" style="zoom:80%;"><h4 id="情况1">情况1<a class="anchor" href="#情况1">·</a></h4><img src="/2022/06/04/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8E%A8%E6%96%AD/15.jpg" style="zoom:80%;"><p>当$A_1$强烈支持某个假设，但$A_2$并不排斥这个假设时，应该把$A_1$放入先验概率，把$A_2$放入似然概率</p><h4 id="情况2">情况2<a class="anchor" href="#情况2">·</a></h4><img src="/2022/06/04/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8E%A8%E6%96%AD/16.jpg" style="zoom:80%;"><p>当$A_1$强烈反对某个假设，但$A_2$并不排斥这个假设时，应该把$A_1$放入先验概率，把$A_2$放入似然概率</p><p>情况1和2都说明如果某个观测有旗帜鲜明的立场（强烈支持或反对某个假设），而另一个观测则处于和稀泥的状态，则应该坚决的将前一个观测放入先验中</p><h4 id="情况3">情况3<a class="anchor" href="#情况3">·</a></h4><img src="/2022/06/04/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8E%A8%E6%96%AD/17.jpg" style="zoom:80%;"><p>非排他性证据，应该放入似然概率</p><h4 id="总结-2">总结<a class="anchor" href="#总结-2">·</a></h4><img src="/2022/06/04/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8E%A8%E6%96%AD/18.jpg" style="zoom:67%;"><p>信息量也就是排他性，信息量大的观测会强力的支持或反对某个原因，应该放入先验概率</p><p>信息量很小的观测，应该放入似然概率中忽略掉</p><h3 id="例子1-飞机颠簸">例子1-飞机颠簸<a class="anchor" href="#例子1-飞机颠簸">·</a></h3><img src="/2022/06/04/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8E%A8%E6%96%AD/19.jpg" style="zoom:80%;"><h4 id="两种划分方式">两种划分方式<a class="anchor" href="#两种划分方式">·</a></h4><img src="/2022/06/04/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8E%A8%E6%96%AD/20.jpg" style="zoom:80%;"><img src="/2022/06/04/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8E%A8%E6%96%AD/21.jpg" alt="21" style="zoom:80%;"><h3 id="分层描述法">分层描述法<a class="anchor" href="#分层描述法">·</a></h3><p>多个观测时（超过2个），常常出现找不到相关数据的情况，原因是符合观测集的样本数量太少。</p><p>两种方式扩大样本数量</p><ul><li>降低观测数量</li><li>增大颗粒度</li></ul><p>分层描述法：围绕被观测的对象，在不同的颗粒度上将该对象的所有信息展现出来</p><h4 id="具体步骤">具体步骤<a class="anchor" href="#具体步骤">·</a></h4><img src="/2022/06/04/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8E%A8%E6%96%AD/22.jpg" style="zoom:80%;"><h4 id="例子：找到好工作的概率">例子：找到好工作的概率<a class="anchor" href="#例子：找到好工作的概率">·</a></h4><img src="/2022/06/04/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8E%A8%E6%96%AD/23.jpg" style="zoom:80%;"><h4 id="总结-3">总结<a class="anchor" href="#总结-3">·</a></h4><img src="/2022/06/04/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8E%A8%E6%96%AD/24.jpg" style="zoom:80%;">]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动手学深度学习笔记-提升篇</title>
      <link href="2022/05/15/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%8F%90%E5%8D%87%E7%AF%87/"/>
      <url>2022/05/15/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%8F%90%E5%8D%87%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="8-循环神经网络（RNN）">8.循环神经网络（RNN）<a class="anchor" href="#8-循环神经网络（RNN）">·</a></h1><p>CNN：处理空间信息</p><p>RNN-recurrent neural network：处理序列信息</p><h2 id="序列模型">序列模型<a class="anchor" href="#序列模型">·</a></h2><h3 id="统计工具">统计工具<a class="anchor" href="#统计工具">·</a></h3><h4 id="自回归模型">自回归模型<a class="anchor" href="#自回归模型">·</a></h4><p>输入数据的数量 $x_{t-1},…,x_1$ 随着 $t$ 而异，而不是不变的</p><p>策略1：满足某个长度为 $\tau$ 的时间跨度，即使用观测序列 $x_{t-1},…,x_{t-\tau}$，参数数量不变，可以训练一个网络</p><p>策略2：$h_t=g(h_{t-1},x_{t-1})\rightarrow x_t=P(x_t|h_t),$ 更新模型，由于$h_t$没有被观测到，因此称为隐变量自回归模型（latent autoregressive models）</p><p>如何生成训练数据？一般是利用历史观测来预测下一个未来观测。常见的一个假设是虽然$x_t$可能会变，序列本身动力学不改变，不变的动力学称为静止的，即整个序列估计值用以下方式获得：$P(x_1,…,x_t)=\prod <em>{t=1}^T P(x_t|x</em>{t-1},…,x_1)$</p><h4 id="马尔可夫模型">马尔可夫模型<a class="anchor" href="#马尔可夫模型">·</a></h4><p>上文提到的 $x_{t-1},…,x_{t-\tau}$ 来估计 $x_t$ 时如果时近似精确的，则称满足马尔可夫条件，如果$\tau=1$，则可以得到一阶马尔可夫模型</p><p>$P(x_1,…,x_T)=\prod_{t=1}^T P(x_t|x_{t-1})$</p><p>此时可以得到$P(x_{t+1}|x_{t-1})=\frac {\sum_{x_t} P(x_{t+1},x_t,x_{t-1})} {P(x_{t-1})}=\frac {P(x_{t-1})\sum_{x_t} P(x_{t+1}|x_t)P(x_t|x_{t-1})} {P(x_{t-1})}=\sum_{x_t}P(x_{t+1}|x_t)P(x_t|x_{t-1})$</p><h4 id="因果关系">因果关系<a class="anchor" href="#因果关系">·</a></h4><p>基于马尔可夫模型我们还可以得到一个反向条件概率分布，不过一般这不好解释</p><h3 id="训练">训练<a class="anchor" href="#训练">·</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils <span class="keyword">import</span> data</span><br><span class="line">T=<span class="number">1000</span></span><br><span class="line">time = torch.arange(<span class="number">1</span>, T + <span class="number">1</span>, dtype=torch.float32)</span><br><span class="line">x = torch.sin(<span class="number">0.01</span> * time) + torch.normal(<span class="number">0</span>, <span class="number">0.2</span>, (T,))</span><br><span class="line">t=<span class="number">5</span></span><br><span class="line">train_data=torch.zeros(T-t,t)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(t):</span><br><span class="line">    train_data[:,i]=x[i:T-t+i]</span><br><span class="line">train_labels=x[t:].reshape(<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_weights</span><span class="params">(m)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> type(m) == nn.Linear:</span><br><span class="line">        nn.init.xavier_uniform_(m.weight)</span><br><span class="line">batch_size, n_train,epoch,lr = <span class="number">16</span>, <span class="number">600</span>,<span class="number">100</span>,<span class="number">0.1</span></span><br><span class="line"></span><br><span class="line">net=nn.Sequential(</span><br><span class="line">    nn.Linear(<span class="number">5</span>,<span class="number">10</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.Linear(<span class="number">10</span>,<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line">net.apply(init_weights)</span><br><span class="line">loss=nn.MSELoss(reduction=<span class="string">'none'</span>)</span><br><span class="line">optimizer=torch.optim.Adam(net.parameters(), lr)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_array</span><span class="params">(data_arrays, batch_size, is_train=True)</span>:</span> </span><br><span class="line">    <span class="string">"""构造一个PyTorch数据迭代器。"""</span></span><br><span class="line">    dataset = data.TensorDataset(*data_arrays)</span><br><span class="line">    <span class="keyword">return</span> data.DataLoader(dataset, batch_size, shuffle=is_train)</span><br><span class="line">train_iter=load_array((train_data[:n_train],train_labels[:n_train]),batch_size)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(epoch):</span><br><span class="line">    <span class="keyword">for</span> X,y <span class="keyword">in</span> train_iter:</span><br><span class="line">        l=loss(net(X),y)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        l.sum().backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">    cnt=<span class="number">0</span></span><br><span class="line">    loss_sum=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> X,y <span class="keyword">in</span> train_iter:</span><br><span class="line">        l=loss(net(X),y)</span><br><span class="line">        loss_sum+=l.sum()</span><br><span class="line">        cnt+=<span class="number">1</span></span><br><span class="line">    print(<span class="string">f'epoch<span class="subst">&#123;i+<span class="number">1</span>&#125;</span> loss: <span class="subst">&#123;float(loss_sum)/cnt&#125;</span>'</span>)</span><br></pre></td></tr></table></figure><p>进行下一个时间的预测到下$t$个时间的预测都相对较精准，但$t+1$及之后的时间的预测就不精准了，因为需要不断用预测的数据去预测更之后的数据，会造成误差积累。</p><h2 id="文本预处理">文本预处理<a class="anchor" href="#文本预处理">·</a></h2><p>最常见的序列数据就是文本，一篇文章可以看为是一串单词序列，甚至是一串字符序列。</p><p>常见预处理步骤：</p><ul><li>文本作为字符串加载到内存中</li><li>字符串拆分为词元（单词和字符）</li><li>建立一个词表，将拆分的词元映射到数字索引</li><li>将文本转换为数字索引序列，方便模型操作</li></ul><p>此部分在https://github.com/BUAADreamer/nnplayer/tree/master/nlputil处进行了一些实践</p><h2 id="语言模型和数据集">语言模型和数据集<a class="anchor" href="#语言模型和数据集">·</a></h2><p>语言模型的目标：估计序列的联合概率 $P(x_1,x_2,…,x_T)$</p><p>简单统计相对词频，执行某种形式的拉普拉斯平滑</p><h3 id="马尔可夫模型与n元语法">马尔可夫模型与<em>n</em>元语法<a class="anchor" href="#马尔可夫模型与n元语法">·</a></h3><p>涉及⼀个、两个和三个变量的概率公式分别被称为“⼀元语法”（unigram）、“⼆元语法”（bigram）和“三元语法”（trigram）模型</p><h3 id="自然语言统计">自然语言统计<a class="anchor" href="#自然语言统计">·</a></h3><p>词频最高的词都是类似 <code>the/i/and</code> 这样的词，被称为停用词，可以被过滤掉</p><p>词频衰减迅速，齐普夫定律：第 $i$ 个最常用的单词频率$n_i$为 $n_i\propto \frac 1 {i^\alpha}$</p><h2 id="循环神经网络">循环神经网络<a class="anchor" href="#循环神经网络">·</a></h2><h3 id="有隐状态的循环神经网络">有隐状态的循环神经网络<a class="anchor" href="#有隐状态的循环神经网络">·</a></h3><p>$H_t=\phi(X_tW_{xh}+H_{t-1}W_{hh}+b_h)$</p><h3 id="困惑度（Perplexity）">困惑度（<strong>Perplexity</strong>）<a class="anchor" href="#困惑度（Perplexity）">·</a></h3><p>$exp(-\frac 1 n \sum_{t=1}^n log P(x_t|x_{t-1},…,x_{1}))$</p><h3 id="梯度裁剪">梯度裁剪<a class="anchor" href="#梯度裁剪">·</a></h3><p>将梯度映射到$\theta$范围内，比如以下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grad_clipping</span><span class="params">(net, theta)</span>:</span> <span class="comment">#@save</span></span><br><span class="line">    <span class="string">"""裁剪梯度"""</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(net, nn.Module):</span><br><span class="line">    params = [p <span class="keyword">for</span> p <span class="keyword">in</span> net.parameters() <span class="keyword">if</span> p.requires_grad]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    params = net.params</span><br><span class="line">    norm = torch.sqrt(sum(torch.sum((p.grad ** <span class="number">2</span>)) <span class="keyword">for</span> p <span class="keyword">in</span> params)) <span class="comment">#梯度平方和开根号</span></span><br><span class="line">    <span class="keyword">if</span> norm &gt; theta:</span><br><span class="line">    <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">    param.grad[:] *= theta / norm <span class="comment">#映射到theta范围内</span></span><br></pre></td></tr></table></figure><h3 id="简洁实现">简洁实现<a class="anchor" href="#简洁实现">·</a></h3><p>参考实现的代码：https://github.com/BUAADreamer/nlpkiller/blob/master/main.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RNNModel</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="string">"""循环神经网络模型</span></span><br><span class="line"><span class="string">    Defined in :numref:`sec_rnn-concise`"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, rnn_layer, vocab_size, **kwargs)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.rnn = rnn_layer</span><br><span class="line">        self.vocab_size = vocab_size</span><br><span class="line">        self.num_hiddens = self.rnn.hidden_size</span><br><span class="line">        <span class="comment"># 如果RNN是双向的（之后将介绍），num_directions应该是2，否则应该是1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.rnn.bidirectional:</span><br><span class="line">            self.num_directions = <span class="number">1</span></span><br><span class="line">            self.linear = nn.Linear(self.num_hiddens, self.vocab_size)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.num_directions = <span class="number">2</span></span><br><span class="line">            self.linear = nn.Linear(self.num_hiddens * <span class="number">2</span>, self.vocab_size)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, inputs, state)</span>:</span></span><br><span class="line">        X = F.one_hot(inputs.T.long(), self.vocab_size)</span><br><span class="line">        X = X.to(torch.float32)</span><br><span class="line">        Y, state = self.rnn(X, state)</span><br><span class="line">        <span class="comment"># 全连接层首先将Y的形状改为(时间步数*批量大小,隐藏单元数)</span></span><br><span class="line">        <span class="comment"># 它的输出形状是(时间步数*批量大小,词表大小)。</span></span><br><span class="line">        output = self.linear(Y.reshape((<span class="number">-1</span>, Y.shape[<span class="number">-1</span>])))</span><br><span class="line">        <span class="keyword">return</span> output, state</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">begin_state</span><span class="params">(self, device, batch_size=<span class="number">1</span>)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(self.rnn, nn.LSTM):</span><br><span class="line">            <span class="comment"># nn.GRU以张量作为隐状态</span></span><br><span class="line">            <span class="keyword">return</span> torch.zeros((self.num_directions * self.rnn.num_layers,</span><br><span class="line">                                batch_size, self.num_hiddens),</span><br><span class="line">                               device=device)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># nn.LSTM以元组作为隐状态</span></span><br><span class="line">            <span class="keyword">return</span> (torch.zeros((</span><br><span class="line">                self.num_directions * self.rnn.num_layers,</span><br><span class="line">                batch_size, self.num_hiddens), device=device),</span><br><span class="line">                    torch.zeros((</span><br><span class="line">                        self.num_directions * self.rnn.num_layers,</span><br><span class="line">                        batch_size, self.num_hiddens), device=device))</span><br></pre></td></tr></table></figure><h3 id="通过时间反向传播">通过时间反向传播<a class="anchor" href="#通过时间反向传播">·</a></h3><h4 id="数学推导1">数学推导1<a class="anchor" href="#数学推导1">·</a></h4><p>链式求导法则应用于 $f(h(x),g(x))$</p><p>$\frac {d(f(h(x),g(x)))} {dx}=\frac {d(f(h(x),g(x)))} {d(h(x))}*h’(x)+\frac {d(f(h(x),g(x)))} {d(g(x))}*g’(x)$</p><h4 id="数学推导2">数学推导2<a class="anchor" href="#数学推导2">·</a></h4><p>$a_3=b_3+c_3a_2=b_3+c_3(b_2+c_2a_1)=b_3+c_3(b_2+c_2b_1)$</p><p>数学归纳法证明$a_t=b_t+\sum_{i=1}<sup>{t-1}(\prod_{j=i+1}</sup>tc_j)b_i $</p><p>随机截断，常规截断，完整计算（不可行）</p><h1 id="9-现代循环神经网络">9.现代循环神经网络<a class="anchor" href="#9-现代循环神经网络">·</a></h1><h2 id="门控循环单元（GRU）">门控循环单元（GRU）<a class="anchor" href="#门控循环单元（GRU）">·</a></h2><h3 id="重置门和更新门">重置门和更新门<a class="anchor" href="#重置门和更新门">·</a></h3><p>R：重置门 接近0时重置隐状态，接近1时是普通RNN</p><p>Z：更新门 接近0时接近隐状态，接近1时倾向于保留旧状态，来自X的信息基本被忽略，跳过时间步t</p><h3 id="计算重置门和更新门">计算重置门和更新门<a class="anchor" href="#计算重置门和更新门">·</a></h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/5.png" alt></p><h3 id="计算候选隐状态">计算候选隐状态<a class="anchor" href="#计算候选隐状态">·</a></h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/9-2.png" alt></p><p>$\odot$ 是Hardmard积，按元素的乘积</p><h3 id="计算隐状态">计算隐状态<a class="anchor" href="#计算隐状态">·</a></h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/9-3.png" alt></p><p>重置门有助于捕捉序列的短期依赖关系</p><p>更新门有助于捕捉序列的长期依赖关系</p><h3 id="简洁实现-2">简洁实现<a class="anchor" href="#简洁实现-2">·</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num_inputs = vocab_size</span><br><span class="line">gru_layer = nn.GRU(num_inputs, num_hiddens)</span><br><span class="line">model = RNNModel(gru_layer, len(vocab))</span><br><span class="line">model = model.to(device)</span><br><span class="line">train_rnn(model, train_iter, vocab, lr, num_epochs, device)</span><br></pre></td></tr></table></figure><h2 id="长短期记忆网络（LSTM）">长短期记忆网络（LSTM）<a class="anchor" href="#长短期记忆网络（LSTM）">·</a></h2><h3 id="输入门，遗忘门，输出门">输入门，遗忘门，输出门<a class="anchor" href="#输入门，遗忘门，输出门">·</a></h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/9-4.png" alt></p><p>值的范围都在[0,1]内</p><h3 id="候选记忆元">候选记忆元<a class="anchor" href="#候选记忆元">·</a></h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/9-5.png" alt></p><p>值的范围是[-1,1]</p><h3 id="记忆元">记忆元<a class="anchor" href="#记忆元">·</a></h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/9-6.png" alt></p><h3 id="隐状态">隐状态<a class="anchor" href="#隐状态">·</a></h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/9-7.png" alt></p><h3 id="简洁实现-3">简洁实现<a class="anchor" href="#简洁实现-3">·</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num_inputs = vocab_size</span><br><span class="line">lstm_layer = nn.LSTM(num_inputs, num_hiddens)</span><br><span class="line">model = RNNModel(lstm_layer, len(vocab))</span><br><span class="line">model = model.to(device)</span><br><span class="line">train_rnn(model, train_iter, vocab, lr, num_epochs, device)</span><br></pre></td></tr></table></figure><h2 id="深度循环神经网络">深度循环神经网络<a class="anchor" href="#深度循环神经网络">·</a></h2><p>堆叠隐藏层来实现</p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/9-8.png" alt></p><p><img src="/2022/05/15/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%8F%90%E5%8D%87%E7%AF%87/E:%5Ccode%5Cblog%5Csource_posts%5C2022-03-19-%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5C9-9.png" alt></p><p><img src="/2022/05/15/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%8F%90%E5%8D%87%E7%AF%87/E:%5Ccode%5Cblog%5Csource_posts%5C2022-03-19-%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5C9-10.png" alt></p><h3 id="简洁实现-4">简洁实现<a class="anchor" href="#简洁实现-4">·</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#和之前的区别在于指定了</span></span><br><span class="line">vocab_size, num_hiddens, num_layers = len(vocab), <span class="number">256</span>, <span class="number">2</span></span><br><span class="line">num_inputs = vocab_size</span><br><span class="line">device = d2l.try_gpu()</span><br><span class="line">lstm_layer = nn.LSTM(num_inputs, num_hiddens, num_layers)</span><br><span class="line">model = RNNModel(lstm_layer, len(vocab))</span><br><span class="line">model = model.to(device)</span><br></pre></td></tr></table></figure><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/9-1.png" alt></p><h2 id="双向循环神经网络">双向循环神经网络<a class="anchor" href="#双向循环神经网络">·</a></h2><p>增加一个从最后的词元开始<strong>从后向前运行</strong>的循环网络设计，添加反向传递信息的隐藏层。和隐马尔可夫模型中的动态规划前向后向递归没有太大区别</p><p>现代深度⽹络的设计原则：⾸先使⽤经典统计模型的函数依赖类型，然后将其参数化为<strong>通⽤形式</strong>。</p><h2 id="机器翻译与数据集">机器翻译与数据集<a class="anchor" href="#机器翻译与数据集">·</a></h2><p>对语言数据集的source（比如英文）和target（比如中文）同时进行统计和建模</p><p><strong>英法翻译数据集</strong>：有n条数据，每条数据是一句英文和一句对应法文</p><p><strong>数据预处理</strong>：将不间断空格转换为空格，大写转小写</p><p><strong>词元化</strong>：单词级词元化。返回两个词元列表：source和target。source[i]是源语言（此处为英语）第i个文本序列的词元列表，target[i]是目标语言（这里为法语）第i个文本序列的词元列表。</p><p>单词级词元化的词表大小远远大于字符级词元化大小，因此将低于2次的<strong>低频词元</strong>视为相同的<strong>未知词元</strong><code>&lt;unk&gt;</code>。此外指定额外词元。小批量时将序列填充到相同长度的<strong>填充词元</strong><code>&lt;pad&gt;</code>，序列的<strong>开始词元</strong><code>&lt;bos&gt;</code>，<strong>结束词元</strong><code>&lt;eos&gt;</code></p><p><strong>加载数据集</strong>：截断或填充让每个样本的长度保持一致，设置一个统一长度<code>num_steps</code>，小于则填充<code>&lt;pad&gt;</code>，大于则截断。在每个序列的末尾添加<code>&lt;eos&gt;</code>词元表明完成了序列输出工作</p><h2 id="编码器-解码器架构">编码器-解码器架构<a class="anchor" href="#编码器-解码器架构">·</a></h2><p>将一个长度可变的序列作为输入，转换为有固定形状的编码状态。之后解码，将固定形状的编码状态映射到长度可变的序列。比如，先将某句话编码为一个状态，再将这个状态解码，一个词元一个词元的生成翻译后的序列</p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220820220446007.png" alt="image-20220820220446007"></p><p>解码器新增一个<code>init_state</code>函数，将编码器输出转换为编码后的状态，这一过程可能需要额外的输出，比如输入序列的有效长度。为了生成长度可变的词元序列，解码器在每个时间步都将会将输入（比如在前一时间步生成的词元）和状态映射成当前时间步的输出词元</p><h2 id="序列到序列学习（seq2seq）">序列到序列学习（seq2seq）<a class="anchor" href="#序列到序列学习（seq2seq）">·</a></h2><p>循环神经网络编码器将长度可变的序列作为输入，转换为固定形状的隐状态，独立的循环神经网络解码器基于<strong>输入序列的编码信息</strong>和输<strong>出序列已经看见的或者生成的词元</strong>来预测下一个词元。一旦输出序列生成了<code>&lt;eos&gt;</code>词元则停止预测</p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220820223719165.png" alt="image-20220820223719165"></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220821101535573.png" alt="image-20220821101535573"></p><h3 id="BLEU评估方法">BLEU评估方法<a class="anchor" href="#BLEU评估方法">·</a></h3><p>广泛用于测量许多应用的输出序列的质量</p><p>$\exp(min(0,1-\frac {len_{label}} {len_{pred}}))\prod_{n=1}<sup>kp_n</sup>{\frac 1 {2^n}}$</p><p>$p_n$刻画n元语法的正确率，是预测序列中n元语法与标签序列中匹配的数量除以预测序列中n元语法的数量，k是用于匹配的最长n元语法</p><p>比如答案序列abcde，预测序列abcdde</p><p>则$p_1=3/5,p_2=2/4,p_3=1/3,p_4=0$</p><h2 id="束搜索">束搜索<a class="anchor" href="#束搜索">·</a></h2><p>贪心搜索：逐个预测输出序列，每次选择概率最高概率的词元，一直到达最大长度输出完成</p><p>穷举搜索：列举所有的可能性</p><p>束搜索：改进贪心搜索。超参数为束宽(beam size)k，时间步1选择最高条件概率的k个词元，k个词元分别是k个候选输出序列的第一个词元。之后的每个时间步，基于上一时间步的k个候选输出序列，继续选出最高条件概率的k个候选输出序列。</p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220821113727477.png" alt="image-20220821113727477"></p><p>最后得到了6个候选输出序列 A C AB CE ABD CED</p><p>选择其中条件概率最高的序列作为输出序列：</p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220821114045271.png" alt="image-20220821114045271"></p><p>L是最终候选序列的长度，$\alpha$为对长序列的惩罚项，一般为0.75</p><h1 id="10-注意力机制">10.注意力机制<a class="anchor" href="#10-注意力机制">·</a></h1><h2 id="10-1-注意力提示">10.1 注意力提示<a class="anchor" href="#10-1-注意力提示">·</a></h2><p>人类注意力是有限的，有价值，稀缺的</p><p>人通过非自主性和自主性提示有选择性地引导注意力，前者基于自然的突出性，比如一个红色杯子和4个灰色物体，很容易注意红色杯子。后者则需要人主观投入更多注意力，比如：我要认真写作业。</p><p>注意力机制与全连接层/汇聚层的区别在于增加了自主提示。全连接层/汇聚层可以认为是非自主性提示，注意力机制是自主性提示</p><p>注意力机制通过注意力汇聚使得选择偏向于<strong>值</strong>（value 感官输入），其中包含<strong>查询</strong>（query 自主性提示），<strong>键</strong>（key 非自主性提示），<strong>键和值是成对</strong>的，相当于<strong>感官输入的非自主提示</strong>。我们设计注意力汇聚，让给定的<strong>查询（自主性提示）<strong>可以和</strong>键（非自主性提示）<strong>进行匹配，引导得出</strong>最匹配的值（感官输入）</strong></p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220821193248884.png" alt="image-20220821193248884"></p><p>这里的注意力汇聚其实是通过调整不同参数的权重来实现的。</p><h2 id="10-2-注意力汇聚：Nadaraya-Watson-核回归">10.2 注意力汇聚：Nadaraya-Watson 核回归<a class="anchor" href="#10-2-注意力汇聚：Nadaraya-Watson-核回归">·</a></h2><p>注意力汇聚公式：$f(x)=\sum_{i=1}^n\alpha(x,x_i)y_i$   是$y_i$的加权平均</p><p>平均汇聚$\sum_{i=1}^ny_i$可以看成是特殊的注意力汇聚</p><p>查询x和键$x_i$之间的关系建模为注意力权重$\alpha(x,x_i)$，并分配给每一个对应值$y_i$，对于<strong>任何查询</strong>，模型在所有键值对注意力权重都是一个有效的概率分布：<strong>非负且总和为1</strong></p><p>高斯核：$K(u)=\frac 1 {\sqrt{2\pi}}exp(-\frac {u^2} 2)$</p><p>一个键越接近所给的查询x，则分配给这个键对应值$y_i$的注意力权重越大，也就获得了<strong>更多注意力</strong></p><p>unsqueeze函数：在指定位置插入一个维度，默认为1</p><h3 id="非参数型注意力汇聚">非参数型注意力汇聚<a class="anchor" href="#非参数型注意力汇聚">·</a></h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/10-1.png" alt></p><h3 id="参数型非注意力汇聚（加入一个权重，可以被训练）">参数型非注意力汇聚（加入一个权重，可以被训练）<a class="anchor" href="#参数型非注意力汇聚（加入一个权重，可以被训练）">·</a></h3><p>$\omega$仅仅为一个参数，长度为1</p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/10-2.png" alt></p><h2 id="10-3-注意力评分函数">10.3 注意力评分函数<a class="anchor" href="#10-3-注意力评分函数">·</a></h2><p>假设一个查询$q\in R^q$和m个键值对$(k_1,v_1),…,(k_m,v_m)$，其中$k_i\in R^k,v_i\in R^v$，注意力汇聚函数$f$被表示为值的加权和：</p><p>$f(q,(k_1,v_1),…,(k_m,v_m))=\sum_{i=1}^m\alpha (q,k_i)v_i \in R^v$</p><p>其中查询$q$和键$k_i$的注意力权重（标量）是通过注意力评分函数$a$将两个向量映射成标量，再经过softmax运算得到。</p><p>$\alpha (q,k_i)=softmax(a(q,k_i))=\frac {exp(a(q,k_i))} {\sum_{j=1}^mexp(a(q,k_j))}\in R$</p><h3 id="遮掩softmax操作">遮掩softmax操作<a class="anchor" href="#遮掩softmax操作">·</a></h3><p>指定一个有效序列长度，即词元个数，从而过滤掉超出指定范围的位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">masked_softmax</span><span class="params">(X, valid_lens)</span>:</span></span><br><span class="line">    <span class="string">"""通过在最后⼀个轴上掩蔽元素来执⾏softmax操作"""</span></span><br><span class="line">    <span class="comment"># X:3D张量，valid_lens:1D或2D张量</span></span><br><span class="line">    <span class="keyword">if</span> valid_lens <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> nn.functional.softmax(X, dim=<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    shape = X.shape</span><br><span class="line">    <span class="keyword">if</span> valid_lens.dim() == <span class="number">1</span>:</span><br><span class="line">    valid_lens = torch.repeat_interleave(valid_lens, shape[<span class="number">1</span>])</span><br><span class="line">        <span class="comment">#repeat_interleave([2,3],2)==&gt;[2,2,3,3]</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    valid_lens = valid_lens.reshape(<span class="number">-1</span>) </span><br><span class="line">        <span class="comment"># 最后⼀轴上被掩蔽的元素使⽤⼀个⾮常⼤的负值替换，从⽽其softmax输出为0 </span></span><br><span class="line">        X = d2l.sequence_mask(X.reshape(<span class="number">-1</span>, shape[<span class="number">-1</span>]), valid_lens,</span><br><span class="line">    value=<span class="number">-1e6</span>)</span><br><span class="line">    <span class="comment">#对处理后的X做softmax运算</span></span><br><span class="line">    <span class="keyword">return</span> nn.functional.softmax(X.reshape(shape), dim=<span class="number">-1</span>)</span><br><span class="line">masked_softmax(torch.rand(<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>), torch.tensor([<span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">得到结果:</span></span><br><span class="line"><span class="string">tensor([[[0.3412, 0.6588, 0.0000, 0.0000],</span></span><br><span class="line"><span class="string">        [0.4643, 0.5357, 0.0000, 0.0000]],</span></span><br><span class="line"><span class="string">        [[0.1967, 0.3512, 0.4522, 0.0000],</span></span><br><span class="line"><span class="string">        [0.3580, 0.3092, 0.3328, 0.0000]]])</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h3 id="加性注意力">加性注意力<a class="anchor" href="#加性注意力">·</a></h3><p>当<strong>查询</strong>和<strong>键</strong>是<strong>不同长度的矢量</strong>时，可以使用<strong>加性注意力</strong>作为评分函数。给定查询$q\in R^q$和键$k\in R^k$，加性注意力评分函数为$$a(q,k)=w_v^Ttanh(W_qq+W_kk)\in R$$其中可学习的参数是$W_q\in R^{h\times q},W_k\in R^{h\times k}$和$w_v\in R^h$</p><h3 id="缩放点积注意力">缩放点积注意力<a class="anchor" href="#缩放点积注意力">·</a></h3><p>查询和键是相同长度矢量时计算效率更高$$a(q,k)=q^Tk/\sqrt d$$</p><p>基于n个查询和m个键值对计算注意力，查询和键的长度为d，值的长度为v，查询$Q\in R^{n\times d}$，键$K\in R^{m\times d}$ 和值$V\in R^{m\times v}$的缩放点积注意力为$$softmax(\frac {QK^T} {\sqrt d})V\in R^{n\times v}$$</p><h2 id="10-4-Bahdanau注意力">10.4 Bahdanau注意力<a class="anchor" href="#10-4-Bahdanau注意力">·</a></h2><p>在预测词元时，如果<strong>不是所有输⼊词元都相关</strong>，模型将<strong>仅对⻬</strong>（或参与）输⼊序列中<strong>与当前预测相关的部分</strong>。这是通过将<strong>上下⽂变量</strong>视为<strong>注意⼒集中的输出</strong>来实现的。</p><p>9.7中的上下文变量是注意力集中的输出：</p><p>$c_{t’}=\sum_{t=1}^T\alpha (s_{t’-1},h_t)h_t$</p><p>其中，时间步$t’-1$时的解码器隐状态$s_{t’-1}$是查询，编码器隐状态$h_t$既是键，也是值，注意⼒权重$\alpha$是使⽤<strong>加性注意⼒打分函数</strong>计算的。</p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220822094459916.png" alt="image-20220822094459916"></p><h2 id="10-5-多头注意力">10.5 多头注意力<a class="anchor" href="#10-5-多头注意力">·</a></h2><p>将多个注意力汇聚输出进行连结，每个注意力汇聚都被称为一个头</p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220822094343539.png" alt="image-20220822094343539"></p><h2 id="10-6-自注意力和位置编码">10.6 自注意力和位置编码<a class="anchor" href="#10-6-自注意力和位置编码">·</a></h2><p>同⼀组词元同时充当查询、键和值，每个查询都会关注所有的键－值对并⽣成⼀个注意⼒输出</p><p><strong>查询、键和值来自同⼀组输入</strong>，因此被称为<strong>⾃注意⼒</strong></p><p>自注意力同时具有<strong>最大路径长度短</strong>和<strong>可并行</strong>两个优势，CNN可并行，RNN不可并行</p><p>为了学习位置信息，引入<strong>位置编码</strong>：$p_{i,2j}=sin(\frac i {10000^{\frac {2j} d}})$   $p_{i,2j+1}=cos(\frac i {10000^{\frac {2j} d}})$</p><h2 id="10-7-Transformer">10.7 Transformer<a class="anchor" href="#10-7-Transformer">·</a></h2><p>Transformer编码器和解码器是基于⾃注意⼒的模块叠加⽽成的，源（输⼊）序列和⽬标（输出）序列的嵌⼊（embedding）表⽰将加上位置编码（positional encoding），再分别输⼊到编码器和解码器中。</p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220822100053869.png" alt="image-20220822100053869"></p><p>NLP中一般使用层规范化而不是批量规范化</p><h1 id="11-优化算法">11.优化算法<a class="anchor" href="#11-优化算法">·</a></h1><h1 id="12-计算性能">12.计算性能<a class="anchor" href="#12-计算性能">·</a></h1><h1 id="13-计算机视觉">13.计算机视觉<a class="anchor" href="#13-计算机视觉">·</a></h1><h1 id="14-自然语言处理：预训练">14.自然语言处理：预训练<a class="anchor" href="#14-自然语言处理：预训练">·</a></h1><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220822104502404.png" alt="image-20220822104502404"></p><h2 id="14-1-词嵌入（Word2Vec）">14.1 词嵌入（Word2Vec）<a class="anchor" href="#14-1-词嵌入（Word2Vec）">·</a></h2><p><strong>单词映射到实向量</strong>的<strong>技术</strong>称为<strong>词嵌⼊</strong></p><p>独热编码不能刻画词语之间的相似度，需要能够刻画相似度的向量表示</p><h3 id="自监督的word2vec">自监督的word2vec<a class="anchor" href="#自监督的word2vec">·</a></h3><h4 id="跳元模型（Skip-Gram）">跳元模型（Skip-Gram）<a class="anchor" href="#跳元模型（Skip-Gram）">·</a></h4><p>假设<strong>一个词</strong>可以用来在文本序列中<strong>生成其周围的单词</strong></p><p>每个词都有<strong>两个d维向量表示</strong>，用于计算条件概率。对于词典中索引为i的任何词，分别用$v_i\in R^d$和$u_i\in R^d$表示其用作<strong>中心词</strong>和<strong>上下文词</strong>时的<strong>两个向量</strong>。</p><p><strong>给定中心词</strong>$w_c$（词典中的索引c），<strong>生成任何上下文词</strong>$w_o$（词典中索引o）的条件概率可以通过对<strong>向量点积的softmax操作</strong>来建模：</p><p>$P(w_o|w_c)=\frac {exp(u_o^Tv_c)} {\sum_{i\in V}exp(u_i^Tv_c)}$</p><p>词表索引集$V={0,1,…,|V|-1}$ 给定长度为T的文本序列，其中时间步t处的词表示为$w^{(t)}$。假设上下文词是在给定任何中心词的情况下独立生成的。对于<strong>上下文窗口m</strong>，跳元模型的似然函数是<strong>给定任何中心词</strong>的情况下<strong>生成所有上下文词</strong>的概率：</p><p>$\prod_{t=1}^T\prod_{-m\le j\le m,j\neq 0}P(w<sup>{(t+j)}|w</sup>{(t)})$</p><h5 id="训练-2">训练<a class="anchor" href="#训练-2">·</a></h5><p>用最大化似然函数（极大似然估计）来学习模型参数</p><p>最终使用<strong>中心词向量</strong>作为词表示</p><h4 id="连续词袋模型（CBOW）">连续词袋模型（CBOW）<a class="anchor" href="#连续词袋模型（CBOW）">·</a></h4><p>基于在文本序列中的<strong>周围上下文词</strong>生成<strong>中心词</strong></p><p>也就是P( “loves” | “I” , “you” )</p><p>计算条件概率时对<strong>上下文词向量进行平均</strong></p><p>给定上下文词$w_{o_1},…,w_{o_m}$生成中心词$w_c$的条件概率由以下公式建模：</p><p>$P(w_c|w_{o_1},…,w_{o_m})=\frac {exp(\frac 1 {2m}u_c^T(v_{o_1}+…+v_{o_{2m}}))} {\sum_{i\in V}exp(\frac 1 {2m}u_i^T(v_{o_1}+…+v_{o_{2m}}))}$</p><p>通常使用上下文词向量作为词表示</p><h2 id="14-2-近似训练">14.2 近似训练<a class="anchor" href="#14-2-近似训练">·</a></h2><ul><li>负采样。修改目标函数，增加负采样。训练的计算量与每⼀步的噪声词数成线性关系。</li><li>层序Softmax。使⽤⼆叉树中从根节点到叶节点的路径构造损失函数。训练的计算成本取决于词表⼤⼩的对数。</li></ul><h2 id="14-5-全局向量的词嵌入（GloVe）">14.5 全局向量的词嵌入（GloVe）<a class="anchor" href="#14-5-全局向量的词嵌入（GloVe）">·</a></h2><h3 id="带全局语料统计的跳元模型">带全局语料统计的跳元模型<a class="anchor" href="#带全局语料统计的跳元模型">·</a></h3><p>用$q_{ij}$表示词$w_j$的条件概率$P(w_j|w_i)$，在跳元模型中给定词$w_i$，可以得到：</p><p>$q_{ij}=\frac {exp(u_j^Tv_i)} {\sum_{k\in V}exp(u_k^Tv_i)}$</p><p>在整个语料库中，词$w_i$可能出现多次，则所有以它为中心词的上下文词形成了一个词索引的多重集$C_i$，允许同一元素的多个实例。实例数称为重数。比如以$w_i$为中心词的上下文词索引为a,b,c,d和a,c,e 那么多重集$C_i={a,a,b,c,c,d,e}$ a,b,c,d,e的重数为2，1，2，1，1</p><p>将多重集$C_i$中$j$元素的重数表示为$x_{ij}$，这是词$w_j$作为上下文词和词$w_i$作为中心词在整个语料库中的同一上下文窗口中的全局共现计数，则此时的跳元模型损失函数为：$-\sum_{i\in V}\sum_{j\in V}x_{ij}\log q_{ij}$</p><p>用$x_i$表示上下文窗口中所有上下文词的数量，其中$w_i$作为中心词出现，相当于$|C_i|$，设$p_{ij}$为用于生成上下文词$w_{j}$的条件概率$x_{ij}/x_i$，给定中心词，将损失函数重写为：$-\sum_{i\in V}x_i\sum_{j\in V}p_{ij}\log q_{ij}$</p><p>计算全局语料统计的条件分布$p_{ij}$和模型预测的条件分布$q_{ij}$的交叉熵，这⼀损失也按$x_i$加权</p><p>这个损失函数计算昂贵且给太多罕见事件赋值，需要替换</p><h3 id="GloVe模型">GloVe模型<a class="anchor" href="#GloVe模型">·</a></h3><p>基于平方损失，修改了跳元模型</p><ol><li>使用变量$p’<em>{ij}=x</em>{ij}$ 和$q’<em>{ij}=exp(u_j^Tv_i)$ 而非概率分布，并取二者的对数。平方损失项是$(\log(p’</em>{ij})-\log(q’<em>{ij}))<sup>2=(u_j</sup>Tv_i-\log x</em>{ij})^2$</li><li>为每个词$w_i$添加两个标量参数模型：中心词偏置$b_i$和上下文偏置$c_i$</li><li>用权重函数$h(x_{ij})$替换每个损失项的权重，其中$h(x)$在[0,1]区间单调增</li></ol><p>整合以下，训练GloVe就是降低以下损失函数</p><p>$\sum_{i\in V}\sum_{j\in V}h(x_{ij})(u_j^Tv_i+b_i+c_j-\log x_{ij})^2$</p><p>对于权重函数，建议是：当x&lt;c时，$h(x)=(x/c)^\alpha$，否则$h(x)=1$</p><p>这样可以省略掉任何$x_{ij}=0$的平方损失项</p><p>每次随机抽样一批非零的$x_{ij}$（预先计算的全局语料库统计数据，所以GloVe被叫做全局向量）来计算梯度并更新模型参数</p><p>由于$x_{ij}=x_{ji}$，所以任意词的中心词向量和上下文词向量是等价的，实际应用中，同一个词经过训练后，在两个向量中可能得到不同值，因此最后将其相加作为输出向量。</p><h2 id="14-6-子词嵌入">14.6 子词嵌入<a class="anchor" href="#14-6-子词嵌入">·</a></h2><h3 id="fastText模型">fastText模型<a class="anchor" href="#fastText模型">·</a></h3><p>子词级跳元模型</p><p>对于where单词，先在开头和末尾添加特殊字符&quot;&lt;“和”&gt;&quot;，从而将前缀和后缀与其他子词分开。之后提取出n-gram。比如n=3时，获得长度为3的所有子词：<code>&lt;wh,whe,her,ere,re&gt;</code>和特殊子词<code>&lt;where&gt;</code></p><p>对于任意词w，用$g_w$表示其长度在3和6之间的所有子词与其特殊子词的并集。<strong>词表</strong>是<strong>所有子词的集合</strong>。假设$z_g$是词典中的子词g的向量，则跳元模型中作为中心词的词w的向量$v_w$是其子词向量的和：</p><p>$v_w=\sum_{g\in g_w}z_g$</p><p>其余部分和跳元模型相同。因此fastText词量更大，模型参数也更多。同时计算一个词表示必须对所有子词向量求和，计算复杂度增高。但是对于具有相似结构的词之间共享来自子词的参数，罕见词甚至词表外的词在fastText中可能获得更好的向量表示</p><h3 id="字节对编码（Byte-Pair-Encoding）">字节对编码（Byte Pair Encoding）<a class="anchor" href="#字节对编码（Byte-Pair-Encoding）">·</a></h3><p>在fastText中所有子词长度必须指定，词表大小不能预定义</p><p>为了在固定大小的词表中允许可变长度的子词，应用一种字节对编码压缩算法来提取子词</p><p>字节对编码执⾏训练数据集的统计分析，以发现单词内的公共符号，诸如任意⻓度的连续字符。从⻓度为1的符号开始，字节对编码迭代地合并最频繁的连续符号对以产⽣新的更⻓的符号。请注意，为提⾼效率，不考虑跨越单词边界的对。最后，我们可以使⽤像⼦词这样的符号来切分单词。字节对编码及其变体已经⽤于诸如<strong>GPT-2</strong>和<strong>RoBERTa</strong>等⾃然语⾔处理预训练模型中的输⼊表⽰。</p><h2 id="14-7-词的相似性和类比任务">14.7 词的相似性和类比任务<a class="anchor" href="#14-7-词的相似性和类比任务">·</a></h2><ul><li>在实践中，在⼤型语料库上预先练的词向量可以应⽤于下游的⾃然语⾔处理任务。</li><li>预训练的词向量可以应⽤于词的<strong>相似性</strong>和<strong>类⽐任务</strong>。</li></ul><h2 id="14-8-来⾃Transformers的双向编码器表⽰（BERT）">14.8 来⾃Transformers的双向编码器表⽰（BERT）<a class="anchor" href="#14-8-来⾃Transformers的双向编码器表⽰（BERT）">·</a></h2><h3 id="从上下⽂⽆关到上下⽂敏感">从上下⽂⽆关到上下⽂敏感<a class="anchor" href="#从上下⽂⽆关到上下⽂敏感">·</a></h3><p>之前的编码方式都采用上下文无关表示，但是很多词语在不同句子中有不同表示，因此需要上下文敏感表示方法。常见的有：TagLM（language-model-augmented sequence tagger，语⾔模型增强的序列标记器），CoVe（Context Vectors，上下⽂向量），ELMo（Embeddings from Language Models，来⾃语⾔模型的嵌⼊）</p><p>例如，通过将整个序列作为输⼊，<strong>ELMo</strong>是<strong>为输⼊序列中的每个单词分配⼀个表⽰</strong>的函数。具体来说，ELMo将来⾃预训练的双向⻓短期记忆⽹络的所有中间层表⽰组合为输出表⽰。然后，ELMo的表⽰将作为附加特征添加到下游任务的现有监督模型中，例如通过将ELMo的表⽰和现有模型中词元的原始表⽰（例如GloVe）连结起来。⼀⽅⾯，在加⼊ELMo表⽰后，冻结了预训练的双向LSTM模型中的所有权重。另⼀⽅⾯，现有的监督模型是专⻔为给定的任务定制的。利⽤当时不同任务的不同最佳模型，添加ELMo<strong>改进了六种⾃然语⾔处理任务的技术⽔平</strong>：情感分析、⾃然语⾔推断、语义⻆⾊标注、共指消解、命名实体识别和问答。</p><h3 id="从特定于任务到不可知任务">从特定于任务到不可知任务<a class="anchor" href="#从特定于任务到不可知任务">·</a></h3><p>尽管ELMo显著改进了各种⾃然语⾔处理任务的解决⽅案，但每个解决⽅案仍然依赖于⼀个特定于任务的架构。然⽽，<strong>为每⼀个⾃然语⾔处理任务设计⼀个特定的架构</strong>实际上并不是⼀件容易的事。<strong>GPT（Generative Pre Training，⽣成式预训练）模型</strong>为上下⽂的敏感表⽰设计了通⽤的<strong>任务⽆关模型</strong> 。GPT建⽴在Transformer解码器的基础上，预训练了⼀个⽤于表⽰⽂本序列的语⾔模型。当将GPT应⽤于下游任务时，语⾔模型的输出将被送到⼀个附加的线性输出层，以<strong>预测任务的标签</strong>。与ELMo冻结预训练模型的参数不同，<strong>GPT在下游任务的监督学习过程中对预训练Transformer解码器中的所有参数进⾏微调</strong>。GPT在⾃然语⾔推断、问答、句⼦相似性和分类等12项任务上进⾏了评估，并在对模型架构进⾏最⼩更改的情况下改善了其中9项任务的最新⽔平。然⽽，由于语⾔模型的⾃回归特性，GPT只能向前看（从左到右）。在“i went to the bank to deposit cash”（我去银⾏存现⾦）和“i went to the bank to sit down”（我去河岸边坐下）的上下⽂中，由于“bank”对其左边的上下⽂敏感，GPT将返回“bank”的相同表⽰，尽管它有不同的含义。</p><h3 id="BERT：把两个最好的结合起来">BERT：把两个最好的结合起来<a class="anchor" href="#BERT：把两个最好的结合起来">·</a></h3><p>如我们所⻅，<strong>ELMo对上下⽂进⾏双向编码</strong>，但使⽤<strong>特定于任务</strong>的架构；⽽<strong>GPT是任务⽆关</strong>的，但是<strong>从左到右编码</strong>上下⽂。<strong>BERT（来⾃Transformers的双向编码器表⽰）<strong>结合了这两个⽅⾯的优点。它对</strong>上下⽂进⾏双向编码</strong>，并且<strong>对于⼤多数的⾃然语⾔处理任务只需要最少的架构改变</strong>。通过使⽤预训练的Transformer编码器，BERT能够基于其双向上下⽂表⽰任何词元。在下游任务的监督学习过程中，BERT在两个⽅⾯与GPT相似。⾸先，BERT表⽰将被输⼊到⼀个添加的输出层中，根据任务的性质对模型架构进⾏最⼩的更改，例如预测每个词元与预测整个序列。其次，对预训练Transformer编码器的所有参数进⾏微调，⽽额外的输出层将从头开始训练。</p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220823213359539.png" alt="image-20220823213359539"></p><h3 id="输入表示">输入表示<a class="anchor" href="#输入表示">·</a></h3><p>有些任务以单文本作为输入（情感分析），有些任务以一对文本序列作为输入（自然语言推断）。BERT输入序列明确表示单个文本和文本对。</p><p>输入为单文本的BERT输入序列：特殊类别词元<code>&lt;cls&gt;</code>、文本序列的标记、特殊分割词元<code>&lt;sep&gt;</code>的连结</p><p>输入为文本对时的BERT输入序列：<code>&lt;cls&gt;</code>、第一个文本序列的标记、<code>&lt;sep&gt;</code>、第二个文本序列的标记、<code>&lt;sep&gt;</code>的终结</p><p>BERT输⼊序列的嵌⼊是词元嵌⼊、⽚段嵌⼊和位置嵌⼊的和。</p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220824105522963.png" alt="image-20220824105522963"></p><h3 id="预训练任务">预训练任务<a class="anchor" href="#预训练任务">·</a></h3><h4 id="掩蔽语言模型（Masked-Language-Modeling）">掩蔽语言模型（<strong>Masked Language Modeling</strong>）<a class="anchor" href="#掩蔽语言模型（Masked-Language-Modeling）">·</a></h4><p>为了双向编码上下⽂以表⽰每个词元，BERT<strong>随机掩蔽词元</strong>并使⽤来⾃<strong>双向上下⽂的词元</strong>以⾃监督的⽅式**预测掩蔽词元。**此任务称为掩蔽语⾔模型。</p><h4 id="下一句预测（Next-Sentence-Prediction）">下一句预测（<strong>Next Sentence Prediction</strong>）<a class="anchor" href="#下一句预测（Next-Sentence-Prediction）">·</a></h4><p>为了帮助理解两个⽂本序列之间的关系，BERT在预训练中考虑了⼀个⼆元分类任务——下⼀句预测</p><h1 id="15-自然语言处理：应用">15.自然语言处理：应用<a class="anchor" href="#15-自然语言处理：应用">·</a></h1>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DeepLearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>x86学习笔记</title>
      <link href="2022/04/17/x86-Learning-Note/"/>
      <url>2022/04/17/x86-Learning-Note/</url>
      
        <content type="html"><![CDATA[<h1 id="第1章-基础知识">第1章 基础知识<a class="anchor" href="#第1章-基础知识">·</a></h1><p>IBM-PC输入输出时采用ASCII码进行编码</p><h1 id="第2章-IBM-PC计算机组织">第2章 IBM-PC计算机组织<a class="anchor" href="#第2章-IBM-PC计算机组织">·</a></h1><h2 id="2-3-Intel-8086-8088-CPU的寄存器架构">2.3 Intel 8086/8088 CPU的寄存器架构<a class="anchor" href="#2-3-Intel-8086-8088-CPU的寄存器架构">·</a></h2><h3 id="通用寄存器">通用寄存器<a class="anchor" href="#通用寄存器">·</a></h3><p>AX BX CX DX 常用于存放数据，称为数据寄存器，这四个寄存器可以拆分为AH,AL,BH,BL,CH,CL,DH,DL 8个8位寄存器，分别是相应寄存器的高8位和低8位</p><p>SP BP SI DI 常用于存放指针，称为指针或地址寄存器</p><h4 id="数据寄存器">数据寄存器<a class="anchor" href="#数据寄存器">·</a></h4><p>AX是累加器（accumulator）常用来存放操作数和运算结果，<strong>乘除法强制使用</strong>，输入输出也需要使用</p><p>BX一般用来存放基地址（base address）</p><p>CX常在循环指令及串循环指令中用作计数器，移位指令则用CL作为计数器</p><p>DX用于32位乘除法时AX的扩展，输入输出指令中用来存放I/O端口的地址，实现间接寻址</p><h4 id="指针与变址寄存器">指针与变址寄存器<a class="anchor" href="#指针与变址寄存器">·</a></h4><p>SP <strong>堆栈</strong>寄存器，堆栈的操作（压入，弹出）会自动修改SP值</p><p>BP 基址指针，是一种基地址寄存器（类似于BX），不同的是相对于堆栈段而不是数据段</p><p>SI 源变址寄存器</p><p>DI 目的变址寄存器</p><h3 id="段寄存器">段寄存器<a class="anchor" href="#段寄存器">·</a></h3><p>CS：代码段寄存器</p><p>DS：数据段寄存器</p><p>SS：堆栈段寄存器</p><p>ES：附加段寄存器</p><h3 id="指令指针">指令指针<a class="anchor" href="#指令指针">·</a></h3><p>IP 指令指针寄存器</p><p>当前执行的指令在代码段的偏移地址</p><p>不能直接改动</p><h3 id="标志寄存器">标志寄存器<a class="anchor" href="#标志寄存器">·</a></h3><p>9个一位的标志寄存器（或标志位）</p><p>组合在一起放入一个16位的程序状态字寄存器<strong>PSW</strong>中</p><p><img src="/2022/04/17/x86-Learning-Note/1.jpg" alt></p><img src="/2022/04/17/x86-Learning-Note/2.jpg" style="zoom:80%;"><h2 id="2-4-PC机内存组织">2.4 PC机内存组织<a class="anchor" href="#2-4-PC机内存组织">·</a></h2><p>20根地址线 总内存大小是 $2^{20}=1MB$</p><p>范围表示从 $00000H-FFFFFH$</p><p>同时x86是<strong>小端存储</strong> 即低地址存低位</p><p>采用16位寄存器记录分段信息，一共分为64K个段，每个段最多有64KB的段长</p><p>用逻辑地址，即<strong>段地址：偏移地址</strong>的格式映射某个物理地址</p><p>具体映射方式：物理地址=段地址*16D（或10H）+偏移地址</p><h2 id="2-5-堆栈">2.5 堆栈<a class="anchor" href="#2-5-堆栈">·</a></h2><p>堆栈位置和大小由SS和SP寄存器确定</p><p>栈底由SP初始值确定，栈顶由SP值确定，一直压栈，SP值越来越小，栈顶距离栈底就越来越远</p><h3 id="压栈">压栈<a class="anchor" href="#压栈">·</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUSH AX</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SP&#x3D;SP-2 </span><br><span class="line">[SP]&#x3D;AX</span><br></pre></td></tr></table></figure><h3 id="弹出">弹出<a class="anchor" href="#弹出">·</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POP AX</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AX&#x3D;[SP]</span><br><span class="line">SP&#x3D;SP-2</span><br></pre></td></tr></table></figure><h1 id="第3章-寻址方式与指令系统">第3章 寻址方式与指令系统<a class="anchor" href="#第3章-寻址方式与指令系统">·</a></h1><h2 id="3-1-指令格式">3.1 指令格式<a class="anchor" href="#3-1-指令格式">·</a></h2><h3 id="指令汇编语言格式">指令汇编语言格式<a class="anchor" href="#指令汇编语言格式">·</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OP DST,SRC;类似ADD AX,b</span><br><span class="line">OPSRC ;类似POP</span><br><span class="line">OP;类似DIV</span><br></pre></td></tr></table></figure><h2 id="3-2-寻址方式">3.2 寻址方式<a class="anchor" href="#3-2-寻址方式">·</a></h2><h3 id="与数据相关的寻址方式">与数据相关的寻址方式<a class="anchor" href="#与数据相关的寻址方式">·</a></h3><p>各个指令所需的操作数来自：</p><ul><li>寄存器。包括通用寄存器，段寄存器和标志寄存器（PSW）</li><li>指令本身给出的立即数（常量）</li><li>内存单元</li></ul><h4 id="立即寻址">立即寻址<a class="anchor" href="#立即寻址">·</a></h4><p>只能出现在<strong>源操作数</strong>，<strong>不能出现</strong>在<strong>目的操作数</strong>位置</p><p>目的操作数可以是寄存器或内存操作数</p><p>常用来给寄存器赋初值</p><p>常数可以直接写到指令，常量则需要线用EQU伪指令定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,512</span><br><span class="line">VALUE EQU 51</span><br><span class="line">MOV AX,VALUE</span><br></pre></td></tr></table></figure><h4 id="寄存器寻址">寄存器寻址<a class="anchor" href="#寄存器寻址">·</a></h4><p>操作数是CPU的某个寄存器</p><p>8位操作数，可以是AH,AL,BH,BL,CH,CL,DH,DL</p><p>16位操作数，可以是AX,BX,CX,DX,SP,BP,SI,DI,CS,DS,SS,ES</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,BX</span><br><span class="line">ADD AX,DX</span><br><span class="line">PUSH DS</span><br><span class="line">STD ;设置DF&#x3D;1</span><br><span class="line">PUSHF ;PSW作为源操作数</span><br></pre></td></tr></table></figure><h4 id="直接寻址">直接寻址<a class="anchor" href="#直接寻址">·</a></h4><p>操作数的偏移地址直接在指令中指出的寻址方式</p><p>默认是相对于DS数据段的偏移量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOVAX,[2000H]</span><br></pre></td></tr></table></figure><p>也可以先定义字/字节变量的方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xDW?</span><br><span class="line">cDB&#39;A&#39;</span><br><span class="line">MOVAX,x</span><br><span class="line">MOVAL,c</span><br></pre></td></tr></table></figure><p>汇编程序被汇编器汇编后，会计算出x,c的偏移值替换原来的x或c</p><h4 id="寄存器间接寻址">寄存器间接寻址<a class="anchor" href="#寄存器间接寻址">·</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MOVAX,[BX]</span><br><span class="line">MOVBH,[BP]</span><br><span class="line">MOVCX,[SI]</span><br><span class="line">MOVDL,[DI]</span><br><span class="line"></span><br><span class="line">#等价于 即缺省时是相应的段 也可以修改</span><br><span class="line"></span><br><span class="line">MOVAX,DS:[BX]</span><br><span class="line">MOVBH,SS:[BP]</span><br><span class="line">MOVCX,DS:[SI]</span><br><span class="line">MOVDL,DS:[DI]</span><br></pre></td></tr></table></figure><p>注意<strong>不能用DX</strong>做间接寻址寄存器</p><h4 id="寄存器相对寻址">寄存器相对寻址<a class="anchor" href="#寄存器相对寻址">·</a></h4><p>操作数有效地址EA是<strong>一个基址寄存器或变址寄存器的内容</strong>和指令中指定的<strong>8位或16位位移量</strong>之和</p><p>EA=间接寄存器的值+8位/16位常量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOVAX,[SI+10H]</span><br><span class="line">MOV AX,10H[SI]</span><br><span class="line">MOVAX,ARRAY[SI]</span><br><span class="line">MOV TABLE[DI+1],AL</span><br></pre></td></tr></table></figure><h4 id="基址变址寻址方式">基址变址寻址方式<a class="anchor" href="#基址变址寻址方式">·</a></h4><p>操作数有效地址EA=基址寄存器+变址寄存器内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOVAX,[BX][SI]</span><br><span class="line">MOVAX,[BX+SI]</span><br></pre></td></tr></table></figure><p>注意，基址变址寻址方式的<strong>基址寄存器</strong>只能是<strong>BX或BP</strong>，<strong>变址寄存器</strong>只能是<strong>SI或DI</strong></p><h3 id="与转移地址有关的寻址方式">与转移地址有关的寻址方式<a class="anchor" href="#与转移地址有关的寻址方式">·</a></h3><p>主要运用于转移指令（JMP）和过程调用指令（CALL）</p><p>通过<strong>标号和过程名</strong>来确定同一代码段或另一代码段的偏移地址</p><h4 id="段内直接寻址">段内直接寻址<a class="anchor" href="#段内直接寻址">·</a></h4><p>转向的指令实际有效地址是当前IP寄存器的内容和指令中指定的8位或16位位移量之和</p><p>条件转移指令必须是8位，所以省略了SHORT操作符</p><p>可以指定位移量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JMPSHORT L1 ;8位 短跳转</span><br><span class="line">JMPNEAR PTR L1 ;16位</span><br></pre></td></tr></table></figure><h4 id="段内间接寻址">段内间接寻址<a class="anchor" href="#段内间接寻址">·</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MOVAX,OFFSET P1</span><br><span class="line">MOVADD1,AX</span><br><span class="line">CALL ADD1</span><br><span class="line">MOVBX,OFFSET ADD1</span><br><span class="line">CALL [BX]</span><br><span class="line">JMPBX</span><br></pre></td></tr></table></figure><h4 id="段间直接寻址">段间直接寻址<a class="anchor" href="#段间直接寻址">·</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL FAR PTR P2</span><br></pre></td></tr></table></figure><p>要转移的标号或过程名必须具备FAR属性</p><h4 id="段间间接寻址">段间间接寻址<a class="anchor" href="#段间间接寻址">·</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JMPDWORD PTR [BX+INTERS] ;寄存器相对寻址方式</span><br></pre></td></tr></table></figure><p>转移地址是一个双字，高位字在后，低位字在前</p><h2 id="3-3-指令系统">3.3 指令系统<a class="anchor" href="#3-3-指令系统">·</a></h2><h3 id="数据传送指令">数据传送指令<a class="anchor" href="#数据传送指令">·</a></h3><h4 id="数据通路与类型匹配">数据通路与类型匹配<a class="anchor" href="#数据通路与类型匹配">·</a></h4><img src="/2022/04/17/x86-Learning-Note/3.jpg" style="zoom:80%;"><h4 id="MOV和XCHG指令">MOV和XCHG指令<a class="anchor" href="#MOV和XCHG指令">·</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV DST,SRC</span><br><span class="line">XCHG OPR1,OPR2</span><br></pre></td></tr></table></figure><p>大部分指令需要遵守的规则：</p><ul><li>源和目的必须类型匹配（8位对8位，16位对16位）</li><li>目的操作数不能为立即数</li><li>源和目的操作数<strong>不能同时为内存操作数</strong>（串指令除外）</li><li>源和目的操作数<strong>不能同时为段寄存器</strong></li></ul><h4 id="PUSH-POP-PUSHF-POPF指令">PUSH,POP,PUSHF,POPF指令<a class="anchor" href="#PUSH-POP-PUSHF-POPF指令">·</a></h4><h4 id="地址传送指令-LEA-LDS-LES">地址传送指令 LEA,LDS,LES<a class="anchor" href="#地址传送指令-LEA-LDS-LES">·</a></h4><p>将地址送到指定寄存器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LEAREG,SRC;源操作数src的偏移地址送入reg</span><br><span class="line">LDS REG,SRC;src中的双字内容依次送入reg和DS中</span><br><span class="line">LESREG,SRC;src中的双字内容依次送入reg和ES中</span><br></pre></td></tr></table></figure><p>获得地址也可以使用OFFSET和SEG</p><p>比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOVBX,OFFSET X</span><br><span class="line">MOVAX,SEG X</span><br></pre></td></tr></table></figure><h3 id="算术运算指令">算术运算指令<a class="anchor" href="#算术运算指令">·</a></h3><p>查看45-49页</p><p>加减指令</p><p>CMP与NEG</p><p>乘法指令MUL IMUL和CBW</p><p>除法指令DIV IDIV和CWD</p><h3 id="逻辑指令">逻辑指令<a class="anchor" href="#逻辑指令">·</a></h3><p>查看49-52页</p><p>逻辑运算指令</p><p>测试指令</p><p>移位指令</p><h3 id="控制转移指令">控制转移指令<a class="anchor" href="#控制转移指令">·</a></h3><p>查看52-59页</p><p>无条件转移指令</p><p>条件转移指令</p><p>循环指令</p><p>过程调用和返回指令</p><p>处理器控制指令</p><h1 id="第4章-汇编语言程序格式">第4章 汇编语言程序格式<a class="anchor" href="#第4章-汇编语言程序格式">·</a></h1><h2 id="4-1-分段式程序结构">4.1 分段式程序结构<a class="anchor" href="#4-1-分段式程序结构">·</a></h2><p>SEGMENT ENDS DW EQU ASSUME ENDP END都是常见伪指令</p><p>标号命名必须以<code>@/-/?</code> 或者字母开头，指令与伪指令的常数以字母开头 <code>A/B/C/D/E/F</code> 开头需要在前面加0，避免混淆，不区分大小写！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">STACK1 SEGMENT PARA STACK ;PARA STACK定义了堆栈</span><br><span class="line">        STACK_AREADW100H DUP(?)</span><br><span class="line">        STACK_BTMEQU$-STACK_AREA</span><br><span class="line">STACK1 ENDS ;1-4行定义堆栈段 SEGMENTS和ENDS是一对</span><br><span class="line">DATA SEGMENT</span><br><span class="line">        TABLE_LEN DW 16</span><br><span class="line">        TABLE DW 19,06,19,73,11,22,33,44</span><br><span class="line">                DW 20,06,20,74,55,66,77,88</span><br><span class="line">DATAENDS ;5-9行定义数据段</span><br><span class="line">CODE SEGMENT </span><br><span class="line">ASSUME CS:CODE,DS:DATA,SS:STACK1 ;为了阅读方便和整齐，需要字段对齐 指令语句和伪指令语句不能换行 这里其实没有真正的设置CS DS SS</span><br><span class="line">MAIN PROC FAR ;PROC和ENDP是一对 如果只有一个过程则可以直接在代码段写指令</span><br><span class="line">        MOVAX,STACK1</span><br><span class="line">        MOVSS,AX</span><br><span class="line">        MOV SP,STACK_BTM ;栈底交给SP</span><br><span class="line">        MOVAX,DATA</span><br><span class="line">        MOVDS,AX</span><br><span class="line">LP1:MOV BX,1</span><br><span class="line">MOVCX,TABLE_LEN</span><br><span class="line">DECCX</span><br><span class="line">MOVSI,OFFSET TABLE;把TABLE的偏移地址送给SI</span><br><span class="line">LP2:MOV AX,[SI] ;利用SI进行间接寻址</span><br><span class="line">CMP AX,[SI+2];比较TABLE[i]与TABLE[i+1]的大小</span><br><span class="line">JBECONTINUE;小于等于则跳转到CONTINUE 无符号数比较是JB&#x2F;JA&#x2F;JE 有符号数是 JG&#x2F;JL&#x2F;JE</span><br><span class="line">XCHGAX,[SI+2];大于则交换，用AX当TEMP</span><br><span class="line">MOV[SI],AX</span><br><span class="line">MOVBX,0;清零标志变量</span><br><span class="line">CONTINUE:ADD SI,2</span><br><span class="line">LOOPLP2;&lt;&#x3D;&#x3D;&gt; 先CX-- CX不为0就跳转到 LP2 CX为0则继续往下执行</span><br><span class="line">CMPBX,1</span><br><span class="line">JZEXIT;ZF为0则跳转到EXIT</span><br><span class="line">JMPSHORT LP1;SHORT是相距较近的代码时用的</span><br><span class="line">EXIT:MOV AX,4C00H  ;AH-功能号 AL-返回码 相当于exit(0)，返回MS-DOS命令提示符</span><br><span class="line">INT21H;调用MS-DOS例程</span><br><span class="line">MAINENDP</span><br><span class="line">CODE1 ENDS ;10-36行定义代码段</span><br><span class="line">ENDMAIN ;告诉编译器程序入口在MAIN</span><br></pre></td></tr></table></figure><h2 id="4-2-定义程序结构的伪指令">4.2 定义程序结构的伪指令<a class="anchor" href="#4-2-定义程序结构的伪指令">·</a></h2><h2 id="4-3-数据定义与内存分配">4.3 数据定义与内存分配<a class="anchor" href="#4-3-数据定义与内存分配">·</a></h2><h3 id="常数与常量">常数与常量<a class="anchor" href="#常数与常量">·</a></h3><p>二进制数：0-1序列，B结尾，比如：010B</p><p>八进制数：0-7组成序列，Q结尾，比如：127Q</p><p>十进制数：0-9组成序列，D结尾，D也可以省略。比如：129/129D</p><p>十六进制数：0-9，A-F组成序列，H结尾</p><p>字符或字符串：单引号或双引号括起来的字符：‘A’,“ABC”</p><p>实数：整数，小数，指数三部分，比如1.234E-5</p><p>EQU指令指定常量 比如：<code>A EQU 12H</code></p><p>当前位置计数器 <code>$</code>，常用来计算长度，比如 <code>SRACK_BTM EQU-TABLE</code></p><h3 id="变量与变量定义">变量与变量定义<a class="anchor" href="#变量与变量定义">·</a></h3><p>x86中所有的地址+1，都是+1个BYTE对应的地址</p><p><code>String1 DB 'ABCD',0DH,0AH,'$'</code> 这里其实定义了7个字，即A B C D 0DH 0AH $</p><p><code>ARRAY1 DB 10 DUP(?)</code></p><p><code>ARRAY2D DB 5 DUP(1,2,3,4,?)</code> 二维数组定义</p><h3 id="汇编，链接，运行">汇编，链接，运行<a class="anchor" href="#汇编，链接，运行">·</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">masm code.asm</span><br><span class="line">link code.asm</span><br><span class="line">code.asm</span><br></pre></td></tr></table></figure><h3 id="调试与DEBUG">调试与DEBUG<a class="anchor" href="#调试与DEBUG">·</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debug code.exe</span><br></pre></td></tr></table></figure><h1 id="第5章-分支与循环程序设计">第5章 分支与循环程序设计<a class="anchor" href="#第5章-分支与循环程序设计">·</a></h1><h2 id="5-1-顺序程序设计">5.1 顺序程序设计<a class="anchor" href="#5-1-顺序程序设计">·</a></h2><h3 id="例题5-1-将一个25行，80列的数组的第y行，第x列元素的第i位置1">例题5.1 将一个25行，80列的数组的第y行，第x列元素的第i位置1<a class="anchor" href="#例题5-1-将一个25行，80列的数组的第y行，第x列元素的第i位置1">·</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">STACK1 SEGMENTPARA</span><br><span class="line">STACK_AREADW100H DUP(?)</span><br><span class="line">STACK_BOTTOMEQU$-STACK_AREA</span><br><span class="line">STACK1  ENDS</span><br><span class="line"></span><br><span class="line">DATASEGMENT PARA </span><br><span class="line">ARRAYDB25*80DUP(?)</span><br><span class="line">XDB? ;字节变量</span><br><span class="line">YDB?</span><br><span class="line">IDB ?</span><br><span class="line">END SEGMENT</span><br><span class="line"></span><br><span class="line">CODESEGMENT PARA</span><br><span class="line">ASSUMECS:CODE,SS:STACK1,DS:DATA</span><br><span class="line">MAINPROC FAR</span><br><span class="line">MOVAX,STACK1</span><br><span class="line">MOVSS,AX</span><br><span class="line">MOVSP,STACK_BOTTOM</span><br><span class="line">MOVAX,DATA</span><br><span class="line">MOVDS,AX</span><br><span class="line"></span><br><span class="line">MOVAL,80</span><br><span class="line">MULY;相当于AL*Y 结果送到AX</span><br><span class="line">MOVDL,X</span><br><span class="line">XORDH,DH ;将DH清零 从而DX&#x3D;X</span><br><span class="line">ADDAX,DX ;AX&#x3D;Y*80+X</span><br><span class="line">MOVSI,OFFSET ARRAY;SI&#x3D;ARRAY首地址</span><br><span class="line">ADDSI,AX;SI&#x3D;需要的元素地址</span><br><span class="line">MOVAL,80H;AL&#x3D;10000000B</span><br><span class="line">MOVCL,I;CL&#x3D;I</span><br><span class="line">SHRAL,CL;AL&#x3D;AL&gt;&gt;I移位的数字不是1，必须使用CL寄存器！！</span><br><span class="line">OR[SI],AL;第I位置1 SI寄存器间接寻址</span><br><span class="line">EXIT:MOVAX,4C00H</span><br><span class="line">INT21H</span><br><span class="line">MAINENDP</span><br><span class="line">CODE END</span><br><span class="line">ENDMAIN</span><br></pre></td></tr></table></figure><h3 id="例题5-2-用查表方式将一位十六进制数转换成相应ascii码">例题5.2 用查表方式将一位十六进制数转换成相应ascii码<a class="anchor" href="#例题5-2-用查表方式将一位十六进制数转换成相应ascii码">·</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">STACK1 SEGMENT PARA STACK</span><br><span class="line">STACK_AREADB100H DUP(?) ;定义PARA STACK就会自动初始化SP和SS</span><br><span class="line">STACK1 ENDS</span><br><span class="line"></span><br><span class="line">DATA SEGMENT PARA</span><br><span class="line">ASCII_TABLEDB30H,31H,32H,33H,34H,35H,36H,37H</span><br><span class="line">DB38H,39H,41H,42H,43H,44H,45H,46H</span><br><span class="line">HEXDB?</span><br><span class="line">ASCDB?</span><br><span class="line">DATA ENDS</span><br><span class="line"></span><br><span class="line">CODE SEGMENTPARA</span><br><span class="line">ASSUMECS:CODE,SS:STACK,DS:DATA</span><br><span class="line">MAIN PROCFAR</span><br><span class="line">MOVAX,DATA</span><br><span class="line">MOV DS,AX</span><br><span class="line">MOVSI,OFFSETASCII_TABLE</span><br><span class="line">MOVAL,HEX</span><br><span class="line">XORAH,AH;AX&#x3D;HEX</span><br><span class="line">ADDSI,AX;SI&#x3D;HEX对应的ascii码元素的地址</span><br><span class="line">MOVAL,[SI]</span><br><span class="line">MOVASC,AL</span><br><span class="line"></span><br><span class="line">;打印ASCII码</span><br><span class="line">MOVAH,2;二号中断</span><br><span class="line">MOVDL,AL</span><br><span class="line">INT 21H</span><br><span class="line"></span><br><span class="line">EXIT:MOV AX,4C00H</span><br><span class="line">INT 21H</span><br><span class="line">MAIN ENDP</span><br><span class="line">CODE ENDS</span><br><span class="line">END MAIN</span><br></pre></td></tr></table></figure><p>也可以用以下寄存器相对寻址方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">XORAH,AH</span><br><span class="line">MOVAL,HEX</span><br><span class="line">MOVSI,AX</span><br><span class="line">MOVAL,ASCII_TABLE[SI]</span><br><span class="line">MOVASC,AL</span><br></pre></td></tr></table></figure><p>也可以用基址加变址方式寻址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MOVBX,OFFSETASCII_TABLE</span><br><span class="line">MOVAL,HEX</span><br><span class="line">XORAH,AH</span><br><span class="line">MOVSI,AX</span><br><span class="line">MOVAL,[BX+SI]</span><br><span class="line">MOVASC,AL</span><br></pre></td></tr></table></figure><h2 id="5-2-分支程序设计">5.2 分支程序设计<a class="anchor" href="#5-2-分支程序设计">·</a></h2><h3 id="例5-3-删除数组中目标元素">例5.3 删除数组中目标元素<a class="anchor" href="#例5-3-删除数组中目标元素">·</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">STACK1SEGMENTPARA STACK</span><br><span class="line">STACK_AREADB100H DUP(?)</span><br><span class="line">STACK1 ENDS</span><br><span class="line"></span><br><span class="line">DATASEGMENT</span><br><span class="line">TABLE_LENEQU20</span><br><span class="line">TABLEDWTABLE_LENDUP(?)</span><br><span class="line">TABLE_ENDLABELWORD ;表最后的下一个元素</span><br><span class="line">VALUEDW?;要查找的目标值</span><br><span class="line">DATA ENDS</span><br><span class="line"></span><br><span class="line">CODESEGMENT</span><br><span class="line">ASSUMECS:CODE,SS:STACK1,DS:DATA</span><br><span class="line">MAINPROCFAR</span><br><span class="line">MOVAX,DATA</span><br><span class="line">MOVDS,AX</span><br><span class="line"></span><br><span class="line">SEARCH:MOVBX,OFFSETTABLE</span><br><span class="line">MOVAX,VALUE</span><br><span class="line">CMPAX,[BX]</span><br><span class="line">JEFOUND</span><br><span class="line">INCBX</span><br><span class="line">INCBX ;BX+&#x3D;2</span><br><span class="line">CMPTABLE_END</span><br><span class="line">JBSEARCH</span><br><span class="line">MOVSI,0FFFFH ;没找到</span><br><span class="line">JMPSHORT EXIT</span><br><span class="line"></span><br><span class="line">FOUND:MOVSI,BX</span><br><span class="line">DELETE:CMPBX,TABLE_END</span><br><span class="line">JAEEXIT ;大于等于跳转</span><br><span class="line">MOVAX,[BX+2]</span><br><span class="line">MOV[BX],AX</span><br><span class="line">ADDBX,2</span><br><span class="line">JMPSHORT DELETE</span><br><span class="line"></span><br><span class="line">EXIT:MOVAX,4C00H</span><br><span class="line">INT21H</span><br><span class="line">MAINENDP</span><br><span class="line">CODEENDS</span><br><span class="line">ENDMAIN</span><br></pre></td></tr></table></figure><h3 id="例5-4：跳转表">例5.4：跳转表<a class="anchor" href="#例5-4：跳转表">·</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">STACK0 SEGMENT PARA STACK</span><br><span class="line">STACK_AREADW 100H DUP(?)</span><br><span class="line">STACK0 ENDS</span><br><span class="line"></span><br><span class="line">DATA SEGMENTPARA</span><br><span class="line">N EQU 5</span><br><span class="line">JMP_TABLEDWROAD1,ROAD2,ROAD3,ROAD4,ROAD5</span><br><span class="line">IDW 3</span><br><span class="line">DATA ENDS</span><br><span class="line"></span><br><span class="line">CODE SEGMENTPARA</span><br><span class="line">ASSUME CS:CODE,DS:DATA,SS:STACK0</span><br><span class="line">MAIN PROC FAR</span><br><span class="line">MOVAX,DATA</span><br><span class="line">MOV DS,AX</span><br><span class="line">MOVBX,I</span><br><span class="line">DECBX</span><br><span class="line">SHLBX,1</span><br><span class="line">JMP JMP_TABLE[BX]</span><br><span class="line">ROAD1:MOVAH,2</span><br><span class="line">MOVDL,31H</span><br><span class="line">INT 21H</span><br><span class="line">JMP EXIT</span><br><span class="line">ROAD2:MOVAH,2</span><br><span class="line">MOVDL,32H</span><br><span class="line">INT 21H</span><br><span class="line">JMP EXIT</span><br><span class="line">ROAD3:MOVAH,2</span><br><span class="line">MOVDL,33H</span><br><span class="line">INT 21H</span><br><span class="line">JMP EXIT</span><br><span class="line">ROAD4:MOVAH,2</span><br><span class="line">MOVDL,34H</span><br><span class="line">INT 21H</span><br><span class="line">JMP EXIT</span><br><span class="line">ROAD5:MOVAH,2</span><br><span class="line">MOVDL,35H</span><br><span class="line">INT 21H</span><br><span class="line">JMP EXIT</span><br><span class="line">EXIT:MOV AX,4C00H</span><br><span class="line">INT 21H</span><br><span class="line">MAIN ENDP</span><br><span class="line">CODE ENDS</span><br><span class="line">END MAIN</span><br></pre></td></tr></table></figure><h2 id="5-3-循环程序设计">5.3 循环程序设计<a class="anchor" href="#5-3-循环程序设计">·</a></h2><h3 id="与CX搭配使用的循环用法">与CX搭配使用的循环用法<a class="anchor" href="#与CX搭配使用的循环用法">·</a></h3><p>LOOP：先将CX设置为需要循环的次数，循环一次后，LOOP指令先将CX减1，并判断是否为0，不为0则继续循环，反之结束循环</p><p>LOOPE/LOOPZ：在LOOP基础上增加条件ZF==1 ，只有当ZF==1才继续循环</p><p>LOOPNE/LOOPNZ：在LOOP基础上增加条件ZF==0只有当ZF==0才继续循环</p><p>JCXZ：只判断，不递减CX。当CX==0时跳转</p><h3 id="例5-5：内存中的一个字（二进制数）转换为十六进制数，并在屏幕上显示出来">例5.5：内存中的一个字（二进制数）转换为十六进制数，并在屏幕上显示出来<a class="anchor" href="#例5-5：内存中的一个字（二进制数）转换为十六进制数，并在屏幕上显示出来">·</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">STACK1SEGMENT PARA STACK</span><br><span class="line">STACK_AREADB 100H DUP(?)</span><br><span class="line">STACK1ENDS</span><br><span class="line"></span><br><span class="line">DATASEGMENTPARA </span><br><span class="line">VALUEDW0011101000101111B ;3A2F</span><br><span class="line">DATA ENDS</span><br><span class="line"></span><br><span class="line">CODESEGMENTPARA</span><br><span class="line">        ASSUME  CS:CODE,SS:STACK1,DS:DATA</span><br><span class="line">MAINPROC FAR</span><br><span class="line">MOVAX,DATA</span><br><span class="line">MOVDS,AX</span><br><span class="line">MOVBX,VALUE</span><br><span class="line">MOVCX,4 ;循环次数</span><br><span class="line">SHIFT:PUSHCX</span><br><span class="line">MOVCL,4</span><br><span class="line">ROLBX,CL ;BX循环左移4位</span><br><span class="line">MOVAL,BL ;取出低8位</span><br><span class="line">ANDAL,0FH;清除高四位，只留最低四位</span><br><span class="line">ADDAL,30H</span><br><span class="line">CMPAL,39H</span><br><span class="line">JBEPRINT</span><br><span class="line">ADDAL,&#39;A&#39;-&#39;9&#39;-1</span><br><span class="line">PRINT:MOVDL,AL</span><br><span class="line">MOVAH,2</span><br><span class="line">INT 21H</span><br><span class="line">POPCX</span><br><span class="line">LOOPSHIFT</span><br><span class="line">EXIT:MOVAX,4C00H</span><br><span class="line">INT21H</span><br><span class="line">MAINENDP</span><br><span class="line">CODEENDS</span><br><span class="line">END MAIN</span><br></pre></td></tr></table></figure><h3 id="将内存中一个字（二进制或十六进制数）转换成十进制数的ASCII码，并显示出来">将内存中一个字（二进制或十六进制数）转换成十进制数的ASCII码，并显示出来<a class="anchor" href="#将内存中一个字（二进制或十六进制数）转换成十进制数的ASCII码，并显示出来">·</a></h3><h4 id="方法1-例5-6-依次除以10000，1000，100，10，1-得到商">方法1 例5.6 依次除以10000，1000，100，10，1 得到商<a class="anchor" href="#方法1-例5-6-依次除以10000，1000，100，10，1-得到商">·</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">STACK1  SEGMENT PARA STACK</span><br><span class="line">STACK_AREA  DB  100H    DUP(?)</span><br><span class="line">STACK1  ENDS</span><br><span class="line"></span><br><span class="line">DATA    SEGMENT</span><br><span class="line">VALUE   DW      0FFFEH</span><br><span class="line">DIVISOR DW      10000,1000,100,10,1</span><br><span class="line">DATA    ENDS</span><br><span class="line"></span><br><span class="line">CODE    SEGMENT</span><br><span class="line">        ASSUME  CS:CODE,SS:STACK1,DS:DATA</span><br><span class="line">;description</span><br><span class="line">MAIN    PROC</span><br><span class="line">        MOV     AX,DATA</span><br><span class="line">        MOV     DS,AX</span><br><span class="line">        MOV     SI,OFFSET  DIVISOR</span><br><span class="line">        MOV     AX,VALUE</span><br><span class="line">        MOV     CX,5</span><br><span class="line">LP:     XOR     DX,DX ;清空被除数高16位</span><br><span class="line">        DIV     WORD PTR [SI] ;AX&#x3D;AX&#x2F;DIVISOR</span><br><span class="line">        PUSH    DX</span><br><span class="line">        OR      AX,30H ;变成ASCII码</span><br><span class="line">PRINT:  MOV     DL,AL</span><br><span class="line">        MOV     AH,2</span><br><span class="line">        INT     21H</span><br><span class="line">        POP     AX</span><br><span class="line">        ADD     SI,2</span><br><span class="line">        LOOP    LP</span><br><span class="line">EXIT:   MOV     AX,4C00H</span><br><span class="line">        INT     21H</span><br><span class="line">MAIN    ENDP</span><br><span class="line">CODE    ENDS</span><br><span class="line">        END     MAIN</span><br></pre></td></tr></table></figure><h4 id="方法2-例5-7-不断除以10，按顺序所得的余数倒排即为所求">方法2 例5.7 不断除以10，按顺序所得的余数倒排即为所求<a class="anchor" href="#方法2-例5-7-不断除以10，按顺序所得的余数倒排即为所求">·</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">STACK1  SEGMENT PARA STACK</span><br><span class="line">STACK_AREA  DB  100H    DUP(?)</span><br><span class="line">STACK1  ENDS</span><br><span class="line"></span><br><span class="line">DATA    SEGMENT</span><br><span class="line">VALUE   DW      0FFFEH</span><br><span class="line">DATA    ENDS</span><br><span class="line"></span><br><span class="line">CODE    SEGMENT</span><br><span class="line">        ASSUME  CS:CODE,SS:STACK1,DS:DATA</span><br><span class="line">;description</span><br><span class="line">MAIN    PROC</span><br><span class="line">        MOV     AX,DATA</span><br><span class="line">        MOV     DS,AX</span><br><span class="line">        MOV     CX,5</span><br><span class="line">        MOV     AX,VALUE</span><br><span class="line">        MOV     BX,10</span><br><span class="line">LOOP1:  XOR     DX,DX</span><br><span class="line">        DIV     BX</span><br><span class="line">        PUSH    DX</span><br><span class="line">        LOOP    LOOP1</span><br><span class="line">        MOV     CX,5</span><br><span class="line">LOOP2:  POP     AX</span><br><span class="line">        OR      AX,30H</span><br><span class="line">        MOV     DL,AL</span><br><span class="line">        MOV     AH,2</span><br><span class="line">        INT     21H</span><br><span class="line">        LOOP    LOOP2</span><br><span class="line">EXIT:   MOV     AX,4C00H</span><br><span class="line">        INT     21H</span><br><span class="line">MAIN    ENDP</span><br><span class="line">CODE    ENDS</span><br><span class="line">        END     MAIN</span><br></pre></td></tr></table></figure><p>堆栈的出入栈都必须以字为单位！</p><p>内存中组织好一个ASCII字符串，串的有效内容后加一个’$'结束字符，就可以利用DOS的9号功能打印字符串。</p><p>使用如下方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOVDX,串的首地址</span><br><span class="line">MOVAH,9</span><br><span class="line">INT21H</span><br></pre></td></tr></table></figure><h4 id="方法3-例5-8-不断除以10得到商和余数，利用字符串进行输出">方法3 例5.8 不断除以10得到商和余数，利用字符串进行输出<a class="anchor" href="#方法3-例5-8-不断除以10得到商和余数，利用字符串进行输出">·</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">STACK1  SEGMENT PARA STACK</span><br><span class="line">STACK_AREA  DB  100H    DUP(?)</span><br><span class="line">STACK1  ENDS</span><br><span class="line"></span><br><span class="line">DATA    SEGMENT</span><br><span class="line">VALUE   DW      0FFFEH</span><br><span class="line">RES     DB 5 DUP(?),&#39;$&#39;</span><br><span class="line">DATA    ENDS</span><br><span class="line"></span><br><span class="line">CODE    SEGMENT</span><br><span class="line">        ASSUME  CS:CODE,SS:STACK1,DS:DATA</span><br><span class="line">;description</span><br><span class="line">MAIN    PROC</span><br><span class="line">        MOV     AX,DATA</span><br><span class="line">        MOV     DS,AX</span><br><span class="line">        MOV     CX,5</span><br><span class="line">        MOV     AX,VALUE</span><br><span class="line">        MOV     BX,10</span><br><span class="line">        MOV     DI,OFFSET RES + 4</span><br><span class="line">LOOP1:  XOR     DX,DX</span><br><span class="line">        DIV     BX</span><br><span class="line">        OR      DX,30H</span><br><span class="line">        MOV     [DI],DL</span><br><span class="line">        DEC     DI</span><br><span class="line">        LOOP    LOOP1</span><br><span class="line">LOOP2:  MOV     DX,OFFSET RES</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        INT     21H</span><br><span class="line">EXIT:   MOV     AX,4C00H</span><br><span class="line">        INT     21H</span><br><span class="line">MAIN    ENDP</span><br><span class="line">CODE    ENDS</span><br><span class="line">        END     MAIN</span><br></pre></td></tr></table></figure><h3 id="多重循环设计-冒泡排序为例">多重循环设计 冒泡排序为例<a class="anchor" href="#多重循环设计-冒泡排序为例">·</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">STACK1  SEGMENT PARA STACK</span><br><span class="line">STACK_AREA  DW  100H  DUP(?)</span><br><span class="line">STACK1  ENDS</span><br><span class="line"></span><br><span class="line">DATA    SEGMENT PARA</span><br><span class="line">TABLEDATA_LEN   DW  16</span><br><span class="line">TABLEDATA       DW  19,37,35,73,20,06,30,07</span><br><span class="line">                DW  20H,17H,0FFFFH,2001,2022,4,29,56</span><br><span class="line">RES     DB  5  DUP(?),20H,&#39;$&#39; ;十进制最多5位，20H表示空格</span><br><span class="line">STR1    DB  &#39;INIT_ARRAY:&#39;,&#39;$&#39;</span><br><span class="line">STR2    DB  &#39;SORTED_ARRAY:&#39;,&#39;$&#39;       </span><br><span class="line"></span><br><span class="line">NEWLINE     DB  0DH,0AH,&#39;$&#39; ;回车换行</span><br><span class="line">DATA    ENDS</span><br><span class="line"></span><br><span class="line">CODE    SEGMENT PARA</span><br><span class="line">        ASSUME CS:CODE,SS:STACK1,DS:DATA</span><br><span class="line">MAIN    PROC    FAR</span><br><span class="line">        MOV     AX,DATA</span><br><span class="line">        MOV     DS,AX</span><br><span class="line"></span><br><span class="line">PRINT_INIT_ARRAY: ;先打印初始的数组</span><br><span class="line">        MOV     DX,OFFSET STR1</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        INT     21H</span><br><span class="line">        MOV     DX,OFFSET NEWLINE</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        INT     21H</span><br><span class="line">        MOV     CX,TABLEDATA_LEN</span><br><span class="line">        MOV     SI,OFFSET TABLEDATA</span><br><span class="line">WHILE1: </span><br><span class="line">        PUSH    CX</span><br><span class="line">        MOV     CX,5</span><br><span class="line">        MOV     DI,OFFSET RES+4</span><br><span class="line">        MOV     BX,10</span><br><span class="line">        MOV     AX,[SI]</span><br><span class="line">WHILE2:</span><br><span class="line">        XOR     DX,DX</span><br><span class="line">        DIV     BX</span><br><span class="line">        OR      DL,30H</span><br><span class="line">        MOV     [DI],DL</span><br><span class="line">        DEC     DI</span><br><span class="line">        LOOP    WHILE2</span><br><span class="line">        ;打印字符串</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET RES</span><br><span class="line">        INT     21H</span><br><span class="line">        INC     SI</span><br><span class="line">        INC     SI</span><br><span class="line">        POP     CX</span><br><span class="line">        LOOP    WHILE1</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET NEWLINE</span><br><span class="line">        INT     21H</span><br><span class="line"></span><br><span class="line">BUBBLE_SORT: ;冒泡排序</span><br><span class="line">        MOV     CX,TABLEDATA_LEN</span><br><span class="line">SORT_LOOP1: ;外层循环</span><br><span class="line">        PUSH    CX</span><br><span class="line">        MOV     SI,OFFSET TABLEDATA</span><br><span class="line">        MOV     BX,0 ;BX作为一个标志变量，如果一次内层循环后仍然为0，说明已经是按照顺序排列了</span><br><span class="line">SORT_LOOP2: ;内层循环   </span><br><span class="line">        MOV     AX,[SI]</span><br><span class="line">        CMP     AX,[SI+2]</span><br><span class="line">        JNA     CONTINUE     </span><br><span class="line">SWAP:   </span><br><span class="line">        MOV     BX,1</span><br><span class="line">        XCHG    AX,[SI+2]</span><br><span class="line">        MOV     [SI],AX</span><br><span class="line">CONTINUE:</span><br><span class="line">        ADD     SI,2</span><br><span class="line">        LOOP    SORT_LOOP2</span><br><span class="line">        POP     CX</span><br><span class="line">        CMP     BX,0</span><br><span class="line">        JZ      PRINT_SORTED_ARRAY</span><br><span class="line">        LOOP    SORT_LOOP1</span><br><span class="line"></span><br><span class="line">PRINT_SORTED_ARRAY: ;打印排序后的数组</span><br><span class="line">        MOV     DX,OFFSET STR2</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        INT     21H</span><br><span class="line">        MOV     DX,OFFSET NEWLINE</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        INT     21H</span><br><span class="line">        MOV     CX,TABLEDATA_LEN</span><br><span class="line">        MOV     SI,OFFSET TABLEDATA</span><br><span class="line">WHILE3: </span><br><span class="line">        PUSH    CX</span><br><span class="line">        MOV     CX,5</span><br><span class="line">        MOV     DI,OFFSET RES+4</span><br><span class="line">        MOV     BX,10</span><br><span class="line">        MOV     AX,[SI]</span><br><span class="line">WHILE4:</span><br><span class="line">        XOR     DX,DX</span><br><span class="line">        DIV     BX</span><br><span class="line">        OR      DL,30H</span><br><span class="line">        MOV     [DI],DL</span><br><span class="line">        DEC     DI</span><br><span class="line">        LOOP    WHILE4</span><br><span class="line">        ;打印字符串</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET RES</span><br><span class="line">        INT     21H</span><br><span class="line">        INC     SI</span><br><span class="line">        INC     SI</span><br><span class="line">        POP     CX</span><br><span class="line">        LOOP    WHILE3</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET NEWLINE</span><br><span class="line">        INT     21H</span><br><span class="line"></span><br><span class="line">EXIT:   MOV     AX,4C00H</span><br><span class="line">        INT     21H</span><br><span class="line">MAIN    ENDP</span><br><span class="line">CODE    ENDS</span><br><span class="line">        END     MAIN</span><br></pre></td></tr></table></figure><h2 id="5-4-串处理">5.4 串处理<a class="anchor" href="#5-4-串处理">·</a></h2><h3 id="串处理指令">串处理指令<a class="anchor" href="#串处理指令">·</a></h3><p>典型的寻址过程是：DS:[SI]==&gt;ES:[DI]</p><p>目的串——ES[DI] 即从这里取出</p><p>源串——DS[SI] 即写入这里</p><h4 id="取串指令LODSB-LODSW">取串指令LODSB/LODSW<a class="anchor" href="#取串指令LODSB-LODSW">·</a></h4><p>LODSB将源串DS:[SI]的一个字节或一个字取到AL或AX中。</p><p>操作完后，按照DF的值自动修改SI的值。</p><p>DF=0则对SI+1或+2（根据字节或字）</p><p>DF=1则对SI-1或-2（根据字节或字）</p><h4 id="存串指令STOSB-STOSW">存串指令STOSB/STOSW<a class="anchor" href="#存串指令STOSB-STOSW">·</a></h4><p>将AL或AX中的一个字节或字存入ES:[DI]中</p><p>操作完后，根据DF的值修改DI</p><p>DF=0则对DI +1或+2（根据字节或字）</p><p>DF=1则对DI -1或-2（根据字节或字）</p><h4 id="串传送指令MOVSB-MOVSW">串传送指令MOVSB/MOVSW<a class="anchor" href="#串传送指令MOVSB-MOVSW">·</a></h4><p>将DS:[SI]中的字节或字传送到ES:[DI]中</p><p>操作完后，根据DF的值同时修改SI与DI</p><p>DF=0则SI与DI都+1或+2</p><p>DF=1则SI与DI都-1或-2</p><h4 id="串比较指令CMPSB-CMPSW">串比较指令CMPSB/CMPSW<a class="anchor" href="#串比较指令CMPSB-CMPSW">·</a></h4><p>比较源串DS:[SI]与目的串ES:[DI]中的一个字节或一个字，与CMP类似</p><p>比较时，用源串中一个字节（字）减去目的串中一个字节（字）</p><p>不保留结果但影响标志寄存器，如CF,SF,ZF</p><p>执行完后根据DF值修改SI/DI</p><h4 id="串扫描指令SCASB-SCASW">串扫描指令SCASB/SCASW<a class="anchor" href="#串扫描指令SCASB-SCASW">·</a></h4><p>在ES:[DI]中指定的目的串中扫描是否含有AL或AX中指定的字节或字，用AL或AX的内容减去ES:[DI]中的字节或字，比较结果影响标志寄存器。</p><p>执行完后根据DF值修改SI/DI</p><h4 id="重复前缀指令REP">重复前缀指令REP<a class="anchor" href="#重复前缀指令REP">·</a></h4><p>格式：REP 串操作指令</p><p>比如：REPMOVSB</p><p>类似LOOP</p><p>每执行一次串操作指令就CX-1，直到CX为0时停止</p><h4 id="条件重复前缀指令REPE-REPZ-REPNE-REPNZ">条件重复前缀指令REPE/REPZ REPNE/REPNZ<a class="anchor" href="#条件重复前缀指令REPE-REPZ-REPNE-REPNZ">·</a></h4><h5 id="REPE-REPZ">REPE/REPZ<a class="anchor" href="#REPE-REPZ">·</a></h5><p>当CX==0或ZF==0时退出串操作指令，即运算结果不为0时退出</p><p>CX-=1</p><h5 id="REPNE-REPNZ">REPNE/REPNZ<a class="anchor" href="#REPNE-REPNZ">·</a></h5><p>CX==0或ZF==1时退出串操作指令，即运算结果为0时退出</p><p>CX-=1</p><h4 id="修改DF方向标志命令CLD，STD">修改DF方向标志命令CLD，STD<a class="anchor" href="#修改DF方向标志命令CLD，STD">·</a></h4><p>CLD清除DF标志寄存器，使得DF=0</p><p>STD设置DF标志寄存器，是的DF=1</p><h3 id="串处理指令应用">串处理指令应用<a class="anchor" href="#串处理指令应用">·</a></h3><p>使用串处理的步骤</p><ul><li>根据需要设置DS,SI,ES,DI</li><li>设置DF标志</li><li>设置CX值</li><li>选用REP，REPZ/REPE、REPNZ/REPNE</li></ul><h4 id="例5-10-5-14">例5.10-5.14<a class="anchor" href="#例5-10-5-14">·</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line">STACK1  SEGMENT PARA    STACK</span><br><span class="line">STACK_AREA  DW  100H    DUP(?)</span><br><span class="line">STACK1  ENDS</span><br><span class="line"></span><br><span class="line">DATA    SEGMENT PARA</span><br><span class="line">LEN     DW  8</span><br><span class="line">BUFF    DB  &#39;19373573&#39;,&#39;$&#39;</span><br><span class="line">BUFF1   DB  &#39;20131839&#39;,&#39;$&#39;</span><br><span class="line">BUFF2   DB  &#39;33839230&#39;,&#39;$&#39;</span><br><span class="line">BUFF3   DB  &#39;abcdEFZc&#39;,&#39;$&#39;</span><br><span class="line">BUFF4   DB  &#39;AKSHBASB&#39;,&#39;$&#39;</span><br><span class="line">BUFF5   DB  &#39;ASNSODOJ&#39;,&#39;$&#39;</span><br><span class="line">STR1    DB  &#39;P_5_10:&#39;,&#39;$&#39;</span><br><span class="line">STR2    DB  &#39;P_5_11:&#39;,&#39;$&#39;</span><br><span class="line">STR3    DB  &#39;P_5_12:&#39;,&#39;$&#39;</span><br><span class="line">STR4    DB  &#39;P_5_13:&#39;,&#39;$&#39;</span><br><span class="line">STR5    DB  &#39;P_5_14:&#39;,&#39;$&#39;</span><br><span class="line">BIG_STR DB  &#39;BUFF4&gt;BUFF5&#39;,&#39;$&#39;</span><br><span class="line">SMALL_STR DB &#39;BUFF4&lt;BUFF5&#39;,&#39;$&#39;</span><br><span class="line">NEW_LINE    DB 0DH,0AH,&#39;$&#39;</span><br><span class="line">FIND_STR  DB &#39;BUFF5 CONTAINS A&#39;,&#39;$&#39;</span><br><span class="line">DATA    ENDS</span><br><span class="line"></span><br><span class="line">CODE    SEGMENT PARA</span><br><span class="line">        ASSUME  CS:CODE,DS:DATA,SS:STACK1</span><br><span class="line">MAIN    PROC    FAR</span><br><span class="line">        ;INIT</span><br><span class="line">        MOV     AX,DATA</span><br><span class="line">        MOV     DS,AX</span><br><span class="line">P_5_10:</span><br><span class="line">        ;PRINT</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET STR1</span><br><span class="line">        INT     21H</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET NEW_LINE</span><br><span class="line">        INT     21H</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET BUFF</span><br><span class="line">        INT     21H</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET NEW_LINE</span><br><span class="line">        INT     21H</span><br><span class="line">        ;SAVE ES AND SET ES TO DS</span><br><span class="line">        PUSH    ES</span><br><span class="line">        PUSH    DS</span><br><span class="line">        POP     ES</span><br><span class="line">        ;STOSB</span><br><span class="line">        CLD</span><br><span class="line">        MOV     CX,LEN</span><br><span class="line">        MOV     DI,OFFSET BUFF</span><br><span class="line">        MOV     AL,0</span><br><span class="line">        REP     STOSB  </span><br><span class="line">        POP     ES </span><br><span class="line">        ;PRINT</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET BUFF</span><br><span class="line">        INT     21H</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET NEW_LINE</span><br><span class="line">        INT     21H</span><br><span class="line">P_5_11:</span><br><span class="line">        ;PRINT</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET STR2</span><br><span class="line">        INT     21H</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET NEW_LINE</span><br><span class="line">        INT     21H</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET BUFF1</span><br><span class="line">        INT     21H</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET NEW_LINE</span><br><span class="line">        INT     21H</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET BUFF2</span><br><span class="line">        INT     21H</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET NEW_LINE</span><br><span class="line">        INT     21H</span><br><span class="line">        ;SAVE ES AND SET ES TO DS</span><br><span class="line">        PUSH    ES</span><br><span class="line">        PUSH    DS</span><br><span class="line">        POP     ES</span><br><span class="line">        ;MOVSB</span><br><span class="line">        CLD</span><br><span class="line">        MOV     CX,LEN</span><br><span class="line">        MOV     DI,OFFSET BUFF2</span><br><span class="line">        MOV     SI,OFFSET BUFF1</span><br><span class="line">        REP     MOVSB</span><br><span class="line">        POP     ES </span><br><span class="line">        ;PRINT</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET BUFF1</span><br><span class="line">        INT     21H</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET NEW_LINE</span><br><span class="line">        INT     21H</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET BUFF2</span><br><span class="line">        INT     21H</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET NEW_LINE</span><br><span class="line">        INT     21H</span><br><span class="line">P_5_12:</span><br><span class="line">        ;PRINT</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET STR3</span><br><span class="line">        INT     21H</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET NEW_LINE</span><br><span class="line">        INT     21H</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET BUFF3</span><br><span class="line">        INT     21H</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET NEW_LINE</span><br><span class="line">        INT     21H</span><br><span class="line">        ;SAVE ES AND SET ES TO DS</span><br><span class="line">        PUSH    ES</span><br><span class="line">        PUSH    DS</span><br><span class="line">        POP     ES</span><br><span class="line">        ;STOSB,LODSB</span><br><span class="line">        CLD</span><br><span class="line">        MOV     CX,LEN</span><br><span class="line">        MOV     DI,OFFSET BUFF3</span><br><span class="line">        MOV     SI,OFFSET BUFF3</span><br><span class="line">WHILE1:  </span><br><span class="line">        LODSB</span><br><span class="line">        CMP     AL,&#39;a&#39;</span><br><span class="line">        JB      NEXT     </span><br><span class="line">        CMP     AL,&#39;z&#39;</span><br><span class="line">        JG      NEXT</span><br><span class="line">        SUB     AL,20H</span><br><span class="line">        STOSB</span><br><span class="line">        JMP     NEXT1</span><br><span class="line">NEXT:   INC     DI</span><br><span class="line">NEXT1:  LOOP    WHILE1</span><br><span class="line">        POP     ES </span><br><span class="line">        ;PRINT</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET BUFF3</span><br><span class="line">        INT     21H</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET NEW_LINE</span><br><span class="line">        INT     21H</span><br><span class="line"></span><br><span class="line">P_5_13:</span><br><span class="line">        ;PRINT</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET STR4</span><br><span class="line">        INT     21H</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET NEW_LINE</span><br><span class="line">        INT     21H</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET BUFF4</span><br><span class="line">        INT     21H</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET NEW_LINE</span><br><span class="line">        INT     21H</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET BUFF5</span><br><span class="line">        INT     21H</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET NEW_LINE</span><br><span class="line">        INT     21H</span><br><span class="line">        ;SAVE ES AND SET ES TO DS</span><br><span class="line">        PUSH    ES</span><br><span class="line">        PUSH    DS</span><br><span class="line">        POP     ES</span><br><span class="line">        ;CMPSB</span><br><span class="line">        CLD</span><br><span class="line">        MOV     CX,LEN</span><br><span class="line">        MOV     DI,OFFSET BUFF5</span><br><span class="line">        MOV     SI,OFFSET BUFF4</span><br><span class="line">        JMP     WHILE3</span><br><span class="line">WHILE2: ;WAY1</span><br><span class="line">        CMPSB   </span><br><span class="line">        JB      SMALLER</span><br><span class="line">        JG      BIGGER</span><br><span class="line">        LOOP    WHILE2</span><br><span class="line">WHILE3: ;WAY2</span><br><span class="line">        REPZ    CMPSB</span><br><span class="line">        JB      SMALLER</span><br><span class="line">        JA      BIGGER   </span><br><span class="line">BIGGER: ;SRC&gt;DST</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET   BIG_STR</span><br><span class="line">        INT     21H</span><br><span class="line">        JMP     END_P_5_13</span><br><span class="line">SMALLER: ;SRC&lt;DST</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET   SMALL_STR</span><br><span class="line">        INT     21H</span><br><span class="line">END_P_5_13:</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET NEW_LINE</span><br><span class="line">        INT     21H</span><br><span class="line"></span><br><span class="line">P_5_14: ;跑不通，原因不详</span><br><span class="line">        PUSH    ES</span><br><span class="line">        PUSH    DS</span><br><span class="line">        POP     ES</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET STR5</span><br><span class="line">        INT     21H</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     DX,OFFSET NEW_LINE</span><br><span class="line">        INT     21H</span><br><span class="line">        MOV     AL,&#39;A&#39;</span><br><span class="line">        CLD</span><br><span class="line">        MOV     CX,LEN</span><br><span class="line">        MOV     DI,OFFSET BUFF5</span><br><span class="line">        REPNZ   SCASB</span><br><span class="line">        POP     ES</span><br><span class="line">        JNZ     EXIT</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        MOV     AX,OFFSET BUFF5</span><br><span class="line">        INT     21H</span><br><span class="line">EXIT:   MOV     AX,4C00H</span><br><span class="line">        INT     21H</span><br><span class="line">MAIN    ENDP</span><br><span class="line">CODE    ENDS</span><br><span class="line">        END     MAIN</span><br></pre></td></tr></table></figure><h1 id="第6章-子程序结构">第6章 子程序结构<a class="anchor" href="#第6章-子程序结构">·</a></h1><h2 id="6-1-子程序设计方法">6.1 子程序设计方法<a class="anchor" href="#6-1-子程序设计方法">·</a></h2><h3 id="过程定义">过程定义<a class="anchor" href="#过程定义">·</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PROC_NAMEPROCFAR ;默认为NEAR</span><br><span class="line">...</span><br><span class="line">PROC_NAMEENDP</span><br></pre></td></tr></table></figure><h3 id="过程调用与返回">过程调用与返回<a class="anchor" href="#过程调用与返回">·</a></h3><p>使用CALL进行调用，RET返回调用者程序</p><p>CALL和RET都有FAR和NEAR属性</p><p>段内调用和返回使用NEAR，段间调用与返回使用FAR</p><p>段间返回的RET指令经汇编后会变成RETF</p><p>如果调用指令和所定义过程在<strong>同一代码段</strong>，则定义为<strong>NEAR</strong>属性，可省略NEAR</p><p>调用指令与所定义过程<strong>不在一个代码段</strong>，则定义为<strong>FAR</strong>属性。</p><h2 id="6-2-编写子程序注意事项">6.2 编写子程序注意事项<a class="anchor" href="#6-2-编写子程序注意事项">·</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">DISPLAY_STRING  PROC     FAR</span><br><span class="line">        PUSH    AX</span><br><span class="line">        MOV     AH,2</span><br><span class="line">        INT     21H</span><br><span class="line">        POP     AX</span><br><span class="line">        RET</span><br><span class="line">DISPLAY_STRING  ENDP</span><br><span class="line">DISPLAY_CHAR    PROC     FAR</span><br><span class="line">        PUSH    AX</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        INT     21H</span><br><span class="line">        PUSH    DX</span><br><span class="line">        MOV     DX,OFFSET NEW_LINE ;打印换行符</span><br><span class="line">        MOV     AH,9</span><br><span class="line">        INT     21H</span><br><span class="line">        POP     DX</span><br><span class="line">        POP     AX</span><br><span class="line">        RET</span><br><span class="line">DISPLAY_CHAR    ENDP</span><br></pre></td></tr></table></figure><h3 id="确定接口参数与传参">确定接口参数与传参<a class="anchor" href="#确定接口参数与传参">·</a></h3><ul><li>使用寄存器</li><li>使用约定的内存变量</li><li>使用堆栈</li></ul><h1 id="第7章-高级汇编语言技术">第7章 高级汇编语言技术<a class="anchor" href="#第7章-高级汇编语言技术">·</a></h1><h2 id="7-1-宏">7.1 宏<a class="anchor" href="#7-1-宏">·</a></h2><h3 id="宏定义">宏定义<a class="anchor" href="#宏定义">·</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">宏名MACRO[形参表]</span><br><span class="line"> ...</span><br><span class="line"> ENDM</span><br></pre></td></tr></table></figure><h3 id="例子">例子<a class="anchor" href="#例子">·</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PRINTCHAR MACRO</span><br><span class="line">ORDL,30H</span><br><span class="line">MOVAH,2</span><br><span class="line">INT21H</span><br><span class="line">ENDM</span><br><span class="line">PRINTCHAR1MACROREG</span><br><span class="line">MOVDL,REG</span><br><span class="line">ORDL,30H</span><br><span class="line">MOVAH,2</span><br><span class="line">INT21H</span><br><span class="line">ENDM</span><br><span class="line">PRINCHARS   MACRO REG1,REG2</span><br><span class="line">            MOV DL,REG1</span><br><span class="line">            MOV AH,2</span><br><span class="line">            INT 21H</span><br><span class="line">            MOV DL,REG2</span><br><span class="line">            MOV AH,2</span><br><span class="line">            INT 21H</span><br><span class="line">            ENDM</span><br><span class="line">PRINCHARS AL,BL</span><br></pre></td></tr></table></figure><h2 id="7-2-结构">7.2 结构<a class="anchor" href="#7-2-结构">·</a></h2><h3 id="定义">定义<a class="anchor" href="#定义">·</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">结构名STRUC</span><br><span class="line">...</span><br><span class="line">结构名ENDS</span><br><span class="line"></span><br><span class="line">;如,描述学生</span><br><span class="line">STUDENTSTRUC</span><br><span class="line">CLASSDB8 DUP(?) ;班号</span><br><span class="line">NUMDW? ;学号</span><br><span class="line">NAME1DB20 DUP(? ) ;名字</span><br><span class="line">STEDENTENDS</span><br></pre></td></tr></table></figure><h3 id="结构的预置与内存分配">结构的预置与内存分配<a class="anchor" href="#结构的预置与内存分配">·</a></h3><h4 id="结构预置定义">结构预置定义<a class="anchor" href="#结构预置定义">·</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">结构变量名结构名 &lt;字段值表&gt;</span><br><span class="line">STUDENT1STUDENT&lt;&#39;19373000&#39;,01,&#39;SHARP&#39;&gt;</span><br><span class="line">STUDENTSSTUDENT28DUP(&lt;&#39;19373000&#39;,01,&#39;SHARP&#39;&gt;)</span><br></pre></td></tr></table></figure><h4 id="访问结构变量及其字段">访问结构变量及其字段<a class="anchor" href="#访问结构变量及其字段">·</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MOVCX,TYPESTUDENT1;CX&#x3D;30 是结构体的长度</span><br><span class="line">MOVBX,OFFSET STUDENT1;BX&#x3D;STUDENT1的偏移值</span><br><span class="line">MOVCX,LENGTH STUDENT1  ;CX&#x3D;1</span><br><span class="line">MOVCX,LENGTH STUDENTS;CX&#x3D;28</span><br><span class="line">MOVCX,SIZESTUDENTS;CX&#x3D;28*30</span><br><span class="line"></span><br><span class="line">MOVSI,OFFSETSTUDENT1.NUM ;获得结构体中NUM变量的首地址</span><br><span class="line">MOVAX,[SI].NUM[1]</span><br><span class="line">MOVAX,STUDENT1.NUM[1]</span><br><span class="line">MOVAX,STUDENT1.NUM+1</span><br></pre></td></tr></table></figure><h1 id="第8章-输入-输出程序设计">第8章 输入/输出程序设计<a class="anchor" href="#第8章-输入-输出程序设计">·</a></h1><h2 id="8-1-输入-输出指令">8.1 输入/输出指令<a class="anchor" href="#8-1-输入-输出指令">·</a></h2><p>Intel 8086/8088内存寻址空间为1MB，而I/O空间为64KB</p><h3 id="IN-OUT指令">IN/OUT指令<a class="anchor" href="#IN-OUT指令">·</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IN OP1,OP2 ;OP1为AL&#x2F;AX OP2为输入端口地址或DX(用来存放端口地址)</span><br><span class="line">OUT OP1,OP2 ;OP1为输出端口地址或DX，OP2为AL&#x2F;AX</span><br></pre></td></tr></table></figure><h2 id="8-2-输入-输出控制方式">8.2 输入/输出控制方式<a class="anchor" href="#8-2-输入-输出控制方式">·</a></h2><h3 id="程序控制的I-O方式">程序控制的I/O方式<a class="anchor" href="#程序控制的I-O方式">·</a></h3><h4 id="立即传送方式">立即传送方式<a class="anchor" href="#立即传送方式">·</a></h4><h4 id="程序查询方法">程序查询方法<a class="anchor" href="#程序查询方法">·</a></h4><h3 id="中断控制方式">中断控制方式<a class="anchor" href="#中断控制方式">·</a></h3><h3 id="直接内存访问方式-DMA">直接内存访问方式 DMA<a class="anchor" href="#直接内存访问方式-DMA">·</a></h3><h2 id="8-3-中断控制方式">8.3 中断控制方式<a class="anchor" href="#8-3-中断控制方式">·</a></h2><h3 id="中断">中断<a class="anchor" href="#中断">·</a></h3><h3 id="中断源">中断源<a class="anchor" href="#中断源">·</a></h3><h4 id="内中断">内中断<a class="anchor" href="#内中断">·</a></h4><h4 id="外中断">外中断<a class="anchor" href="#外中断">·</a></h4><h3 id="中断优先级">中断优先级<a class="anchor" href="#中断优先级">·</a></h3><h3 id="中断向量表">中断向量表<a class="anchor" href="#中断向量表">·</a></h3><h3 id="中断过程">中断过程<a class="anchor" href="#中断过程">·</a></h3><h2 id="8-4-编写中断处理程序">8.4 编写中断处理程序<a class="anchor" href="#8-4-编写中断处理程序">·</a></h2>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> assembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP入门学习笔记</title>
      <link href="2022/04/13/NLP-Intro-Learning-Note/"/>
      <url>2022/04/13/NLP-Intro-Learning-Note/</url>
      
        <content type="html"><![CDATA[<h1 id="Part0-简介">Part0 简介<a class="anchor" href="#Part0-简介">·</a></h1><p>本文是笔者为了准备暑期实验室实习而写的NLP入门学习纲要，学习的内容和分类主要来自老师的建议和这篇原北航学姐的文章：https://mp.weixin.qq.com/s/49k1NLxfTSXK185RCoASxA</p><p>学习过程中参考了<a href="https://zh-v2.d2l.ai/" target="_blank" rel="noopener">李沐老师的课程</a>，本文仅作为一个纲要梳理学习的大致内容，以及记录一些实践练习收获。</p><p>用以下<strong>两个博客</strong>记录具体学习内容：</p><ul><li><a href="https://buaadreamer.top/2022/03/19/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">动手学深度学习笔记-基础篇</a></li><li><a href="https://buaadreamer.top/2022/05/15/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%8F%90%E5%8D%87%E7%AF%87/">动手学深度学习笔记-提升篇</a></li></ul><p>完成了一系列的代码实践，放在一个仓库里，作为<strong>NLP武器库</strong>：<a href="https://github.com/BUAADreamer/nlpkiller" target="_blank" rel="noopener">nlpkiller</a>，基本实现了本文提到的算法，大多参考或直接复制自沐神的代码。</p><h2 id="时间节点-简要记录">时间节点-简要记录<a class="anchor" href="#时间节点-简要记录">·</a></h2><h3 id="4-13-4-27">4.13-4.27<a class="anchor" href="#4-13-4-27">·</a></h3><ul><li><p>学习了动手学习深度学习前8章除了现代CNN之外的内容，大致有pytorch基本应用，mlp,cnn,rnn等。</p></li><li><p>编写了nn框架 <a href="https://github.com/BUAADreamer/nnplayer" target="_blank" rel="noopener">nnplayer</a></p></li><li><p>学习d2l代码实现了基本的rnn语言模型，包含预处理与模型训练预测。</p></li></ul><h3 id="4-28-5-11">4.28-5.11<a class="anchor" href="#4-28-5-11">·</a></h3><ul><li>学习了动手学习深度学习第9章内容，熟悉GRU,LSTM</li></ul><h3 id="5-12-5-25">5.12-5.25<a class="anchor" href="#5-12-5-25">·</a></h3><ul><li>学习动手学习深度学习第10章内容，熟悉了注意力机制</li><li>结合软件杯的摘要生成任务，学习了相关的一些seq2seq语言模型，了解了一种先抽取后生成的摘要生成模型</li><li>熟悉了ACT实验室的GPU集群的用法，并在上面完整训练了2个端到端模型并做了测试，在华为云服务器上部署了摘要生成模型，提供了接口</li></ul><h3 id="5-26-6-8">5.26-6.8<a class="anchor" href="#5-26-6-8">·</a></h3><ul><li>进一步学习注意力机制和transformer</li><li>结合摘要生成题目进行相关实践</li></ul><h3 id="6-8-7-1">6.8-7.1<a class="anchor" href="#6-8-7-1">·</a></h3><p>复习准备考试，没有学习</p><h3 id="7-1-8-17">7.1-8.17<a class="anchor" href="#7-1-8-17">·</a></h3><ul><li><p>完成了中国软件杯智能创作平台的比赛</p></li><li><p>学习了常见的<strong>摘要抽取</strong>算法：</p><ul><li><p>TextRank</p></li><li><p>基于Bert的句子编码+聚类/DGCNN</p></li></ul></li><li><p>学习了常见的<strong>NLP数据预处理</strong>方法，一般来说就是</p><ul><li><p>数据获取（爬虫/广泛搜索）</p></li><li><p>数据清洗（去除一些句子/字词，替换一些句子/字词）</p></li><li><p>数据增强（同/反义词替换，随机替换词/句，随机去除词语）</p></li><li><p>分词（jieba，Bert分词器），去除停用词</p></li></ul></li><li><p>学习了目前比较流行的<strong>标题/摘要生成</strong>方式，发现很少那种长文本-长文本的数据集。最终采用基于<strong>T5-Pegasus的预训练模型</strong>对我们的数据集进行调整的方式。学习了利用FastT5对模型进行了onnx转换和量化压缩。</p></li><li><p>完整的完成了一个NLP项目，从模型设计训练，模型压缩部署，后端构建都有所收获</p></li></ul><h3 id="8-18-8-27">8.18-8.27<a class="anchor" href="#8-18-8-27">·</a></h3><ul><li>复习了CNN，RNN。补充了RNN、注意力机制的代码实现和阅读理解</li><li>学习了编码器-解码器架构</li><li>学习预训练相关知识：Word2Vec，GloVe，BERT，并简单学习和运行了代码</li></ul><h1 id="Part1-基础原理">Part1 基础原理<a class="anchor" href="#Part1-基础原理">·</a></h1><h2 id="todo">todo<a class="anchor" href="#todo">·</a></h2><ul class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> 词向量<ul class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> Word2Vec</li><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> GloVe</li><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> 子词嵌入：fastText，字节对编码</li></ul></li><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> CNN</li><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> RNN</li><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> LSTM</li><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> GRU</li><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> BERT（简要了解GPT、ELMo）</li></ul><h2 id="神经网络">神经网络<a class="anchor" href="#神经网络">·</a></h2><p><img src="/2022/04/13/NLP-Intro-Learning-Note/1.jpg" alt></p><h3 id="词向量">词向量<a class="anchor" href="#词向量">·</a></h3><h4 id="Word2Vec">Word2Vec<a class="anchor" href="#Word2Vec">·</a></h4><p>有跳元模型和连续词袋模型两种，都得到了词语作为中心词和上下文词时的向量</p><h4 id="Glove">Glove<a class="anchor" href="#Glove">·</a></h4><p>对跳元模型的损失函数进行修改，得到了融合全局特征的词向量</p><h3 id="CNN">CNN<a class="anchor" href="#CNN">·</a></h3><p>总的来说CNN的知识包含：</p><ul><li>卷积操作（实际用起来是互相关运算），其中会有填充，步幅等内容，多输入通道会汇合成一个输出通道（求和）</li><li>汇聚（池化），其中也有填充，步幅等内容，每个输入通道单独有一个输出通道</li><li>各种成熟的CNN网络结构</li></ul><h3 id="RNN">RNN<a class="anchor" href="#RNN">·</a></h3><p>基本的RNN就是对MLP加入了隐变量输出H，同时对时间步进行循环，对隐变量进行预测和更新。</p><h3 id="LSTM">LSTM<a class="anchor" href="#LSTM">·</a></h3><p>包含输入门，遗忘门，输出门，候选记忆元，隐状态等。</p><h3 id="BERT">BERT<a class="anchor" href="#BERT">·</a></h3><p>通过使⽤预训练的Transformer编码器，BERT能够基于其双向上下⽂表⽰任何词元。</p><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220823213359539.png" alt="image-20220823213359539"></p><h1 id="Part2-经典模型与技巧">Part2 经典模型与技巧<a class="anchor" href="#Part2-经典模型与技巧">·</a></h1><h2 id="todo-2">todo<a class="anchor" href="#todo-2">·</a></h2><h3 id="文本分类">文本分类<a class="anchor" href="#文本分类">·</a></h3><ul class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> MLP</li><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> CNN</li><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> RNN</li><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> LSTM</li><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> Attention</li><li class="task-list-item"><input class="task-list-item-checkbox" checked disabled type="checkbox"> Transformer</li></ul><h2 id="文本分类-2">文本分类<a class="anchor" href="#文本分类-2">·</a></h2><p><img src="/2022/04/13/NLP-Intro-Learning-Note/2.jpg" alt></p><h3 id="MLP">MLP<a class="anchor" href="#MLP">·</a></h3><p>此部分<strong>要求手写</strong>，不用现成模型。为了学习多层感知机，以及复习神经网络相关内容，笔者在参考一些博客和源码后，实现了一个微型深度学习框架，地址如下：<a href="https://github.com/BUAADreamer/nnplayer" target="_blank" rel="noopener">https://github.com/BUAADreamer/nnplayer</a>，使用方式基本和pytorch类似，之后有时间会不断完善，作为学习各种深度学习模型的一个实践方式，主要使用了numpy库进行矩阵计算和操作，采用面向对象的方式进行编写。目前使用这个框架实现基本的多层感知机demo代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> nnplayer <span class="keyword">as</span> npl</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># build net</span></span><br><span class="line">net = npl.Sequence(npl.Linear(<span class="number">10</span>, <span class="number">6</span>), npl.Sigmoid(), npl.Linear(<span class="number">6</span>, <span class="number">4</span>), npl.Sigmoid())</span><br><span class="line"><span class="comment"># calculate loss </span></span><br><span class="line">loss = npl.MSELoss(net)</span><br><span class="line"><span class="comment"># optimizer</span></span><br><span class="line">optimizer = npl.SGD(net.getParamsList())</span><br><span class="line"><span class="comment"># build the dataset</span></span><br><span class="line">X = np.arange(<span class="number">40</span>).reshape(<span class="number">4</span>, <span class="number">10</span>)</span><br><span class="line">Y = np.arange(<span class="number">16</span>).reshape(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment"># train</span></span><br><span class="line">epoch = <span class="number">100</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(epoch):</span><br><span class="line">    Y_predict = net.forward(X)</span><br><span class="line">    l = loss.loss(Y_predict, Y)</span><br><span class="line">    print(<span class="string">f'epoch<span class="subst">&#123;i + <span class="number">1</span>&#125;</span> loss:<span class="subst">&#123;l.mean()&#125;</span>'</span>)</span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line">l = loss.loss(net.forward(X), Y)</span><br><span class="line">print(l.mean())</span><br></pre></td></tr></table></figure><h3 id="Attention">Attention<a class="anchor" href="#Attention">·</a></h3><p>注意力汇聚，注意力评分函数，Bahdanau注意力，多头注意力，自注意力和位置编码，Transformer</p><h3 id="Transformer">Transformer<a class="anchor" href="#Transformer">·</a></h3><p><img src="https://umeta-model.oss-cn-beijing.aliyuncs.com/documents/image-20220822100053869.png" alt="image-20220822100053869"></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结对编程实录</title>
      <link href="2022/04/04/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E5%AE%9E%E5%BD%95/"/>
      <url>2022/04/04/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E5%AE%9E%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>项目</th><th>内容</th></tr></thead><tbody><tr><td>这个作业属于哪个课程</td><td><a href="https://bbs.csdn.net/forums/BH-SE" target="_blank" rel="noopener">2022春季软件工程（罗杰 任健）</a></td></tr><tr><td>这个作业的要求在哪里</td><td><a href="https://bbs.csdn.net/topics/605443466" target="_blank" rel="noopener">结对编程项目-最长英语单词链</a></td></tr><tr><td>我在这个课程的目标是</td><td>学习软工的项目合作管理知识，提升软件开发技术</td></tr><tr><td>这个作业在哪个具体方面帮助我实现目标</td><td>学习敏捷开发中的PSP与结对编程的思想并付诸实践</td></tr></tbody></table><h1 id="Part0-准备">Part0 准备<a class="anchor" href="#Part0-准备">·</a></h1><h2 id="1-必要信息">1.必要信息<a class="anchor" href="#1-必要信息">·</a></h2><p>教学班级：周二班</p><p>项目地址：<a href="https://github.com/BUAADreamer/Longest-English-word-chain" target="_blank" rel="noopener">https://github.com/BUAADreamer/Longest-English-word-chain</a></p><h2 id="2-PSP开发时间估计">2.PSP开发时间估计<a class="anchor" href="#2-PSP开发时间估计">·</a></h2><table><thead><tr><th style="text-align:left">PSP2.1</th><th style="text-align:left">Personal Software Process Stages</th><th style="text-align:left">预估耗时（分钟）</th></tr></thead><tbody><tr><td style="text-align:left">Planning</td><td style="text-align:left">计划</td><td style="text-align:left">90</td></tr><tr><td style="text-align:left">· Estimate</td><td style="text-align:left">· 估计这个任务需要多少时间</td><td style="text-align:left">90</td></tr><tr><td style="text-align:left">Development</td><td style="text-align:left">开发</td><td style="text-align:left">790</td></tr><tr><td style="text-align:left">· Analysis</td><td style="text-align:left">· 需求分析 (包括学习新技术)</td><td style="text-align:left">60</td></tr><tr><td style="text-align:left">· Design Spec</td><td style="text-align:left">· 生成设计文档</td><td style="text-align:left">30</td></tr><tr><td style="text-align:left">· Design Review</td><td style="text-align:left">· 设计复审 (和同事审核设计文档)</td><td style="text-align:left">30</td></tr><tr><td style="text-align:left">· Coding Standard</td><td style="text-align:left">· 代码规范 (为目前的开发制定合适的规范)</td><td style="text-align:left">10</td></tr><tr><td style="text-align:left">· Design</td><td style="text-align:left">· 具体设计</td><td style="text-align:left">60</td></tr><tr><td style="text-align:left">· Coding</td><td style="text-align:left">· 具体编码</td><td style="text-align:left">360</td></tr><tr><td style="text-align:left">· Code Review</td><td style="text-align:left">· 代码复审</td><td style="text-align:left">60</td></tr><tr><td style="text-align:left">· Test</td><td style="text-align:left">· 测试（自我测试，修改代码，提交修改）</td><td style="text-align:left">180</td></tr><tr><td style="text-align:left">Reporting</td><td style="text-align:left">报告</td><td style="text-align:left">100</td></tr><tr><td style="text-align:left">· Test Report</td><td style="text-align:left">· 测试报告</td><td style="text-align:left">60</td></tr><tr><td style="text-align:left">· Size Measurement</td><td style="text-align:left">· 计算工作量</td><td style="text-align:left">10</td></tr><tr><td style="text-align:left">· Postmortem &amp; Process Improvement Plan</td><td style="text-align:left">· 事后总结, 并提出过程改进计划</td><td style="text-align:left">30</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">合计</td><td style="text-align:left">980</td></tr></tbody></table><h1 id="Part1-设计">Part1 设计<a class="anchor" href="#Part1-设计">·</a></h1><h2 id="3-看教科书和其它资料中关于-Information-Hiding，Interface-Design，Loose-Coupling-的章节，说明你们在结对编程中是如何利用这些方法对接口进行设计的">3.看教科书和其它资料中关于 Information Hiding，Interface Design，Loose Coupling 的章节，说明你们在结对编程中是如何利用这些方法对接口进行设计的<a class="anchor" href="#3-看教科书和其它资料中关于-Information-Hiding，Interface-Design，Loose-Coupling-的章节，说明你们在结对编程中是如何利用这些方法对接口进行设计的">·</a></h2><h3 id="Information-Hiding">Information Hiding<a class="anchor" href="#Information-Hiding">·</a></h3><h4 id="多层设计中的层与层之间加入接口层">多层设计中的层与层之间加入接口层<a class="anchor" href="#多层设计中的层与层之间加入接口层">·</a></h4><p>本次项目的接口层主要是顶层模块和各个模块的接口，使用了一个 <code>List&lt;string&gt; CmdTestInterface.Solve(string[] args)</code> 接口，只需要传递一个 参数字符串列表 <code>args</code>，即可返回最终得到的结果字符串列表</p><h4 id="所有类与类之间都通过接口类访问">所有类与类之间都通过接口类访问<a class="anchor" href="#所有类与类之间都通过接口类访问">·</a></h4><p>此特点主要是通过 <code>CommandParser</code> 和 <code>Core</code> 之间的传递访问接口类 <code>ResultRes</code> 类进行传递</p><p>其中 <code>ParseRes</code> 类包含了允许成环，首尾字母，文件绝对路径字符串，最长的模式，命令字符串这些计算模块需要的数据。<code>ParseRes</code> 的实例既可以通过直接传给 <code>Core</code> 进行处理，也可以通过获得 <code>ParseRes</code> 类的数据进行传递来达到相同目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class ParseRes</span><br><span class="line">&#123;</span><br><span class="line">    public bool enableLoop &#x3D; false;</span><br><span class="line">    public char start;</span><br><span class="line">    public char end;</span><br><span class="line">    public string absolutePathOfWordList &#x3D; &quot;&quot;;</span><br><span class="line">    public int mode &#x3D; 0; &#x2F;&#x2F;最长的模式 0表示单词数量 1表示字母个数</span><br><span class="line">    public HashSet&lt;char&gt; cmdChars;</span><br><span class="line">    public ParseRes(int mode, bool enableLoop, char start, char end, string absolutePathOfWordList, HashSet&lt;char&gt; cmdChars)</span><br><span class="line">    &#123;</span><br><span class="line">        this.enableLoop &#x3D; enableLoop;</span><br><span class="line">        this.mode &#x3D; mode;</span><br><span class="line">        this.start &#x3D; start;</span><br><span class="line">        this.end &#x3D; end;</span><br><span class="line">        this.absolutePathOfWordList &#x3D; absolutePathOfWordList;</span><br><span class="line">        this.cmdChars &#x3D; cmdChars;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类的所有数据成员都是private，所有访问都是通过访问函数实现的">类的所有数据成员都是private，所有访问都是通过访问函数实现的<a class="anchor" href="#类的所有数据成员都是private，所有访问都是通过访问函数实现的">·</a></h4><p>在计算核心模块中，所有的数据都是不可见的，对于外部其他模块来说，这些数据都不能直接访问，只能通过一些接口函数间接修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class CalcuCore</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;数据变量</span><br><span class="line">    private List&lt;string&gt; words;</span><br><span class="line">    private Hashtable graph;</span><br><span class="line">    private Hashtable inDegree;</span><br><span class="line">    private Hashtable word2len;</span><br><span class="line">    private char start;</span><br><span class="line">    private char end;</span><br><span class="line">    private bool enableLoop;</span><br><span class="line">    private int graphMode;</span><br><span class="line">    private int totalCharCount;</span><br><span class="line">    private int MAXLEN &#x3D; 20000;</span><br><span class="line">    private int chainCount;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;方法</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Interface-Design">Interface Design<a class="anchor" href="#Interface-Design">·</a></h3><p>本次项目我们和交换的小组定义了统一的四个 <code>c#</code> 函数接口，如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static int gen_chain_word(List&lt;string&gt; words, List&lt;string&gt; result, char head, char tail, bool enable_loop)</span><br><span class="line"></span><br><span class="line">public static int gen_chains_all(List&lt;string&gt; words, List&lt;string&gt; result)</span><br><span class="line"></span><br><span class="line">public static int gen_chain_word_unique(List&lt;string&gt; words, List&lt;string&gt; result)</span><br><span class="line"></span><br><span class="line">public static int gen_chain_char(List&lt;string&gt; words, List&lt;string&gt; result, char head, char tail, bool enable_loop)</span><br></pre></td></tr></table></figure><p>这四个接口函数都符合单一职责原则和接口隔离原则，即四个接口的设计都首先是功能单一的，而且几乎不可再分，每一个接口函数如果拼凑就冗余，如果细分则显得太琐碎。</p><h3 id="Loose-Coupling">Loose Coupling<a class="anchor" href="#Loose-Coupling">·</a></h3><p>本次 <code>CLI</code> 主程序和 <code>GUI</code> 主程序，<code>Library</code>，<code>Core</code> 四个模块都是松耦合的，即每两个模块之间没有重复的部分。</p><p>可以用下图进行示意</p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-04-04-结对编程实录/loosecoupling.png" style="zoom: 67%;"><p>即 <code>CLI</code> 和 <code>GUI</code> 都调用了 <code>Library</code> 和 <code>Core</code> 中的接口，而每个模块都只处理了自己那部分的事务，其他的功能通过接口调用实现。</p><h2 id="4-计算模块接口的设计与实现过程。设计包括代码如何组织，比如会有几个类，几个函数，他们之间关系如何，关键函数是否需要画出流程图？说明你的算法的关键（不必列出源代码），以及独到之处">4.计算模块接口的设计与实现过程。设计包括代码如何组织，比如会有几个类，几个函数，他们之间关系如何，关键函数是否需要画出流程图？说明你的算法的关键（不必列出源代码），以及独到之处<a class="anchor" href="#4-计算模块接口的设计与实现过程。设计包括代码如何组织，比如会有几个类，几个函数，他们之间关系如何，关键函数是否需要画出流程图？说明你的算法的关键（不必列出源代码），以及独到之处">·</a></h2><h3 id="计算模块接口设计">计算模块接口设计<a class="anchor" href="#计算模块接口设计">·</a></h3><p>由于阅读了后面阶段的要求，并且预先找到了互换模块的小组，所以我们设计了适用于 <code>C#</code> 的类似于官方接口的接口，接口中每个方法的功能，和官方接口同名方法的功能相同。</p><p>接口设计如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static int gen_chain_word(List&lt;string&gt; words, List&lt;string&gt; result, char head, char tail, bool enable_loop);</span><br><span class="line"></span><br><span class="line">public static int gen_chains_all(List&lt;string&gt; words, List&lt;string&gt; result);</span><br><span class="line"></span><br><span class="line">public static int gen_chain_word_unique(List&lt;string&gt; words, List&lt;string&gt; result);</span><br><span class="line"></span><br><span class="line">public static int gen_chain_char(List&lt;string&gt; words, List&lt;string&gt; result, char head, char tail, bool enable_loop);</span><br></pre></td></tr></table></figure><p>我们将这些接口方法整合到了 <code>PairTestInterface</code> 中。在本地测试时，我们通过 <code>CmdTestInterface</code> 接口去驱动测试，调用 <code>PairTestInterface</code> 提供的接口，而 <code>PairTestInterface</code> 提供的接口调用 <code>CalcuCore</code> 中的具体计算方法。</p><p>计算部分的 UML 如下（<code>CalcuCore</code> 中的私有方法因为过多且无需外界关心，故没有列出）：</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-04-04-%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E5%AE%9E%E5%BD%95/UML.jpg" alt="UML"></p><p>接口方法的实现，实际上是首先通过参数去<strong>实例化 <code>CalcuCore</code> 类</strong>（这是我们真正的核心计算类），然后<strong>调用 <code>CalcuCore</code> 类中对应的真正的计算方法</strong> ，之后对返回的结果做<strong>异常处理</strong>，体现了<strong>层次化</strong>的思想。例如：</p><ul><li>对于<code>gen_chain_word</code> ，我们用给定的参数 <code>words</code>、<code>head</code>、<code>tail</code>、<code>enable_loop</code> 以及一些 <code>default</code> 参数（辅助建图）去实例化一个 <code>CalcuCore</code>，然后调用 <code>CalcuCore</code> 中的 <code>getMaxWordCountChain</code> 方法进行具体的计算。</li><li>对于 <code>CalcuCore</code> ：<ul><li>其构造方法会使用 <code>gen_chain_word</code> 给定的参数，进行参数化建图。</li><li><code>getMaxWordCountChain </code> 首先会调用<strong>数据检查方法 <code>dataCheck</code></strong>，去检查数据中<strong>是否有隐含环</strong>以及<strong>是否允许在有环的情况下求解</strong>；如果数据中没有环，则调用<strong>重构图方法 <code>refactorGraph</code> 对图进行预处理</strong>，接着调用<strong>快速算法 <code>fastGetMaxWordCountChain</code></strong> 在 <code>DAG</code> 上跑 <code>dp</code> 求解；如果数据中<strong>有环</strong>，且<strong>要求在有环的情况下求解</strong>，则调用暴力算法 <code>trivialGetMaxWordCountChain</code> 求解最长链。</li></ul></li><li>对于异常：<ul><li>主要是处理<strong>结果过长</strong>以及<strong>数据有环且不能求解</strong>这两种情况。</li></ul></li></ul><h3 id="具体算法设计">具体算法设计<a class="anchor" href="#具体算法设计">·</a></h3><p>首先，如果单词 <code>A</code> 的尾字母和单词 <code>B</code> 的首字母相同，则以 <code>A</code> 和 <code>B</code> 为结点，连接一条从 <code>A</code> 到 <code>B</code> 的有向边，在 $O(n^2)$ 的时间内建立一张有向图。其中 $n$ 是不同单词的种类数。有向图的边权我们并不关心，但是点权的设置要根据情况来：如果我们求解的最长链是以个数为指标，则点权为 1；如果是以字母数为指标，那么点权为单词的长度。</p><p>然后就是每个具体接口的求解算法：</p><p><code>gen_chain_word</code> 的求解算法主要是 <code>getMaxWordCountChain</code> ，而 <code>getMaxWordCountChain</code> 的算法分为两部分。如果图是一个有向无环图，那么可以使用动态规划求解：</p><ul><li><code>dp[word]</code> 表示 <code>word</code> 以 <code>word</code> 结尾的单词链的最长长度，<code>lastWord[word]</code> 表示以 <code>word</code> 结尾的最长链的前驱结点。</li><li>初始化 <code>dp[word]</code> 为 <code>word</code> 的点权，<code>lastWord[word]</code> 为空（即没有前驱）。</li><li>转移时，采用在拓扑排序的基础上进行状态转移的方式，假设 <code>A</code> 是 <code>B</code> 的前驱，那么 <code>dp[B] = max(dp[B], dp[A] + weight[B])</code>，其中 <code>weight[B]</code> 是 <code>B</code> 的点权。假如有 <code>dp[A] + weight[B] &gt; dp[B]</code>，那么还需要更新前驱，即 <code>lastWord[B] = A</code>。</li><li>最终统计答案时，需要看所有点的 <code>dp</code> 值，把最大的那个给记录下来，这就是最长链的长度。由于要求解出一条具体的链，所以还需要通过这条最长链的尾结点，根据 <code>lastWord</code> 去找到所有的前驱，重构出整条链。</li><li>上面的算法过程是假设了没有设置头结点的开头字母。倘若要求指定开头字母的最长链，那么需要先进行重构图操作：做一遍拓扑排序，每次把<strong>入度为 0 且开头字母不是指定字母</strong>的单词加入队列中，等到从队列中弹出时则将其彻底删除掉。这样做完之后，使用剩下的单词重构图，可以保证拓扑序并列第一大的结点都是以给定字母开头，这样可以在重构的图上执行上面几步的操作，即可求出结果。</li><li>时间复杂度为 $O(n^2 + m)$，$n$ 为重构前图的点数，$m$ 为重构后图的边数。</li><li>快速算法的流程图如图所示：<img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-04-04-%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E5%AE%9E%E5%BD%95/fastGetMaxWordCountChain.jpg" alt="fastGetMaxWordCountChain"></li></ul><p>而如果图是一个有环图，那么则使用暴力求解：</p><ul><li>选择一个以给定字母开头的单词，调用 <code>getOneMaxWordCountChain</code> 方法，找到以该单词开头的最长链。在搜索的每一步判断结尾是否符合字母要求，如果符合要求就看能否更新当前的最长链以及长度。在实现 <code>getOneMaxWordCountChain</code>的时候为了加速计算，需要传递一些冗余的参数，比如当前最长链列表。</li><li>暴力算法的流程图如图所示：<img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-04-04-%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E5%AE%9E%E5%BD%95/trivialGetMaxWordCountChain.jpg" alt="trivialGetMaxWordCountChain"></li></ul><p><code>gen_chain_char</code> 和 <code>gen_chain_word</code> 没有本质区别，二者调用的快速算法是同一个方法，暴力算法仅在更新长度时略有不同，故不再赘述。</p><p><code>gen_chain_all</code> 的求解算法是纯暴力搜索：</p><ul><li><p>枚举所有单词作为起点，然后以这个点开始 <code>dfs</code>，求出来以这个点为开头的所有链。</p></li><li><p>由于最终结果不允许超过 <code>20000</code> 字符，所以可以实时统计答案的字符数，超过 <code>20000</code> 就只搜索统计链的个数而不保存具体链的结果，防止内存消耗过大导致程序崩溃。要想在每个链上避免一些重复计算，则需要参数传递时好好考虑，比如传递当前链的时候应该传递最终的字符串而不是单词列表。</p></li><li><p>暴力算法过程大同小异，所以不再重复给出流程图。</p></li></ul><p><code>gen_chain_word_unique</code> 的求解我们组没有按照是否为有向无环图进行分类，因为我们在讨论的时候不确定线性算法的正确性，且在和其他组互测的过程中发现其他组的线性算法似乎存在一定的问题，所以最后统一使用了暴力搜索：</p><ul><li>枚举所有单词作为起点，然后以这个点开始 <code>dfs</code>，需要维护当前的首字母集合，保证在转移的时候不能转移到重复的首字母的单词。</li><li>由于要随时更新已经求得的最长链，所以要把已经求得的最长链作为参数传递下去。</li><li>暴力算法大同小异，所以不再重复给出流程图。</li></ul><p><code>CalcuCore</code> 中方法之间的调用关系示意图如图所示：</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-04-04-%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E5%AE%9E%E5%BD%95/function_relation.jpg" alt="function_relation"></p><p>其中，<code>A -&gt; B</code> 意味着方法 <code>A</code> 调用方法 <code>B</code>。</p><p>在性能方面：</p><ul><li>我们最开始的打算便是所有的求解都复用核心计算函数 <code>getAllWordChain</code>，使用该方法找到所有单词链，最后把合法链挑出来，统计想要计算的结果即可。这样实现的后果是<strong>随手复制英语文章中的两句话都未必能在程序崩溃之前跑出结果</strong>。</li><li>在测好了暴力求解之后，我们发现了<strong>有向无环图</strong>具有优良的性质，可以<strong>按照拓扑序从前往后递推</strong>计算很多信息，所以我们针对 <code>-w</code> 和 <code>-c</code> 进行了建图后拓扑排序 + 动态规划求解不带环的部分。但对于指定 <code>-h</code> 参数，最开始我们没有想到很好的方案。</li><li>后来，我们发现了 <code>-h</code> 的部分可以额外用一遍拓扑排序删去没用但是拓扑序比较靠前的单词，这样得到的新的图就又可以动态规划求解了，所以我们编写了重新建图方法来扩大上面想到的算法的适用范围。至此，<code>-w</code> 和 <code>-c</code> 参数搭配 <code>-h</code> 和 <code>-t</code> 参数，且数据无环时都可以快速求解。</li><li>最后，我们对每种问题的暴力方法根据题目的不同去单独编写：对于 <code>-w</code>，<code>-c</code>，<code>-m</code>，其暴力算法无需保所有的链，所以只需要维护当前链以及已经找到的最长链即可；对于 <code>-n</code>，由于题目要求求出所有的链，但是又要求输出长度不能超过 <code>20000</code>，所以我们在保存链的同时维护了当前结果的长度，如果超过 <code>20000</code> 字符则只统计链的个数，而不保存链，这样就能较好地避免因为链太多导致内存空间消耗过多。</li><li>最后的最后，说下没有优化的 <code>-m</code>。我们注意到有别的组的同学使用动态规划了来解决，但是和他们对拍时发现了他们似乎存在 bug ，且我们组内两人也不确定这是不是假算法，于是就没优化这个部分，所以我们 <code>-m</code> 的求解性能可能相比其他同学要差一些。</li></ul><h2 id="5-阅读有关-UML-的内容，画出-UML-图显示计算模块部分各个实体之间的关系（画一个图即可）">5.阅读有关 UML 的内容，画出 UML 图显示计算模块部分各个实体之间的关系（画一个图即可）<a class="anchor" href="#5-阅读有关-UML-的内容，画出-UML-图显示计算模块部分各个实体之间的关系（画一个图即可）">·</a></h2><p>之前第四部分已经展示过一个UML图大致表现从顶层模块到底层模块的调用关系，这里再仔细展示一下 <code>Core</code> 模块内部的4个类的调用关系，由于本次项目需求并不复杂，因此只使用了一个 <code>CalcuCore</code> 类进行主要的计算逻辑书写，而在计算过程中遇到的异常则进行抛出。内部有几个公共方法供互测接口调用。</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-04-04-%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E5%AE%9E%E5%BD%95/Core.png" alt="UML"></p><h1 id="Part2-编码与测试">Part2 编码与测试<a class="anchor" href="#Part2-编码与测试">·</a></h1><h2 id="6-计算模块接口部分的性能改进。记录在改进计算模块性能上所花费的时间，描述你改进的思路，并展示一张性能分析图（由VS-2019的性能分析工具自动生成），并展示你程序中消耗最大的函数。">6.计算模块接口部分的性能改进。记录在改进计算模块性能上所花费的时间，描述你改进的思路，并展示一张性能分析图（由VS 2019的性能分析工具自动生成），并展示你程序中消耗最大的函数。<a class="anchor" href="#6-计算模块接口部分的性能改进。记录在改进计算模块性能上所花费的时间，描述你改进的思路，并展示一张性能分析图（由VS-2019的性能分析工具自动生成），并展示你程序中消耗最大的函数。">·</a></h2><p>整个性能调优和回归测试上总计花了约 5 小时，调优前：</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-04-04-%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E5%AE%9E%E5%BD%95/before_optimize.jpg" alt="before_optimize"></p><p>优化后：</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-04-04-%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E5%AE%9E%E5%BD%95/after_optimize.png" alt="after_optimize"></p><p>可见优化后只有过于暴力（实际上也只能暴力）的 <code>gen_chain_all</code> 占用 CPU 仍然很高。</p><p>优化后几百个随机单词的有向无环图可以秒出 <code>-w</code>、<code>-c</code>，几十个随机单词的 <code>-r</code> 在对拍时也可以在三五秒之内算出结果。</p><h2 id="7-看-Design-by-Contract，Code-Contract-的内容，并描述这些做法的优缺点，说明你是如何把它们融入结对作业中的。">7.看 Design by Contract，Code Contract 的内容，并描述这些做法的优缺点，说明你是如何把它们融入结对作业中的。<a class="anchor" href="#7-看-Design-by-Contract，Code-Contract-的内容，并描述这些做法的优缺点，说明你是如何把它们融入结对作业中的。">·</a></h2><p>Design by Contract，即契约式设计，在此方面的杰出代表是Eiffel语言，<code>Java</code> 中的 <code>JML</code> 也是契约式设计的具体实例。其中用到的涉及到规则约束和编译检查相关的部分被称为Code Contract</p><p>简单来说就是每个类或者实体方法都需要满足某种前置条件，后置条件和不变式以及其他的状态约束条件，这对于代码的状态有了一个很好的描述。</p><p>本次作业虽然我们没有明确的用这种思想编程，即严格规定每个方法和类的三种状态约束条件，但是在设计 <code>CalcuCore</code> 类时还是确立了在实例化类之前并没有图的建立，实例化之后建立了图结构，而之后在各个函数内部默认前置条件是已经建立了图，不变式为处理的过程不能破坏已有结构图，且始终需要保证是否符合数据约束，后置条件为返回值需要确保是正确结果。<code>Library</code> 中也有类似的函数设计</p><h2 id="8-计算模块部分单元测试展示。展示出项目部分单元测试代码，并说明测试的函数，构造测试数据的思路。并将单元测试得到的测试覆盖率截图，发表在博客中。要求总体覆盖率到-90-以上，否则单元测试部分视作无效。">8.计算模块部分单元测试展示。展示出项目部分单元测试代码，并说明测试的函数，构造测试数据的思路。并将单元测试得到的测试覆盖率截图，发表在博客中。要求总体覆盖率到 90% 以上，否则单元测试部分视作无效。<a class="anchor" href="#8-计算模块部分单元测试展示。展示出项目部分单元测试代码，并说明测试的函数，构造测试数据的思路。并将单元测试得到的测试覆盖率截图，发表在博客中。要求总体覆盖率到-90-以上，否则单元测试部分视作无效。">·</a></h2><p>本次项目我们用两种方式进行测试，一种是 <code>visual studio</code> 内部进行单元测试，另一种是使用 <code>WordList.exe</code> 接口在本地进行大量数据对拍测试。</p><h3 id="单元测试">单元测试<a class="anchor" href="#单元测试">·</a></h3><p>本次项目我们建立了四个单元测试类分别对四个主要模块进行测试</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-04-04-%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E5%AE%9E%E5%BD%95/test1.png" alt></p><p>总的来说，单元测试采用局部和整体两部分测试逻辑。</p><h4 id="局部测试">局部测试<a class="anchor" href="#局部测试">·</a></h4><p>局部的测试主要针对于特定的类的方法进行测试，对于四个接口函数进行单独的样例测试，示例代码如下。数据主要是制造量少但是可以直接看出正确结果的典型数据。力求对输入输出和计算类，异常类中各个函数都有基本的正确性测试检验</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public void CoreTest5()</span><br><span class="line">&#123;</span><br><span class="line">    List&lt;string&gt; words &#x3D; new List&lt;string&gt;() &#123; &quot;gbps&quot;, &quot;generate&quot;, &quot;google&quot;, </span><br><span class="line">                                             &quot;growing&quot;, &quot;handle&quot;, &quot;handling&quot;, &quot;hardware&quot;, &quot;has&quot;&#125;;</span><br><span class="line">    List&lt;string&gt; res &#x3D; new List&lt;string&gt;();</span><br><span class="line">    PairTestInterface.gen_chains_all(words, res);</span><br><span class="line">    Assert.AreEqual(res.Count, 10);</span><br><span class="line"></span><br><span class="line">    res &#x3D; new List&lt;string&gt;();</span><br><span class="line">    PairTestInterface.gen_chain_word(words, res, &#39;g&#39;, &#39;e&#39;, true);</span><br><span class="line">    Assert.AreEqual(res.Count, 2);</span><br><span class="line"></span><br><span class="line">    res &#x3D; new List&lt;string&gt;();</span><br><span class="line">    PairTestInterface.gen_chain_word_unique(words, res);</span><br><span class="line">    Assert.AreEqual(res.Count, 2);</span><br><span class="line"></span><br><span class="line">    res &#x3D; new List&lt;string&gt;();</span><br><span class="line">    PairTestInterface.gen_chain_char(words, res, &#39;i&#39;, &#39;e&#39;, true);</span><br><span class="line">    Assert.AreEqual(res.Count, 0);</span><br><span class="line"></span><br><span class="line">    res &#x3D; new List&lt;string&gt;();</span><br><span class="line">    PairTestInterface.gen_chain_char(words, res, &#39;h&#39;, &#39;t&#39;, false);</span><br><span class="line">    Assert.AreEqual(res.Count, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void InputTest1()</span><br><span class="line">&#123;</span><br><span class="line">    string[] args &#x3D; &#123; &quot;-w&quot; ,&quot;-t&quot;,&quot;a&quot;&#125;;</span><br><span class="line">    CommandParser commandParser &#x3D; new CommandParser(args);</span><br><span class="line">    ParseRes parseRes &#x3D; commandParser.getParseRes();</span><br><span class="line">    Assert.AreEqual(parseRes.mode,1);</span><br><span class="line">    Assert.AreEqual(parseRes.end, &#39;a&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="整体测试">整体测试<a class="anchor" href="#整体测试">·</a></h4><p>整体测试主要是强调将整个预处理到计算的流程完整性，采用大量数据进行测试。由于这样的情况下并无法手动确定出正确结果，因此采用了对拍这一思路，使用和我们组在第四阶段交换的小组的 <code>Core.dll</code> 引入进行测试。具体在测试时调用了如下方法 <code>TestOneSample</code> 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public void TestOneSample(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">    List&lt;string&gt; res;</span><br><span class="line">    List&lt;string&gt; res1;</span><br><span class="line">    int a &#x3D; 0;</span><br><span class="line">    try </span><br><span class="line">    &#123; </span><br><span class="line">        res &#x3D; CmdTestInterface.testOneSample(args);</span><br><span class="line">    &#125;</span><br><span class="line">    catch(Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(e.Message);</span><br><span class="line">        a &#x3D; 1;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            res1 &#x3D; TestOneSampleByOther(args);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e1)</span><br><span class="line">        &#123;</span><br><span class="line">            a &#x3D; 2;</span><br><span class="line">            Console.WriteLine(e1.Message);</span><br><span class="line">        &#125;</span><br><span class="line">        Assert.AreEqual(2, a);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        res1 &#x3D; TestOneSampleByOther(args);</span><br><span class="line">        Assert.AreEqual(res.Count, res1.Count);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        a &#x3D; 1;</span><br><span class="line">        printArgs(args);</span><br><span class="line">        Assert.AreEqual(2, a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>CmdTestInterface.testOneSample</code> 方法是我们定义的一个顶层接口，输入参数列表，返回字符串列表形式的结果。<code>TestOneSampleByOther</code> 则是调用交换的小组的 <code>core</code> 进行计算逻辑，而其他的输入输出使用我们自己的代码进行处理。这两个函数都运行之后，将得到的两个结果进行比较即可判定整体的正确性。即类似计算机网络中的 <code>ping</code> 通，一旦可以跑完就说明整个流程都是正确的。</p><p>数据生成上主要包含回归测试和指令组合覆盖性测试。对于每一个文件都使用四层循环遍历所有可能的两两指令组合以及首尾字母组合，覆盖性测试代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public void CoreTest2()</span><br><span class="line">&#123;</span><br><span class="line">    int testNum &#x3D; 5;</span><br><span class="line">    String baseFile &#x3D; &quot;C:&#x2F;Users&#x2F;fzc&#x2F;source&#x2F;repos&#x2F;Longest-English-word-chain&#x2F;Longest-English-word-chain&#x2F;TestFile&#123;0&#125;.txt&quot;;</span><br><span class="line">    String testFile &#x3D; String.Format(baseFile,testNum);</span><br><span class="line">    for (int j &#x3D; 0; j &lt; 26; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int k &#x3D; 0; k &lt; 26; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            String head &#x3D; (&#39;a&#39; + j).ToString();</span><br><span class="line">            String tail &#x3D; (&#39;a&#39; + k).ToString();</span><br><span class="line">            foreach (char c1 in validCmdChars)</span><br><span class="line">            &#123;</span><br><span class="line">                ArrayList argList &#x3D; new ArrayList() &#123; &quot;-&quot; + c1 &#125;;</span><br><span class="line">                if (c1 &#x3D;&#x3D; &#39;t&#39;) argList.Add(tail);</span><br><span class="line">                if (c1 &#x3D;&#x3D; &#39;h&#39;) argList.Add(head);</span><br><span class="line">                argList.Add(&quot;&quot;);</span><br><span class="line">                for (int i &#x3D; 1; i &lt;&#x3D; testNum; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    testFile &#x3D; String.Format(baseFile, i);</span><br><span class="line">                    argList[argList.Count - 1] &#x3D; testFile;</span><br><span class="line">                    TestOneSample(getArgs(argList));</span><br><span class="line">                &#125;</span><br><span class="line">                foreach (char c2 in validCmdChars)</span><br><span class="line">                &#123;</span><br><span class="line">                    argList &#x3D; new ArrayList() &#123; &quot;-&quot; + c1 &#125;;</span><br><span class="line">                    if (c1 &#x3D;&#x3D; &#39;t&#39;) argList.Add(tail);</span><br><span class="line">                    if (c1 &#x3D;&#x3D; &#39;h&#39;) argList.Add(head);</span><br><span class="line">                    argList.Add(&quot;-&quot; + c2);</span><br><span class="line">                    if (c2 &#x3D;&#x3D; &#39;t&#39;) argList.Add(tail);</span><br><span class="line">                    if (c2 &#x3D;&#x3D; &#39;h&#39;) argList.Add(head);</span><br><span class="line">                    argList.Add(&quot;&quot;);</span><br><span class="line">                    for (int i &#x3D; 1; i &lt;&#x3D; testNum; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        testFile &#x3D; String.Format(baseFile, i);</span><br><span class="line">                        argList[argList.Count - 1] &#x3D; testFile;</span><br><span class="line">                        TestOneSample(getArgs(argList));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(correctNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单元测试结果展示">单元测试结果展示<a class="anchor" href="#单元测试结果展示">·</a></h4><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-04-04-%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E5%AE%9E%E5%BD%95/test2.png" alt></p><p>可以看到每个模块的单元测试覆盖率都达到了90%以上，总体覆盖率为96%，这个过程也确实发现了自己和交换小组的很多bug，效果还是较好的。</p><h3 id="本地CLI对拍">本地CLI对拍<a class="anchor" href="#本地CLI对拍">·</a></h3><p>本地 CLI 对拍主要是使用我们的 <code>me.exe</code>和小组的 <code>other.exe</code> 对正确性部分进行随机数据测试。这部分并不属于单元测试，但因为我们做了，所以这里也介绍一下。</p><p>对拍主要编写了 <code>test.cpp</code> 和 <code>create.cpp</code> 两个文件。</p><p><code>test.cpp</code> 负责驱动对拍以及检查答案：</p><ul><li>编译一遍数据生成脚本 <code>create.cpp</code>。</li><li>执行 <code>create.exe</code>，并把输出的数据重定向到 <code>in.txt</code>。</li><li>随机从参数池中生成一组<strong>合法命令行参数</strong>：<ul><li>首先是从 <code>-n</code>，<code>-m</code>，<code>-w</code>，<code>-c</code> 中随机选择一个作为<strong>主参数</strong>。</li><li>然后根据参数的自身限制，随机生成其他可以组合的<strong>辅参数</strong>。</li></ul></li><li>执行 <code>me.exe</code> 和 <code>other.exe</code>，将输出的内容写到各自的输出文件中。</li><li>比较结果的一致性，我使用的判定方法都比较简单：<ul><li>对于 <code>-n</code>，只看第一行的个数是否一样。</li><li>对于 <code>-m</code> 和 <code>-w</code>，只看输出的单词行数以及首尾字母。</li><li>对于 <code>-c</code>，看首尾字母，并计算字符个数，比对是否一致。</li></ul></li></ul><p><code>create.cpp</code> 的负责数据生成，由于时间紧张，所以只生成了两类特殊的随机数据：</p><ul><li>纯随机单词数据的生成策略：每次随机从可见字符里面输出一串字符。根据被测程序的性能，可以控制输出字符串的长度。</li><li>有向无环图生成策略：考虑按顺序枚举首字母从 <code>a</code> 到 <code>z</code>，假设当前枚举到首字母为 <code>ch</code>，则可以生成随机个数的以 <code>ch</code> 为开头的单词，且这些单词的<strong>尾字母必须字典序比 <code>ch</code> 大</strong>，这样保证生成出来的数据不能往之前生成的单词连有向边，所以生成的数据就是有向无环图。</li></ul><p>对拍时，我们组发现的自己的 bug 有：</p><ul><li>最长单词链算法中单个单词也误当作链了。</li><li><code>-n</code> 时没有输出到 <code>stdout</code> 。</li><li>性能调优过程中出现的算法错误。</li></ul><p>我们组发现的别的组的 bug 有：</p><ul><li>最长单词链算法中单个单词也误当作链了。</li><li><code>-m</code> 算法错误。</li><li><code>-c</code> 最长链算出来不是最长的。</li></ul><p><s>OO 互测既视感</s>。</p><h2 id="9-计算模块部分异常处理说明。在博客中详细介绍每种异常的设计目标。每种异常都要选择一个单元测试样例发布在博客中，并指明错误对应的场景。">9.计算模块部分异常处理说明。在博客中详细介绍每种异常的设计目标。每种异常都要选择一个单元测试样例发布在博客中，并指明错误对应的场景。<a class="anchor" href="#9-计算模块部分异常处理说明。在博客中详细介绍每种异常的设计目标。每种异常都要选择一个单元测试样例发布在博客中，并指明错误对应的场景。">·</a></h2><p>本次项目主要确定了5种异常并进行测试。描述和测试样例如下：</p><h3 id="错误的参数-CommandInvalidException">错误的参数 CommandInvalidException<a class="anchor" href="#错误的参数-CommandInvalidException">·</a></h3><h4 id="描述">描述<a class="anchor" href="#描述">·</a></h4><ul><li>没有指定主参数，即 <code>n/w/m/c</code> 至少出现一个</li><li>文件参数没有放在最后的位置</li><li>出现非法字符（出现了<code>- n</code>这样的横线没有和字母连起来的情况或者其他非法字符）</li></ul><h4 id="测试">测试<a class="anchor" href="#测试">·</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public void CommandInvalidExceptionTest()</span><br><span class="line">&#123;</span><br><span class="line">    string[] args &#x3D; &#123; &quot;-n&quot;, &quot;t&quot;, &quot;C:&#x2F;Users&#x2F;fzc&#x2F;source&#x2F;repos&#x2F;Longest-English-word-chain&#x2F;Longest-English-word-chain&#x2F;TestFile1.txt&quot; &#125;;</span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        CmdTestInterface.testOneSample(args);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (CommandInvalidException e)</span><br><span class="line">    &#123;</span><br><span class="line">        ans &#x3D; 1;</span><br><span class="line">        Console.WriteLine(e.Message);</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.AreEqual(1, ans);</span><br><span class="line"></span><br><span class="line">    args &#x3D; new string[] &#123; &quot;-n&quot;, &quot;-!&quot;, &quot;C:&#x2F;Users&#x2F;fzc&#x2F;source&#x2F;repos&#x2F;Longest-English-word-chain&#x2F;Longest-English-word-chain&#x2F;TestFile2.txt&quot; &#125;;</span><br><span class="line">    ans &#x3D; 0;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        CmdTestInterface.testOneSample(args);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (CommandInvalidException e)</span><br><span class="line">    &#123;</span><br><span class="line">        ans &#x3D; 1;</span><br><span class="line">        Console.WriteLine(e.Message);</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.AreEqual(1, ans);</span><br><span class="line"></span><br><span class="line">    args &#x3D; new string[] &#123; &quot;-r&quot;, &quot;C:&#x2F;Users&#x2F;fzc&#x2F;source&#x2F;repos&#x2F;Longest-English-word-chain&#x2F;Longest-English-word-chain&#x2F;TestFile2.txt&quot; &#125;;</span><br><span class="line">    ans &#x3D; 0;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        CmdTestInterface.testOneSample(args);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (CommandInvalidException e)</span><br><span class="line">    &#123;</span><br><span class="line">        ans &#x3D; 1;</span><br><span class="line">        Console.WriteLine(e.Message);</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.AreEqual(1, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="错误的参数组合-CommandComplexException">错误的参数组合 CommandComplexException<a class="anchor" href="#错误的参数组合-CommandComplexException">·</a></h3><h4 id="描述-2">描述<a class="anchor" href="#描述-2">·</a></h4><p>两两参数冲突如下</p><table><thead><tr><th></th><th>-n</th><th>-w</th><th>-m</th><th>-c</th><th>-h</th><th>-t</th><th>-r</th></tr></thead><tbody><tr><td>-n</td><td>×</td><td>×</td><td>×</td><td>×</td><td>×</td><td>×</td><td>×</td></tr><tr><td>-w</td><td>×</td><td>×</td><td>×</td><td>×</td><td></td><td></td><td></td></tr><tr><td>-m</td><td>×</td><td>×</td><td>×</td><td>×</td><td>×</td><td>×</td><td>×</td></tr><tr><td>-c</td><td>×</td><td>×</td><td>×</td><td>×</td><td></td><td></td><td></td></tr><tr><td>-h</td><td>×</td><td></td><td>×</td><td></td><td>×</td><td></td><td></td></tr><tr><td>-t</td><td>×</td><td></td><td>×</td><td></td><td></td><td>×</td><td></td></tr><tr><td>-r</td><td>×</td><td></td><td>×</td><td></td><td></td><td></td><td>×</td></tr></tbody></table><p>上表中打 <code>×</code> 的位置说明两者是冲突的</p><h4 id="测试-2">测试<a class="anchor" href="#测试-2">·</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public void CommandComplexExceptionTest()</span><br><span class="line">&#123;</span><br><span class="line">    string[] args &#x3D; &#123; &quot;-n&quot;,&quot;-n&quot;, &quot;C:&#x2F;Users&#x2F;fzc&#x2F;source&#x2F;repos&#x2F;Longest-English-word-chain&#x2F;Longest-English-word-chain&#x2F;TestFile1.txt&quot; &#125;;</span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        CmdTestInterface.testOneSample(args);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (CommandComplexException e)</span><br><span class="line">    &#123;</span><br><span class="line">        ans &#x3D; 1;</span><br><span class="line">        Console.WriteLine(e.Message);</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.AreEqual(1, ans);</span><br><span class="line"></span><br><span class="line">    args &#x3D; new string[] &#123; &quot;-n&quot;, &quot;-m&quot;, &quot;C:&#x2F;Users&#x2F;fzc&#x2F;source&#x2F;repos&#x2F;Longest-English-word-chain&#x2F;Longest-English-word-chain&#x2F;TestFile2.txt&quot; &#125;;</span><br><span class="line">    ans &#x3D; 0;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        CmdTestInterface.testOneSample(args);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (CommandComplexException e)</span><br><span class="line">    &#123;</span><br><span class="line">        ans &#x3D; 1;</span><br><span class="line">        Console.WriteLine(e.Message);</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.AreEqual(1, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="错误的文件格式-FileInvalidException">错误的文件格式 FileInvalidException<a class="anchor" href="#错误的文件格式-FileInvalidException">·</a></h3><h4 id="描述-3">描述<a class="anchor" href="#描述-3">·</a></h4><ul><li>没有以 <code>.txt</code> 结尾</li><li>文件不存在</li></ul><h4 id="测试-3">测试<a class="anchor" href="#测试-3">·</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public void FileInvalidExceptionTest()</span><br><span class="line">&#123;</span><br><span class="line">    string[] args &#x3D; &#123; &quot;-n&quot;, &quot;C:&#x2F;Users&#x2F;fzc&#x2F;source&#x2F;repos&#x2F;Longest-English-word-chain&#x2F;Longest-English-word-chain&quot; &#125;;</span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        CmdTestInterface.testOneSample(args);</span><br><span class="line">    &#125;</span><br><span class="line">    catch(FileInvalidException e)</span><br><span class="line">    &#123;</span><br><span class="line">        ans &#x3D; 1;</span><br><span class="line">        Console.WriteLine(e.Message);</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.AreEqual(1, ans);</span><br><span class="line"></span><br><span class="line">    args &#x3D; new string[] &#123; &quot;-n&quot;, &quot;C:&#x2F;Users&#x2F;fzc&#x2F;source&#x2F;repos&#x2F;Longest-English-word-chain&#x2F;Longest-English-word-chain&#x2F;1.txt&quot; &#125;;</span><br><span class="line">    ans &#x3D; 0;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        CmdTestInterface.testOneSample(args);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (FileInvalidException e)</span><br><span class="line">    &#123;</span><br><span class="line">        ans &#x3D; 1;</span><br><span class="line">        Console.WriteLine(e.Message);</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.AreEqual(1, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果过长-ResultTooLongException">结果过长 ResultTooLongException<a class="anchor" href="#结果过长-ResultTooLongException">·</a></h3><h4 id="描述-4">描述<a class="anchor" href="#描述-4">·</a></h4><ul><li>计算得到的结果列表过长</li></ul><h4 id="测试-4">测试<a class="anchor" href="#测试-4">·</a></h4><p>样例数据：<code>aa ab bb bc cc cd dd de ee ef ff fg gg gh hh hi ii ij jj jk kk kl ll lm mm mn nn no oo op pp pq qq </code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void ResultTooLongExceptionTest()</span><br><span class="line">&#123;</span><br><span class="line">    string[] args &#x3D; &#123; &quot;-n&quot;, &quot;C:&#x2F;Users&#x2F;fzc&#x2F;source&#x2F;repos&#x2F;Longest-English-word-chain&#x2F;Longest-English-word-chain&#x2F;TestFile7.txt&quot; &#125;;</span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        CmdTestInterface.testOneSample(args);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (ResultTooLongException e)</span><br><span class="line">    &#123;</span><br><span class="line">        ans &#x3D; 1;</span><br><span class="line">        Console.WriteLine(e.Message);</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.AreEqual(ans, 1);</span><br><span class="line">    ans &#x3D; 0;</span><br><span class="line">    args &#x3D; new string[] &#123; &quot;-n&quot;, &quot;C:&#x2F;Users&#x2F;fzc&#x2F;source&#x2F;repos&#x2F;Longest-English-word-chain&#x2F;Longest-English-word-chain&#x2F;TestFile7.txt&quot; &#125;;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        CmdTestInterface.testOneSample(args);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (ResultTooLongException e)</span><br><span class="line">    &#123;</span><br><span class="line">        ans &#x3D; 1;</span><br><span class="line">        Console.WriteLine(e.Message);</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.AreEqual(ans, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出现单词环-HasImplicitLoopException">出现单词环 HasImplicitLoopException<a class="anchor" href="#出现单词环-HasImplicitLoopException">·</a></h3><h4 id="描述-5">描述<a class="anchor" href="#描述-5">·</a></h4><ul><li>输入的数据中含有隐含环</li><li>比如：<code>ab ba bc</code> 这样的文本</li></ul><h4 id="测试-5">测试<a class="anchor" href="#测试-5">·</a></h4><p>样例数据：<code>abc ca</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void HasImplicitLoopExceptionTest()</span><br><span class="line">&#123;</span><br><span class="line">    string[] args &#x3D; &#123; &quot;-n&quot;, &quot;C:&#x2F;Users&#x2F;fzc&#x2F;source&#x2F;repos&#x2F;Longest-English-word-chain&#x2F;Longest-English-word-chain&#x2F;TestFile6.txt&quot; &#125;;</span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        CmdTestInterface.testOneSample(args);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (HasImplicitLoopException e)</span><br><span class="line">    &#123;</span><br><span class="line">        ans &#x3D; 1;</span><br><span class="line">        Console.WriteLine(e.Message);</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.AreEqual(ans, 1);</span><br><span class="line">    ans &#x3D; 0;</span><br><span class="line">    args &#x3D; new string[] &#123; &quot;-w&quot;, &quot;C:&#x2F;Users&#x2F;fzc&#x2F;source&#x2F;repos&#x2F;Longest-English-word-chain&#x2F;Longest-English-word-chain&#x2F;TestFile6.txt&quot; &#125;;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        CmdTestInterface.testOneSample(args);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (HasImplicitLoopException e)</span><br><span class="line">    &#123;</span><br><span class="line">        ans &#x3D; 1;</span><br><span class="line">        Console.WriteLine(e.Message);</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.AreEqual(ans, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-界面模块的详细设计过程。在博客中详细介绍界面模块是如何设计的，并写一些必要的代码说明解释实现过程。">10.界面模块的详细设计过程。在博客中详细介绍界面模块是如何设计的，并写一些必要的代码说明解释实现过程。<a class="anchor" href="#10-界面模块的详细设计过程。在博客中详细介绍界面模块是如何设计的，并写一些必要的代码说明解释实现过程。">·</a></h2><p>首先是<strong>原型设计</strong>，由于时间有限，只是在脑海中大致想了一下布局，即左半部分是输入部分，右半部分是输出部分。两边都是有一个文本框和若干操作按钮组成。</p><p>之后是<strong>技术调研</strong>，最开始选择 <code>c#</code> 就是为了体验一下 <code>gui</code> 设计，于是主要学习了 <code>WinForm</code> 的使用</p><p>之后就开始<strong>正式开发</strong>了，先新建了一个 <code>C# windows</code> 应用程序项目，之后利用工具箱中的组件拖动进主界面进行组件化开发。</p><p>主要使用了 <code>Button/TextBox/Label/ToolTip/MessageBox/ShowDialog</code>  这6个组件，拖动到设计界面后，调整位置和文字参数，之后在相应的 <code>.cs</code> 文件的绑定的控制函数中进行逻辑编写。这里以一个导入文件的按钮举例。当按下按钮时，就会触发这个事件函数，就会先弹出一个文件选择框，选择之后就会将文本导入到输入框内。其他的按钮的逻辑也类似，都是通过相应的按钮事件函数进行绑定。给每个按钮和文本都写好相应的事件后，就差不多写好了GUI界面的基本逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void button1_Click(object sender, EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">    if (openFileDialog1.ShowDialog(this) &#x3D;&#x3D; DialogResult.OK)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;保存路径</span><br><span class="line">        string filePath &#x3D; Path.GetFullPath(openFileDialog1.FileName);</span><br><span class="line">        Console.WriteLine(filePath);</span><br><span class="line">        &#x2F;&#x2F;读取数据</span><br><span class="line">        StreamReader str &#x3D; new StreamReader(filePath);</span><br><span class="line">        &#x2F;&#x2F;获取每行字符</span><br><span class="line">        string line;</span><br><span class="line">        string inputStr &#x3D; &quot;&quot;;</span><br><span class="line">        while ((line &#x3D; str.ReadLine()) !&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;通过&#39;,&#39;将行分裂为字符串组</span><br><span class="line">            inputStr +&#x3D; line+&quot;\r\n&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        str.Close();</span><br><span class="line">        textBox1.Text &#x3D; inputStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体逻辑为，导入文件或者直接输入到文本框内，设置相应的命令，之后对输入文本框内的字符串进行处理和分析，得到输出结果，输出结果实时打印到右侧的输出框。之后可以采用将结果导出到文件等操作。异常处理和完整处理计算流程主要放在导出分析结果文件这个按钮的事件函数中，按下之后就会触发整个的流程得到计算结果。</p><p>具体设计时的界面如下图所示</p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-04-04-结对编程实录/gui4.png" style="zoom:50%;"><h2 id="11-界面模块与计算模块的对接。详细地描述-UI-模块的设计与两个模块的对接，并在博客中截图实现的功能。">11.界面模块与计算模块的对接。详细地描述 UI 模块的设计与两个模块的对接，并在博客中截图实现的功能。<a class="anchor" href="#11-界面模块与计算模块的对接。详细地描述-UI-模块的设计与两个模块的对接，并在博客中截图实现的功能。">·</a></h2><h3 id="对接计算模块">对接计算模块<a class="anchor" href="#对接计算模块">·</a></h3><p>先在 <code>visual studio 2019</code> 中点击 <code>项目-添加项目引用-浏览-导入Library.dll Core.dll</code></p><p>主要在 <code>开始分析</code> 按钮处进行预处理和计算流程运行，大致代码架构如下，可以很轻松的修改使用的 <code>Core </code></p><p>主要在核心计算逻辑部分使用 <code>Core</code> 内定义的四个接口进行计算，其余部分都使用 <code>Library.dll</code> 中的类进行操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">private void button4_Click(object sender, EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;CoreType:0 使用我们的Core</span><br><span class="line">    &#x2F;&#x2F;CoreType:1 使用交换的Core</span><br><span class="line">    int CoreType &#x3D; 0;</span><br><span class="line">    if (CoreType &#x3D;&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;预处理</span><br><span class="line">            string[] args &#x3D; System.Text.RegularExpressions.Regex.Split(textBox3.Text, @&quot;\s+&quot;);</span><br><span class="line">            CommandParser parser &#x3D; new CommandParser(args);</span><br><span class="line">            ParseRes parseRes &#x3D; parser.getParseRes();</span><br><span class="line">            WordListMaker maker &#x3D; new WordListMaker();</span><br><span class="line">            string article &#x3D; textBox1.Text;</span><br><span class="line">            List&lt;string&gt; wordList &#x3D; maker.makeWordList(article);</span><br><span class="line">            List&lt;string&gt; result &#x3D; new List&lt;string&gt;();</span><br><span class="line">            &#x2F;&#x2F;核心计算逻辑</span><br><span class="line">            int outputMode &#x3D; 1;</span><br><span class="line">            if (parseRes.cmdChars.Contains(&#39;n&#39;))</span><br><span class="line">            &#123;</span><br><span class="line">                outputMode &#x3D; 0;</span><br><span class="line">                PairTestInterface.gen_chains_all(wordList, result);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (parseRes.cmdChars.Contains(&#39;w&#39;))</span><br><span class="line">            &#123;</span><br><span class="line">                PairTestInterface.gen_chain_word(wordList, result, </span><br><span class="line">                                                 parseRes.start, parseRes.end, parseRes.enableLoop);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (parseRes.cmdChars.Contains(&#39;m&#39;))</span><br><span class="line">            &#123;</span><br><span class="line">                PairTestInterface.gen_chain_word_unique(wordList, result);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                PairTestInterface.gen_chain_char(wordList, result, </span><br><span class="line">                                                 parseRes.start, parseRes.end, parseRes.enableLoop);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;输出逻辑</span><br><span class="line">            Output output &#x3D; new Output();</span><br><span class="line">            string outputRes &#x3D; output.printWordChains(result, outputMode);</span><br><span class="line">            outputRes &#x3D; outputRes.Replace(&quot;\n&quot;, &quot;\r\n&quot;);</span><br><span class="line">            textBox2.Text &#x3D; outputRes;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception error)</span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox.Show(error.Message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;预处理</span><br><span class="line">            string[] args &#x3D; System.Text.RegularExpressions.Regex.Split(textBox3.Text, @&quot;\s+&quot;);</span><br><span class="line">            CommandParser parser &#x3D; new CommandParser(args);</span><br><span class="line">            ParseRes parseRes &#x3D; parser.getParseRes();</span><br><span class="line">            WordListMaker maker &#x3D; new WordListMaker();</span><br><span class="line">            string article &#x3D; textBox1.Text;</span><br><span class="line">            List&lt;string&gt; wordList &#x3D; maker.makeWordList(article);</span><br><span class="line">            List&lt;string&gt; result &#x3D; new List&lt;string&gt;();</span><br><span class="line">            &#x2F;&#x2F;核心计算逻辑</span><br><span class="line">            if (parseRes.cmdChars.Contains(&#39;n&#39;))</span><br><span class="line">            &#123;</span><br><span class="line">                Chain.gen_chains_all(wordList, 0, result);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (parseRes.cmdChars.Contains(&#39;w&#39;))</span><br><span class="line">            &#123;</span><br><span class="line">                Chain.gen_chain_word(wordList, 0, result, </span><br><span class="line">                                     parseRes.start, parseRes.end, parseRes.enableLoop);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (parseRes.cmdChars.Contains(&#39;m&#39;))</span><br><span class="line">            &#123;</span><br><span class="line">                Chain.gen_chain_word_unique(wordList, 0, result);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                Chain.gen_chain_char(wordList, 0, result, </span><br><span class="line">                                     parseRes.start, parseRes.end, parseRes.enableLoop);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;输出逻辑</span><br><span class="line">            Output output &#x3D; new Output();</span><br><span class="line">            string outputRes &#x3D; output.printWordChains(result, 1);</span><br><span class="line">            outputRes &#x3D; outputRes.Replace(&quot;\n&quot;, &quot;\r\n&quot;);</span><br><span class="line">            textBox2.Text &#x3D; outputRes;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception error)</span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox.Show(error.Message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="功能介绍">功能介绍<a class="anchor" href="#功能介绍">·</a></h3><h4 id="导入文件">导入文件<a class="anchor" href="#导入文件">·</a></h4><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-04-04-结对编程实录/gui2.png" style="zoom:50%;"><h4 id="输入命令进行分析">输入命令进行分析<a class="anchor" href="#输入命令进行分析">·</a></h4><h5 id="选择命令参数按钮输入命令">选择命令参数按钮输入命令<a class="anchor" href="#选择命令参数按钮输入命令">·</a></h5><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-04-04-结对编程实录/gui5.png" style="zoom:50%;"><h5 id="必要的输入提示">必要的输入提示<a class="anchor" href="#必要的输入提示">·</a></h5><p>输入 <code>-h/-t</code> 后会提示再输入一个字母</p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-04-04-结对编程实录/gui.png" style="zoom:50%;"><h5 id="清空参数">清空参数<a class="anchor" href="#清空参数">·</a></h5><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-04-04-%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E5%AE%9E%E5%BD%95/gui8.png" alt></p><h4 id="分析结果并给出必要异常提示">分析结果并给出必要异常提示<a class="anchor" href="#分析结果并给出必要异常提示">·</a></h4><h5 id="正常的输出">正常的输出<a class="anchor" href="#正常的输出">·</a></h5><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-04-04-结对编程实录/gui6.png" style="zoom:50%;"><h5 id="遇到异常">遇到异常<a class="anchor" href="#遇到异常">·</a></h5><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-04-04-结对编程实录/gui7.png" style="zoom:50%;"><h4 id="导出分析结果到文件">导出分析结果到文件<a class="anchor" href="#导出分析结果到文件">·</a></h4><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-04-04-结对编程实录/gui3.png" style="zoom:50%;"><h2 id="附加任务-互换核心模块">附加任务-互换核心模块<a class="anchor" href="#附加任务-互换核心模块">·</a></h2><h3 id="信息">信息<a class="anchor" href="#信息">·</a></h3><p>与我们互换的组为：</p><ul><li>杨濡冰 19373263</li><li>黄炜 19373174</li></ul><h3 id="交换过程总结">交换过程总结<a class="anchor" href="#交换过程总结">·</a></h3><p>命令行和GUI，以及测试程序都对杨濡冰和黄炜组的 <code>Core</code> 进行了使用。</p><p>基本的使用方式是先添加项目引用，导入他们提供的 <code>HYCore.dll</code>，之后调用他们提供的接口 <code>Chain.接口函数</code> 进行计算即可，我们将之前使用 <code>PairTestInterface.接口函数</code> 的部分替换成他们的函数即可。值得注意的是版本比较重要，<code>.net</code> 官方文档中明确提出了只保证大版本号的兼容，即 <code>4.x</code> 是可以互相兼容的，但是 <code>3.x</code> 和 <code>4.x</code> 的支持就很不顺畅，所以我们双方都单独生成了对方能够使用的版本。</p><p>我们小组单独生成了 <code>.net 4.7.2</code> 版本的 <code>Core.dll</code>，具体来说就是新建一个 <code>.net framework 用于创建c#类库</code> 的项目，之后添加现有项。把 <code>Core</code> 的相关文件导入，并直接运行一下就会在 <code>bin</code> 路径下找到 <code>dll</code> 文件。</p><p>正常导入之后，我们发现了他们的一些小bug，下图中发现他们有环数据遇到了下标越界的错误</p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-04-04-结对编程实录/pairtest1.png" style="zoom:50%;"><p>同时在单元测试还发现了在遇到找不到某个结尾的链时会抛异常，这些错误我们都及时反馈并帮助他们完善了设计。</p><p>无独有偶，他们也发现了我们的类似bug</p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-04-04-结对编程实录/pairtest2.png" style="zoom:50%;"><p>在完成bug修复之后，我们都使用对方的 <code>Core.dll</code> 得到了正确的运行结果</p><h3 id="正确运行效果">正确运行效果<a class="anchor" href="#正确运行效果">·</a></h3><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-04-04-结对编程实录/pairtest3.png" style="zoom:50%;"><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-04-04-结对编程实录/pairtest4.png" style="zoom:50%;"><h1 id="Part3-总结">Part3 总结<a class="anchor" href="#Part3-总结">·</a></h1><h2 id="12-描述结对的过程，提供两人在讨论的结对图像资料（比如-Live-Share-的截图）。关于如何远程进行结对参见作业最后的注意事项。">12.描述结对的过程，提供两人在讨论的结对图像资料（比如 Live Share 的截图）。关于如何远程进行结对参见作业最后的注意事项。<a class="anchor" href="#12-描述结对的过程，提供两人在讨论的结对图像资料（比如-Live-Share-的截图）。关于如何远程进行结对参见作业最后的注意事项。">·</a></h2><h3 id="3-22-宿舍-初步讨论">3.22 宿舍 初步讨论<a class="anchor" href="#3-22-宿舍-初步讨论">·</a></h3><p>进行第一次大致读题和进度安排，用时10min，主要是大概沟通一下和理解基本要求。同时明确了当天晚上需要好好学习 <code>c#</code> 相关的知识以及自己动手写一些demo，做好开发前必要准备工作。</p><h3 id="3-23-主M楼-计划与初步开发">3.23 主M楼 计划与初步开发<a class="anchor" href="#3-23-主M楼-计划与初步开发">·</a></h3><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-04-04-结对编程实录/3_23.jpg" style="zoom: 33%;"><p>深入读题，明确了代码规范和开发计划，完成了设计文档，同时进行了第一次结对实践，完成了输入类和一个简陋的dfs算法。</p><p>计划好之后两天自己独自开发的内容</p><h3 id="3-25-新主楼-核心逻辑开发1">3.25 新主楼 核心逻辑开发1<a class="anchor" href="#3-25-新主楼-核心逻辑开发1">·</a></h3><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-04-04-结对编程实录/3_25.jpg" alt="3_25" style="zoom:33%;"><p>zcx重构了算法，使用拓扑排序等方法进行优化，完成了一个输出函数。</p><p>fzc写好了GUI以及实现了参数解析，定义了输入输出的一些异常</p><h3 id="3-27-新主楼-核心逻辑开发2">3.27 新主楼 核心逻辑开发2<a class="anchor" href="#3-27-新主楼-核心逻辑开发2">·</a></h3><p>（此次忘记拍照了）</p><p>zcx继续完善算法逻辑</p><p>fzc写完善输入输出，设计单元测试</p><h3 id="3-29-主M楼-核心逻辑开发3">3.29 主M楼 核心逻辑开发3<a class="anchor" href="#3-29-主M楼-核心逻辑开发3">·</a></h3><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-04-04-结对编程实录/3_29.jpg" alt="3_29" style="zoom:33%;"><p>修复了解析参数的一些bug，讨论接口实现</p><p>zcx发现了之前算法的一些问题，进行重新构建</p><h3 id="4-2-主M楼-GUI、CLI与计算模块对接，完善异常设计">4.2 主M楼 GUI、CLI与计算模块对接，完善异常设计<a class="anchor" href="#4-2-主M楼-GUI、CLI与计算模块对接，完善异常设计">·</a></h3><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-04-04-结对编程实录/4_2.jpg" alt="4_2" style="zoom:33%;"><p>基本完成了所有模块的编写，进行测试，以及命令行主程序，GUI界面和计算模块的对接</p><p>fzc进行整体文件架构的调整，zcx继续完成接口</p><h3 id="4-3-4-5-测试各个接口，模块松耦合">4.3-4.5 测试各个接口，模块松耦合<a class="anchor" href="#4-3-4-5-测试各个接口，模块松耦合">·</a></h3><p>这两天由于各种原因，线上一起进行。</p><p>和交换的小组进行互换模块，交流并互测。</p><p>编写文档，测试以及做最后的签入</p><h3 id="完结撒花合影">完结撒花合影<a class="anchor" href="#完结撒花合影">·</a></h3><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-04-04-结对编程实录/4_4.jpg" alt="4_2" style="zoom:33%;"><p>感谢战哥的包容和忍耐以及算法的carry！这两周的合作简直丝滑至极😀</p><h2 id="13-看教科书和其它参考书，网站中关于结对编程的章节，例如：http-www-cnblogs-com-xinz-archive-2011-08-07-2130332-html-，说明结对编程的优点和缺点。同时描述结对的每一个人的优点和缺点在哪里（要列出至少三个优点和一个缺点）">13.看教科书和其它参考书，网站中关于结对编程的章节，例如：http://www.cnblogs.com/xinz/archive/2011/08/07/2130332.html ，说明结对编程的优点和缺点。同时描述结对的每一个人的优点和缺点在哪里（要列出至少三个优点和一个缺点）<a class="anchor" href="#13-看教科书和其它参考书，网站中关于结对编程的章节，例如：http-www-cnblogs-com-xinz-archive-2011-08-07-2130332-html-，说明结对编程的优点和缺点。同时描述结对的每一个人的优点和缺点在哪里（要列出至少三个优点和一个缺点）">·</a></h2><h3 id="结对编程评价">结对编程评价<a class="anchor" href="#结对编程评价">·</a></h3><h4 id="优点-7">优点<a class="anchor" href="#优点-7">·</a></h4><ul><li>代码质量高，写出来的代码往往很规范而且不容易有bug，因为有问题往往也第一时间解决了。比如本次项目我们的算法设计部分就在一开始就解决了很多问题</li><li>对于需求理解更到位，对一些边界问题会有更清晰的把握</li><li>专注度更高，效率高，出于不浪费他人时间的考虑，且有人监督，一般在一起写的时候没人会开小差做别的事。</li><li>适合于一些中间的阶段或者一些需要对需求有一个全面清晰认知的模块编写，比如本次项目的参数解析模块。</li></ul><h4 id="缺点-7">缺点<a class="anchor" href="#缺点-7">·</a></h4><ul><li>对于一些简单的模块和函数，两个人一起写的效率可能物极必反，因为这部分代码本身没有什么需要一起复审的，这个时候领航员并行写一些简单的逻辑会更好</li><li>出于怕麻烦的心理，在被看写代码的时候压力较大，会使用更保险，更安全的写法，有时候会带来代码冗余和代码效率较低，无法写出特别高质量的代码。</li></ul><h3 id="个人评价">个人评价<a class="anchor" href="#个人评价">·</a></h3><h4 id="优点-8">优点<a class="anchor" href="#优点-8">·</a></h4><ul><li>对于新技术有热情，学习能力较强</li><li>善于合作，沟通能力强</li><li>测试能力较强</li></ul><h4 id="缺点-8">缺点<a class="anchor" href="#缺点-8">·</a></h4><ul><li>代码风格需要IDE的自动调整，有时候自己写风格上会出问题</li><li>算法能力较弱</li></ul><h3 id="队友评价">队友评价<a class="anchor" href="#队友评价">·</a></h3><h4 id="优点-9">优点<a class="anchor" href="#优点-9">·</a></h4><ul><li>对于算法设计与优化具有很高热情，算法设计与实现能力强（这次结对尝试实现过很多图算法，以及进行了较多的优化）</li><li>代码设计风格相当规范甚至可以说是精美</li><li>学习能力强，善于查阅资料文档</li><li>善于合作，接口设计对接与交流很顺畅</li></ul><h4 id="缺点-9">缺点<a class="anchor" href="#缺点-9">·</a></h4><ul><li>也许是别的事太多了，有时候懒得配环境</li></ul><h2 id="14-在你实现完程序之后，在附录提供的PSP表格记录下你在程序的各个模块上实际花费的时间。">14.在你实现完程序之后，在附录提供的PSP表格记录下你在程序的各个模块上实际花费的时间。<a class="anchor" href="#14-在你实现完程序之后，在附录提供的PSP表格记录下你在程序的各个模块上实际花费的时间。">·</a></h2><table><thead><tr><th style="text-align:left">PSP2.1</th><th style="text-align:left">Personal Software Process Stages</th><th style="text-align:left">预估耗时（分钟）</th><th style="text-align:left">实际耗时（分钟）</th></tr></thead><tbody><tr><td style="text-align:left">Planning</td><td style="text-align:left">计划</td><td style="text-align:left">90</td><td style="text-align:left">90</td></tr><tr><td style="text-align:left">· Estimate</td><td style="text-align:left">· 估计这个任务需要多少时间</td><td style="text-align:left">90</td><td style="text-align:left">90</td></tr><tr><td style="text-align:left">Development</td><td style="text-align:left">开发</td><td style="text-align:left">790</td><td style="text-align:left">915</td></tr><tr><td style="text-align:left">· Analysis</td><td style="text-align:left">· 需求分析 (包括学习新技术)</td><td style="text-align:left">60</td><td style="text-align:left">30</td></tr><tr><td style="text-align:left">· Design Spec</td><td style="text-align:left">· 生成设计文档</td><td style="text-align:left">30</td><td style="text-align:left">30</td></tr><tr><td style="text-align:left">· Design Review</td><td style="text-align:left">· 设计复审 (和同事审核设计文档)</td><td style="text-align:left">30</td><td style="text-align:left">10</td></tr><tr><td style="text-align:left">· Coding Standard</td><td style="text-align:left">· 代码规范 (为目前的开发制定合适的规范)</td><td style="text-align:left">10</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left">· Design</td><td style="text-align:left">· 具体设计</td><td style="text-align:left">60</td><td style="text-align:left">60</td></tr><tr><td style="text-align:left">· Coding</td><td style="text-align:left">· 具体编码</td><td style="text-align:left">360</td><td style="text-align:left">480</td></tr><tr><td style="text-align:left">· Code Review</td><td style="text-align:left">· 代码复审</td><td style="text-align:left">60</td><td style="text-align:left">120</td></tr><tr><td style="text-align:left">· Test</td><td style="text-align:left">· 测试（自我测试，修改代码，提交修改）</td><td style="text-align:left">180</td><td style="text-align:left">180</td></tr><tr><td style="text-align:left">Reporting</td><td style="text-align:left">报告</td><td style="text-align:left">100</td><td style="text-align:left">100</td></tr><tr><td style="text-align:left">· Test Report</td><td style="text-align:left">· 测试报告</td><td style="text-align:left">60</td><td style="text-align:left">60</td></tr><tr><td style="text-align:left">· Size Measurement</td><td style="text-align:left">· 计算工作量</td><td style="text-align:left">10</td><td style="text-align:left">10</td></tr><tr><td style="text-align:left">· Postmortem &amp; Process Improvement Plan</td><td style="text-align:left">· 事后总结, 并提出过程改进计划</td><td style="text-align:left">30</td><td style="text-align:left">30</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">合计</td><td style="text-align:left">980</td><td style="text-align:left">1105</td></tr></tbody></table><h2 id="事后总结">事后总结<a class="anchor" href="#事后总结">·</a></h2><p>本次结对编程是一次非常令人难忘的经历，收获了以下内容：</p><ul><li>从几乎陌生到大概了解 <code>c#</code> 面向对象设计，<code>c# WinForm GUI</code> 开发</li><li>掌握了基本的 <code>visual studio</code> 使用方法，包括单元测试，代码性能分析，打包方法，编译运行等等</li><li>基本了解了结对编程的流程，大致掌握了一种高效的两人项目开发方法</li><li>复习了OO课上的JML和UML部分的一些内容，同时对于接口设计，高内聚低耦合等设计原则有了更深的理解</li><li>同时很重要的是更加了解战哥这位巨佬，从他身上也学到了不少东西，包括设计思想，代码规范等等</li></ul><p>同时对于结对编程的流程也有了一些改进的想法，之后结对编程和团队开发中可以吸取教训和经验</p><ul><li>项目的松耦合从一开始就要大致规划好，除了代码层面的松耦合，还有项目之间的松耦合，比如需要分出几个子项目，以及同一个项目之内需要分成几个模块。以及版本也需要从一开始进行统一</li><li>编码时就要考虑 Information Hiding，Interface Design，Loose Coupling 这些原则，保证接口，实体类，工具类，方法的可扩展性。同时一定程度上可以对于算法设计，以及有明确输入输出的函数进行契约化设计实践</li><li>结对编程不能一味死板的执行领航+驾驶这样的原则，相当的一段时间还是需要独立思考开发的。但是对于边界较混乱和比较复杂的部分需要合作和讨论完成，确保不会出错</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-SE-2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动手学深度学习笔记-基础篇</title>
      <link href="2022/03/19/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2022/03/19/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言">1.前言<a class="anchor" href="#1-前言">·</a></h1><h2 id="日常生活中的机器学习">日常生活中的机器学习<a class="anchor" href="#日常生活中的机器学习">·</a></h2><h2 id="关键组件">关键组件<a class="anchor" href="#关键组件">·</a></h2><p><strong>数据</strong>，<strong>转换数据的模型</strong>，<strong>目标函数</strong>，调整模型参数从而优化目标函数的<strong>算法</strong></p><h2 id="各种机器学习问题">各种机器学习问题<a class="anchor" href="#各种机器学习问题">·</a></h2><h3 id="监督学习（supervised-learning）">监督学习（supervised learning）<a class="anchor" href="#监督学习（supervised-learning）">·</a></h3><ul><li>回归（regression）</li><li>分类（classification）<ul><li>层次分类</li></ul></li><li>标记问题<ul><li>二元分类</li><li>多元分类 ==&gt; 多标签分类（multi-label classification）</li></ul></li><li>搜索</li><li>推荐系统（recommender system）</li><li>序列学习<ul><li>标记与解析</li><li>自动语音识别</li><li>文本到语音</li><li>机器翻译</li></ul></li></ul><h3 id="无监督学习（unsupervised-learning）">无监督学习（unsupervised learning）<a class="anchor" href="#无监督学习（unsupervised-learning）">·</a></h3><ul><li>聚类（clustering）</li><li>主成分分析（principal component analysis）</li><li>因果关系（causality）和概率图模型（probabilistic graphical models）</li><li>生成对抗性网络（generative adversarial networks）</li></ul><h3 id="与环境互动">与环境互动<a class="anchor" href="#与环境互动">·</a></h3><p>前面两者都是离线学习（offline learning），即不需要和环境交互，先训练好再启动</p><h3 id="强化学习（reinforcement-learning）">强化学习（reinforcement learning）<a class="anchor" href="#强化学习（reinforcement-learning）">·</a></h3><ul><li>深度Q网络（Q-network）</li><li>AlphaGo</li><li>在强化学习问题中，agent在一系列的时间步骤上与环境交互。 在每个特定时间点，agent从环境接收一些观察（observation），并且必须选择一个动作（action），然后通过某种机制（有时称为执行器）将其传输回环境，最后agent从环境中获得奖励（reward）。 此后新一轮循环开始，agent接收后续观察，并选择后续操作，依此类推。</li></ul><h2 id="起源">起源<a class="anchor" href="#起源">·</a></h2><h2 id="深度学习之路">深度学习之路<a class="anchor" href="#深度学习之路">·</a></h2><h2 id="成功案例">成功案例<a class="anchor" href="#成功案例">·</a></h2><h2 id="特点">特点<a class="anchor" href="#特点">·</a></h2><h1 id="2-预备知识">2.预备知识<a class="anchor" href="#2-预备知识">·</a></h1><h2 id="2-1数据操作">2.1数据操作<a class="anchor" href="#2-1数据操作">·</a></h2><p>张量tensor，<code>pytorch</code> 和 <code>tensorflow</code> 中是 <code>Tensor</code>，其实就是<strong>多维数组</strong></p><h3 id="入门">入门<a class="anchor" href="#入门">·</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">x=torch.arange(<span class="number">12</span>)</span><br><span class="line">x.shape</span><br><span class="line">x.numel <span class="comment">#将多维数组展平成一维数组的长度，即张量的元素个数</span></span><br><span class="line">X=x.reshape(<span class="number">3</span>,<span class="number">4</span>) <span class="comment">#改变张量的形状但不改元素数量和元素值</span></span><br><span class="line">X=x.reshape(<span class="number">-1</span>,<span class="number">4</span>) <span class="comment">#使用-1自动计算对应位置的大小</span></span><br><span class="line">X=torch.ones((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">X=torch.zeros(<span class="number">10</span>) </span><br><span class="line">X=torch.randn(<span class="number">3</span>,<span class="number">4</span>) <span class="comment">#shape为(3,4)的一个随机数张量，元素分布遵循N(0,1)</span></span><br><span class="line">X=torch.tensor([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">#根据列表建立</span></span><br></pre></td></tr></table></figure><h3 id="运算符">运算符<a class="anchor" href="#运算符">·</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#按元素运算</span></span><br><span class="line">x=torch.tensor([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">y=torch.tensor([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">x+y,x-y,x*y,x/y,x**y <span class="comment">#张量每个对应位置元素计算得到相同形状的张量</span></span><br><span class="line">torch.exp(x) <span class="comment">#求幂</span></span><br><span class="line"><span class="comment">#连结张量</span></span><br><span class="line">X=torch.arange(<span class="number">6</span>,dtype=torch.float32).reshape(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">Y=torch.tensor([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">torch.cat((X,Y),dim=<span class="number">0</span>),torch.cat((X,Y),dim=<span class="number">1</span>) </span><br><span class="line"><span class="comment">#dim=0 shape的第一个元素，即行上进行cat，会影响shape的第一个元素的长度</span></span><br><span class="line"><span class="comment">#dim=1 shape的第二个元素，即列上进行cat，会影响shape的第二个元素的长度</span></span><br><span class="line">X==Y <span class="comment">#产生一个X.shape的布尔数组</span></span><br><span class="line">X.sum(dim=<span class="literal">None</span>, keepdim=<span class="literal">False</span>, dtype=<span class="literal">None</span>) <span class="comment">#默认求所有元素的和 dim设为0和1解释同上</span></span><br></pre></td></tr></table></figure><h3 id="广播机制">广播机制<a class="anchor" href="#广播机制">·</a></h3><p>先复制元素扩展，再对同样形状的数组进行按元素操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=torch.arange(<span class="number">3</span>).reshape(<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line">b=torch.arange(<span class="number">2</span>).reshape(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">a+b</span><br><span class="line"><span class="comment">#先将a复制扩充成[[0,0]，[1,1],[2,2]]</span></span><br><span class="line"><span class="comment">#再将b复制扩充成[[0,1],[0,1],[0,1]]</span></span><br><span class="line"><span class="comment">#再将扩充后的数组相加得到[[0,1],[1,2],[2,3]]</span></span><br></pre></td></tr></table></figure><h3 id="索引和切片">索引和切片<a class="anchor" href="#索引和切片">·</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X[<span class="number">-1</span>],x[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">#此处和python索引切片一致</span></span><br><span class="line">X[<span class="number">1</span>,<span class="number">2</span>]=<span class="number">3</span></span><br><span class="line">X[<span class="number">0</span>:<span class="number">2</span>,:]=<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="节省内存">节省内存<a class="anchor" href="#节省内存">·</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">before = id(Y)</span><br><span class="line">Y = Y + X</span><br><span class="line">id(Y) == before <span class="comment">#False 重新为上面的计算左侧的Y分配了空间</span></span><br><span class="line">before = id(Y)</span><br><span class="line">Y[:]=Y+X</span><br><span class="line">id(Y) == before <span class="comment">#True 原址改动</span></span><br></pre></td></tr></table></figure><h3 id="转换为其他python对象">转换为其他python对象<a class="anchor" href="#转换为其他python对象">·</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X=torch.tensor([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">A = X.numpy()</span><br><span class="line">B = torch.tensor(A)</span><br><span class="line">B = torch.from_numpy(A)</span><br></pre></td></tr></table></figure><h2 id="2-2数据预处理">2.2数据预处理<a class="anchor" href="#2-2数据预处理">·</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pandas基本数据处理</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.makedirs(os.path.join(<span class="string">'..'</span>, <span class="string">'data'</span>), exist_ok=<span class="literal">True</span>)</span><br><span class="line">data_file = os.path.join(<span class="string">'..'</span>, <span class="string">'data'</span>, <span class="string">'house_tiny.csv'</span>)</span><br><span class="line"><span class="comment">#写入数据集</span></span><br><span class="line"><span class="keyword">with</span> open(data_file, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">'NumRooms,Alley,Price\n'</span>)  <span class="comment"># 列名</span></span><br><span class="line">    f.write(<span class="string">'NA,Pave,127500\n'</span>)  <span class="comment"># 每行表示一个数据样本</span></span><br><span class="line">    f.write(<span class="string">'2,NA,106000\n'</span>)</span><br><span class="line">    f.write(<span class="string">'4,NA,178100\n'</span>)</span><br><span class="line">    f.write(<span class="string">'NA,NA,140000\n'</span>)</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df=pd.read_csv(data_file)</span><br><span class="line">inputs,outputs=data.iloc[:,<span class="number">0</span>:<span class="number">2</span>],data.iloc[:,<span class="number">2</span>]</span><br><span class="line">inputs = inputs.fillna(inputs.mean()) <span class="comment">#填补残缺值</span></span><br><span class="line">inputs = pd.get_dummies(inputs, dummy_na=<span class="literal">True</span>) <span class="comment">#将离散值转换为数值类型</span></span><br><span class="line">X, y = torch.tensor(inputs.values), torch.tensor(outputs.values) <span class="comment">#转换为张量格式</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drop_col</span><span class="params">(df)</span>:</span></span><br><span class="line">    num = df.isna().sum() <span class="comment">#获得缺失值统计信息</span></span><br><span class="line">    num_dict = num.to_dict() <span class="comment">#转为字典</span></span><br><span class="line">    max_key =max(num_dict,key=num_dict.get) <span class="comment">#取字典中最大值的键</span></span><br><span class="line">    <span class="keyword">del</span> df[max_key] <span class="comment">#删除缺失值最多的列</span></span><br><span class="line">    <span class="keyword">return</span> df</span><br></pre></td></tr></table></figure><h2 id="2-3线性代数">2.3线性代数<a class="anchor" href="#2-3线性代数">·</a></h2><h3 id="标量：单个数">标量：单个数<a class="anchor" href="#标量：单个数">·</a></h3><p>x,y,z</p><h3 id="向量：标量组成的列表">向量：标量组成的列表<a class="anchor" href="#向量：标量组成的列表">·</a></h3><p><strong>x</strong>,<strong>y</strong>,<strong>z</strong></p><h3 id="矩阵：标量组成的二维数组">矩阵：标量组成的二维数组<a class="anchor" href="#矩阵：标量组成的二维数组">·</a></h3><p>A,B,C</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A.T</span><br><span class="line">A==A.T <span class="comment">#看是否是对称矩阵</span></span><br></pre></td></tr></table></figure><h3 id="张量：标量组成的多维数组">张量：标量组成的多维数组<a class="anchor" href="#张量：标量组成的多维数组">·</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">X=torch.range(<span class="number">24</span>).reshape(<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>) <span class="comment">#可认为是三颜色通道，尺寸为3*4的图片数据</span></span><br><span class="line">A = torch.arange(<span class="number">20</span>, dtype=torch.float32).reshape(<span class="number">5</span>, <span class="number">4</span>)</span><br><span class="line">B = A.clone()</span><br><span class="line">A*B <span class="comment">#按元素乘法 Hadamard积（Hadamard product）（数学符号⊙）</span></span><br><span class="line">A+<span class="number">1</span> <span class="comment">#每个元素都+1</span></span><br><span class="line">A*<span class="number">2</span> <span class="comment">#每个元素*2</span></span><br></pre></td></tr></table></figure><h3 id="降维">降维<a class="anchor" href="#降维">·</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x=torch.arange(<span class="number">6</span>,dtype=torch.float32).reshape(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">x.sum(axis=<span class="number">0</span>) <span class="comment">#==&gt;[5,7,9]</span></span><br><span class="line">x.sum(axis=<span class="number">1</span>) <span class="comment">#==&gt;[6,15]</span></span><br><span class="line"><span class="comment">#其他函数比如mean也有类似性质</span></span><br></pre></td></tr></table></figure><h3 id="非降维求和">非降维求和<a class="anchor" href="#非降维求和">·</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x=torch.arange(<span class="number">6</span>,dtype=torch.float32).reshape(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">sum_x = x.sum(axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">sum_x <span class="comment">#==&gt;[[6],[15]]</span></span><br><span class="line"><span class="comment">#这样可以直接用x/sum_x进行标准化</span></span><br><span class="line">x/sum_x <span class="comment">#==&gt;[[0.0000, 0.3333, 0.6667],[0.2500, 0.3333, 0.4167]</span></span><br><span class="line">x.cumsum(axis=<span class="number">0</span>) <span class="comment">#==&gt;累计总和:[[0., 1., 2.],[3., 5., 7.]]</span></span><br></pre></td></tr></table></figure><h3 id="点积">点积<a class="anchor" href="#点积">·</a></h3><p>$x,y\in R<sup>d,x</sup>Ty=\sum_{i=1}^dx_iy_i$</p><p>加权和，计算夹角余弦</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x=torch.range(<span class="number">4</span>)</span><br><span class="line">y=torch.ones(<span class="number">4</span>,dtype=torch.float32)</span><br><span class="line"><span class="comment">#两种计算方式</span></span><br><span class="line">torch.dot(x,y)</span><br><span class="line">torch.sum(x*y)</span><br></pre></td></tr></table></figure><h3 id="矩阵-向量积">矩阵-向量积<a class="anchor" href="#矩阵-向量积">·</a></h3><p>$A\in R^{m\times n},x\in R^n$</p><p><img src="/2022/03/19/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png" alt></p><p>相乘得到$B^m$ 即长度为m的向量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A=torch.arange(<span class="number">6</span>).reshape(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">x=torch.tensor([<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="comment">#2*3的矩阵与长度为3的向量</span></span><br><span class="line">torch.mv(A,x) <span class="comment">#==&gt;[14,47]</span></span><br></pre></td></tr></table></figure><h3 id="矩阵乘法">矩阵乘法<a class="anchor" href="#矩阵乘法">·</a></h3><p>$A\in R^{n\times k},B\in R^{k\times m}$</p><p>$AB\in R^{n\times m}$</p><p>可以理解为是A的<strong>n个行向量</strong>与B的<strong>m个列向量</strong>分别相乘</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A=torch.range(<span class="number">15</span>).reshape(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line">B=torch.range(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">torch.mm(A,B)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[[ 20,  23,  26,  29],</span></span><br><span class="line"><span class="string">        [ 56,  68,  80,  92],</span></span><br><span class="line"><span class="string">        [ 92, 113, 134, 155],</span></span><br><span class="line"><span class="string">        [128, 158, 188, 218],</span></span><br><span class="line"><span class="string">        [164, 203, 242, 281]]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h3 id="范数-norm">范数 norm<a class="anchor" href="#范数-norm">·</a></h3><p>将向量<strong>x</strong>映射到标量的函数$f$</p><p>满足三个性质</p><ul><li>$f(\alpha x)=|\alpha|f(x)$</li><li>$f(x+y)\leq f(x)+f(y)$，三角不等式</li><li>$f(x)\ge 0$，当且仅当<strong>x</strong>分量全为0时相等</li></ul><p>$L_2$范数：$||x||<em>2=\sqrt{(\sum</em>{i=1}<sup>nx_i</sup>2)}$ 一般可以简写为$||x||$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u=torch.tensor([<span class="number">3.0</span>,<span class="number">4.0</span>])</span><br><span class="line">torch.norm(u) <span class="comment">#==&gt;[5.0]</span></span><br></pre></td></tr></table></figure><p>$L_1$范数：$||x||<em>1=\sum</em>{i=1}^n|x_i|$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u=torch.tensor([<span class="number">3.0</span>,<span class="number">4.0</span>])</span><br><span class="line">torch.abs(u).sum() <span class="comment">#==&gt;[7.0]</span></span><br></pre></td></tr></table></figure><p>$L_p$范数：$||x||<em>p=(\sum</em>{i=1}<sup>n|x_i|</sup>p)^{1/p}$</p><p>矩阵的$Frobenius$范数（Frobenius norm）是矩阵元素平方和的平方根</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.norm(torch.ones((<span class="number">4</span>, <span class="number">9</span>))) <span class="comment">#==&gt;tensor(6.)</span></span><br></pre></td></tr></table></figure><p>深度学习中的目标常表达为范数</p><h2 id="2-4微积分">2.4微积分<a class="anchor" href="#2-4微积分">·</a></h2><h2 id="2-5自动微分">2.5自动微分<a class="anchor" href="#2-5自动微分">·</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#标量计算梯度</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">x = torch.arange(<span class="number">4.0</span>)</span><br><span class="line">x.requires_grad_(<span class="literal">True</span>)</span><br><span class="line">y=<span class="number">10</span>*torch.dot(x,x)</span><br><span class="line">y.backward()</span><br><span class="line">x.grad  <span class="comment">#[0.,4.,8.,12.]</span></span><br><span class="line">x.grad==<span class="number">20</span>*x </span><br><span class="line"></span><br><span class="line">x.grad.zero_() <span class="comment">#清除梯度</span></span><br><span class="line">y = x.sum()</span><br><span class="line">y.backward()</span><br><span class="line">x.grad <span class="comment">#[1.,1.,1.,1.]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#非标量变量的反向传播</span></span><br><span class="line">x.grad.zero_()</span><br><span class="line">y = x * x</span><br><span class="line">y.sum().backward() <span class="comment">#等价于y.backward(torch.ones(len(x)))</span></span><br><span class="line">x.grad <span class="comment">#相当于2x 即[0,2,4,6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#分离计算</span></span><br><span class="line">x.grad.zero_()</span><br><span class="line">y = x * x </span><br><span class="line">u = y.detach() <span class="comment">#将u与x进行分离，即作为常数参与之后的运算</span></span><br><span class="line">z = u * x </span><br><span class="line">z.sum().backward() </span><br><span class="line">x.grad == u <span class="comment">#是一样的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Python控制流的梯度计算</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a)</span>:</span></span><br><span class="line">b = a * <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> b.norm() &lt; <span class="number">1000</span>: </span><br><span class="line">        b = b * <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> b.sum() &gt; <span class="number">0</span>: c = b</span><br><span class="line"><span class="keyword">else</span>:c = <span class="number">100</span> * b</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">a = torch.randn(size=(), requires_grad=<span class="literal">True</span>) </span><br><span class="line">d = f(a)</span><br><span class="line">d.backward()</span><br></pre></td></tr></table></figure><h2 id="2-6概率">2.6概率<a class="anchor" href="#2-6概率">·</a></h2><h2 id="2-7查阅⽂档">2.7查阅⽂档<a class="anchor" href="#2-7查阅⽂档">·</a></h2><h1 id="3-线性神经网络（LNN）">3.线性神经网络（LNN）<a class="anchor" href="#3-线性神经网络（LNN）">·</a></h1><h2 id="线性回归">线性回归<a class="anchor" href="#线性回归">·</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils <span class="keyword">import</span> data</span><br><span class="line"><span class="comment">#生成原始数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">synthetic_data</span><span class="params">(w, b, num_examples)</span>:</span></span><br><span class="line">    <span class="string">"""生成y=Xw+b+噪声</span></span><br><span class="line"><span class="string">    Defined in :numref:`sec_linear_scratch`"""</span></span><br><span class="line">    X = torch.normal(<span class="number">0</span>, <span class="number">1</span>, (num_examples, len(w)))</span><br><span class="line">    y = torch.matmul(X, w) + b</span><br><span class="line">    y += torch.normal(<span class="number">0</span>, <span class="number">0.01</span>, y.shape)</span><br><span class="line">    <span class="keyword">return</span> X, torch.reshape(y, (<span class="number">-1</span>, <span class="number">1</span>))</span><br><span class="line">true_w = torch.tensor([<span class="number">2</span>, <span class="number">-3.4</span>])</span><br><span class="line">true_b = <span class="number">4.2</span></span><br><span class="line">features, labels = synthetic_data(true_w, true_b, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义加载数据方法，获得迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_array</span><span class="params">(data_arrays, batch_size, is_train=True)</span>:</span> </span><br><span class="line">    <span class="string">"""构造一个PyTorch数据迭代器。"""</span></span><br><span class="line">    dataset = data.TensorDataset(*data_arrays)</span><br><span class="line">    <span class="keyword">return</span> data.DataLoader(dataset, batch_size, shuffle=is_train)</span><br><span class="line">batch_size = <span class="number">10</span></span><br><span class="line">data_iter = load_array((features, labels), batch_size)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义网络</span></span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line">net = nn.Sequential(nn.Linear(<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义初始权重</span></span><br><span class="line">net[<span class="number">0</span>].weight.data.normal_(<span class="number">0</span>, <span class="number">0.01</span>)</span><br><span class="line">net[<span class="number">0</span>].bias.data.fill_(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义损失函数与优化方法</span></span><br><span class="line">loss = nn.MSELoss() <span class="comment">#2范数损失的平均值</span></span><br><span class="line">trainer = torch.optim.SGD(net.parameters(), lr=<span class="number">0.03</span>) <span class="comment">#net.parameters()指定需要优化的参数，同时还需要传入优化算法需要的超参数字典，对于小批量随机梯度下降，这里是lr=0.03</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#开始训练</span></span><br><span class="line">num_epochs = <span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(num_epochs):</span><br><span class="line">  <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter:</span><br><span class="line">      <span class="comment">#前向计算</span></span><br><span class="line">    l = loss(net(X) ,y)</span><br><span class="line">    <span class="comment">#清除梯度</span></span><br><span class="line">    trainer.zero_grad()</span><br><span class="line">    <span class="comment">#反向传播</span></span><br><span class="line">    l.backward()</span><br><span class="line">    <span class="comment">#优化器根据梯度进行梯度计算更新</span></span><br><span class="line">    trainer.step()</span><br><span class="line">    <span class="comment">#计算打印损失</span></span><br><span class="line">    l = loss(net(features), labels)</span><br><span class="line">  print(<span class="string">f'epoch <span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>, loss <span class="subst">&#123;l:f&#125;</span>'</span>)</span><br></pre></td></tr></table></figure><h2 id="softmax回归">softmax回归<a class="anchor" href="#softmax回归">·</a></h2><p>$softmax$ 运算：$y_j=\frac {exp(o_j)} {\sum_{k=1}^nexp(o_k)}$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision,torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取输入</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_dataloader_workers</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""使用4个进程来读取数据"""</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data_fashion_mnist</span><span class="params">(batch_size, resize=None)</span>:</span></span><br><span class="line">    <span class="string">"""下载Fashion-MNIST数据集，然后将其加载到内存中"""</span></span><br><span class="line">    trans = [transforms.ToTensor()]</span><br><span class="line">    <span class="keyword">if</span> resize:</span><br><span class="line">        trans.insert(<span class="number">0</span>, transforms.Resize(resize))</span><br><span class="line">    trans = transforms.Compose(trans)</span><br><span class="line">    mnist_train = torchvision.datasets.FashionMNIST(</span><br><span class="line">        root=<span class="string">"../data"</span>, train=<span class="literal">True</span>, transform=trans, download=<span class="literal">True</span>)</span><br><span class="line">    mnist_test = torchvision.datasets.FashionMNIST(</span><br><span class="line">        root=<span class="string">"../data"</span>, train=<span class="literal">False</span>, transform=trans, download=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> (data.DataLoader(mnist_train, batch_size, shuffle=<span class="literal">True</span>,</span><br><span class="line">                            num_workers=get_dataloader_workers()),</span><br><span class="line">            data.DataLoader(mnist_test, batch_size, shuffle=<span class="literal">False</span>,</span><br><span class="line">                            num_workers=get_dataloader_workers()))</span><br><span class="line">batch_size = <span class="number">256</span></span><br><span class="line">train_iter, test_iter = load_data_fashion_mnist(batch_size)</span><br><span class="line"></span><br><span class="line"><span class="comment"># PyTorch不会隐式地调整输⼊的形状。因此，</span></span><br><span class="line"><span class="comment"># 我们在线性层前定义了展平层（flatten），来调整⽹络输⼊的形状</span></span><br><span class="line">net = nn.Sequential(nn.Flatten(), nn.Linear(<span class="number">784</span>, <span class="number">10</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_weights</span><span class="params">(m)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> type(m) == nn.Linear:</span><br><span class="line">    nn.init.normal_(m.weight, std=<span class="number">0.01</span>)</span><br><span class="line">net.apply(init_weights)</span><br><span class="line"><span class="comment">#损失函数为交叉熵</span></span><br><span class="line">loss = nn.CrossEntropyLoss(reduction=<span class="string">'none'</span>)</span><br><span class="line">trainer = torch.optim.SGD(net.parameters(), lr=<span class="number">0.1</span>)</span><br><span class="line">num_epochs = <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(num_epochs):</span><br><span class="line">    <span class="keyword">for</span> X,y <span class="keyword">in</span> train_iter:</span><br><span class="line">      <span class="comment">#前向计算</span></span><br><span class="line">      l=loss(net(X),y)</span><br><span class="line">      <span class="comment">#清除梯度</span></span><br><span class="line">      trainer.zero_grad()</span><br><span class="line">      <span class="comment">#反向传播</span></span><br><span class="line">      l.mean().backward()</span><br><span class="line">      <span class="comment">#更新权重</span></span><br><span class="line">      trainer.step()</span><br><span class="line">    loss_sum = <span class="number">0</span></span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> X,y <span class="keyword">in</span> test_iter:</span><br><span class="line">      loss_sum+=loss(net(X),y).sum()</span><br><span class="line">      cnt+=<span class="number">1</span></span><br><span class="line">    print(<span class="string">"epoch%d"</span>%i,<span class="string">":"</span>,float(loss_sum/cnt))</span><br></pre></td></tr></table></figure><h1 id="4-多层感知机（MLP）">4.多层感知机（MLP）<a class="anchor" href="#4-多层感知机（MLP）">·</a></h1><h2 id="多层感知机">多层感知机<a class="anchor" href="#多层感知机">·</a></h2><h3 id="实现">实现<a class="anchor" href="#实现">·</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#此处代码与第3章中softmax回归的代码除了net定义都是一样的</span></span><br><span class="line">net = nn.Sequential(</span><br><span class="line">    nn.Flatten(),</span><br><span class="line">    nn.Linear(<span class="number">784</span>,<span class="number">256</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.Linear(<span class="number">256</span>,<span class="number">10</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="激活函数">激活函数<a class="anchor" href="#激活函数">·</a></h3><h4 id="ReLU函数">ReLU函数<a class="anchor" href="#ReLU函数">·</a></h4><p>$ReLU(x)=max(x,0)$</p><h4 id="sigmoid函数">sigmoid函数<a class="anchor" href="#sigmoid函数">·</a></h4><p>$sigmoid(x)=\frac {1} {1+exp(-x)}$</p><h4 id="tanh函数">tanh函数<a class="anchor" href="#tanh函数">·</a></h4><p>$tanh(x)=\frac {1-exp(-2x)} {1+exp(-2x)}$</p><h2 id="模型选择、欠拟合和过拟合">模型选择、欠拟合和过拟合<a class="anchor" href="#模型选择、欠拟合和过拟合">·</a></h2><h2 id="权重衰减">权重衰减<a class="anchor" href="#权重衰减">·</a></h2><p>给权重加上惩罚项，也称为$L_2$正则化</p><p>最简单的方式：直接使用权重向量的某个范数来度量复杂性，比如二范数</p><p>即损失变为：$L(w,b)+\frac \lambda 2 ||\omega||^2$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#此处代码与第3章中softmax回归的代码除了trainer定义都是一样的</span></span><br><span class="line">wd=<span class="number">3</span></span><br><span class="line">trainer=torch.optim.SGD([</span><br><span class="line">&#123;<span class="string">"params"</span>:net[<span class="number">0</span>].weight,<span class="string">'weight_decay'</span>:wd&#125;,</span><br><span class="line">&#123;<span class="string">"params"</span>:net[<span class="number">0</span>].bias&#125;],lr=lr)</span><br></pre></td></tr></table></figure><h2 id="暂退法">暂退法<a class="anchor" href="#暂退法">·</a></h2><p>扰动或者随机抛弃一些隐藏层的输出（即下一层输入）降低影响</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#此处代码与第3章中softmax回归的代码除了net定义都是一样的</span></span><br><span class="line">net = nn.Sequential(</span><br><span class="line">    nn.Flatten(),</span><br><span class="line">    nn.ReLU(),    </span><br><span class="line">    nn.Dropout(<span class="number">0.2</span>) <span class="comment">#抛弃20%的隐藏层神经元</span></span><br><span class="line">    nn.Linear(<span class="number">784</span>,<span class="number">256</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.Dropout(<span class="number">0.2</span>) <span class="comment">#抛弃20%的隐藏层神经元</span></span><br><span class="line">    nn.Linear(<span class="number">256</span>,<span class="number">10</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="前向传播，反向传播与计算图">前向传播，反向传播与计算图<a class="anchor" href="#前向传播，反向传播与计算图">·</a></h2><h2 id="数值稳定性和模型初始化">数值稳定性和模型初始化<a class="anchor" href="#数值稳定性和模型初始化">·</a></h2><h2 id="环境与分布偏移">环境与分布偏移<a class="anchor" href="#环境与分布偏移">·</a></h2><h1 id="5-深度学习计算">5.深度学习计算<a class="anchor" href="#5-深度学习计算">·</a></h1><h2 id="层和块">层和块<a class="anchor" href="#层和块">·</a></h2><h3 id="自定义块">自定义块<a class="anchor" href="#自定义块">·</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.nn.modules.flatten <span class="keyword">import</span> Flatten</span><br><span class="line"><span class="keyword">import</span> torchvision,torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MLP</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.hidden=nn.Linear(<span class="number">20</span>,<span class="number">256</span>)</span><br><span class="line">        self.output=nn.Linear(<span class="number">256</span>,<span class="number">10</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,X)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.output(F.relu(self.hidden(X)))</span><br><span class="line">mlp=MLP()</span><br><span class="line">X=torch.arange(<span class="number">20</span>,dtype=torch.float32)</span><br><span class="line">mlp(X)</span><br></pre></td></tr></table></figure><h3 id="顺序块">顺序块<a class="anchor" href="#顺序块">·</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySequential</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">super().__init__()</span><br><span class="line"><span class="keyword">for</span> idx, module <span class="keyword">in</span> enumerate(args):</span><br><span class="line">            <span class="comment"># 这⾥，module是Module⼦类的⼀个实例。我们把它保存在'Module'类的成员</span></span><br><span class="line">            <span class="comment"># 变量_modules中。module的类型是OrderedDict</span></span><br><span class="line">            self._modules[str(idx)] = module</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        <span class="comment"># OrderedDict保证了按照成员添加的顺序遍历它们</span></span><br><span class="line">        <span class="keyword">for</span> block <span class="keyword">in</span> self._modules.values():</span><br><span class="line">        X = block(X)</span><br><span class="line">        <span class="keyword">return</span> X</span><br><span class="line">net = MySequential(nn.Linear(<span class="number">20</span>, <span class="number">256</span>), nn.ReLU(), nn.Linear(<span class="number">256</span>, <span class="number">10</span>))</span><br><span class="line">net(X)</span><br></pre></td></tr></table></figure><h3 id="前向传播函数中执行代码">前向传播函数中执行代码<a class="anchor" href="#前向传播函数中执行代码">·</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyForwardSequential</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        <span class="comment"># 不计算梯度的随机权重参数。因此其在训练期间保持不变</span></span><br><span class="line">        self.rand_weight = torch.rand((<span class="number">20</span>, <span class="number">20</span>), requires_grad=<span class="literal">False</span>)</span><br><span class="line">        self.linear = nn.Linear(<span class="number">20</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        <span class="comment"># OrderedDict保证了按照成员添加的顺序遍历它们</span></span><br><span class="line">        X=self.linear(X)</span><br><span class="line">        X=F.relu(X)</span><br><span class="line">        X=self.linear(X)</span><br><span class="line">        <span class="comment">#控制流</span></span><br><span class="line">        <span class="keyword">while</span> X.sum()&gt;<span class="number">1</span>:</span><br><span class="line">            X/=<span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> X.sum()</span><br><span class="line">net = MyForwardSequential()</span><br><span class="line">net(X)</span><br></pre></td></tr></table></figure><h2 id="参数管理">参数管理<a class="anchor" href="#参数管理">·</a></h2><h3 id="参数访问">参数访问<a class="anchor" href="#参数访问">·</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">net = nn.Sequential(nn.Linear(<span class="number">4</span>, <span class="number">8</span>), nn.ReLU(), nn.Linear(<span class="number">8</span>, <span class="number">1</span>))</span><br><span class="line">net[<span class="number">2</span>].state_dict()</span><br><span class="line">net[<span class="number">2</span>].bias</span><br><span class="line">net[<span class="number">2</span>].bias.data</span><br><span class="line">net[<span class="number">2</span>].bias.grad</span><br><span class="line">net[<span class="number">2</span>].weight</span><br><span class="line">net[<span class="number">2</span>].weight.data</span><br><span class="line">net[<span class="number">2</span>].weight.grad</span><br><span class="line"><span class="comment">#新的获取参数的方式</span></span><br><span class="line">print(*[(name, param.shape) <span class="keyword">for</span> name, param <span class="keyword">in</span> net[<span class="number">2</span>].named_parameters()])</span><br><span class="line">print(*[(name, param.shape) <span class="keyword">for</span> name, param <span class="keyword">in</span> net.named_parameters()])</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">('weight', torch.Size([1, 8])) ('bias', torch.Size([1]))</span></span><br><span class="line"><span class="string">('0.weight', torch.Size([8, 4])) ('0.bias', torch.Size([8])) ('2.weight', torch.Size([1, 8])) ('2.bias', torch.Size([1]))</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="参数初始化">参数初始化<a class="anchor" href="#参数初始化">·</a></h3><h4 id="内置初始化">内置初始化<a class="anchor" href="#内置初始化">·</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_normal</span><span class="params">(m)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> type(m) == nn.Linear:</span><br><span class="line">        nn.init.normal_(m.weight, mean=<span class="number">0</span>, std=<span class="number">0.01</span>)</span><br><span class="line">        nn.init.zeros_(m.bias)</span><br><span class="line">        nn.init.constant_(m.weight,<span class="number">1</span>) <span class="comment">#设置为一个常数</span></span><br><span class="line">        nn.init.xavier_uniform_(m.weight) <span class="comment">#Xavier初始化⽅法 防止梯度消失或者地图爆炸</span></span><br><span class="line">net.apply(init_normal)  </span><br><span class="line"><span class="comment">#不同层使用不同初始化方法</span></span><br><span class="line">net[<span class="number">0</span>].apply(xavier)</span><br><span class="line">net[<span class="number">2</span>].apply(init_42)</span><br><span class="line">print(net[<span class="number">0</span>].weight.data[<span class="number">0</span>])</span><br><span class="line">print(net[<span class="number">2</span>].weight.data)</span><br></pre></td></tr></table></figure><h2 id="延后初始化">延后初始化<a class="anchor" href="#延后初始化">·</a></h2><p>输入维度与前一层输出维度都延后到第一次计算时自动进行推断</p><h2 id="自定义层">自定义层<a class="anchor" href="#自定义层">·</a></h2><h3 id="不带参数">不带参数<a class="anchor" href="#不带参数">·</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CenteredLayer</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> X - X.mean()</span><br><span class="line">net=nn.Sequential(</span><br><span class="line">    nn.Linear(<span class="number">20</span>,<span class="number">12</span>),</span><br><span class="line">    CenteredLayer(),</span><br><span class="line">    nn.Dropout(<span class="number">0.8</span>),</span><br><span class="line">    nn.ReLU()</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="带参数">带参数<a class="anchor" href="#带参数">·</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinear</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,innum,outnum)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.weight=nn.Parameter(torch.randn(innum,outnum))</span><br><span class="line">        self.bias=nn.Parameter(torch.randn(outnum))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,X)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> torch.matmul(X,self.weight.data)+self.bias.data <span class="comment">#此处不能用mm！！</span></span><br></pre></td></tr></table></figure><h2 id="读写文件">读写文件<a class="anchor" href="#读写文件">·</a></h2><h3 id="加载和保存张量">加载和保存张量<a class="anchor" href="#加载和保存张量">·</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x=torch.arange(<span class="number">24</span>)</span><br><span class="line">torch.save(x,<span class="string">'x-tensor'</span>)</span><br><span class="line">x=torch.load(<span class="string">'x-tensor'</span>)</span><br><span class="line">torch.save([x,y],<span class="string">'x-tensor'</span>)</span><br><span class="line">x,y=torch.load(<span class="string">'x-tensor'</span>)</span><br><span class="line">torch.save(&#123;<span class="string">'x'</span>:x,<span class="string">'y'</span>:y&#125;,<span class="string">'dict'</span>)</span><br><span class="line">mydict=torch.load(<span class="string">'dict'</span>)</span><br></pre></td></tr></table></figure><h3 id="加载和保存模型参数">加载和保存模型参数<a class="anchor" href="#加载和保存模型参数">·</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net=MLP()</span><br><span class="line">torch.save(net.state_dict(),<span class="string">'mlp.params'</span>)</span><br><span class="line">net.load_state_dict(torch.load(<span class="string">'mlp.params'</span>))</span><br><span class="line">net.eval() <span class="comment">#不更新梯度，只计算</span></span><br></pre></td></tr></table></figure><h2 id="GPU">GPU<a class="anchor" href="#GPU">·</a></h2><h3 id="计算设备">计算设备<a class="anchor" href="#计算设备">·</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line">torch.device(<span class="string">'cpu'</span>)</span><br><span class="line">torch.device(<span class="string">'cuda'</span>)</span><br><span class="line">torch.cuda.device_count()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">try_all_gpus</span><span class="params">()</span>:</span></span><br><span class="line">    devices=[torch.device(<span class="string">f'cuda:<span class="subst">&#123;i&#125;</span>'</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(torch.cuda.device_count())]</span><br><span class="line">    <span class="keyword">return</span> devices <span class="keyword">if</span> devices <span class="keyword">else</span> [torch.device(<span class="string">'cpu'</span>)]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">try_gpu</span><span class="params">(i=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> torch.device(<span class="string">'cpu'</span>) <span class="keyword">if</span> torch.cuda.device_count()&lt;i+<span class="number">1</span> <span class="keyword">else</span> torch.device(<span class="string">f'cuda:<span class="subst">&#123;i&#125;</span>'</span>)</span><br></pre></td></tr></table></figure><h3 id="张量与GPU">张量与GPU<a class="anchor" href="#张量与GPU">·</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#存储在GPU上</span></span><br><span class="line">x=torch.tensor([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">x.device <span class="comment">#device(type='cpu')</span></span><br><span class="line">x=torch.ones(<span class="number">2</span>,<span class="number">3</span>,device=try_gpu())</span><br><span class="line"><span class="comment">#复制</span></span><br><span class="line">x=torch.ones(<span class="number">2</span>,<span class="number">3</span>,device=try_gpu(<span class="number">0</span>))</span><br><span class="line">x=torch.ones(<span class="number">2</span>,<span class="number">3</span>,device=try_gpu(<span class="number">1</span>))</span><br><span class="line">Z=X.cuda(<span class="number">1</span>) <span class="comment">#将X的数据复制到第0块GPU上</span></span><br></pre></td></tr></table></figure><h3 id="神经网络与GPU">神经网络与GPU<a class="anchor" href="#神经网络与GPU">·</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net=nn.Sequential(nn.Linear(<span class="number">3</span>,<span class="number">1</span>))</span><br><span class="line">net=net.to(device=(try_gpu()))</span><br><span class="line"><span class="comment">#之后net的所有计算都会在GPU上</span></span><br></pre></td></tr></table></figure><h1 id="6-卷积神经网络（CNN）">6.卷积神经网络（CNN）<a class="anchor" href="#6-卷积神经网络（CNN）">·</a></h1><h2 id="卷积基础">卷积基础<a class="anchor" href="#卷积基础">·</a></h2><h3 id="卷积核">卷积核<a class="anchor" href="#卷积核">·</a></h3><p>沃尔多检测器—空间不变性！</p><p>从二维图像输入，即二维张量$m*n$开始，则如果隐藏层是全连接层，就会需要有$m<sup>2n</sup>2$个参数，此时的计算公式为：</p><p>$H_{i,j}=U_{i,j}+\sum_k\sum_lW_{i,j,k,l}X_{k,l}=U_{i,j}+\sum_{a}\sum_bV_{i,j,a,b}X_{i+a,j+b}$</p><p>此时利用图像的不变性原则，即对于同一个物体在不同处检测结果应该一致，所以有$V_{i,j,a,b}=V_{a,b}$</p><p>且$U$为常数，设为$u$</p><p>所以可以简化为$H_{i,j}=u+\sum_{a}\sum_bV_{a,b}X_{i+a,j+b}$，相当于对其$X_{i,j}$周边的像素进行加权得到$H_{i,j}$</p><p>同时，又考虑到局部性，因此最终的$H_{i,j}=u+\sum_{-\Delta}<sup>{\Delta}\sum_{-\Delta}</sup>{\Delta}V_{a,b}X_{i+a,j+b}$</p><p>这里的$V$是卷积核(convolution kernel)，或者说是滤波器(filter)</p><h3 id="通道">通道<a class="anchor" href="#通道">·</a></h3><p>输入的图像数据一般是三通道的，即红绿蓝，而维数则是3维张量。隐藏层一般也设置成3维张量，但由于需要学习更多的隐藏表示，每个隐藏表示是一系列具有二维张量的通道，比如纹理，边缘等等，有时也称为特征映射，被称为feature maps，为了表示多个隐藏表示，所以需要给卷积核增加一个维度，即</p><p>$H_{i,j,d}=\sum_{-\Delta}<sup>{\Delta}\sum_{-\Delta}</sup>{\Delta}\sum_cV_{a,b,c,d}X_{i+a,j+b,c}$</p><h2 id="图像卷积">图像卷积<a class="anchor" href="#图像卷积">·</a></h2><h3 id="互相关运算">互相关运算<a class="anchor" href="#互相关运算">·</a></h3><p>比如以下的卷积计算结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#input:</span></span><br><span class="line">[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line"> [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line"> [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line"><span class="comment">#卷积核:</span></span><br><span class="line">[[<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line"><span class="comment">#卷积结果:</span></span><br><span class="line">[[<span class="number">25</span>,<span class="number">31</span>],</span><br><span class="line"> [<span class="number">43</span>,<span class="number">49</span>]]</span><br></pre></td></tr></table></figure><p>输入为$n<em>m$，卷积核为$h</em>w$，则卷积相当于是一个正方块在输入的正方形进行移动计算，并到达自己能够到达的每个位置，最后的卷积结果为$(n-h+1)*(m-w+1)$</p><h3 id="卷积层">卷积层<a class="anchor" href="#卷积层">·</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构造⼀个⼆维卷积层，它具有1个输入通道，1个输出通道和形状为（1，2）的卷积核</span></span><br><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>,<span class="number">1</span>, kernel_size=(<span class="number">1</span>, <span class="number">2</span>), bias=<span class="literal">False</span>) </span><br><span class="line"><span class="comment"># 这个⼆维卷积层使⽤四维输⼊和输出格式（批量⼤⼩、通道、⾼度、宽度），</span></span><br><span class="line"><span class="comment"># 其中批量⼤⼩和通道数都为1 </span></span><br><span class="line">X = X.reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">8</span>))</span><br><span class="line">Y = Y.reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">7</span>))</span><br><span class="line">lr = <span class="number">3e-2</span> <span class="comment"># 学习率</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">Y_hat = conv2d(X)</span><br><span class="line">    l = (Y_hat - Y) ** <span class="number">2</span></span><br><span class="line">    conv2d.zero_grad()</span><br><span class="line">    l.sum().backward()</span><br><span class="line">    <span class="comment"># 迭代卷积核</span></span><br><span class="line">    conv2d.weight.data[:] -= lr * conv2d.weight.grad</span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">    print(<span class="string">f'epoch <span class="subst">&#123;i+<span class="number">1</span>&#125;</span>, loss <span class="subst">&#123;l.sum():<span class="number">.3</span>f&#125;</span>'</span>)</span><br></pre></td></tr></table></figure><h3 id="特征映射与感受野">特征映射与感受野<a class="anchor" href="#特征映射与感受野">·</a></h3><p>对于某⼀层的任意元素x，其感受野（receptive field）是指在前向传播期间可能影响x计算的所有元素（来⾃所有先前层）</p><h2 id="填充与步幅">填充与步幅<a class="anchor" href="#填充与步幅">·</a></h2><h3 id="填充">填充<a class="anchor" href="#填充">·</a></h3><p>对输入做填充处理从而捕捉边缘信息</p><img src="/2022/03/19/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2.png" style="zoom:67%;"><p>假设添加$p_h$行填充和$p_w$列填充，填充的内容都是上下差不多各一半，左右差不多各一半，则输出形状为 $(n_h-k_h+p_h+1)\times (n_w-k_w+p_w+1)$</p><p>所以一般设置 $p_h=k_h-1,p_w=k_w-1$ 这样就可以让输入输出形状相同</p><p>同时，如果满足：</p><ul><li>卷积核大小为奇数</li><li>所有边的填充行数与列数相同</li><li>输出与输入具有相同高度和宽度</li></ul><p>则可以得出：输出$Y[i,j]$是通过输入$X[i,j]$为中心，与卷积核进行互相关计算得到的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=(<span class="number">5</span>, <span class="number">3</span>), padding=(<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=(<span class="number">5</span>, <span class="number">3</span>), padding=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h3 id="步幅">步幅<a class="anchor" href="#步幅">·</a></h3><p>按照一定步幅进行卷积，从而输入的宽度高度减少一定比例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, stride=<span class="number">2</span>)</span><br><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">1</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, stride=(<span class="number">2</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>变为：$\lfloor(n_k-k_h+p_h+s_h)/s_h\rfloor\times \lfloor(n_w-k_w+p_w+s_w)/s_w\rfloor$</p><p>后面的池化也是类似的</p><h2 id="多输⼊多输出通道">多输⼊多输出通道<a class="anchor" href="#多输⼊多输出通道">·</a></h2><h3 id="多输入通道">多输入通道<a class="anchor" href="#多输入通道">·</a></h3><p>每个通道计算完成之后将每个通道卷积得到的结果相加</p><img src="/2022/03/19/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3.png" style="zoom: 67%;"><h3 id="多输出通道">多输出通道<a class="anchor" href="#多输出通道">·</a></h3><p>在之前多输入基础上，加上一个维度来产生多通道的输出，相当于每一个通道自己有一组核函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">K = torch.stack((K, K + <span class="number">1</span>, K + <span class="number">2</span>), <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="汇聚层">汇聚层<a class="anchor" href="#汇聚层">·</a></h2><p>汇聚层目的：降低卷积层对<strong>位置</strong>的敏感性，降低对<strong>空间降采样</strong>表示的敏感性</p><h3 id="最大汇聚层与平均汇聚层">最大汇聚层与平均汇聚层<a class="anchor" href="#最大汇聚层与平均汇聚层">·</a></h3><p>不包含参数，具有确定性，即直接计算汇聚窗口中的所有元素的最大值或平均值</p><p><img src="/2022/03/19/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/4.png" alt></p><p>同样，汇聚层也具有<strong>填充和步幅</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pool2d = nn.MaxPool2d(<span class="number">3</span>,padding=<span class="number">1</span>, stride=<span class="number">2</span>) <span class="comment">#这里的padding相当于是上下各加1行，左右各加一列</span></span><br><span class="line">pool2d = nn.MaxPool2d(<span class="number">3</span>,padding=(<span class="number">1</span>,<span class="number">2</span>), stride=(<span class="number">2</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>多通道时，每个输入通道单独运算而不会对结果汇总，因此输出的通道数量与输入通道数相同</p><h2 id="卷积神经网络（LeNet）">卷积神经网络（LeNet）<a class="anchor" href="#卷积神经网络（LeNet）">·</a></h2><p>Lenet包含两个部分：</p><ul><li>卷积编码器：两个卷积块组成<ul><li>每个卷积块包含1个卷积层，1个sigmoid激活函数，还有平均汇聚层</li></ul></li><li>全连接层密集块：三个全连接层组成</li></ul><h3 id="网络结构">网络结构<a class="anchor" href="#网络结构">·</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#输入为28*28</span></span><br><span class="line">net = nn.Sequential(</span><br><span class="line">    nn.Conv2d(<span class="number">1</span>, <span class="number">6</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">2</span>), nn.Sigmoid(), <span class="comment">#==&gt;6*28*28</span></span><br><span class="line">    nn.AvgPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>), <span class="comment">#==&gt;(28-2+2)/2=14 6*14*14</span></span><br><span class="line">    nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, kernel_size=<span class="number">5</span>), nn.Sigmoid(), <span class="comment">#==&gt;16*10*10</span></span><br><span class="line">    nn.AvgPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>), <span class="comment">#==&gt;16*5*5</span></span><br><span class="line">    nn.Flatten(), <span class="comment">#==&gt;400</span></span><br><span class="line">    nn.Linear(<span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">120</span>), nn.Sigmoid(),</span><br><span class="line">    nn.Linear(<span class="number">120</span>, <span class="number">84</span>), nn.Sigmoid(),</span><br><span class="line">    nn.Linear(<span class="number">84</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure><h1 id="7-现代卷积神经网络">7.现代卷积神经网络<a class="anchor" href="#7-现代卷积神经网络">·</a></h1><ul><li>AlexNet。它是第⼀个在⼤规模视觉竞赛中击败传统计算机视觉模型的⼤型神经⽹络；</li><li>使⽤重复块的⽹络（VGG）。它利⽤许多重复的神经⽹络块；</li><li>⽹络中的⽹络（NiN）。它重复使⽤由卷积层和1 <em>×</em> 1卷积层（⽤来代替全连接层）来构建深层⽹络;</li><li>含并⾏连结的⽹络（GoogLeNet）。它使⽤并⾏连结的⽹络，通过不同窗⼝⼤⼩的卷积层和最⼤汇聚层来并⾏抽取信息；</li><li>残差⽹络（ResNet）。它通过残差块构建跨层的数据通道，是计算机视觉中最流⾏的体系架构；</li><li>稠密连接⽹络（DenseNet）。它的计算成本很⾼，但给我们带来了更好的效果。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DeepLearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件案例分析-音乐软件界的卧龙凤雏-酷狗音乐与网易云音乐</title>
      <link href="2022/03/14/%E8%BD%AF%E4%BB%B6%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-%E9%9F%B3%E4%B9%90%E8%BD%AF%E4%BB%B6%E7%95%8C%E7%9A%84%E5%8D%A7%E9%BE%99%E5%87%A4%E9%9B%8F-QQ%E9%9F%B3%E4%B9%90%E4%B8%8E%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90/"/>
      <url>2022/03/14/%E8%BD%AF%E4%BB%B6%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-%E9%9F%B3%E4%B9%90%E8%BD%AF%E4%BB%B6%E7%95%8C%E7%9A%84%E5%8D%A7%E9%BE%99%E5%87%A4%E9%9B%8F-QQ%E9%9F%B3%E4%B9%90%E4%B8%8E%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>项目</th><th>内容</th></tr></thead><tbody><tr><td>这个作业属于哪个课程</td><td><a href="https://bbs.csdn.net/forums/BH-SE" target="_blank" rel="noopener">2022春季软件工程（罗杰 任健）</a></td></tr><tr><td>这个作业的要求在哪里</td><td><a href="https://bbs.csdn.net/topics/605231753" target="_blank" rel="noopener">个人作业-软件案例分析</a></td></tr><tr><td>我在这个课程的目标是</td><td>学习软工的项目合作管理知识，提升软件开发技术</td></tr><tr><td>这个作业在哪个具体方面帮助我实现目标</td><td>深入分析软件的功能与问题，学习如何进行软件测评以及调研市场需求</td></tr></tbody></table><h1 id="Part0-前言">Part0 前言<a class="anchor" href="#Part0-前言">·</a></h1><p>现在许多人生活中都离不开音乐，而当前主要的听音乐方式毫无疑问就是各种音乐软件，包括移动端，Web端，PC客户端这三种主要的软件呈现形式，当前国内的音乐app数量众多，本次作业主要选取笔者和朋友们日常使用最多的两款软件，即：</p><ul><li>酷狗音乐</li><li>网易云音乐</li></ul><p>进行对比分析，做较为深入的评测分析。需要说明的是，由于笔者过去用酷狗，现在用网易云，没怎么使用过QQ音乐，虽然QQ音乐目前市场占有率也很高，但暂时不纳入本次博客的范围，有时间补上。在具体的软件形式上，考虑到中国手机市场目前主要被安卓手机占据（2021年安卓手机份额占比84%），以及PC端的较长的产品历史，主要选取比较成熟的PC客户端和安卓app端进行分析，ios与mac等苹果生态产品暂不纳入本次考虑范围。</p><h1 id="Part1-调研-评测">Part1 调研+评测<a class="anchor" href="#Part1-调研-评测">·</a></h1><p>开始之前，先明确几件事情，<strong>bug等级</strong>，<strong>音乐软件功能</strong>和<strong>评测环境</strong>。</p><h2 id="1-0-概念定义">1.0 概念定义<a class="anchor" href="#1-0-概念定义">·</a></h2><h3 id="bug等级">bug等级<a class="anchor" href="#bug等级">·</a></h3><table><thead><tr><th>星级</th><th>bug波及范围</th></tr></thead><tbody><tr><td>⭐⭐⭐⭐⭐</td><td>致命性系统故障；致命性安全漏洞</td></tr><tr><td>⭐⭐⭐⭐</td><td>严重系统故障；严重安全漏洞；严重影响用户体验</td></tr><tr><td>⭐⭐⭐</td><td>一定程度的系统故障；一定程度的安全漏洞；严重影响用户体验</td></tr><tr><td>⭐⭐</td><td>较大影响用户体验</td></tr><tr><td>⭐</td><td>略微影响用户体验</td></tr></tbody></table><h3 id="音乐软件功能">音乐软件功能<a class="anchor" href="#音乐软件功能">·</a></h3><p>由于当下的音乐APP功能繁多，因此笔者先按照自己的理解将常见的功能分为以下七类方便描述</p><p>其中听，评，探，搜是几大app的主要竞争区域，也是容易产生差异化的部分，被纳入了核心功能。而后三类往往普通用户的使用频率会相对低一些，被纳入了辅助功能。</p><table><thead><tr><th style="text-align:center">功能名称</th><th style="text-align:center">功能具体举例</th><th style="text-align:center">功能类别</th></tr></thead><tbody><tr><td style="text-align:center">听</td><td style="text-align:center">听音乐 查看歌词 播放MV 下载音乐</td><td style="text-align:center">核心功能</td></tr><tr><td style="text-align:center">评</td><td style="text-align:center">歌曲评论 音乐交流社区</td><td style="text-align:center">核心功能</td></tr><tr><td style="text-align:center">探</td><td style="text-align:center">音乐推荐 探索 收藏歌曲 歌单</td><td style="text-align:center">核心功能</td></tr><tr><td style="text-align:center">搜</td><td style="text-align:center">歌曲搜索 听歌识曲</td><td style="text-align:center">核心功能</td></tr><tr><td style="text-align:center">看</td><td style="text-align:center">电台 主播 视频</td><td style="text-align:center">辅助功能</td></tr><tr><td style="text-align:center">唱</td><td style="text-align:center">创作 音乐发行</td><td style="text-align:center">辅助功能</td></tr><tr><td style="text-align:center">我</td><td style="text-align:center">个性化皮肤 彩铃 壁纸 分享 歌单、收藏、喜欢管理</td><td style="text-align:center">辅助功能</td></tr></tbody></table><h3 id="评测环境">评测环境<a class="anchor" href="#评测环境">·</a></h3><h4 id="电脑端">电脑端<a class="anchor" href="#电脑端">·</a></h4><ul><li>戴尔灵越16</li><li>内存：32GB</li><li>CPU：酷睿i7-11800H @ 2.30GHz</li></ul><h4 id="安卓手机端">安卓手机端<a class="anchor" href="#安卓手机端">·</a></h4><ul><li>华为nova 5 Pro</li><li>内存：8GB</li><li>CPU：Huawei Kirin 980</li></ul><h2 id="1-1-网易云音乐">1.1 网易云音乐<a class="anchor" href="#1-1-网易云音乐">·</a></h2><h3 id="产品体验">产品体验<a class="anchor" href="#产品体验">·</a></h3><h4 id="初探">初探<a class="anchor" href="#初探">·</a></h4><p>PC端一打开就发现了一个微小的问题，如下图所示，windows的正在运行的图标栏中网易云的位置居然是<strong>空白</strong>，不过这个可能和具体的安装方式有关系，笔者的一位朋友就没遇到，然而还是让我对PC端有了<font color="red">很不好的第一印象</font></p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/1.png" style="zoom: 25%;"><p>之后登录进来之后，首页显示方面和app端还是保持了很高的一致性，主要包括<strong>发现音乐</strong>，<strong>播客</strong>，<strong>视频</strong>，<strong>关注</strong>，<strong>直播</strong>，<strong>私人FM</strong>这些官方提供的服务，以及<strong>我的音乐</strong>，<strong>创建的歌单</strong>，<strong>收藏的歌单</strong>等自定义功能。而客户端的顶部有各种按钮，主要与设置皮肤等配置功能。对比一下PC与移动端，可以看到设计上还是相对统一的，同时首页的推荐内容也是几乎一致的。</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/1.jpg" style="zoom: 18%;">       <img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/4.png" style="zoom:28%;"></p><h4 id="听">听<a class="anchor" href="#听">·</a></h4><p>PC端听歌界面大致将界面分为<strong>左中右三栏</strong>，分别是歌的碟片展示，歌词，以及相关的歌曲推荐。有效利用了空间。全屏模式体验感会更好一些，单纯看这个界面会<strong>不太友好</strong></p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/5.png" style="zoom: 25%;"><p>app端限于手机的屏幕尺寸，一个页面复用显示不同的内容。同时可以查看，上传乐谱，电脑端砍掉了这个乐谱的功能</p><p>​                                               <img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/2.jpg" alt="2" style="zoom:20%;">         <img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/3.jpg" style="zoom:20%;"></p><p>总的来说，PC端的按钮偏小了，页面总体的<strong>空白比较多</strong>，明明功能不少却让人感觉<strong>空空</strong>的感觉，而手机端则看起来很充实。至于具体的音量调节，歌曲切换，这些具体功能，用起来都比较丝滑。</p><p>值得一提的是手机端的播放功能有一个驾驶模式比较有趣，点进去之后会看到一个简洁的界面，方便开车的时候操作，只能说是非常贴心了，只保留了切换、暂停、关闭、喜爱等简单功能。</p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/4.jpg" style="zoom:20%;"><h4 id="评">评<a class="anchor" href="#评">·</a></h4><p>作为一个致力于打造云音乐社区的产品，网易云的评论功能应该是一个重点维护的功能。不过PC端仍然采用了比较传统的<strong>树洞博客式</strong>的<strong>交流方式设计</strong>，估计是大多用户都会使用手机端进行评论的原因。这样完全没有楼层和跟帖的感觉，一方面使用量少导致了这种设计，一方面这个设计也会减少客户端的评论使用率。</p><p>下面选用了手机端和PC同一首歌《young》进行对比。@来@去的确实是相对原始了，app的楼设计显然更合理，每一个评论都会单独建一个楼，在这个楼内大家才是互相@来显示相互之间的关系。而且app端也可以方便选择推荐，最热，最新评论帖子。</p><p>​                                   <img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/6.png" style="zoom:30%;"> <img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/5.jpg" style="zoom: 20%;"></p><p>作为社区，社交属性也是网易云想打造的，因此就有了话题与状态发布等功能，界面是直接复用了评论功能，总的来说和发pyq以及空间没有很大的区别（内容随意选的如有冒犯纯属偶然hhh）</p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/8.jpg" style="zoom:25%;"><h4 id="探">探<a class="anchor" href="#探">·</a></h4><p>这部分主要是<strong>推荐和探索</strong>功能，评价的方式主要是看看产品能不能为用户<strong>找到近期的感兴趣</strong>的音乐以及能否帮助用户<strong>打破音乐信息茧房</strong>，发现更多自己的兴趣。</p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/7.png" style="zoom:50%;"><p>以本人举例，笔者近期比较喜欢听旋律说唱和欧美流行，显然这个歌单还是很对胃口的，除了最近听的比较多的歌手以外，也有未曾听过的<strong>八三夭</strong>乐队推荐，据说类似五月天，也是我喜欢的一种风格，效果整体不错。除此之外，个人页面歌单助手的<strong>试试看</strong>功能也会随机提供各种兴趣关联密切或者不密切的内容，随机点一个进去也许就会有新的体会，这个功能体验还是不错的。</p><p>​                                     <img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/6.jpg" style="zoom:25%;">         <img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/7.jpg" alt="7" style="zoom:25%;"></p><p>其他方面比如曲库歌单排行榜等，按照歌手，风格进行各种分类，用户也可以自行探寻喜欢的歌曲</p><h4 id="搜">搜<a class="anchor" href="#搜">·</a></h4><p>PC端搜索功能只有历史和热搜，而手机端则有话题榜和视频榜，更加丰富。搜索的准确性自然毋庸置疑，说唱关键词下面也都是一般的中国hiphop近几年耳熟能详的歌曲，而且<strong>令人惊喜的是都是笔者喜欢</strong>的（<s><em>我家闪火占了两席怎能不爱</em></s>）</p><p>​                                             <img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/8.png" style="zoom: 40%;">  <img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/10.jpg" style="zoom:20%;"><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/9.jpg" style="zoom:20%;"></p><p>至于搜歌的另一方面，听歌识曲功能，电脑端只能识别播放中的歌曲，没法上传文件或者哼唱，估计是用的人少所以干脆没开发完整。而手机端提供了<strong>听歌识曲和哼唱识曲</strong>。识别功能，受限于时间，试了一个生日歌哼唱，简单的唱了开始的一句话，就识别出来了。手机端还推出了<strong>识别其他app的音乐</strong>和<strong>置顶显示结果</strong>的功能。以及识别结束之后也会提供准确度反馈。下图就是检测酷狗音乐中的《stay》的例子，检测时如果周围安静，只需要<strong>很小的声音</strong>就可以检测出来。</p><p>​                                                          <img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/11.jpg" style="zoom: 20%;"><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/12.jpg" alt="12" style="zoom:20%;"></p><h4 id="看">看<a class="anchor" href="#看">·</a></h4><p>主要包含直播，播客和云村的视频服务三方面内容，其中播客只是换了一点界面样式的听歌形式，不过内容包括各方面，比较丰富。直播内容和一般直播软件差不多，没有啥好说的，运存的视频播放观感类似抖音等视频分享软件的界面，<strong>艺人偷税</strong>的事件出现在这个软件也证明了网易云的<strong>复杂性和功能庞杂</strong>，居然还有<strong>新闻自媒体</strong>hhh。</p><p>​                           <img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/13.jpg" style="zoom:20%;"><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/15.jpg" alt="15" style="zoom:20%;"><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/14.jpg" style="zoom:20%;"></p><h4 id="唱">唱<a class="anchor" href="#唱">·</a></h4><p>网易云主要有<strong>音街K歌</strong>和<strong>录音创作</strong>两种方式，前者类似全民K歌提供录歌打分等服务，好处是直接和网易云歌库连接，即听即唱，岂不美哉！录音创作</p><h4 id="我">我<a class="anchor" href="#我">·</a></h4><p>网易云的个人音乐库管理以歌单为主，其他包括喜欢的音乐（其实也是一个歌单），最近播放，收藏歌等为辅</p><p>而皮肤功能如果是<strong>vip用户相当友好</strong>，普通用户就没太多可选项了</p><p>音乐彩铃，音乐闹钟都是直接和相关功能连接，很方便。</p><h3 id="功能性bug">功能性bug<a class="anchor" href="#功能性bug">·</a></h3><h4 id="电脑：我播了，手机：你没播！">电脑：我播了，手机：你没播！<a class="anchor" href="#电脑：我播了，手机：你没播！">·</a></h4><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/14.png" style="zoom: 25%;"><p>可以看到我PC端在10:08听了一首歌</p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/20.jpg" style="zoom:20%;"><p>而手机端显然没有出现相应播放记录。同时笔者在3.15一天在客户端听了大量歌曲，而手机端却一直没有相应的增长</p><p>反之，手机端的播放数据也没有及时出现在电脑端</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/21.jpg" style="zoom:20%;"> <img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/15.png" style="zoom:33%;"></p><p><strong>触发条件</strong>：使用网易云音乐PC客户端2.9.7版本，电脑端播放音乐，查看手机端8.7.03.193311版本的最近播放，反之亦然。同时电脑端和ios端的同样条件也会触发bug</p><p><strong>触发概率/复现概率</strong>：100%</p><p><strong>BUG分析</strong>：可能是出于隔离两个端用户的考虑？（显然有点说不通）手机上的播放数据也许和电脑端的数据并不是共享同一个数据库，而是分开处理了，从而导致了播放数据不同步。</p><p><strong>BUG严重程度</strong>：⭐⭐⭐⭐。原因：用户的两个端的播放数据不一致，显然导致很多时候使用起来会感到非常不协调，也有朋友抱怨这让他错失了早日<s>到达高级别的梦想</s></p><h4 id="我的评论哪去了？—-评论失踪事件">我的评论哪去了？— 评论失踪事件<a class="anchor" href="#我的评论哪去了？—-评论失踪事件">·</a></h4><p>在讨论区发一个达到字数限制的表情组合时发现了这样的bug</p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/22.jpg" style="zoom: 25%;"><p>可以看到显示有8条评论，然而下面只有7条评论🙀，那条评论消失了！！</p><p>可惜那一条是啥笔者发完就忘了，但是只记得是两个表情的组合</p><p>同时经过测试发现，下图的表情只能自己可见，其他人都看不到（注：此bug和YiFei大佬合作挖掘出来，故相关图可能一样），下图是两个用户的相同评论区内容</p><p>​                                                              <img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/26.jpg" style="zoom:20%;"> <img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/25.jpg" style="zoom:20%;"></p><p>然后之后就顺藤摸瓜发现了稳定复现的bug，可以看到下面两图种<strong>外面显示有11条</strong>，点进去之后<strong>里面显示有13条评论</strong>！！</p><p>​                                                              <img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/23.jpg" style="zoom:25%;"> <img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/25.jpg" style="zoom:20%;"></p><p><strong>触发条件</strong>：使用手机端8.7.03.193311版本的评论区打出上图中的表情至上限，就会出现内外评论数量不一致。同时极小概率会触发不知道原因的评论消失的情形。</p><p><strong>触发概率/复现概率</strong>：100%</p><p><strong>BUG分析</strong>：发出的表情不同人看不到大概率是因为权限设置问题，首先自己发的自己可以看到，但估计是因为文本屏蔽导致上述消息看不到。而评论数量不一致应该是外部和内部的搜索方式不一致，外部查找的是能看到的评论数，而内部则是显示全部的评论数量。</p><p><strong>BUG严重程度</strong>：⭐⭐⭐。原因：达到字数限制之后就会出现各种不稳定情况，尤其是表情，这会让网易云的社区这一王牌功能给用户带来一些不好的体验</p><h4 id="真的有在一起听音乐吗？">真的有在一起听音乐吗？<a class="anchor" href="#真的有在一起听音乐吗？">·</a></h4><p>如下图所示，如果两个人加入了一起听歌之后，再退出app一会，再进入，这段时间虽然我们确实没在听歌，但是显示的一起听歌时间还是在增长，<s>合着是空气人在听歌呗</s></p><h4 id="img-src-https-fzc-1300590701-cos-ap-nanjing-myqcloud-com-blogImages-2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐-27-jpg-style-zoom-20-img-src-https-fzc-1300590701-cos-ap-nanjing-myqcloud-com-blogImages-2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐-29-jpg-alt-28-style-zoom-20-img-src-https-fzc-1300590701-cos-ap-nanjing-myqcloud-com-blogImages-2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐-28-jpg-alt-29-style-zoom-20"><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/27.jpg" style="zoom:20%;"><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/29.jpg" alt="28" style="zoom:20%;"><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/28.jpg" alt="29" style="zoom:20%;"><a class="anchor" href="#img-src-https-fzc-1300590701-cos-ap-nanjing-myqcloud-com-blogImages-2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐-27-jpg-style-zoom-20-img-src-https-fzc-1300590701-cos-ap-nanjing-myqcloud-com-blogImages-2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐-29-jpg-alt-28-style-zoom-20-img-src-https-fzc-1300590701-cos-ap-nanjing-myqcloud-com-blogImages-2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐-28-jpg-alt-29-style-zoom-20">·</a></h4><p><strong>触发条件</strong>：两个人都使用手机端8.7.03.193311版本的一起听功能，并都直接退出app并清理运行内存。</p><p><strong>触发概率/复现概率</strong>：100%</p><p><strong>BUG分析</strong>：可能是只要进入了这个模式就会在数据库中相应位置标注正在一起听，而退出app没有改变或者暂停这个标志，导致实际时间不准确。</p><p><strong>BUG严重程度</strong>：⭐⭐。原因：一般人不会care这个小问题，<s>不过强迫症患者可能就不这么认为了</s></p><h4 id="诶，我的动态怎么不见了？">诶，我的动态怎么不见了？<a class="anchor" href="#诶，我的动态怎么不见了？">·</a></h4><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/16.png" style="zoom:33%;"><p>可以看到电脑端的个人页面我其实是有13条动态的，然而点进去之后。。。</p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/17.png" style="zoom:25%;"><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/18.png" style="zoom:25%;"><p>显然只有4条，那么消失的9条是啥情况呢？</p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/30.jpg" style="zoom:20%;"><p>是因为音街的原因，我在音街唱歌的记录在电脑端会看不到。不过如果打开次数足够多，偶尔也会显示几条【此消息无法在电脑上显示】</p><p><strong>触发条件</strong>：使用网易云音乐PC客户端2.9.7版本，电脑端打开个人动态页面，发现里面的实际内容达不到数量显示</p><p><strong>触发概率/复现概率</strong>：90% （10%的情况下会出现此消息无法在电脑上显示）</p><p><strong>BUG分析</strong>：猜测原因为手机端的音街功能电脑上开发难度过大也没有必要，所以开发团队选择摆烂，然而没摆彻底，有时候显示不支持显示此消息有时候直接没有</p><p><strong>BUG严重程度</strong>：⭐⭐⭐。原因：用户打开电脑端会以为自己进入了一个不同的app或者会怀疑自己到底有多少动态</p><h3 id="Bug-反馈">Bug 反馈<a class="anchor" href="#Bug-反馈">·</a></h3><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/24.png" style="zoom:50%;"><h3 id="结论">结论<a class="anchor" href="#结论">·</a></h3><p><font color="blue">好，不错</font></p><table><thead><tr><th>类别</th><th>描述</th><th>评分 （满分 10 分, 良好 6 分, 及格 4 分，聊胜于无 1 分, 很差 -3 分）</th></tr></thead><tbody><tr><td>听</td><td>听音乐 查看歌词 播放MV 下载音乐</td><td>8</td></tr><tr><td>评</td><td>歌曲评论 音乐交流社区</td><td>10</td></tr><tr><td>探</td><td>音乐推荐 探索 收藏歌曲 歌单</td><td>8</td></tr><tr><td>搜</td><td>歌曲搜索 听歌识曲</td><td>10</td></tr><tr><td>看</td><td>电台 主播 视频</td><td>9</td></tr><tr><td>唱</td><td>创作 音乐发行</td><td>10</td></tr><tr><td>我</td><td>个性化皮肤 彩铃 壁纸 分享 歌单、收藏、喜欢管理</td><td>8</td></tr><tr><td>细节</td><td>有什么为用户考虑的细节?</td><td>9</td></tr><tr><td>用户体验</td><td>当用户完成功能时，不干扰用户 (例如: 是否不断弹出不相关广告)。</td><td>9</td></tr><tr><td>差异化功能</td><td>这个软件独特的功能. 它对用户的吸引力有多大?</td><td>9</td></tr><tr><td>软件的效能</td><td>占用内存, 启动速度, 内存泄漏情况</td><td>8</td></tr><tr><td>软件的适应性</td><td>在联网/断网, 大小屏幕, 没有鼠标的情况下都可以顺畅操作. 和不同平台的软件能流畅协作</td><td>6</td></tr><tr><td>成长性</td><td>记住用户的选择, 适应用户的特点，用户越用越方便</td><td>7</td></tr><tr><td>用户有控制权</td><td>系统状态有反馈，等待时间要合适。关键操作有确认提示，有明确的错误信息。 让用户方便地从错误中恢复工作, 快捷操作键可调整。</td><td>8</td></tr><tr><td>整体使用感觉</td><td>曲库版权的丰富，完整性，用户环境</td><td>6</td></tr><tr><td>总评</td><td></td><td>125</td></tr></tbody></table><h3 id="用户采访">用户采访<a class="anchor" href="#用户采访">·</a></h3><p>英语专业大二学生，使用网易云超过4年，希望获得采访获得对于网易云的使用体验与感受</p><blockquote><p>Q：您一般会使用哪些网易云音乐的哪些栏目和功能？A：每日推荐，私人雷达，心动模式，私人FM；订阅歌手私信Q：在使用过程中您遇到了哪些亮点或者问题呢？A：自主网易音乐人很多，宝藏无限大；用户可以自己上传歌曲和歌词。小问题是有时候不小心取消红心了，没有撤回功能，重新点红心，歌曲顺序会改变，想让它一直在我歌单底层做不到。有时候误点到网易里自带的小程序，想切屏上滑退出小程序，网易就整个关掉重来，虽然现在貌似已经修复了Q：您有没有什么新的需求可以提出或者认为可以改进的部分？A：版权嘛老问题了；升级之后订阅歌手的私信居然不能单条删除了，以前可以的</p></blockquote><h2 id="1-2-酷狗音乐">1.2 酷狗音乐<a class="anchor" href="#1-2-酷狗音乐">·</a></h2><h3 id="产品体验-2">产品体验<a class="anchor" href="#产品体验-2">·</a></h3><h4 id="初探-2">初探<a class="anchor" href="#初探-2">·</a></h4><p>打开之后可以看到主要的默认状态的设计风格是<strong>蓝色</strong>。区别于网易云的歌单为最小单位，首页主要以<strong>单曲推荐</strong>为主，手机端也分为清晰的四栏，用户可以直接选择自己想要的功能（<em><s>没错，本文的7种功能的分类借鉴于此</s></em>）</p><p>​                   <img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/10.png" style="zoom: 25%;"> <img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/16.jpg" style="zoom:16%;"></p><h4 id="听-2">听<a class="anchor" href="#听-2">·</a></h4><p>可以看到酷狗的PC端沉浸感很强，使用体验不亚于手机端，而且背景的图片效果相比网易云的主打胶碟片式的设计风格也有不一样的的感觉。手机端的<strong>竖屏mv与弹幕</strong>的效果很惊艳</p><p>​             <img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/12.png" style="zoom: 25%;"> <img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/17.jpg" style="zoom:16%;"></p><h4 id="评-2">评<a class="anchor" href="#评-2">·</a></h4><p>PC评论区直接采用<strong>楼套楼</strong>的方式，手机端与网易云处理方式类似。没有社区动态等功能。</p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/13.png" style="zoom:25%;"><h4 id="探-2">探<a class="anchor" href="#探-2">·</a></h4><p>笔者评测期间听了很多英文歌，因此顺理成章的推荐全是英文歌，不过可能因为数量太少，女声的居多。不过<strong>猜你喜欢部分</strong>，<strong>30s试听</strong>，<strong>发现和小众</strong>这几个功能还是可以很好的试探用户喜好，并在尽可能节省时间的前提下帮助用户挖掘更多兴趣</p><p>​                                                            <img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/18.jpg" style="zoom:25%;"> <img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/19.jpg" style="zoom:16%;"></p><h4 id="搜-2">搜<a class="anchor" href="#搜-2">·</a></h4><p>搜索时都会弹出热搜榜，电台榜和历史搜索，两个端风格比较统一</p><h4 id="看-2">看<a class="anchor" href="#看-2">·</a></h4><p>功能与直播软件基本一致了，不同于网易云主要是音乐相关直播，酷狗更像是一个<strong>综合的直播软件集成</strong>了</p><h4 id="唱-2">唱<a class="anchor" href="#唱-2">·</a></h4><p>使用体验基本和网易云的音街一致，正常的K歌服务都有，而且也是集成在app内部</p><p>不过令人惊叹甚至上瘾的功能是他的<strong>1v1排位赛</strong>，真的<strong>很有意思</strong>，笔者本想体验一下，结果被他的功能设计吸引了，直接从白银一路玩到了铂金，虽然有一点bug，不过整体体验感很好。具体来说就是先选一首歌，然后和陌生人匹配，你唱选的歌曲的一段，对方也唱一段，比较双方的评分。唱完之后可以和对方聊天以及决定要不要继续和对方接着唱。这样的模式大大<strong>提升了唱歌的乐趣</strong>。同时还有一个和好友双人一起唱歌的比较传统的功能。</p><h4 id="我-2">我<a class="anchor" href="#我-2">·</a></h4><p>具体的歌曲管理上与网易云几乎一样，也是自建歌单+收藏歌单+最近，不过还多了一个<strong>默认列表</strong>，但没有发现有明确作用</p><p>播放列表有一个历史播放列表，可以记录之前的播放列表，还蛮贴心的。</p><p>其他诸如驾驶模式，皮肤等没有太大的亮点</p><h3 id="功能性bug-2">功能性bug<a class="anchor" href="#功能性bug-2">·</a></h3><h4 id="PC和手机端井水不犯河水">PC和手机端井水不犯河水<a class="anchor" href="#PC和手机端井水不犯河水">·</a></h4><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/31.jpg" style="zoom:20%;"><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/19.png" alt="19" style="zoom: 50%;"></p><p>以上分别是手机端和电脑端，最近播放的曲目不能说是没有联系，只能说是毫不相关</p><p><strong>触发条件</strong>：使用酷狗音乐PC客户端0.2.51版本，电脑端播放音乐，查看酷狗手机端11.1.3版本的最近播放，反之亦然。同时电脑端和ios端的同样条件也会触发bug</p><p><strong>触发概率/复现概率</strong>：100%</p><p><strong>BUG分析</strong>：考虑到QQ音乐以及网易云都有这个原因，猜测是设计的时候就想让电脑端用户单独在电脑上听，手机亦然，但是没有任何解释以及开关让两边同步，这显然是不合理的</p><p><strong>BUG严重程度</strong>：⭐⭐⭐⭐。原因：用户的两个端的播放数据不一致，显然导致很多时候使用起来会感到非常不协调，如果手机或者电脑突然更换或者丢失且没有备份就会出现令人窒息的情况</p><h4 id="1v1对战，还没听到对手开始唱怎么就轮到我了！！？">1v1对战，还没听到对手开始唱怎么就轮到我了！！？<a class="anchor" href="#1v1对战，还没听到对手开始唱怎么就轮到我了！！？">·</a></h4><p>当在酷狗音乐的1v1对战环节打了几十把之后，发现时不时因为各种原因，会出现下列的情况，即对对方的演唱时间卡在一个时间点，然后之后突然就跳到自己的开始环节了，带来很不好的体验，一方面没法听到对面的歌声，一方面自己没有准备时间，体验感非常不好</p><p>​                                                    <img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/kugoubug0.gif" style="zoom: 33%;"><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/kugoubug1.gif" alt="kugoubug1" style="zoom: 33%;"></p><p><strong>触发条件</strong>：使用酷狗音乐PC客户端0.2.51版本，使用唱页面中的1v1对战功能，进入之后匹配其他用户</p><p><strong>触发概率/复现概率</strong>：5% 玩100把大概能遇到5把或者更多场次</p><p><strong>BUG分析</strong>：这个bug可能有多方面的原因，动画资源加载代码性能问题，网速问题，app代码的效率问题，多端数据协调同步问题等等，总之高峰期多用户使用情况下，这个服务会非常不稳定，尤其是如果一个用户的网速不甚稳定就会带来非常严重到想重开或者弃坑的延迟时间。</p><p><strong>BUG严重程度</strong>：⭐⭐⭐⭐。原因：这个长延迟在遇到的时候会让人想退出app或者至少想放弃进行游戏的冲动，而且错失的这30s时间怎么弥补呢？？</p><h4 id="我居然实现了评论字数自由！！">我居然实现了评论字数自由！！<a class="anchor" href="#我居然实现了评论字数自由！！">·</a></h4><p>如下图所示，虽然PC端打字时会限制10000个字符，但是其实随意输入10000个字符之后，还是可以继续挨个输入表情，假设我理论上可以输入无限的表情？？</p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/20.png" style="zoom:25%;"><p>同样，手机端也有类似甚至更严重的问题，评论甚至没有字数限制？？？</p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/kugoubug2.gif" style="zoom:33%;"><p>笔者大概在这个测试帖子下面每个评论框里都至少输入了5000+的字符，最后的帖子甚至有超过30000的长度，真想知道具体是怎么存的，然后为了更直观提现恶果，我还再输入了一个大概在15万字数级别的回复，大概输入到100000左右已经卡的不行，以及可以看到上图中的加载速度已经很慢了</p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/kugoubug3.gif" style="zoom:25%;"><p><strong>触发条件</strong>：使用酷狗音乐PC客户端0.2.51版本进入音乐圈发一个帖子，酷狗手机端11.1.3版本中查看某人动态并发一个帖子</p><p><strong>触发概率/复现概率</strong>：100%</p><p><strong>BUG分析</strong>：显然app和客户端在测试的时候都不充分，app甚至没有字数限制真是让人毛骨悚然，要是有人想做文章咋办？？？</p><p><strong>BUG严重程度</strong>：⭐⭐⭐⭐⭐。原因：字符串无限制，那要是有人每分钟自动化发，总量几千万条，服务器和数据库顶得住吗，用户的服务会不会收到影响？</p><h3 id="Bug-反馈-2">Bug 反馈<a class="anchor" href="#Bug-反馈-2">·</a></h3><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/23.png" style="zoom: 50%;"><h3 id="用户采访-2">用户采访<a class="anchor" href="#用户采访-2">·</a></h3><p>北航经管学院大三学生，使用酷狗超过5年，希望获得采访获得对于酷狗音乐的使用体验与感受</p><blockquote><p>Q：您一般会使用哪些酷狗音乐的哪些栏目和功能？A：听歌栏目 每日推荐 听歌识曲Q：在使用过程中您遇到了哪些亮点或者问题呢？A：亮点歌曲版权较全（周杰伦等）缺点：歌曲评论质量较差社区氛围性不够 （这也是为什么网易云远远比酷狗梗更多如“网抑云”）Q：您有没有什么新的需求可以提出或者认为可以改进的部分？A：开软件广告即使年费SVIP都不能去掉 广告严重影响体验</p></blockquote><h3 id="结论-2">结论<a class="anchor" href="#结论-2">·</a></h3><p><font color="blue">一般</font></p><table><thead><tr><th>类别</th><th>描述</th><th>评分 （满分 10 分, 良好 6 分, 及格 4 分，聊胜于无 1 分, 很差 -3 分）</th></tr></thead><tbody><tr><td>听</td><td>听音乐 查看歌词 播放MV 下载音乐</td><td>10</td></tr><tr><td>评</td><td>歌曲评论 音乐交流社区</td><td>4</td></tr><tr><td>探</td><td>音乐推荐 探索 收藏歌曲 歌单</td><td>10</td></tr><tr><td>搜</td><td>歌曲搜索 听歌识曲</td><td>10</td></tr><tr><td>看</td><td>电台 主播 视频</td><td>9</td></tr><tr><td>唱</td><td>创作 音乐发行</td><td>6</td></tr><tr><td>我</td><td>个性化皮肤 彩铃 壁纸 分享 歌单、收藏、喜欢管理</td><td>8</td></tr><tr><td>细节</td><td>有什么为用户考虑的细节?</td><td>10</td></tr><tr><td>用户体验</td><td>当用户完成功能时，不干扰用户 (例如: 是否不断弹出不相关广告)。</td><td>6</td></tr><tr><td>差异化功能</td><td>这个软件独特的功能. 它对用户的吸引力有多大?</td><td>7</td></tr><tr><td>软件的效能</td><td>占用内存, 启动速度, 内存泄漏情况</td><td>8</td></tr><tr><td>软件的适应性</td><td>在联网/断网, 大小屏幕, 没有鼠标的情况下都可以顺畅操作. 和不同平台的软件能流畅协作</td><td>6</td></tr><tr><td>成长性</td><td>记住用户的选择, 适应用户的特点，用户越用越方便</td><td>9</td></tr><tr><td>用户有控制权</td><td>系统状态有反馈，等待时间要合适。关键操作有确认提示，有明确的错误信息。 让用户方便地从错误中恢复工作, 快捷操作键可调整。</td><td>5</td></tr><tr><td>整体使用感觉</td><td>曲库版权的丰富，完整性，用户环境</td><td>10</td></tr><tr><td>总评</td><td></td><td>117</td></tr></tbody></table><h1 id="Part2-网易云音乐分析">Part2 网易云音乐分析<a class="anchor" href="#Part2-网易云音乐分析">·</a></h1><h2 id="2-1-使用此服务的所有功能，估计这个软件-网站-服务做到这个程度大约需要多少时间-团队人数6人左右，计算机大学毕业生，并有专业UI支持-。">2.1 使用此服务的所有功能，估计这个软件/网站/服务做到这个程度大约需要多少时间(团队人数6人左右，计算机大学毕业生，并有专业UI支持)。<a class="anchor" href="#2-1-使用此服务的所有功能，估计这个软件-网站-服务做到这个程度大约需要多少时间-团队人数6人左右，计算机大学毕业生，并有专业UI支持-。">·</a></h2><p>假定本次开发的目标是功能最为完整的网易云安卓app端</p><p>预计总完成时间为34周，约8个半月，总花费为51人月</p><ul><li>需求调研、产品设计阶段：2周</li><li>项目原型图设计阶段：1周</li><li>项目UI设计阶段：3周</li><li>app开发阶段：20周 （除了基本app页面页面设计，还有相关推荐算法，音乐识别算法，音乐打分，音效改变算法需要开发部署）</li><li>app测试阶段：4周（alpha beta测试一共一个月时间）</li><li>app上线阶段：4周（正式上线后还需要根据用户实时反馈来修改和新增完善功能）</li></ul><h2 id="2-2-分析这个软件目前的优劣-和类似软件相比-，这个产品的质量在同类产品中估计名列第几？">2.2 分析这个软件目前的优劣(和类似软件相比)，这个产品的质量在同类产品中估计名列第几？<a class="anchor" href="#2-2-分析这个软件目前的优劣-和类似软件相比-，这个产品的质量在同类产品中估计名列第几？">·</a></h2><h3 id="优点-6">优点<a class="anchor" href="#优点-6">·</a></h3><ul><li>网易云音乐让音乐更好的联系感情。除了正常的乐评以外，直接将音乐和动态联系在一起也让用户能够更好地表达情感</li><li>不断加深用户的了解，个性化服务，精准分发的个性化推荐满足用户的音乐偏好，推荐算法准确度较高</li><li>高质量的音乐UGC社区增强产品的社交活跃度。乐评+歌单+播客+K歌+鼓励原创=完整UGC链条，整个社区氛围良好，容易吸引兴趣相似的用户一起享受音乐</li><li>鼓励原创和小众音乐文化发展，注重打造原创音乐人，以及鼓励说唱，摇滚等相对小众音乐形式的传播和推广</li></ul><h3 id="缺点-6">缺点<a class="anchor" href="#缺点-6">·</a></h3><ul><li>版权不足。许多大牌成名歌手的歌曲版权量较少，比如周杰伦的很多歌就没法听。</li><li>过于个性化，有时候用户会感到被<strong>过拟合</strong>了，较难探索到新的音乐领域</li><li>上线时间短，缺乏资源积累，同时相对缺少明星大咖</li><li>电脑端的产品（web和客户端）的体验感相对较差</li></ul><h3 id="排名">排名<a class="anchor" href="#排名">·</a></h3><p>本次对比主要选取了ios APP Store和华为应用市场的数据</p><h4 id="ios-APP-Store数据统计">ios APP Store数据统计<a class="anchor" href="#ios-APP-Store数据统计">·</a></h4><table><thead><tr><th>应用名称</th><th>评分</th><th>评论量</th><th>昨日下载量</th></tr></thead><tbody><tr><td>酷狗音乐</td><td>4.9</td><td>1346万</td><td>68,501</td></tr><tr><td><strong>网易云音乐</strong></td><td>4.6</td><td>133万</td><td><strong>64,564</strong></td></tr><tr><td>QQ音乐</td><td>4.7</td><td>143万</td><td>74,083</td></tr></tbody></table><p>同时根据禅大师数据观察一下近三个月的ios应用榜单排名对比</p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/2022-03-14-软件案例分析-音乐软件界的卧龙凤雏-QQ音乐与网易云音乐/22.png" style="zoom:80%;"><h4 id="华为应用市场数据统计">华为应用市场数据统计<a class="anchor" href="#华为应用市场数据统计">·</a></h4><table><thead><tr><th>应用名称</th><th>评分</th><th>评论量</th><th>下载量</th></tr></thead><tbody><tr><td>酷狗音乐</td><td>4.7</td><td>1.4万</td><td>69亿</td></tr><tr><td><strong>网易云音乐</strong></td><td>3.9</td><td><strong>0.8万</strong></td><td>68亿</td></tr><tr><td>QQ音乐</td><td>2.7</td><td>0.65万</td><td>51亿</td></tr></tbody></table><h4 id="结论-3">结论<a class="anchor" href="#结论-3">·</a></h4><p>可以看到酷狗音乐的基数是最大的，整体评分也最高，但是近期的热榜上已经渐渐被网易云和QQ音乐超越，整体来说，考虑当下的实际情况，<strong>预估</strong>网易云音乐在三者之中<strong>排名第二名</strong>。因为随着人们的情感和个性化表达需求，网易云的音乐+社交模式还是能很好的吸引广大的次世代用户群体的使用。</p><h2 id="2-3-从各方面的问题，推理出这个软件团队在软件工程方面可以提高的一个重要方面-具体建议-。">2.3 从各方面的问题，推理出这个软件团队在软件工程方面可以提高的一个重要方面(具体建议)。<a class="anchor" href="#2-3-从各方面的问题，推理出这个软件团队在软件工程方面可以提高的一个重要方面-具体建议-。">·</a></h2><p>好的产品从来不是只有一个端好用其他的就可以不管，建议着力在PC客户端和web端进行优化，主要从UI设计和功能丰富两个方面进行开率。</p><ul><li>UI设计上web端请至少保证符合当下的美学风格，而不是当前的停留在10年前的网页设计风格上。</li><li>功能丰富上客户端需要重点完善听歌时的体验，主要是听歌页面的UI以及数据的同步两个方面，同时将手机端的唱歌服务的一些数据部分移植到电脑上，让用户不要有太大的使用割裂感。</li><li>安卓端的评分远远低于苹果端，猜想这和安卓本身的UI风格有关，也和相应的投入有关，ios的开发投入也许比安卓端更高，这一点还请希望开发团队尊重广大的中国安卓用户，增大对于安卓app端的完善力度。</li></ul><h2 id="2-4-你在第一部分发现的bug，为何软件团队不能在发布前修复？他们是不知道，还是有意不修复？你觉得是什么原因？">2.4 你在第一部分发现的bug，为何软件团队不能在发布前修复？他们是不知道，还是有意不修复？你觉得是什么原因？<a class="anchor" href="#2-4-你在第一部分发现的bug，为何软件团队不能在发布前修复？他们是不知道，还是有意不修复？你觉得是什么原因？">·</a></h2><ul><li>缺少对于<strong>边界情况</strong>的测试。比如评论区的若干bug，其实就是没有经过完备的边界情况分析和覆盖性测试。猜测是由于团队认为一般人不会发这么多内容因此就不想考虑，或者单纯是测试人员的疏忽</li><li>严重缺少对于<strong>电脑端产品完善</strong>的决心，手机端的使用体验比电脑端好太多。同时两个端的数据同步问题至少也应该给用户一个设置方式让他们选择性的自动同步，而不是干脆摆烂，两边毫无联系，各干各的。而对于手机上动态电脑上有时候消失这样的错误，测试时应该会想到，但出于侥幸心理没有完善和修复，只能说是项目开发人员的责任心不够了，没有完全为电脑端用户考虑。</li></ul><h1 id="Part3-建议和规划">Part3 建议和规划<a class="anchor" href="#Part3-建议和规划">·</a></h1><h2 id="3-1-市场概况">3.1 市场概况<a class="anchor" href="#3-1-市场概况">·</a></h2><h3 id="首先市场有多大？">首先市场有多大？<a class="anchor" href="#首先市场有多大？">·</a></h3><p>2021 年我国互联网普及率为 73.0%，手机上网人数达 10.29 亿人，其中在线音乐市场用户数量为7亿以上，这是一个很大的市场，据知名机构预测2022年的是市场规模大致在242亿元左右，而月均支付价格也预计将达到10元每月，中国用户的付费获取服务的习惯逐渐养成。</p><h3 id="其次直接的用户有多少？潜在的用户又有多少？">其次直接的用户有多少？潜在的用户又有多少？<a class="anchor" href="#其次直接的用户有多少？潜在的用户又有多少？">·</a></h3><p>根据2020年数据统计，音乐市场中的主要用户是90后和80后，两者总占比可以达到64%，紧随其后则是00后和70后，两者总占比大致在33%，因此可以看到主要的用户群体就在10-50岁的中青少年群体。而随着近几年各类音乐app引入了各种便捷的功能和对老年人友好的关怀功能，未来潜在用户包括即将成为新的消费主力军的10后以及60岁以上的老龄人群体。</p><h2 id="3-2-市场现状">3.2 市场现状<a class="anchor" href="#3-2-市场现状">·</a></h2><h3 id="目前市场上有什么样的产品了？">目前市场上有什么样的产品了？<a class="anchor" href="#目前市场上有什么样的产品了？">·</a></h3><p>市面上最主要的产品是5款酷狗音乐，QQ音乐，网易云音乐，酷我音乐，咪咕音乐。近期发展最迅猛的则是前三个。</p><h3 id="上述产品的定位、优势与劣势在哪里？">上述产品的定位、优势与劣势在哪里？<a class="anchor" href="#上述产品的定位、优势与劣势在哪里？">·</a></h3><p>主要对头部的三个音乐软件进行分析，即酷狗，网易云和QQ音乐</p><p>网易云音乐主要打造<strong>音乐+社交+个性化</strong>的模式，着重在小众音乐领域和原创音乐上下功夫，市场定位主要是相对意义上的年轻人。短板主要在于版权和业内资源较少，且据2020年的机构分析，其主打的原创音乐模式背后的作者目前还是处于相对弱势的群体。但是原创音乐人的用户粘性强，随着流行音乐发展，潜在用户群体越来越多</p><p>酷狗音乐主要依托多年的<strong>资源积累和版权优势</strong>，打造<strong>优质全面的乐库</strong>，面向全年龄段，短板主要在于企业的商业领域比较单一，软件的功能太丰富导致经不起细致推敲，听书直播看书等等铁锅乱炖，音乐性丧失严重。社交属性相对于网易云较弱。</p><p>QQ音乐依托于微信QQ的成功经验和丰富数据用户资源，将<strong>音乐产品和已有的社交关系</strong>进行再次利用开发，让用户有更<strong>一致</strong>的使用感，目前没有明显的短板。</p><h3 id="上述产品之间呈现什么样的关系，哪些为竞品关系？以及竞争中的各方态势如何？">上述产品之间呈现什么样的关系，哪些为竞品关系？以及竞争中的各方态势如何？<a class="anchor" href="#上述产品之间呈现什么样的关系，哪些为竞品关系？以及竞争中的各方态势如何？">·</a></h3><p>三个头部产品总体都是竞品关系，值得一提的是几年前腾讯还曾和网易云合作共享过一些版权，然而由于使用上的权限不好界定，最终收回了版权。</p><p>具体的内容上，QQ音乐和酷狗音乐呈现直接完全竞争的趋势，两者都是面向全年龄段的海量歌库的服务，主要突出量。而网易云音乐主要针对点上用力，致力于给特定的中青年用户带来个性化体验。</p><p>网易云音乐的女性用户群体和年轻用户群体增长迅速，目前发展势头迅猛。而QQ音乐的综合市场占有率上升仍然很迅速，目前是市场上最受欢迎的产品。</p><h2 id="3-3-市场与产品生态">3.3 市场与产品生态<a class="anchor" href="#3-3-市场与产品生态">·</a></h2><h3 id="这个产品的核心用户群是什么样的人？典型用户是什么样的？学历，年龄，专业，爱好，收入，表面需求，潜在需求都是什么？">这个产品的核心用户群是什么样的人？典型用户是什么样的？学历，年龄，专业，爱好，收入，表面需求，潜在需求都是什么？<a class="anchor" href="#这个产品的核心用户群是什么样的人？典型用户是什么样的？学历，年龄，专业，爱好，收入，表面需求，潜在需求都是什么？">·</a></h3><p>核心用户群分类和需求如下</p><ul><li>10-18岁，小学生和中学生，一般没有太强的经济能力，主要需求是课余时间放松缓解压力，提高学习效率，潜在需求是探索自己的兴趣领域，从歌曲中吸取更多的知识，发现自己的兴趣</li><li>18-25岁，大学生，一般有一定的经济自主权，主要是追寻自己的真正的热爱的歌曲，以及为自己喜欢的歌手或者领域消费，需求是美学设计需要美观，现代感，同时也希望扩大社交圈，对新的技术和功能有很高的热情。</li><li>25-40岁，有稳定工作或者无业游民，主要是平时休闲时用音乐来怡情和放松，需要简单舒适的功能，以及稳定一致的软件体验。</li><li>40岁-55岁，在社会中拥有一定的话语权，平时迫于职位压力不能完全放开，需要在音乐的世界里找寻自我，对于隐私和年代较远一些的歌曲会需求强烈。</li></ul><h3 id="产品的用户群体之间是否存在一定的关系？是否有利用其相互作用二次构成特定用户生态的可能性？">产品的用户群体之间是否存在一定的关系？是否有利用其相互作用二次构成特定用户生态的可能性？<a class="anchor" href="#产品的用户群体之间是否存在一定的关系？是否有利用其相互作用二次构成特定用户生态的可能性？">·</a></h3><p>有很强的关系，比如同一个用户群中大家会相互推荐比较喜欢的产品，如果能吸引和推动这些用户为公司背书，会对音乐软件市场占有率提升有很大的积极作用。同时年轻用户往往可以促进年长用户对于新产品新功能的探索和使用，同一个歌手的粉丝群之内会相互推荐产品。</p><h3 id="产品的子产品，以及其他相关产品之间是否存在一定的关系？是否有利用各个产品特性之间的相互关系二次构成产品生态的可能性？">产品的子产品，以及其他相关产品之间是否存在一定的关系？是否有利用各个产品特性之间的相互关系二次构成产品生态的可能性？<a class="anchor" href="#产品的子产品，以及其他相关产品之间是否存在一定的关系？是否有利用各个产品特性之间的相互关系二次构成产品生态的可能性？">·</a></h3><p>比如QQ音乐就推出了音乐状态功能，设计上和微信的状态几乎一致，可以畅想在未来社交软件和音乐软件深度融合，两个人聊天聊着聊着就点某个按钮开始了一起唱歌听歌的模式，甚至不需要切换app。</p><h2 id="3-4-产品规划">3.4 产品规划<a class="anchor" href="#3-4-产品规划">·</a></h2><h3 id="你要在当前软件的基础上设计什么样的新功能？为何要做这个功能，而不是其他功能？为什么用户会用你的产品-功能？你的创新在哪里？可以用NABCD分析。">你要在当前软件的基础上设计什么样的新功能？为何要做这个功能，而不是其他功能？为什么用户会用你的产品/功能？你的创新在哪里？可以用NABCD分析。<a class="anchor" href="#你要在当前软件的基础上设计什么样的新功能？为何要做这个功能，而不是其他功能？为什么用户会用你的产品-功能？你的创新在哪里？可以用NABCD分析。">·</a></h3><p>如果我要为网易云设计新功能，我会添加：<strong>唱歌对战</strong>功能。</p><ul><li>Need 需求<ul><li>网易云的说唱爱好者很多，也有很多相对小众的音乐类型爱好者，他们会需要一个展现自己和他人切磋的平台，因此可以设计针对不同音乐风格的专属的比赛，让不同兴趣用户各取所需。</li><li>用户对于和其他用户交流自己的唱歌技巧有强烈需求，既希望展示自己，也希望欣赏他人的歌声</li></ul></li><li>Approach 做法<ul><li>开发单独的对战界面，可以考虑在唱歌的功能里进行集成，与之前的打分系统进行融合</li><li>除了1v1battle模式，也可以引入2人甚至多人排位赛，让用户体验合作完成歌曲的快乐</li><li>可以设置专门的说唱battle挑战赛，freestyle挑战赛等等让用户可以选择感兴趣的比赛</li><li>引入综合评价体系，而不是单纯唯音准论，比如可以针对特定歌曲采用不同的评价方式。民谣可以检测感情，摇滚可以检测声音质感，说唱检测顺畅度。</li><li>比赛前和后都留出足够时间供选手选择歌曲和与他人交流</li></ul></li><li>Benefit 好处<ul><li>给用户展现自己唱歌技艺的机会，也能提升相应的特定领域歌唱水平</li><li>更加促进用户之间的交流，在原有的交流方式上引入全新的battle模式可以维持用户粘性，让用户有更加丰富有趣的K歌体验</li></ul></li><li>Competitors 竞争<ul><li>目前酷狗音乐已经有了基本的1v1对战功能，不过内容相对单一，只有片段的唱歌对战，且从选择歌曲到对战体验存在很多优化空间，因此考虑在网易云设计这样的功能，查漏补缺，并让整个过程更有趣多变</li></ul></li><li>Delivery 推广<ul><li>新功能是在原有的K歌模式基础上进行扩展，不需要修改相应架构模式，同时只要引入了自定义比赛、特定个性化评价体系和多人对战模式，本身就已经足够有吸引力，相信可以吸引更多现有和潜在用户的使用</li></ul></li></ul><h3 id="如果你是项目经理，可以招聘6个人，并且有4个月的时间，你认为应该如何配置角色-开发，测试，美工等等-才能在第16周如期发布软件的改进版本，并取得预想中的成绩。">如果你是项目经理，可以招聘6个人，并且有4个月的时间，你认为应该如何配置角色(开发，测试，美工等等) 才能在第16周如期发布软件的改进版本，并取得预想中的成绩。<a class="anchor" href="#如果你是项目经理，可以招聘6个人，并且有4个月的时间，你认为应该如何配置角色-开发，测试，美工等等-才能在第16周如期发布软件的改进版本，并取得预想中的成绩。">·</a></h3><table><thead><tr><th style="text-align:left">人员分配</th><th style="text-align:left">人数</th></tr></thead><tbody><tr><td style="text-align:left">美工UI设计</td><td style="text-align:left">1人</td></tr><tr><td style="text-align:left">app前端开发</td><td style="text-align:left">2人</td></tr><tr><td style="text-align:left">app后端开发</td><td style="text-align:left">2人</td></tr><tr><td style="text-align:left">测试</td><td style="text-align:left">1人</td></tr></tbody></table><p>同时，测试人员和美工只是主要负责相应工作，如果有开发经验，在必要时刻也需要参与前后端的开发工作</p><h3 id="请为你的团队设计16个周期每周的详细规划。">请为你的团队设计16个周期每周的详细规划。<a class="anchor" href="#请为你的团队设计16个周期每周的详细规划。">·</a></h3><table><thead><tr><th>周次</th><th>任务</th></tr></thead><tbody><tr><td>1~2</td><td>小组团建增进感情，需求调研，竞品分析，头脑风暴确立目标，前端小组和后端小组进行结对编程增进了解，测试人员熟悉测试流程</td></tr><tr><td>3~4</td><td>UI原型设计，代码架构与技术路线讨论与确定，基本的软件开发环境搭建，完善需求，确定代码风格规范，制定alpha阶段开发计划与进度安排。美工和前端人员，测试与后端人员，测试与前端人员分别进行测试相关的结对编程</td></tr><tr><td>5~9</td><td>alpha阶段开发，前后端同步开发，后端小组和前端小组内部进行代码互审，测试人员和直接开发人员对每日最终的签入负责，每日进行例会，讨论遇到的问题，进行当天工作总结，确立次日计划</td></tr><tr><td>10</td><td>中期小结，alpha版本产品发布，进行团队内测，共同分析解决上一阶段出现的各种问题，制定beta阶段开发计划与进度安排</td></tr><tr><td>11~14</td><td>beta阶段开发，前后端同步开发，后端小组和前端小组内部进行代码互审，测试人员和直接开发人员对每日最终的签入负责，每日进行例会，讨论遇到的问题，进行当天工作总结，确立次日计划</td></tr><tr><td>15</td><td>beta版本公测，向用户收集产品的问题与新的需求，并解决此阶段的bug，同时进行回归测试，增量开发可以完成的新需求</td></tr><tr><td>16</td><td>产品正式发布上线，进行后续的宣发运维工作，继续收集用户的需求，并不断修改集成</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-SE-2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022软工出发-阅读和调研-构建之法与CICD与版本管理</title>
      <link href="2022/03/05/SE%E9%9B%86%E7%BB%93%E5%8F%B7-%E9%98%85%E8%AF%BB%E5%92%8C%E8%B0%83%E7%A0%94/"/>
      <url>2022/03/05/SE%E9%9B%86%E7%BB%93%E5%8F%B7-%E9%98%85%E8%AF%BB%E5%92%8C%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>项目</th><th>内容</th></tr></thead><tbody><tr><td>这个作业属于哪个课程</td><td><a href="https://bbs.csdn.net/forums/BH-SE" target="_blank" rel="noopener">2022春季软件工程（罗杰 任健）</a></td></tr><tr><td>这个作业的要求在哪里</td><td><a href="https://bbs.csdn.net/topics/605073900" target="_blank" rel="noopener">个人阅读作业</a></td></tr><tr><td>我在这个课程的目标是</td><td>学习软工的项目合作管理知识，提升软件开发技术</td></tr><tr><td>这个作业在哪个具体方面帮助我实现目标</td><td>通过《构建之法》理解软工，动手实践各种平台比较CI/CD</td></tr></tbody></table><h1 id="Begin-of-SE">Begin of SE<a class="anchor" href="#Begin-of-SE">·</a></h1><p>作为一个在北航计算机学院摸爬滚打的普通学生，由于6系丰富的资源，笔者接触了一些软件项目，包括OO课程网站维护，学者数据爬取平台，航送app，数据库的电商平台等等，还有一些网站小程序等等，然而做了这些项目之后，自己的实际项目管理和软件素养并没有得到完全显著的提升，原因一个是要么网站过于复杂仅仅是维护和更新部分代码，要么就是课程或者项目用完即扔。这也是我最终选择敏捷开发课程的原因，希望能够在大三下这个最后的黄金学习时间，向老师和助教以及同学们学习到尽可能多的具体技术和软件开发、项目管理的思想方法，让自己的开发和团队协作能力都上一个档次，软工，我来了！！！</p><h1 id="《构建之法》阅读提问">《构建之法》阅读提问<a class="anchor" href="#《构建之法》阅读提问">·</a></h1><h2 id="阅读中记录的琐碎疑问">阅读中记录的琐碎疑问<a class="anchor" href="#阅读中记录的琐碎疑问">·</a></h2><p>看的过程随手记录了一些不成形的问题，选择了几个进行深究，其他的就留存于此作为记录</p><ul><li>没有银弹未来是否可有实现？现在有低代码平台等等</li><li>P47 团队对个人期望，专业人士不需要灵感与激情？</li><li>P80 结对编程的要求，似乎有点过于拘束死板？</li><li>P85-86 的中间层和最内层的例子中的表述似乎都相当负面且情绪化，为什么这两个就不能有一些柔和的处理以及表达呢？</li><li>P116 scrum对团队人员的要求 PM vs Scrum leader ? ?</li><li>敏捷开发不了AI算法软件或者技术背景强的软件？？ P121</li><li>P159 人类学调查 走到真实世界会不会太泛泛而谈了，实际的生活我们到底应该以什么样的方式和频率介入哪些生活？</li><li>P184 有没有可能借鉴去中心化网络架构ring AllReduce，即两个人之间进行交流，并将他们组成环？</li><li>P357 赢者通吃 如何看待如今的天猫京东拼多多 以及美团外卖和饿了吗？</li><li>P371 当下的低代码平台或者云速建站服务也只需要很少的代码 似乎与只能手工相悖？</li></ul><h2 id="1-专业软件开发师仅需要按照流程理性地工作？">1.专业软件开发师仅需要按照流程理性地工作？<a class="anchor" href="#1-专业软件开发师仅需要按照流程理性地工作？">·</a></h2><h3 id="原文">原文<a class="anchor" href="#原文">·</a></h3><p>内容参见原书第3章 P47-48</p><blockquote><p>理性地工作∶软件开发有很多个人的、感情驱动的因素，但是一个成熟的团队成员必 须从事实和数据出发，按照流程，理性地工作。很多人认为自己需要灵感和激情，才能为宏大的目标奋斗，才能成为专业人士。著名的艺术家 Chuck Close 说∶“ 我总觉得 灵感是属于业余爱好者的。我们职业人士只是每天持续工作。今天你继续昨天的工作，明天你继续今天的工作，最终你会有所成就 ”</p></blockquote><h3 id="问题">问题<a class="anchor" href="#问题">·</a></h3><ul><li>仅仅按部就班地理性工作，真的能保证大部分工程师有所成就吗？</li></ul><h3 id="解释">解释<a class="anchor" href="#解释">·</a></h3><ul><li>个人认为对于著名的艺术家或者成功人士来说，他们本身就已经具有了很高的天赋或者很高的热情，因此对他们来说，也许只要按部就班进行工作就已经可以完成很高质量的代码，但是对于一般的工程师来说，每天重复差不多低质量的工作，没有任何激情和推动，可能最后只能带来较低质量的产品。而且对于一些重大复杂的算法问题或者架构问题，很多时候依赖于突发奇想或者灵机一动，如果单纯仅仅是机械做一样的工作，能解决这样的问题吗？同时这样的工作模式也很难催生新的问题发现和技术创新</li><li>因此这一点我个人认为更适合的是大多时候理性，但该有激情的时候需要热情投入。</li></ul><h2 id="2-结对编程能更加灵活吗？">2.结对编程能更加灵活吗？<a class="anchor" href="#2-结对编程能更加灵活吗？">·</a></h2><h3 id="原文-2">原文<a class="anchor" href="#原文-2">·</a></h3><p>内容参见原书第3章 P81</p><blockquote><p>4.5.4 如何结对编程</p><p>1. 驾驶员∶写设计文档，进行编码和单元测试等 XP开发流程。 2.  领航员∶审阅驾驶员的文档;监督驾驶员对编码等开发流程的执行;考虑单元测试的覆盖 率;思考是否需要和如何重构;帮助驾驶员解决具体的技术问题。领航员也可以设计TDD中的测试用例。 3. 驾驶员和领航员不断轮换角色，不要连续工作超过一小时，每工作一小时休息 15分钟。 领航员要控制时间。  4. 主动参与。任何一个任务都首先是两个人的责任，也是所有人的责任。  5. 只有水平上的差距，没有级别上的差异。两人结对，尽管可能大家的级别资历不同，但不 管在分析、设计或编码上，双方都拥有平等的决策权利。  6. 设置好结对编程的环境，座位、显示器、桌面等都要能允许两个人舒适地讨论和工作。如 果是通过远程结对编程，那么网络、语音通讯和屏幕共享程序要设置好。</p></blockquote><h3 id="问题-2">问题<a class="anchor" href="#问题-2">·</a></h3><ul><li>能否有两个人先讨论好然后再一起写不同模块或者同一个文件中不同代码，之后再互相测试？</li><li>形式能否更加灵活？</li></ul><h3 id="解释-2">解释<a class="anchor" href="#解释-2">·</a></h3><ul><li>原文中的结对编程描述貌似必须有一个人是领航，一个人是驾驶，但是事实上对于太复杂的需求，驾驶员在写代码的时候被监视就好比是面试中做算法题一样难受，甚至发挥失常（虽然这个和人的心理素质和代码能力密不可分）。而面对过于简单的需求，大部分时候不太需要领航员一直检查和review或者帮助理解文档，这个时候领航员似乎就无所事事了</li><li>结对编程能不能采用两个人先一起研究需求，并行编程，写微小的模块，之后一起检查测试代码的模式？这样似乎也可以提高效率，而且每个人负责的微小部分代码更精细，同时两个人互相测试也能测试效率更高。</li></ul><h2 id="3-团队的强弱与scrum">3.团队的强弱与scrum<a class="anchor" href="#3-团队的强弱与scrum">·</a></h2><h3 id="原文-3">原文<a class="anchor" href="#原文-3">·</a></h3><p>内容参见原书第6章P116页</p><blockquote><p>如果你的团队很弱，那么强行把敏捷（或者其他高级方法）套在上面也没有用，也许还会适得其反，往往需要经历多次失败/总结/改进的过程才能让 Scrum 走上正轨。换句话说，如果你的团队已经有这么厉害（自主管理、自我组织、多功能型）的一帮人，那么用不用 Scrum 都能写好软件!</p></blockquote><h3 id="问题-3">问题<a class="anchor" href="#问题-3">·</a></h3><ul><li>如何衡量一个团队的强弱？从技术角度还是从努力角度还是综合起来？如果是参差不齐的队伍呢？</li><li>强大的个人组合成的队伍就不需要scrum来开发软件了吗？</li></ul><h3 id="解释-3">解释<a class="anchor" href="#解释-3">·</a></h3><ul><li>首先这里的团队的强弱本身是一个很主观而且很难给出答案的定义。比如一个队伍可能每个人技术上都很强，甚至每个人都做过全栈开发。但是他们的团队合作能力和意识不一定好，以及可能有些人在这次开发中与团队愿景不一致，那又如何定义这样的队伍的强弱呢？同时一个队伍可能技术比较平均甚至平庸，但每个人的学习能力较强，愿景类似，而且能投入的精力都很多，那这个团队是强还是弱呢。同时参差不齐的队伍又该如何计算？个人认为大多数队伍都可以实现scrum，只是可能对于不同队伍，目标和具体细节做出相应改动罢了。</li><li>假设已经满足了作者关于强的team的定义，那这个scrum流程就不需要了，那大家敏捷开发就一锅乱炖，看心情来完成代码吗？显然不太合理吧，所以要么有相应的简化处理，要么就换一种方法论，但显然似乎也不是完全不需要scrum了</li></ul><h2 id="4-敏捷仅仅适用于简单的应用？">4.敏捷仅仅适用于简单的应用？<a class="anchor" href="#4-敏捷仅仅适用于简单的应用？">·</a></h2><h3 id="原文-4">原文<a class="anchor" href="#原文-4">·</a></h3><p>内容参见原书第6章P121页表6-3</p><blockquote><img src="/2022/03/05/SE%E9%9B%86%E7%BB%93%E5%8F%B7-%E9%98%85%E8%AF%BB%E5%92%8C%E8%B0%83%E7%A0%94/8.png" style="zoom: 50%;"></blockquote><h3 id="问题-4">问题<a class="anchor" href="#问题-4">·</a></h3><ul><li>只有简单的变化多的网站适合敏捷，而复杂且稳定软件就不适合甚至不需要吗？</li></ul><h3 id="解释-4">解释<a class="anchor" href="#解释-4">·</a></h3><ul><li>当下的很多项目都需要开发者在短时间内开发集成了众多AI算法且质量很高的软件，这时候如果不使用敏捷思想的话难道需要磨洋工吗，显然也不太可能。这个时候如果单纯用本书提到的scrum不行的话，能不能采用相似的或者以本书的敏捷方法为内核的稍加修改后的方法呢？笔者认为可以分配更多的角色，比如算法工程师，模型部署测试等角色来扩充现有的模型。</li><li>像开发底层正则表达式解析模块其实也需要不断做测试以及迅速交付，如果恰恰有项目需要做一个底层的库而用户还需要定期检查呢？那似乎这个时候敏捷也没什么不好。而且很多bug都必须在真实的大量场景测试才能找到问题</li></ul><h2 id="5-人类学调查的具体方式？">5.人类学调查的具体方式？<a class="anchor" href="#5-人类学调查的具体方式？">·</a></h2><h3 id="原文-5">原文<a class="anchor" href="#原文-5">·</a></h3><p>内容参见原书P158-159</p><blockquote><p>大学生们如果能暂时放下自己所学的许多高端技术，走到真实的世界中去，也许会看到并理解来自普通用户的真实需求</p></blockquote><h3 id="问题-5">问题<a class="anchor" href="#问题-5">·</a></h3><ul><li>真实世界这么大，我们该走到哪，走多深呢？</li></ul><h3 id="解释-5">解释<a class="anchor" href="#解释-5">·</a></h3><ul><li>很多时候我们进入生活就迷茫了，这么大的世界，随便走走就眼花缭乱了，具体的真实需求可能就找不到了。具体操作时似乎不能泛泛的撒网了解真实世界，而是寻找其中的若干个有意思的点深入挖掘探索才会更有效率一些。而具体应该探索哪些行业，做哪些具体的事情呢？我个人认为最好的方式是和真实世界中的用户或者客户直接对话或者体验他们的应用场景，这样似乎比出去走走要更加具体实在一些。</li></ul><h2 id="6-赢者真的能通吃吗？">6.赢者真的能通吃吗？<a class="anchor" href="#6-赢者真的能通吃吗？">·</a></h2><h3 id="原文-6">原文<a class="anchor" href="#原文-6">·</a></h3><p>内容参见原书P357</p><blockquote><p>赢者通吃 这个游戏规定第一名得到全部的分数，第二名（不管多接近）到倒数第二名都是0分，最后一名还要倒扣分。软件行业就是一个赢者通吃的环境，最后一名还要把自己的身家倒贴进去。</p></blockquote><h3 id="问题-6">问题<a class="anchor" href="#问题-6">·</a></h3><ul><li>软件行业赢家真的可以通吃吗？</li></ul><h3 id="解释-6">解释<a class="anchor" href="#解释-6">·</a></h3><ul><li>比如：360vs电脑管家vs鲁大师，饿了吗vs美团外卖，腾讯视频vs爱奇艺vs优酷，至今都没有分出胜负，而最近的统计似乎也显示这些公司互有胜负，所以赢者通吃这种说法似乎有待商榷，这个游戏的合理性似乎也需要讨论。似乎很多时候并不能做到作者说的赢家通吃。</li></ul><h2 id="7-手工写代码和银弹">7.手工写代码和银弹<a class="anchor" href="#7-手工写代码和银弹">·</a></h2><h3 id="原文-7">原文<a class="anchor" href="#原文-7">·</a></h3><p>内容参见原书P371</p><blockquote><p>一些人士批评&quot;很多企业还处于手工式的开发生产阶段&quot;，我不知道软件除了用手工，还可以用什么别的来写。也许有人说，是不是那些CASE（Computer Aided Software Engineering》工具，或者是代码向导（Code Wizard），用右键一点，然后继续点【下一步】、【下一步】就可以产生出很多很多代码?这些固然好，但是你可以点一下产生很多代码，另一个公司也可以点一下产生很多同样的代码。你的核心技术在哪里呢? 本文之后提到的各种编程牛人做的有价值的软件，都是自己动手写代码，而不是用什么代码生成器搞出来的。</p></blockquote><h3 id="问题-7">问题<a class="anchor" href="#问题-7">·</a></h3><ul><li>自动代码平台与软工似乎越来越普及，如何看待？</li><li>随着AI发展，未来自动写软工的机器人和低代码甚至0代码平台会成为银弹吗？</li></ul><h3 id="解释-7">解释<a class="anchor" href="#解释-7">·</a></h3><ul><li>似乎在当下2022年和未来非手工写代码或者自动软件工程渐渐成为现实，包括腾讯和华为在内的很多公司的云服务都提供了低代码甚至自动部署的云建站服务，这些服务很多时候已经可以满足用户的需求了，那么这是不是认为就可以取代手工写代码了呢？</li><li>最近 <code>Alphacode</code> 在很多算法平台获得了突破，以后的AI是否也可以在软工领域取得突破呢，包括甚至有机器人模拟scrum的过程，完整地进行高效编码，那这会不会成为软工领域的银弹呢？</li></ul><h1 id="调研源代码版本管理软件">调研源代码版本管理软件<a class="anchor" href="#调研源代码版本管理软件">·</a></h1><h2 id="版本控制系统分类">版本控制系统分类<a class="anchor" href="#版本控制系统分类">·</a></h2><p>一般来说，版本控制系统有三种主要类型，即：</p><ul><li>本地：所有开发人员都在同一个文件系统中</li><li>集中式：团队在中央服务器上是最新的项目版本，成员需要先从中央服务器拉取最新版本，然后开始自己的修改开发，之后再传到中央服务器上</li><li>分布式：开发人员每个人都有一个自己的代码存储库，需要更改时在存储库之间推送共享</li></ul><p>一般来说，最有效率的是Git Repos，也就是目前最成功的分布式版本控制系统，本次调研也主要针对Git的几个软件<strong>GitHub</strong>、<strong>GitLab</strong>与<strong>BitBucket</strong></p><h2 id="Git-版本控制管理软件的共同特点">Git 版本控制管理软件的共同特点<a class="anchor" href="#Git-版本控制管理软件的共同特点">·</a></h2><ul><li>拉取请求 Pull Request</li><li>代码审查 作为拉取请求的后续机制，可以在Pull Request中夹带针对指定代码行的注释，或者要求他人对拉取的请求做修改</li><li>内联编辑</li><li>问题跟踪</li><li>Markdown支持</li><li>双向认证</li><li>高级权限管理</li><li>托管的静态网页 github pages 等等</li><li>功能丰富的API</li><li>Fork / Clone Repositories 克隆和复制</li><li>代码段</li><li>第三方集成</li></ul><h2 id="GitHub、Gitlab、Bitbucket、Coding">GitHub、Gitlab、Bitbucket、Coding<a class="anchor" href="#GitHub、Gitlab、Bitbucket、Coding">·</a></h2><table><thead><tr><th style="text-align:center">比较内容</th><th style="text-align:center">GitHub</th><th style="text-align:center">Gitlab</th><th style="text-align:center">Bitbucket</th><th style="text-align:center">Coding</th></tr></thead><tbody><tr><td style="text-align:center">开源性</td><td style="text-align:center">存储的代码内容开源，软件本身不开源</td><td style="text-align:center">社区版软件开源</td><td style="text-align:center">不开源，购买【托管服务】中含有<strong>产品定制</strong>功能</td><td style="text-align:center">WebIDE开源</td></tr><tr><td style="text-align:center">协作性</td><td style="text-align:center">find+follow+大牛和科技巨头聚集地</td><td style="text-align:center">find</td><td style="text-align:center">find+follow</td><td style="text-align:center">find+follow+允许开发者自定义兴趣标签</td></tr><tr><td style="text-align:center">导入代码仓库类型</td><td style="text-align:center">Git SVN HG TFS</td><td style="text-align:center">Git</td><td style="text-align:center">Git SVN HG</td><td style="text-align:center">Git CodePlex Google Code HG SourceForge SVN</td></tr><tr><td style="text-align:center">免费计划</td><td style="text-align:center">Free Plans：允许托管无限的public仓库，随时进行clone fork contribute 磁盘无限制但项目不能超1G 单个文件不能超100MB</td><td style="text-align:center">Small teams plan：允许5个成员加入，公私有仓库免费但不能大于1GB</td><td style="text-align:center">cloud-hosted plan：无限用户使用无限数量的项目，单个仓库10GB限制</td><td style="text-align:center">免费计划：允许 10 个成员使用不限量公共存储库，总容量小于等于1GB</td></tr><tr><td style="text-align:center">错误追踪</td><td style="text-align:center">提供错误跟踪系统，用于提高编码质量</td><td style="text-align:center">提供了错误跟踪系统以及基于Web的代码编辑选项，用于提高编码质量</td><td style="text-align:center">使用语义搜索来分析编码语法，以提高编码质量</td><td style="text-align:center">提供错误跟踪系统</td></tr><tr><td style="text-align:center">API服务</td><td style="text-align:center">提供了API用于应用程序开发</td><td style="text-align:center">提供了API用于应用程序开发</td><td style="text-align:center">集成了多个API和服务</td><td style="text-align:center">提供了API用于应用程序开发</td></tr></tbody></table><h1 id="调研持续集成-部署工具">调研持续集成/部署工具<a class="anchor" href="#调研持续集成-部署工具">·</a></h1><h2 id="Gitlab-CI">Gitlab CI<a class="anchor" href="#Gitlab-CI">·</a></h2><h3 id="说明">说明<a class="anchor" href="#说明">·</a></h3><p>本次Gitlab使用了OO的gitlab的CI进行测试，由于相关服务器刚刚迁移到校内，因此需要重新配置runner，这部分除了CI部分顺便记录一下创建个人项目和配置runner的过程</p><h3 id="创建Group与Project">创建Group与Project<a class="anchor" href="#创建Group与Project">·</a></h3><p>首先gitlab是基于group进行操作的，因此第一步首先需要建立group才能在内部进行项目创建，为了方便组员的CI测试，我单独创建了一个setest group并拉进了所有的软工小组成员，截止目前有两个项目，其中Setest是我的项目，里面有一个python文件实现了快速排序</p><p><img src="/2022/03/05/SE%E9%9B%86%E7%BB%93%E5%8F%B7-%E9%98%85%E8%AF%BB%E5%92%8C%E8%B0%83%E7%A0%94/Users/fzc/AppData/Roaming/Typora/typora-user-images/image-20230131001637674.png" alt="image-20230131001637674"></p><p><img src="/2022/03/05/SE%E9%9B%86%E7%BB%93%E5%8F%B7-%E9%98%85%E8%AF%BB%E5%92%8C%E8%B0%83%E7%A0%94/1.png" alt></p><p><img src="/2022/03/05/SE%E9%9B%86%E7%BB%93%E5%8F%B7-%E9%98%85%E8%AF%BB%E5%92%8C%E8%B0%83%E7%A0%94/2.png" alt></p><h3 id="配置runner">配置runner<a class="anchor" href="#配置runner">·</a></h3><p>网上很多博客内容太杂了，其实就简单的几行命令和一个服务器就可以</p><p>先在左侧栏的Settings里找到CI/CD，进入之后将Runners旁边的Expand点开，之后点击里面的安装指导，按照里面的命令在任意的服务器上装好服务并完成register就好了</p><p>笔者使用的是linux amd64服务器，命令参考如下：</p><h4 id="Download-and-install-binary">Download and install binary<a class="anchor" href="#Download-and-install-binary">·</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Download the binary for your system</span><br><span class="line">sudo curl -L --output &#x2F;usr&#x2F;local&#x2F;bin&#x2F;gitlab-runner https:&#x2F;&#x2F;gitlab-runner-downloads.s3.amazonaws.com&#x2F;latest&#x2F;binaries&#x2F;gitlab-runner-linux-amd64</span><br><span class="line"></span><br><span class="line"># Give it permissions to execute</span><br><span class="line">sudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;gitlab-runner</span><br><span class="line"></span><br><span class="line"># Create a GitLab CI user</span><br><span class="line">sudo useradd --comment &#39;GitLab Runner&#39; --create-home gitlab-runner --shell &#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line"># Install and run as service</span><br><span class="line">sudo gitlab-runner install --user&#x3D;gitlab-runner --working-directory&#x3D;&#x2F;home&#x2F;gitlab-runner</span><br><span class="line">sudo gitlab-runner start</span><br></pre></td></tr></table></figure><h4 id="Command-to-register-runner">Command to register runner<a class="anchor" href="#Command-to-register-runner">·</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-runner register --url $URL --registration-token $REGISTRATION_TOKEN</span><br></pre></td></tr></table></figure><p>注意这里的$URL和$REGISTRATION_TOKEN替换成相应的url和token就好了。同时可以参考选择 <code>ruby2.7</code> 的 <code>docker</code> 进行部署</p><p>这样操作完之后，Runners展开的左侧就会有runners列表，这时需要点进你的服务器的编辑按钮，将内部的 <code>Indicates whether this runner can pick jobs without tags</code> 勾上就可以使用了</p><h3 id="CI测试">CI测试<a class="anchor" href="#CI测试">·</a></h3><ol><li>主要是对一份快速排序的代码进行了评测，代码如下，正确的输出是 <code>[1,2,3,4,5] </code>，仓库链接：http://gitlab.oo.buaa.edu.cn/setest/setest</li></ol><p><img src="/2022/03/05/SE%E9%9B%86%E7%BB%93%E5%8F%B7-%E9%98%85%E8%AF%BB%E5%92%8C%E8%B0%83%E7%A0%94/3.png" alt></p><ol start="2"><li>编写 <code>.gitlab-ci.yml</code> 上传并进行CI测试</li></ol><p><img src="/2022/03/05/SE%E9%9B%86%E7%BB%93%E5%8F%B7-%E9%98%85%E8%AF%BB%E5%92%8C%E8%B0%83%E7%A0%94/4.png" alt></p><h2 id="Github-Action">Github Action<a class="anchor" href="#Github-Action">·</a></h2><ol><li>同样的代码上传至 <code>github</code> 上进行相同的代码测试 链接：https://github.com/BUAADreamer/Setest</li></ol><p><img src="/2022/03/05/SE%E9%9B%86%E7%BB%93%E5%8F%B7-%E9%98%85%E8%AF%BB%E5%92%8C%E8%B0%83%E7%A0%94/6.png" alt></p><ol start="2"><li>编写 <code>.yaml</code> 文件使用 <code>action</code> 的 <code>overflow</code> 进行测试结果</li></ol><p><img src="/2022/03/05/SE%E9%9B%86%E7%BB%93%E5%8F%B7-%E9%98%85%E8%AF%BB%E5%92%8C%E8%B0%83%E7%A0%94/5.png" alt></p><h2 id="CI-CD-相关">CI/CD 相关<a class="anchor" href="#CI-CD-相关">·</a></h2><h3 id="1-CI-CD工具定义">1.CI/CD工具定义<a class="anchor" href="#1-CI-CD工具定义">·</a></h3><p><strong>CI</strong>持续集成，<strong>CD</strong>持续部署，这是一种通过在应用开发阶段引入<strong>自动化</strong>来频繁向客户交付应用的方法。CI/CD 的核心概念是<strong>持续集成、持续交付和持续部署</strong>。作为一个面向开发和运营团队的解决方案，CI/CD 主要针对在<strong>集成新代码</strong>时所引发的问题</p><h3 id="2-Gitlab-CI特点，特性">2.Gitlab CI特点，特性<a class="anchor" href="#2-Gitlab-CI特点，特性">·</a></h3><p>Gitlab CI/CD内置于GitLab，是Gitlab一个简洁好用的的持续集成/持续交付/持续部署的框架</p><ul><li>多平台： Unix，Windows，macOS和任何其他支持Go的平台上执行构建。</li><li>多语言： 构建脚本是命令行驱动的，并且可以与Java，PHP，Ruby，C和任何其他语言一起使用。</li><li>稳定构建： 构建在与GitLab不同的机器上运行。</li><li>并行构建： GitLab CI / CD在多台机器上拆分构建，以实现快速执行。</li><li>实时日志记录： 合并请求中的链接将您带到动态更新的当前构建日志。</li><li>灵活的管道： 可以在每个阶段定义多个并行作业，并且可以触发其他构建。</li><li>版本管道： 一个 .gitlab-ci.yml文件 包含测试和整个过程的步骤，使每个人都能贡献更改，并确保每个分支获得所需的管道。</li><li>自动缩放： 可以自动缩放构建机器，以确保立即处理您的构建并将成本降至最低。</li><li>构建工件： 可以将二进制文件和其他构建工件上载到 GitLab并浏览和下载它们。</li><li>Docker支持： 可以使用自定义Docker映像， 作为测试的一部分启动服务， 构建新的Docker映像，甚至可以在Kubernetes上运行。</li><li>容器注册表： 内置的容器注册表， 用于存储，共享和使用容器映像。</li><li>受保护的变量： 在部署期间使用受每个环境保护的变量安全地存储和使用机密。</li><li>环境： 定义多个环境。</li></ul><h3 id="3-Github-Actions特点，特性">3.Github Actions特点，特性<a class="anchor" href="#3-Github-Actions特点，特性">·</a></h3><p>actions可以用来作为CI/CD使用，但是它不只是CI/CD，因为它其实是<strong>一组docker容器</strong>所组成的<strong>Workflow</strong>，Workflow的触发条件，公共仓库目前仅支持push，私有仓库则支持check_run、create、delete、issue comment， commit comment, pull request等许多事件, 通过这些事件，可以完成包含CI/CD在内的许多自动化操作，例如接收到issue comment之后使用telegram bot发送通知等等</p><h3 id="4-CI-CD工具作用分析">4.CI/CD工具作用分析<a class="anchor" href="#4-CI-CD工具作用分析">·</a></h3><ul><li>CI/CD主要运用了jenkins进行对后端的开发代码的拉取，经过自动编译，打包，测试后，自动发布到tomcat服务器上，实现自动化的产品上线。</li><li>持续集成注重将各个开发者的工作集合到一个代码仓库中，通常每天会进行几次， 主要目的是尽早发现集成错误，使团队更加紧密结合，更好地协作。 通过持续集成，开发人员能够频繁地将其代码集成到公共代码仓库的主分支中。 开发人员能够在任何时候多次向仓库提交作品，而不是独立地开发每个功能模块并在开发周期结束时一一提交。</li><li>持续部署的目的是最小化部署或发布过程中团队固有的摩擦， 它的实现通常能够将构建部署的每个步骤自动化，以便任何时刻能够安全地完成代码发布。 持续部署扩展了持续交付，以便软件构建在通过所有测试时自动部署。在这样的流程中， 不需要人为决定何时及如何投入生产环境。CI/CD 系统的最后一步将在构建后的组件/包退出流水线时自动部署。 此类自动部署可以配置为快速向客户分发组件、功能模块或修复补丁，并准确说明当前提供的内容。</li></ul><h3 id="5-CI-CD工具对比">5.CI/CD工具对比<a class="anchor" href="#5-CI-CD工具对比">·</a></h3><p>Gitlab CI与Github Actions的系统对比在 https://about.gitlab.com/devops-tools/github-vs-gitlab/ci-missing-github-capabilities/ 非常详尽的展示了，其中CICD的对比大致用以下图来总结</p><p><img src="/2022/03/05/SE%E9%9B%86%E7%BB%93%E5%8F%B7-%E9%98%85%E8%AF%BB%E5%92%8C%E8%B0%83%E7%A0%94/7.png" alt></p><p>可以看到，对于CD部署的第三方性，以及CICD的部署容器和底层配置架构，gitlab做的更加细致一些，而github的市场化和开源性更好。</p><p>总的来说，使用体验来看由于github过于庞大，对于CICD的关注度显然没有gitlab到位，但是actions的丰富功能确实也很吸引人，然而出于种种原因最后可能软工还是会选用gitlab或者coding平台。coding对于中国用户当然是更加友好，不过具体功能还有待调研。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-SE-2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法导论笔记</title>
      <link href="2021/08/09/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%94%E8%AE%B0/"/>
      <url>2021/08/09/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一部分-基础知识">第一部分 基础知识<a class="anchor" href="#第一部分-基础知识">·</a></h1><h3 id="循环不变式">循环不变式<a class="anchor" href="#循环不变式">·</a></h3><p><strong>初始化</strong>：循环的第一次迭代之前为真</p><p><strong>保持</strong>：循环的某次迭代之前为真，则在下次迭代之前也为真</p><p><strong>终止</strong>：循环终止时，不变式提供有用性质，有助于证明算法成立</p><h2 id="第四章-分治策略">第四章 分治策略<a class="anchor" href="#第四章-分治策略">·</a></h2><h3 id="归并排序">归并排序<a class="anchor" href="#归并排序">·</a></h3><h3 id="最大子数组问题">最大子数组问题<a class="anchor" href="#最大子数组问题">·</a></h3><p>将数组切成左右两部分，则最大子数组要么出现在[l,mid]中，要么跨越了mid，要么就在[mid+1,r]中</p><h3 id="矩阵乘法的Strassen算法">矩阵乘法的Strassen算法<a class="anchor" href="#矩阵乘法的Strassen算法">·</a></h3><p>https://zhuanlan.zhihu.com/p/78657463</p><p>思想：矩阵乘法算法复杂度高，用矩阵加减法代替部分的矩阵乘法运算</p><p>从$O(n<sup>3)$降到了$O(n</sup>{lg7})$，但由于涉及多次浮点数加减乘除，算法稳定性精确度较低。对于n&gt;300时才适用</p><h3 id="求解递归式">求解递归式<a class="anchor" href="#求解递归式">·</a></h3><p>递归树，归纳法，主方法</p><h3 id="主方法">主方法<a class="anchor" href="#主方法">·</a></h3><p>$T(n)=aT(n/b)+f(n)$  $a\ge1,b&gt;1,\epsilon&gt;0$</p><ol><li><p>$f(n)=O(n<sup>{log_b</sup>{a-\epsilon}})\rightarrow T(n)=\Theta(n<sup>{log_b</sup>a})$</p></li><li><p>$f(n)=\Theta(n<sup>{log_b</sup>{a}})\rightarrow T(n)=\Theta(n<sup>{log_b</sup>a}lgn)$</p></li><li><p>$f(n)=\Omega(n<sup>{log_b</sup>{a+\epsilon}})且\exists c\lt1,s.t.\forall n, af(n/b)\leq cf(n)(正则条件)\rightarrow T(n)=\Theta(f(n))$</p></li></ol><p>主定理理解：情况1和3的小于和大于必须是<strong>多项式意义</strong>的大小关系，即如果没有相差$n^\epsilon$因子，则进入了1和2或者2和3的缝隙</p><h2 id="第五章-概率分析与随机算法">第五章 概率分析与随机算法<a class="anchor" href="#第五章-概率分析与随机算法">·</a></h2><h3 id="雇用问题">雇用问题<a class="anchor" href="#雇用问题">·</a></h3><p>随机化输入之后复杂度为$O(\ln n)$</p><h3 id="随机化序列方法">随机化序列方法<a class="anchor" href="#随机化序列方法">·</a></h3><p>PERMUTE-BY-SORTING方法随机化优先级，根据优先级对数组排列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">permutes=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    permutes.append((A[i],random.randint(<span class="number">0</span>,n*n*n)))</span><br><span class="line">permutes.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line">A=[permutes[i][<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br></pre></td></tr></table></figure><p>RANDOMIZE-IN-PLACE方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">j=random.randint(i,n<span class="number">-1</span>)</span><br><span class="line">    A[i],A[j]=A[j],A[i]</span><br></pre></td></tr></table></figure><h1 id="第二部分-排序与顺序统计量">第二部分 排序与顺序统计量<a class="anchor" href="#第二部分-排序与顺序统计量">·</a></h1><h2 id="第6章-堆排序">第6章 堆排序<a class="anchor" href="#第6章-堆排序">·</a></h2><p>与插入排序一样是原址排序，复杂度与归并排序相当。</p><p>堆可以看成一个<strong>完全二叉树</strong></p><p><strong>最大堆</strong>—进行堆排序</p><p><strong>最小堆</strong>—构造优先队列</p><p><strong>MAX-HEAPIFY</strong>(A, i)：维护i节点为根的子树的最大堆性质</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n=len(A)</span><br><span class="line">l=i*<span class="number">2</span></span><br><span class="line">maxi=i</span><br><span class="line"><span class="keyword">if</span> l&lt;n <span class="keyword">and</span> A[maxi]&lt;A[l]:</span><br><span class="line">    maxi=l</span><br><span class="line">r=i*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> r&lt;n <span class="keyword">and</span> A[maxi]&lt;A[r]:</span><br><span class="line">    maxi=r</span><br><span class="line"><span class="keyword">if</span> i!=maxi:</span><br><span class="line">    A[i],A[maxi]=A[maxi],A[i]</span><br><span class="line">    MAX-HEAPIFY(A, maxi)</span><br></pre></td></tr></table></figure><p><strong>BUILD-MAX-HEAP</strong>(A)：遍历[length/2,1]调用MAX-HEAPIFY</p><p><strong>HEAPSORT</strong>(A)：堆排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BUILD-MAX-HEAP(A)</span><br><span class="line">sz=len(A)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(A),<span class="number">1</span>):</span><br><span class="line">A[<span class="number">0</span>],A[i]=A[i],A[<span class="number">0</span>]</span><br><span class="line">sz-=<span class="number">1</span></span><br><span class="line">HEAPIFY(A,i)</span><br></pre></td></tr></table></figure><h3 id="优先队列">优先队列<a class="anchor" href="#优先队列">·</a></h3><p>共享计算机系统的作业调度</p><p><strong>MAXIMUM</strong>(S):return S[0]</p><p><strong>EXTRACT-MAX</strong>(x)：删去最大的并维护最大堆</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">max=S[<span class="number">0</span>]</span><br><span class="line">S[<span class="number">0</span>]=S[len(S)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">del</span> S[len(S)<span class="number">-1</span>]</span><br><span class="line">MAX-HEAPIFY(S,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> max</span><br></pre></td></tr></table></figure><p><strong>INCREASE-KEY</strong>(S,i,k)：增加i位置的元素值到k</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> k&lt;S[i]:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">S[i]=k</span><br><span class="line"><span class="keyword">while</span> i&gt;=<span class="number">1</span> <span class="keyword">and</span> S[i//<span class="number">2</span>]&lt;S[i]:</span><br><span class="line">    S[i],S[i//<span class="number">2</span>]=S[i//<span class="number">2</span>],S[i]</span><br><span class="line">    i=i//<span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>INSERT</strong>(S,x)：新增一个元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">MAX_INT=sys.maxsize</span><br><span class="line">S.append(-MAX_INT)</span><br><span class="line">INCREASE-KEY(S,len(S)<span class="number">-1</span>,x)</span><br></pre></td></tr></table></figure><h2 id="第7章-快速排序">第7章 快速排序<a class="anchor" href="#第7章-快速排序">·</a></h2><h3 id="QUICKSORT">QUICKSORT<a class="anchor" href="#QUICKSORT">·</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(a,l,r)</span>:</span></span><br><span class="line">    <span class="comment">#随机化抽样使划分更平衡</span></span><br><span class="line">    tmp=random.randint(l,r)</span><br><span class="line">    a[tmp],a[r]=a[r],a[tmp]</span><br><span class="line">    <span class="comment">#初始化</span></span><br><span class="line">    x=a[r]</span><br><span class="line">    i=l<span class="number">-1</span> <span class="comment">#i表示左边的区域的最右端</span></span><br><span class="line">    j=l <span class="comment">#j表示右边的区域的最右端</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(l,r):</span><br><span class="line">        <span class="keyword">if</span> a[j]&lt;=x:</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">            a[i],a[j]=a[j],a[i]</span><br><span class="line">    a[i+<span class="number">1</span>],a[r]=a[r],a[i+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(a,l,r)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> l&lt;r: <span class="comment">#l&gt;=r时直接返回，否则会爆栈</span></span><br><span class="line">        sep=partition(a,l,r)</span><br><span class="line">        quicksort(a,l,sep<span class="number">-1</span>)</span><br><span class="line">        quicksort(a,sep+<span class="number">1</span>,r)</span><br><span class="line">quicksort(a,<span class="number">0</span>,len(a)<span class="number">-1</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>只要是常数划分，时间复杂度都是$O(n\lg n)$</p><p>随机化划分则算法复杂度为$O(n\lg n)$</p><h2 id="第8章-线性时间排序">第8章 线性时间排序<a class="anchor" href="#第8章-线性时间排序">·</a></h2><h3 id="决策树模型">决策树模型<a class="anchor" href="#决策树模型">·</a></h3><img src="/2021/08/09/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%94%E8%AE%B0/决策树模型演示.jpg" style="zoom: 15%;"><p>每一层表示不同层级条件分支，叶子节点表示排序后的标号序列</p><p>决策树的叶节点数量为l</p><p>则对于一个长度为n的排列</p><p>$n!\leq l \lt 2^h$</p><p>$h&gt;\lg (n!)=\Omega(n\lg n)$​</p><p>因此任何排序算法的下界为$O(n\lg n)$</p><p><strong>不采用比较方式</strong>的排序需要更多空间，但时间复杂度突破了这个瓶颈，以下几个都为$\Theta(n)$</p><h3 id="计数排序">计数排序<a class="anchor" href="#计数排序">·</a></h3><p>稳定排序：相同数值的两个数排序前后相对次序不变</p><p>空间消耗大</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">12</span>]</span><br><span class="line">m=max(a)</span><br><span class="line">dic=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(m+<span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> a:</span><br><span class="line">    dic[x]+=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(dic)):</span><br><span class="line">    dic[i]+=dic[i<span class="number">-1</span>]</span><br><span class="line">outLs=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)+<span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">    outLs[dic[a[i]]]=a[i]</span><br><span class="line">    dic[a[i]]-=<span class="number">1</span></span><br><span class="line"><span class="keyword">del</span> outLs[<span class="number">0</span>]</span><br><span class="line">print(outLs)</span><br></pre></td></tr></table></figure><h3 id="基数排序">基数排序<a class="anchor" href="#基数排序">·</a></h3><p>早期卡片编程用到</p><p>n次循环(i from 1 to n)，每次序列对第i位数按照从小到大排序，最后的顺序就是从小到大</p><p>要求对一位数的排序为稳定排序</p><h3 id="桶排序">桶排序<a class="anchor" href="#桶排序">·</a></h3><p>将[0,1]划分为[0,1/n],[1/n,2/n]…[(n-1)/n,1]区间</p><p>每个数都属于一个小区间中，对每个区间内的数建立链表，使用插入排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">12</span>]</span><br><span class="line">m=max(a)+<span class="number">1</span></span><br><span class="line">n=len(a)</span><br><span class="line">buckets=[[] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertB</span><span class="params">(suba,x)</span>:</span></span><br><span class="line">    i=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i&lt;len(suba) <span class="keyword">and</span> suba[i]&lt;x:</span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i==len(suba):</span><br><span class="line">        suba.append(x)</span><br><span class="line">    <span class="keyword">elif</span> i==<span class="number">0</span>:</span><br><span class="line">        suba.insert(<span class="number">0</span>,x)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        suba.insert(i,x)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> a:</span><br><span class="line">    pos=int(x*n/m)</span><br><span class="line">    insertB(buckets[pos],x)</span><br><span class="line">outLs=[]</span><br><span class="line"><span class="keyword">for</span> b <span class="keyword">in</span> buckets:</span><br><span class="line">    outLs+=b</span><br><span class="line">print(outLs)</span><br></pre></td></tr></table></figure><h2 id="第9章-中位数与顺序统计量">第9章 中位数与顺序统计量<a class="anchor" href="#第9章-中位数与顺序统计量">·</a></h2><p>第i个<strong>顺序统计量</strong>：一个序列中第i小的元素</p><h3 id="选择问题">选择问题<a class="anchor" href="#选择问题">·</a></h3><p>输入：一个集合A和一个数i</p><p>输出：第i个顺序统计量</p><p>利用快速排序中的随机划分函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">randomselect</span><span class="params">(a,l,r,i)</span>:</span></span><br><span class="line">    q=partition(a,l,r)</span><br><span class="line">    k=q-l+<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> k==i:</span><br><span class="line">        <span class="keyword">return</span> q</span><br><span class="line">    <span class="keyword">elif</span> i&lt;k:</span><br><span class="line">        <span class="keyword">return</span> randomselect(a,l,q<span class="number">-1</span>,i)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> randomselect(a,q+<span class="number">1</span>,r,i-k)</span><br></pre></td></tr></table></figure><h4 id="select算法">select算法<a class="anchor" href="#select算法">·</a></h4><p>https://blog.csdn.net/luoshixian099/article/details/45286303</p><h1 id="第三部分-数据结构">第三部分 数据结构<a class="anchor" href="#第三部分-数据结构">·</a></h1><h2 id="第10章-基本数据结构">第10章 基本数据结构<a class="anchor" href="#第10章-基本数据结构">·</a></h2><h3 id="栈：后进先出">栈：后进先出<a class="anchor" href="#栈：后进先出">·</a></h3><h3 id="队列：先进先出">队列：先进先出<a class="anchor" href="#队列：先进先出">·</a></h3><h3 id="链表">链表<a class="anchor" href="#链表">·</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,val,prev,next)</span>:</span></span><br><span class="line">        self.value = val</span><br><span class="line">        self.prev = prev</span><br><span class="line">        self.next = next</span><br></pre></td></tr></table></figure><p>哨兵用一个哨兵对象nil表示NULL</p><p>哨兵可以降低常数因子，但占用额外空间比较浪费，一般不用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">L.nil.prev=L.tail</span><br><span class="line">L.nil.next=L.head</span><br></pre></td></tr></table></figure><h3 id="有根树的表示">有根树的表示<a class="anchor" href="#有根树的表示">·</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">treenode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,val,p,leftChild,rightChild)</span>:</span></span><br><span class="line">        self.val=val</span><br><span class="line">        self.p=p</span><br><span class="line">        self.leftChild=leftChild</span><br><span class="line">        self.rightChild=rightChild <span class="comment">#多叉树用self.childs=childs childs为节点列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#另一种表示</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">treenode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,val,p,leftChild,rightSibling)</span>:</span></span><br><span class="line">        self.val=val</span><br><span class="line">        self.p=p</span><br><span class="line">        self.leftChild=leftChild</span><br><span class="line">        self.rightSibling=rightSibling </span><br><span class="line">        <span class="comment">#leftChild--&gt;最左边的孩子</span></span><br><span class="line">        <span class="comment">#rightSibling--&gt;每个节点的靠右的第一个兄弟</span></span><br></pre></td></tr></table></figure><h2 id="第11章-散列表">第11章 散列表<a class="anchor" href="#第11章-散列表">·</a></h2><h3 id="直接寻址表">直接寻址表<a class="anchor" href="#直接寻址表">·</a></h3><p>即数组，根据关键字k直接索引元素</p><h3 id="散列表">散列表<a class="anchor" href="#散列表">·</a></h3><p>根据函数h(k)的值索引元素</p><p>冲突解决办法：链接法 开放寻址法</p><h4 id="链接法">链接法<a class="anchor" href="#链接法">·</a></h4><p>假设任何一个给定元素等可能散列到m个槽中任何一个，与其他元素被散列到哪无关，这个假设为<strong>简单均匀散列</strong></p><p>每个槽对应一个链表，冲突则放在链表中</p><h3 id="散列函数">散列函数<a class="anchor" href="#散列函数">·</a></h3><p>多数散列函数都假定<strong>关键字全域</strong>为<strong>自然数集N</strong>，如果不是自然数集则一般要通过某种方式转换为自然数，比如<strong>字符串和Ascii码</strong></p><h4 id="除法散列法">除法散列法<a class="anchor" href="#除法散列法">·</a></h4><p>$h(k)=k\ mod\ m$</p><p>m一般取不接近2的整数幂的素数</p><h4 id="乘法散列法">乘法散列法<a class="anchor" href="#乘法散列法">·</a></h4><p>$h(k)=\lfloor m((kA)\ mod\ 1)\rfloor$​</p><p>其中 $((kA) mod 1)$ ​为取 $kA$​​​ 的小数部分 $0\leq A \leq 1$</p><p>由于移位乘法比较简单，A一般取形如$s/2^w$​的一个小数，m一般取2的整数幂</p><p>Knuth认为$A=(\sqrt 5 -1)/2=0.6180339887…$比较合适</p><h4 id="全域散列法">全域散列法<a class="anchor" href="#全域散列法">·</a></h4><p>随机选择散列函数，使之独立于关键字</p><img src="/2021/08/09/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E7%AC%94%E8%AE%B0/全域散列定义.png" style="zoom: 80%;"><h4 id="开放寻址法">开放寻址法<a class="anchor" href="#开放寻址法">·</a></h4><p>$h:U\times{0,1…m-1}\rightarrow {0,1…m-1}$</p><p>对每一个关键字k，使用开放寻址法的探查序列 $&lt;h(k,0),h(k,1),…,h(k,m-1)&gt;$​ 选择空的槽位</p><p>探查方式</p><ul><li>线性探查</li><li>二次探查</li><li>双重散列</li></ul><h3 id="完全散列">完全散列<a class="anchor" href="#完全散列">·</a></h3><p>二级散列表，每一级都采用全域散列</p><h2 id="第12章-二叉搜索树">第12章 二叉搜索树<a class="anchor" href="#第12章-二叉搜索树">·</a></h2><p>在一棵高度h的二叉树上，动态集合上的操作SEARCH/MINIMUM/MAXIMUM/SUCCESSOR/PREDECESSOR/DELETE/INSERT均可以在O(h)内完成</p><h2 id="第13章-红黑树">第13章 红黑树<a class="anchor" href="#第13章-红黑树">·</a></h2><p>平衡搜索树</p><h2 id="第14章-数据结构的扩张">第14章 数据结构的扩张<a class="anchor" href="#第14章-数据结构的扩张">·</a></h2><h3 id="扩张数据结构的步骤">扩张数据结构的步骤<a class="anchor" href="#扩张数据结构的步骤">·</a></h3><ol><li>选择一种<strong>基础数据结构</strong></li><li>确定基础数据结构中要维护的<strong>附加信息</strong></li><li>检验基础数据结构上的基本修改操作<strong>能否维护</strong>附加信息</li><li>设计一些<strong>新操作</strong></li></ol><p>顺序统计树——在红黑树基础上对每个结点增加一个表示子树大小的size变量</p><p>区间树——红黑树基础上，关键字采用区间信息和端点最大值</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django+vue项目部署</title>
      <link href="2021/07/11/Django-vue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
      <url>2021/07/11/Django-vue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="后端配置">后端配置<a class="anchor" href="#后端配置">·</a></h2><p><a href="https://blog.csdn.net/freezingxu/article/details/77074075" target="_blank" rel="noopener">在Ubuntu/Linux环境下使用MySQL：启动和关闭MySQL服务</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service mysql start</span><br><span class="line">service mysql status</span><br><span class="line">service mysql stop</span><br></pre></td></tr></table></figure><p>修改.cnf文件的方法：直接 <code>sudo vim my.cnf</code></p><p>mysql my.cnf配置：https://blog.csdn.net/weixin_43633797/article/details/102524499</p><p>查看监听端口：netstat -tln   https://www.136.la/mysql/show-80993.html</p><p>彻底删除并重装mysql：https://www.codenong.com/cs106182111/</p><p>sudo apt install mysql-server</p><p>sudo apt install libmysqlclient-dev</p><p>初始密码找不到进不去：https://blog.csdn.net/r527665047/article/details/107056941/</p><p>修改完密码之后要重启mysql！</p><p>进入后端根目录</p><p>python manage.py makemigrations</p><p>python manage.py runserver 8000</p><p>https://www.cnblogs.com/steven_oyj/archive/2010/05/24/1742808.html</p><p>https://blog.csdn.net/leacock1991/article/details/110406708</p><p>解决OSError: mysql_config not found问题：https://blog.csdn.net/zy_whynot/article/details/106960087</p><p>mongo远程连接：https://www.cnblogs.com/kimkat/p/9192785.html</p><h3 id="ngnix配置">ngnix配置<a class="anchor" href="#ngnix配置">·</a></h3><p>https://www.cnblogs.com/niehaidong111/p/11208492.html</p><p>https://www.cnblogs.com/NAG2020/p/12920154.html</p><p>安装ngnix：https://blog.csdn.net/qq_23832313/article/details/83578836</p><p>https://www.cnblogs.com/gede/p/11011693.html</p><p>sudo vim /etc/nginx/conf.d/istic.conf</p><h2 id="前端配置">前端配置<a class="anchor" href="#前端配置">·</a></h2><h3 id="安装npm">安装npm<a class="anchor" href="#安装npm">·</a></h3><p>sudo apt update</p><p>sudo apt install npm</p><p>git clone https://gitee.com/muller2020/BUAACrawler.git</p><p>进入前端目录</p><p>cd vue-admin-template</p><p>npm install</p><p>npm run build:prod</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -aux |grep uwsgi</span><br><span class="line">kill -9 3539 #最后这个号码是最上面那个</span><br><span class="line">uwsgi --ini mywsgi.ini #再重启uwsgi就好了</span><br></pre></td></tr></table></figure><h3 id="前端问题解决">前端问题解决<a class="anchor" href="#前端问题解决">·</a></h3><p><a href="http://blog.itblood.com/2455.html" target="_blank" rel="noopener">Error:Rule can only have resource source(provided resource test include exclude【解决办法】</a> 重装webpack</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm cache clean --force #清除缓存</span><br></pre></td></tr></table></figure><p>npm install一定要保证全局的存储地址有充足的空间！！！（默认在C盘）</p><h2 id="部署完成">部署完成<a class="anchor" href="#部署完成">·</a></h2><h3 id="修改用户密码">修改用户密码<a class="anchor" href="#修改用户密码">·</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">python3 manage.py shell</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth <span class="keyword">import</span> get_user_model</span><br><span class="line">User = get_user_model()</span><br><span class="line">user=User.objects.get(username=<span class="string">'XXX'</span>)</span><br><span class="line">user.set_password(<span class="string">'new_password'</span>)</span><br><span class="line">user.save()</span><br><span class="line">或者</span><br><span class="line">python3 manage.py changepassword username</span><br></pre></td></tr></table></figure><h3 id="连接远程服务器">连接远程服务器<a class="anchor" href="#连接远程服务器">·</a></h3><p>https://www.cnblogs.com/zhuminghui/p/10947930.html</p><h3 id="自动部署">自动部署<a class="anchor" href="#自动部署">·</a></h3><h4 id="生成公私钥">生成公私钥<a class="anchor" href="#生成公私钥">·</a></h4><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -o</span><br></pre></td></tr></table></figure><p>将公钥放到仓库的公钥列表中，并将.git文件夹下的config文件中的url改为ssh地址</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法学习</title>
      <link href="2021/07/10/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/07/10/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>算法学习笔记，本篇主要是一些基本的知识整理</p><a id="more"></a><h1 id="Leetcode高频算法实战学习">Leetcode高频算法实战学习<a class="anchor" href="#Leetcode高频算法实战学习">·</a></h1><h2 id="一、数组">一、数组<a class="anchor" href="#一、数组">·</a></h2><h3 id="数组理论">数组理论<a class="anchor" href="#数组理论">·</a></h3><p>使用静态数组实现的方法：每次大小不够时将新的静态数组长度<strong>增大一倍</strong>，这样就可以将拷贝数值的复杂度降到$O(n)$</p><p>不同遍历方式差别很大，以下三种从上到下时间依次上升。</p><p>参考博客：https://blog.csdn.net/xiewuquan/article/details/50492096</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="built_in">print</span>(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x:a)&#123;</span><br><span class="line">    <span class="built_in">print</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it:a.<span class="built_in">begin</span>();it!=a.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">    <span class="built_in">print</span>(it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>emplace_back</code>效果和<code>push_back</code>一致，最好使用前者，节省空间开销</p><p>如果已经确定了数组长度，就直接先使用<code>vector&lt;int&gt; ans(n);</code>初始化好再直接用下标索引直接赋值，比一个个<code>push_back</code>快</p><h3 id="扫描数组技巧">扫描数组技巧<a class="anchor" href="#扫描数组技巧">·</a></h3><p>求数组区间和，区间方差，二位数组矩阵区域和方法：记录从0到每个序号的和，然后用sum[j]-sum[i-1]的方式求出区间[i,j]的和</p><h3 id="序列问题">序列问题<a class="anchor" href="#序列问题">·</a></h3><h4 id="下一个排列">下一个排列<a class="anchor" href="#下一个排列">·</a></h4><ol><li>数组长度小于2直接返回原数组</li><li>从后往前扫描找到一个序号i使得nums[i]&lt;nums[i+1]</li><li>在nums[i+1,n-1]之间找到一个大于nums[i]且最小的数的序号mini，将mini和i处的数交换</li><li>将i位置之后的数组逆序（由从大到小变为从小到大）</li></ol><h4 id="前一个排列">前一个排列<a class="anchor" href="#前一个排列">·</a></h4><ol><li>数组长度小于2直接返回原数组</li><li>从后往前扫描找到一个序号i使得nums[i]&gt;nums[i+1]</li><li>在nums[i+1,n-1]之间找到一个小于nums[i]且最大的数的序号maxi，将maxi和i处的数交换</li><li>将i位置之后的数组逆序（由从小到大变为从大到小）</li></ol><p>逆序过程可以用sort函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sort(nums+i,nums+n<span class="number">-1</span>,cmp); <span class="comment">//n=nums.size()</span></span><br><span class="line">sort(nums.<span class="built_in">begin</span>()+i,nums.<span class="built_in">end</span>(),cmp); <span class="comment">//另一种写法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a,<span class="keyword">const</span> <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b; <span class="comment">//从大到小排序 a&lt;b则是从小到大</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最大子序和">最大子序和<a class="anchor" href="#最大子序和">·</a></h4><h5 id="最大连续子数组和">最大连续子数组和<a class="anchor" href="#最大连续子数组和">·</a></h5><p>先求出从<code>0</code>到每个位置的和，用<code>sums</code>记录，在这个遍历过程中同时记录在每个位置之前的位置中sum最小的位置，也用另一个数组存储。</p><p>之后对每个位置<code>i</code>，计算<code>sums[i]-sums[minPos[i]]</code>的最大值</p><h5 id="环形数组最大连续子数组和">环形数组最大连续子数组和<a class="anchor" href="#环形数组最大连续子数组和">·</a></h5><p>用一个普通数组表示环形数组</p><p>分为两种情况</p><p>case1:最大的子数组在原数组中间，此时等价于之前普通的数组情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**+++**</span><br></pre></td></tr></table></figure><p>case2:最大子数组在原数组两边，此时等价于求<strong>最小连续子数组和</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++***++</span><br></pre></td></tr></table></figure><h3 id="有序数组查找问题">有序数组查找问题<a class="anchor" href="#有序数组查找问题">·</a></h3><h4 id="两数之和">两数之和<a class="anchor" href="#两数之和">·</a></h4><p>有序数组中，两个指针l,r记录。两个位置数字和与目标值比较，一样的话返回，大了就r–，小的话就l++。</p><h4 id="三数之和">三数之和<a class="anchor" href="#三数之和">·</a></h4><p>三个指针i j k(i&lt;=j&lt;=k)</p><p>定死一个位置i，看是否存在nums[j]+nums[k]=target-nums[i]</p><h4 id="二分查找">二分查找<a class="anchor" href="#二分查找">·</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>,r=n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">        l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><h4 id="搜索旋转排序矩阵">搜索旋转排序矩阵<a class="anchor" href="#搜索旋转排序矩阵">·</a></h4><p>类似二分查找的思路，加一些判定</p><p>假设左边的数位置是 L，右边位置是 R：</p><ol><li><p>如果当前数组的长度小于等于 2 的话，我们按边界条件处理。</p></li><li><p>否则，取中间的位置 M，先判断目标值和 M 位置值的关系，如果相等直接返回 M。</p></li><li><p>然后，如果 M 位置的值大于 L 位置的值:</p><ul><li><p>如果目标值在 L 到 M 之间，我们递归左边部分。</p></li><li><p>其他情况，递归右边部分。</p></li></ul></li><li><p>如果 M 位置的值小于 L 位置的值:</p><ul><li><p>如果目标值在 M 到 R 之间，递归右边部分。</p></li><li><p>其他情况，递归左边部分。</p></li></ul></li></ol><h4 id="搜索二维矩阵">搜索二维矩阵<a class="anchor" href="#搜索二维矩阵">·</a></h4><p>每次从左下角的指针开始判断</p><p>对于m*n矩阵，初始化指针为x=m-1,y=0</p><p>之后<code>nums[x][y]&gt;target</code>就x–</p><p>相等就返回</p><p>小于就y++</p><h2 id="二、栈">二、栈<a class="anchor" href="#二、栈">·</a></h2><p>后进先出</p><p>需要实现top() size() pop() push(x)四个操作</p><h3 id="括号匹配">括号匹配<a class="anchor" href="#括号匹配">·</a></h3><h3 id="表达式计算">表达式计算<a class="anchor" href="#表达式计算">·</a></h3><h2 id="三、队列">三、队列<a class="anchor" href="#三、队列">·</a></h2><p>先进先出</p><h3 id="滑动窗口最大值">滑动窗口最大值<a class="anchor" href="#滑动窗口最大值">·</a></h3><h4 id="方法2：使用单调双向队列解决问题">方法2：使用单调双向队列解决问题<a class="anchor" href="#方法2：使用单调双向队列解决问题">·</a></h4><p>原理：如果在k个数中存在一个编号<code>i&lt;j</code>,<code>nums[i]&lt;=nums[j]</code>则<code>nums[i]</code>必定不可能是最大的那个数，因此将这样的数出队。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q; <span class="comment">//q为原数组的序号队列，相当于同时存储了数值和编号两个值</span></span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123; <span class="comment">//初始化先将前k个数中降序的编号存到队列中</span></span><br><span class="line">            <span class="keyword">while</span>(!q.empty()&amp;&amp;nums[q.back()]&lt;=nums[i])&#123;</span><br><span class="line">                q.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            q.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans=&#123;nums[q.front()]&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!q.empty()&amp;&amp;nums[q.back()]&lt;=nums[i])&#123;</span><br><span class="line">                q.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            q.push_back(i);</span><br><span class="line">            <span class="keyword">if</span>(q.front()&lt;i-k+<span class="number">1</span>)&#123;</span><br><span class="line">                q.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(nums[q.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方差计算：$D(x)=\sum x_i^2-((\sum x_i)/n)^2$</p><h3 id="求岛屿最大面积">求岛屿最大面积<a class="anchor" href="#求岛屿最大面积">·</a></h3><p>遍历每一个土地，是1则开始广度搜索，同时将搜索到的土地标记为0，即不能再次访问，直到队列为空。</p><h2 id="四、链表">四、链表<a class="anchor" href="#四、链表">·</a></h2><h3 id="反转链表">反转链表<a class="anchor" href="#反转链表">·</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归解法</span></span><br><span class="line"><span class="function">ListNode* <span class="title">recurseWay</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head||!head-&gt;next)&#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode * newHead=recurseWay(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next=head;</span><br><span class="line">    head-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归解法</span></span><br><span class="line"><span class="function">ListNode* <span class="title">noRecurseWay</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* newHead=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        ListNode* nt=head-&gt;next;</span><br><span class="line">        head-&gt;next=newHead;</span><br><span class="line">        newHead=head;</span><br><span class="line">        head=nt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、树">五、树<a class="anchor" href="#五、树">·</a></h2><p>前序遍历：根节点–&gt;左子树–&gt;右子树</p><p>中序遍历：左子树–&gt;根节点–&gt;右子树</p><p>后序遍历：左子树–&gt;右子树–&gt;根节点</p><h3 id="根据前序遍历和中序遍历结果构造二叉树">根据前序遍历和中序遍历结果构造二叉树<a class="anchor" href="#根据前序遍历和中序遍历结果构造二叉树">·</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">     TreeNode *left;</span><br><span class="line">     TreeNode *right;</span><br><span class="line">     TreeNode() : val(<span class="number">0</span>), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">     TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">     TreeNode(<span class="keyword">int</span> x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mySolution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rootval=preorder[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> n=inorder.<span class="built_in">size</span>();</span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> TreeNode(rootval);</span><br><span class="line">        <span class="keyword">int</span> r=<span class="built_in">find</span>(inorder.<span class="built_in">begin</span>(),inorder.<span class="built_in">end</span>(),rootval)-inorder.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorder1;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorder2;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder1;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;r;i++)&#123;</span><br><span class="line">            preorder1.push_back(preorder[<span class="number">1</span>+i]);</span><br><span class="line">            inorder1.push_back(inorder[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=r+<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            preorder2.push_back(preorder[i]);</span><br><span class="line">            inorder2.push_back(inorder[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;left=buildTree(preorder1,inorder1);</span><br><span class="line">        root-&gt;right=buildTree(preorder2,inorder2);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">officalSolution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; index;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=inorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            index[inorder[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myBuildTree(preorder,inorder,<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">myBuildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder,<span class="keyword">int</span> prel,<span class="keyword">int</span> prer,<span class="keyword">int</span> inl,<span class="keyword">int</span> inr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prel&gt;prer)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> TreeNode(preorder[prel]);</span><br><span class="line">        <span class="keyword">int</span> rooti=index[preorder[prel]];</span><br><span class="line">        <span class="keyword">int</span> leftLen=rooti-inl;</span><br><span class="line">        root-&gt;left=myBuildTree(preorder,inorder,prel+<span class="number">1</span>,prel+leftLen,inl,inl+leftLen<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right=myBuildTree(preorder,inorder,prel+leftLen+<span class="number">1</span>,prer,rooti+<span class="number">1</span>,inr);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据中序和后序遍历结果构造也是同理，只需要对上述做法微调即可。</p><h3 id="层序遍历">层序遍历<a class="anchor" href="#层序遍历">·</a></h3><p>普通递归或者BFS都可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfsLevelOrder(root,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">myLevelOrder</span><span class="params">(TreeNode* root,<span class="keyword">int</span> level)</span></span>&#123; <span class="comment">//me</span></span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(level&gt;ans.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ls;</span><br><span class="line">                ls.push_back(root-&gt;val);</span><br><span class="line">                ans.push_back(ls);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans[level<span class="number">-1</span>].push_back(root-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            myLevelOrder(root-&gt;left,level+<span class="number">1</span>);</span><br><span class="line">            myLevelOrder(root-&gt;right,level+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">bfsLevelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123; <span class="comment">//Leetcode official</span></span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span> &lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> currentLevelSize = q.<span class="built_in">size</span>();</span><br><span class="line">            ret.push_back(<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; ());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= currentLevelSize; ++i) &#123; </span><br><span class="line">                <span class="comment">//这里的bfs与一般的不同，每次将当前循环中所有元素全部处理并出队，相当于处理完【一层】</span></span><br><span class="line">                <span class="keyword">auto</span> node = q.front(); q.pop();</span><br><span class="line">                ret.back().push_back(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="寻找最近公共祖先">寻找最近公共祖先<a class="anchor" href="#寻找最近公共祖先">·</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==p||root==q)&#123; <span class="comment">//root和p或q中某个相等直接返回root</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* ansl=<span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* ansr=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ansl=lowestCommonAncestor(root-&gt;left,p,q); <span class="comment">//查询左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ansr=lowestCommonAncestor(root-&gt;right,p,q);<span class="comment">//查询右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ansl!=<span class="literal">nullptr</span>&amp;&amp;ansr!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root; <span class="comment">//都不为空，则一个在左子树，一个在右子树</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ansl!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ansl; <span class="comment">//只有一个为空则返回那个结果</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ansr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="树上最接近的两部分">树上最接近的两部分<a class="anchor" href="#树上最接近的两部分">·</a></h3><p>删除一条边使得分开的两部分节点之和最接近（差的绝对值最小）</p><p>思路：先求出每个子树的和并记录在对应节点的val中，再遍历每个节点找出答案</p><p><strong>最优子结构特性</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">similarTwoParts</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        getSum(root);</span><br><span class="line">        <span class="keyword">int</span> s=root-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> minsum=<span class="number">0x3fffff</span>;</span><br><span class="line">        findMax(root,minsum,s);</span><br><span class="line">        <span class="keyword">return</span> minsum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findMax</span><span class="params">(TreeNode* root,<span class="keyword">int</span> &amp;minsum,<span class="keyword">int</span> rootsum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val!=rootsum&amp;&amp;<span class="built_in">abs</span>(rootsum<span class="number">-2</span>*root-&gt;val)&lt;minsum)&#123;</span><br><span class="line">            minsum=<span class="built_in">abs</span>(rootsum<span class="number">-2</span>*root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        findMax(root-&gt;left,minsum,rootsum);</span><br><span class="line">        findMax(root-&gt;right,minsum,rootsum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;val=getSum(root-&gt;left)+getSum(root-&gt;right)+root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="六、堆（优先队列）">六、堆（优先队列）<a class="anchor" href="#六、堆（优先队列）">·</a></h2><p>堆：完全二叉树，且每个子树的根节点的值都是这个子树的最大值或者最小值</p><h3 id="判断二叉树是否为堆">判断二叉树是否为堆<a class="anchor" href="#判断二叉树是否为堆">·</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; index;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLegalHeap</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否为完全二叉树</span></span><br><span class="line">        getIndex(root,<span class="number">0</span>);</span><br><span class="line">        sort(index.<span class="built_in">begin</span>(),index.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;index.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index[i]&gt;index[i<span class="number">-1</span>]+<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是否符合堆的性质</span></span><br><span class="line">        <span class="keyword">return</span> isBiggestLegalHeap(root)||isLeastLegalHeap(root); <span class="comment">//两个函数也可以增加一个变量来合并</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getIndex</span><span class="params">(TreeNode* root,<span class="keyword">int</span> i)</span></span>&#123; <span class="comment">//遍历二叉树获取每个非空元素的在堆中的序号</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        index.push_back(i);</span><br><span class="line">        getIndex(root-&gt;left,i*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        getIndex(root-&gt;right,i*<span class="number">2</span>+<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBiggestLegalHeap</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>&amp;&amp;root-&gt;left-&gt;val&gt;root-&gt;val||root-&gt;right!=<span class="literal">nullptr</span>&amp;&amp;root-&gt;right-&gt;val&gt;root-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isBiggestLegalHeap(root-&gt;left)&amp;&amp;isBiggestLegalHeap(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLeastLegalHeap</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>&amp;&amp;root-&gt;left-&gt;val&lt;root-&gt;val||root-&gt;right!=<span class="literal">nullptr</span>&amp;&amp;root-&gt;right-&gt;val&lt;root-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isLeastLegalHeap(root-&gt;left)&amp;&amp;isLeastLegalHeap(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="将二叉树转换为堆">将二叉树转换为堆<a class="anchor" href="#将二叉树转换为堆">·</a></h3><p>改进的BFS<strong>层序遍历</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">transferHeapToList</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; heap;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> sz=q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;i++)&#123;</span><br><span class="line">                TreeNode* node=q.front();q.pop();</span><br><span class="line">                heap.push_back(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    q.push(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    q.push(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="合并k个有序链表-※※※">合并k个有序链表 ※※※<a class="anchor" href="#合并k个有序链表-※※※">·</a></h3><p>维护这k个有序链表的头节点的优先队列（即最小堆）,每次从最小堆里弹出最小的节点并将他的链表后继节点加入堆中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span> <span class="comment">//LeetCode-Solution</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Status</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode *ptr;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Status &amp;rhs) <span class="keyword">const</span> &#123; <span class="comment">//重载运算符构造最小堆</span></span><br><span class="line">            <span class="keyword">return</span> val &gt; rhs.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    priority_queue &lt;Status&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> node: lists) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node) q.push(&#123;node-&gt;val, node&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode head, *tail = &amp;head; <span class="comment">//head.next指向总链表的头 tail为尾部</span></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> f = q.top(); q.pop();</span><br><span class="line">            tail-&gt;next = f.ptr; </span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (f.ptr-&gt;next) q.push(&#123;f.ptr-&gt;next-&gt;val, f.ptr-&gt;next&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="合并k个最小堆">合并k个最小堆<a class="anchor" href="#合并k个最小堆">·</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Status</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Status &amp;rhs) <span class="keyword">const</span> &#123; <span class="comment">//重载运算符构造最小堆</span></span><br><span class="line">            <span class="keyword">return</span> val &gt; rhs.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    priority_queue &lt;Status&gt; q; <span class="comment">//将每个最小堆的首元素维护一个最小堆</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mergeKHeaps</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; heaps)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;heaps.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            q.push(&#123;i,heaps[i][<span class="number">0</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            ans.push_back(extractMin(heaps));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">extractMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; heaps)</span></span>&#123; <span class="comment">//返回一个堆顶的值，并做相应的各个堆的维护</span></span><br><span class="line">        <span class="comment">/* 以下写法错误，注意避免</span></span><br><span class="line"><span class="comment">        vector&lt;int&gt; heap=heaps[top.i];</span></span><br><span class="line"><span class="comment">        heap.pop_back();</span></span><br><span class="line"><span class="comment">        这样相当于新建了一个heap变量，没有对原heaps做修改</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Status</span> <span class="title">top</span>=<span class="title">q</span>.<span class="title">top</span>();</span>q.pop();</span><br><span class="line">        <span class="keyword">int</span> n=heaps[top.i].<span class="built_in">size</span>(); </span><br><span class="line">        <span class="keyword">int</span> tmp=heaps[top.i][n<span class="number">-1</span>];heaps[top.i][n<span class="number">-1</span>]=heaps[top.i][<span class="number">0</span>];heaps[top.i][<span class="number">0</span>]=tmp;</span><br><span class="line">        heaps[top.i].pop_back();</span><br><span class="line">        <span class="keyword">if</span>(!heaps[top.i].empty())&#123;</span><br><span class="line">            minHeapify(heaps[top.i],<span class="number">0</span>);</span><br><span class="line">            q.push(&#123;top.i,heaps[top.i][<span class="number">0</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> top.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">minHeapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heap,<span class="keyword">int</span> i)</span></span>&#123; <span class="comment">//维持最小堆</span></span><br><span class="line">        <span class="keyword">int</span> n=heap.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l=i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mini=i;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;n&amp;&amp;heap[l]&lt;heap[mini])&#123;</span><br><span class="line">            mini=l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> r=i*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;n&amp;&amp;heap[r]&lt;heap[mini])&#123;</span><br><span class="line">            mini=r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mini!=i)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=heap[i];heap[i]=heap[mini];heap[mini]=tmp;</span><br><span class="line">            minHeapify(heap,mini);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="七、二叉查找树">七、二叉查找树<a class="anchor" href="#七、二叉查找树">·</a></h2><h2 id="八、图">八、图<a class="anchor" href="#八、图">·</a></h2><p>广度优先搜索遍历 DFS</p><p>深度优先搜索遍历 BFS</p><h2 id="九、设计类问题">九、设计类问题<a class="anchor" href="#九、设计类问题">·</a></h2><h2 id="十、贪心与分治">十、贪心与分治<a class="anchor" href="#十、贪心与分治">·</a></h2><h3 id="问题拆解与相应原则-font-color-red-※※※-font">问题拆解与相应原则 <font color="red">※※※</font><a class="anchor" href="#问题拆解与相应原则-font-color-red-※※※-font">·</a></h3><p>如果子问题最优则原问题最优，贪心算法。</p><p>如果子问题需要全部求解才能求解原问题，子问题互相独立，分治算法。</p><p>如果子问题最优不能保证原问题最优，但是子问题之间不会循环（所谓循环，是指从问题 A 拆解出子问题 B，然后子问题 B 又能拆解出子问题 A），考虑动态规划算法。</p><p>更加复杂的情况，我们总是可以考虑暴力搜索解决。</p><h3 id="分发饼干">分发饼干<a class="anchor" href="#分发饼干">·</a></h3><p>先将需求数组g和尺寸数组s排序，然后对于每一个孩子的需求都<strong>寻找到最小的符合需求的饼干</strong>进行满足</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; g, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        sort(g.<span class="built_in">begin</span>(),g.<span class="built_in">end</span>());</span><br><span class="line">        sort(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> n=g.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;n&amp;&amp;j&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]&lt;g[i])&#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="用最少数量的箭引爆气球">用最少数量的箭引爆气球<a class="anchor" href="#用最少数量的箭引爆气球">·</a></h3><p>遇到区间类的贪心问题，都先考虑排序，一般按照左端点或者右端点排序，控制复杂度为 $O(n\lg n)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">point</span>;<span class="comment">//坐标</span></span><br><span class="line">        <span class="keyword">int</span> type; <span class="comment">//0:begin 1:end</span></span><br><span class="line">        <span class="keyword">int</span> pos;  <span class="comment">//编号</span></span><br><span class="line">    &#125; Node;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node x,Node y)</span></span>&#123; <span class="comment">//将所有节点进行排序，坐标小的靠前，坐标一致将起点置于前</span></span><br><span class="line">        <span class="keyword">return</span> x.<span class="built_in">point</span>&lt;y.<span class="built_in">point</span>?<span class="literal">true</span>:</span><br><span class="line">               x.<span class="built_in">point</span>&gt;y.<span class="built_in">point</span>?<span class="literal">false</span>:</span><br><span class="line">               x.type==<span class="number">0</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node&gt; nodes;</span><br><span class="line">        <span class="keyword">int</span> n=points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">exist</span><span class="params">(n,<span class="number">0</span>)</span></span>; <span class="comment">//表示每个编号的气球是否已经被射爆</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; targets; <span class="comment">//当前可以被一次射中的全部气球编号</span></span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            nodes.push_back(&#123;points[i][<span class="number">0</span>],<span class="number">0</span>,i&#125;);</span><br><span class="line">            nodes.push_back(&#123;points[i][<span class="number">1</span>],<span class="number">1</span>,i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nodes.<span class="built_in">begin</span>(),nodes.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> node:nodes)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.type==<span class="number">0</span>)&#123;</span><br><span class="line">                targets.push(node.pos); <span class="comment">//起点，直接进队</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(!exist[node.pos])&#123;   <span class="comment">//终点且这个气球没被射爆</span></span><br><span class="line">                    ans++;</span><br><span class="line">                    <span class="keyword">while</span>(!targets.empty())&#123; <span class="comment">//全部出队并设置为已射爆</span></span><br><span class="line">                        exist[targets.front()]=<span class="number">1</span>;</span><br><span class="line">                        targets.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="快速幂">快速幂<a class="anchor" href="#快速幂">·</a></h3><p>例子：$3^{15}$  $15=(1111)_2 $  $3<sup>{15}=3</sup>{1+2+4+8}$</p><p>分治算法的经典例子</p><p>可以延申求矩阵快速幂，用于动态规划的加速</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> N=n;</span><br><span class="line">        <span class="keyword">return</span> n&gt;=<span class="number">0</span>?quickMul_recursion(x,n):<span class="number">1</span>/quickMul_recursion(x,-N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">quickMul_recursion</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">long</span> <span class="keyword">long</span> n)</span></span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> y=quickMul_recursion(x,n/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> n%<span class="number">2</span>==<span class="number">1</span>?y*y*x:y*y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">quickMul</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">long</span> <span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> x_exp=x;</span><br><span class="line">        <span class="keyword">double</span> ans=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>) ans*=x_exp;</span><br><span class="line">            x_exp*=x_exp;</span><br><span class="line">            n/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="排序链表">排序链表<a class="anchor" href="#排序链表">·</a></h3><p>$O(n\lg n)$ 时间复杂度与常数空间复杂度情况下完成链表排序</p><p>分治算法，先拆分再合并，类似归并排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* odd=<span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* even=<span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* podd=<span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* peven=<span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* p=head;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//先将原链表拆分成奇数位置链表和偶数位置链表两个链表</span></span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!even) even=p;</span><br><span class="line">                <span class="keyword">else</span> peven-&gt;next=p;</span><br><span class="line">                peven=p;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(!odd) odd=p;</span><br><span class="line">                <span class="keyword">else</span> podd-&gt;next=p;</span><br><span class="line">                podd=p;</span><br><span class="line">            &#125;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(podd) podd-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(peven) peven-&gt;next=<span class="literal">nullptr</span>; <span class="comment">//此处不能忘记把当前的指针的下一个设为NULL，否则会一直循环</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;=<span class="number">1</span>) <span class="keyword">return</span> head; <span class="comment">//长度小于等于1时直接返回原指针</span></span><br><span class="line">        <span class="comment">//合并sort后的奇数子表和偶数子表</span></span><br><span class="line">        <span class="keyword">return</span> mergeNode(sortList(even),sortList(odd));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeNode</span><span class="params">(ListNode* p,ListNode* q)</span></span>&#123;</span><br><span class="line">        ListNode* ans=<span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(p||q)&#123; <span class="comment">//比较两个头指针，每次将小的加入到答案链表中</span></span><br><span class="line">            <span class="keyword">if</span>(!q||(p&amp;&amp;(p-&gt;val&lt;q-&gt;val)))&#123;</span><br><span class="line">                <span class="keyword">if</span>(!ans) ans=p;</span><br><span class="line">                <span class="keyword">else</span> cur-&gt;next=p;</span><br><span class="line">                cur=p;</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(!ans) ans=q;</span><br><span class="line">                <span class="keyword">else</span> cur-&gt;next=q;</span><br><span class="line">                cur=q;</span><br><span class="line">                q=q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        cur-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="数组中出现次数超过一半的数字">数组中出现次数超过一半的数字<a class="anchor" href="#数组中出现次数超过一半的数字">·</a></h3><p>分治：子问题为在子数组中出现次数超过一半的数，最后将左右两个子数组的结果合并</p><p>贪心：摩尔投票，利用抵消的方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//my code</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; num2cnt;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            num2cnt[nums[i]]++;</span><br><span class="line">            <span class="keyword">if</span>(num2cnt[nums[i]]&gt;n/<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//贪心 摩尔投票法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> m=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==n) cnt++;<span class="comment">//相同，次数++</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt==<span class="number">0</span>)&#123; <span class="comment">//不相同 若已经到了0，则更换答案，没到0就--</span></span><br><span class="line">                    n=nums[i];</span><br><span class="line">                    cnt=<span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="十一、常用排序算法">十一、常用排序算法<a class="anchor" href="#十一、常用排序算法">·</a></h2><p>冒泡排序，归并排序，快速排序，桶排序，堆排序</p><h3 id="对角线遍历-II">对角线遍历 II<a class="anchor" href="#对角线遍历-II">·</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> s;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">    &#125;Node; <span class="comment">//s=x+y </span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node x,Node y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.s&lt;y.s?<span class="literal">true</span>:</span><br><span class="line">               x.s&gt;y.s?<span class="literal">false</span>:</span><br><span class="line">               x.y&lt;y.y?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findDiagonalOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node&gt; tmp;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                tmp.push_back(&#123;i+j,j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(tmp.<span class="built_in">begin</span>(),tmp.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:tmp)&#123;</span><br><span class="line">            ans.push_back(nums[x.s-x.y][x.y]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最大间距">最大间距<a class="anchor" href="#最大间距">·</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maximumGap_normal(nums);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumGap_normal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123; <span class="comment">//暴力解法</span></span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>,n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,nums[i+<span class="number">1</span>]-nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumGap_Bucketsort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123; <span class="comment">//桶排序方式 这样实现比暴力还慢，不太行</span></span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minx=*min_element(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> maxx=*max_element(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>)<span class="keyword">return</span> maxx-minx; <span class="comment">//只有两个元素，返回两者最大值</span></span><br><span class="line">        <span class="keyword">int</span> d=<span class="built_in">ceil</span>((<span class="keyword">double</span>)(maxx-minx)/(n<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">if</span>(maxx==minx)<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//考虑数组全相等的情况，防止之后d=0出现错误</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">minBuc</span><span class="params">(n<span class="number">-1</span>,maxx+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxBuc</span><span class="params">(n<span class="number">-1</span>,minx<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">ap</span><span class="params">(n<span class="number">-1</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> pos=(nums[i]-minx)/d;</span><br><span class="line">            <span class="keyword">if</span>(pos&gt;=n<span class="number">-1</span>)pos=n<span class="number">-2</span>; <span class="comment">//这里要注意最大值可能会等于minx+(n-1)d 如果不设成n-2会出错</span></span><br><span class="line">            <span class="keyword">if</span>(!ap[pos])ap[pos]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(minBuc[pos]&gt;nums[i])minBuc[pos]=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(maxBuc[pos]&lt;nums[i])maxBuc[pos]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=d;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!ap[i])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> j=i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;n<span class="number">-1</span>&amp;&amp;!ap[j])j++;</span><br><span class="line">            <span class="keyword">if</span>(j==n<span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,minBuc[j]-maxBuc[i]);</span><br><span class="line">            i=j<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="有效的字母异位词">有效的字母异位词<a class="anchor" href="#有效的字母异位词">·</a></h3><p>判断两个单词的每个字母出现次数是否均一样</p><p>采用桶排序，也可以理解为使用标记数组或hash表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnts[<span class="number">26</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> cntt[<span class="number">26</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cnts[s[i]-<span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        n=t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cntt[t[i]-<span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnts[i]!=cntt[i])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="十二、Trie-树和KMP-算法">十二、Trie 树和KMP 算法<a class="anchor" href="#十二、Trie-树和KMP-算法">·</a></h2><h1 id="《labuladong算法小抄》笔记">《labuladong算法小抄》笔记<a class="anchor" href="#《labuladong算法小抄》笔记">·</a></h1><h2 id="一、语言基础">一、语言基础<a class="anchor" href="#一、语言基础">·</a></h2><h3 id="C-2">C++<a class="anchor" href="#C-2">·</a></h3><p>传参用<code>&amp;</code>表示引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;int,int&gt; p(1,2);</span><br><span class="line">cout&lt;&lt;p.first&lt;&lt;p.second;</span><br></pre></td></tr></table></figure><h4 id="1-动态数组vector">1.动态数组vector<a class="anchor" href="#1-动态数组vector">·</a></h4><p>https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html</p><p>https://www.cnblogs.com/maluning/p/8570717.html</p><h5 id="初始化">初始化<a class="anchor" href="#初始化">·</a></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n=<span class="number">7</span>,m=<span class="number">8</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>; <span class="comment">//数组中全部为0</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;; <span class="comment">//初始化为1,3,5</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(n,<span class="number">2</span>)</span></span>; <span class="comment">//初始化一个长度为n且全为2的数组</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp; <span class="comment">//初始一个二维数组</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(m,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n,<span class="literal">true</span>))</span></span>; <span class="comment">//初始一个m*n的二维布尔数组 且值全为true</span></span><br></pre></td></tr></table></figure><h5 id="成员函数">成员函数<a class="anchor" href="#成员函数">·</a></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="comment">//返回是否为空</span></span></span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span></span>; <span class="comment">//返回大小</span></span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span></span>; <span class="comment">//返回最后一个值的引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>; <span class="comment">//尾部插入一个元素val</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>; <span class="comment">//删除尾部元素</span></span><br><span class="line">erase(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator);</span><br></pre></td></tr></table></figure><h4 id="2-字符串string">2.字符串string<a class="anchor" href="#2-字符串string">·</a></h4><h5 id="初始化-2">初始化<a class="anchor" href="#初始化-2">·</a></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s; <span class="comment">//s--&gt;""</span></span><br><span class="line"><span class="built_in">string</span> s=<span class="string">"abc"</span>;</span><br></pre></td></tr></table></figure><h5 id="成员函数-2">成员函数<a class="anchor" href="#成员函数-2">·</a></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">char</span> c)</span></span>; <span class="comment">//尾部插入一个字符c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>; <span class="comment">//删除尾部字符</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">substr</span><span class="params">(<span class="keyword">size_t</span> pos,<span class="keyword">size_t</span> len)</span></span>; <span class="comment">//获得pos开始的长度为len的子串</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s1==s2; <span class="comment">//看两字符串是否相等</span></span><br></pre></td></tr></table></figure><h4 id="3-哈希表unordered-map">3.哈希表unordered_map<a class="anchor" href="#3-哈希表unordered-map">·</a></h4><h5 id="初始化-3">初始化<a class="anchor" href="#初始化-3">·</a></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mapping; <span class="comment">//key and value both int</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; mapping; <span class="comment">//key is string,value is int</span></span><br></pre></td></tr></table></figure><h5 id="成员函数-3">成员函数<a class="anchor" href="#成员函数-3">·</a></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span></span>; <span class="comment">//返回键值对个数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>;<span class="comment">//是否为空</span></span><br><span class="line"><span class="function">size_type <span class="title">count</span> <span class="params">(<span class="keyword">const</span> key_type&amp; key)</span></span>; <span class="comment">//返回key在map中出现次数,由于哈希表，这个值只能是0/1，因此本函数用于判断key是否在哈希表中</span></span><br><span class="line"><span class="function">size_type <span class="title">erase</span><span class="params">(<span class="keyword">const</span> key_type&amp; key)</span></span>; <span class="comment">//清除一个键值对</span></span><br></pre></td></tr></table></figure><h5 id="常见操作">常见操作<a class="anchor" href="#常见操作">·</a></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; counter;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">    counter[num]++; <span class="comment">//如果键值num本来不存在，则相当于是初始化为0后再+1:counter[num]=0;counter[num]++;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; it:counter)&#123;</span><br><span class="line">    <span class="keyword">int</span> key=it.first;</span><br><span class="line">    <span class="keyword">int</span> value=it.second;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;key&lt;&lt;<span class="string">":"</span>&lt;&lt;value&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-哈希集合unordered-set">4.哈希集合unordered_set<a class="anchor" href="#4-哈希集合unordered-set">·</a></h4><h5 id="初始化-4">初始化<a class="anchor" href="#初始化-4">·</a></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; visited;</span><br></pre></td></tr></table></figure><h5 id="成员函数-4">成员函数<a class="anchor" href="#成员函数-4">·</a></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span></span>; <span class="comment">//返回元素的个数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>;<span class="comment">//是否为空</span></span><br><span class="line"><span class="function">size_type <span class="title">count</span> <span class="params">(<span class="keyword">const</span> key_type&amp; key)</span></span>; <span class="comment">//类似哈希表</span></span><br><span class="line">pair&lt;iterator,bool&gt; insert(const key_type&amp; key);//插入元素</span><br><span class="line"><span class="function">size_type <span class="title">erase</span><span class="params">(<span class="keyword">const</span> key_type&amp; key)</span></span>;<span class="comment">//删除元素</span></span><br></pre></td></tr></table></figure><h4 id="5-队列queue">5.队列queue<a class="anchor" href="#5-队列queue">·</a></h4><h5 id="初始化-5">初始化<a class="anchor" href="#初始化-5">·</a></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;</span><br></pre></td></tr></table></figure><h5 id="成员函数-5">成员函数<a class="anchor" href="#成员函数-5">·</a></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span></span>; <span class="comment">//返回队列元素的个数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>;<span class="comment">//队列是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp;val)</span></span>; <span class="comment">//加入元素到队尾</span></span><br><span class="line"><span class="function">value_type&amp; <span class="title">front</span><span class="params">()</span></span>; <span class="comment">//获得队头元素引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">//删除队头元素</span></span><br><span class="line"><span class="keyword">int</span> e=q.front();q.pop(); <span class="comment">//获得队头元素并出队,注意,pop()是直接删除,不会返回队头元素</span></span><br></pre></td></tr></table></figure><h4 id="5-1双向队列deque">5.1双向队列deque<a class="anchor" href="#5-1双向队列deque">·</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> value_type&amp;val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> value_type&amp;val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">value_type&amp; <span class="title">front</span><span class="params">()</span></span>;back();</span><br></pre></td></tr></table></figure><h4 id="6-堆栈stack">6.堆栈stack<a class="anchor" href="#6-堆栈stack">·</a></h4><h5 id="初始化-6">初始化<a class="anchor" href="#初始化-6">·</a></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; stk;</span><br></pre></td></tr></table></figure><h5 id="成员函数-6">成员函数<a class="anchor" href="#成员函数-6">·</a></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span></span>; <span class="comment">//返回堆栈元素的个数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>;<span class="comment">//堆栈是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp;val)</span></span>; <span class="comment">//加入元素到栈顶</span></span><br><span class="line"><span class="function">value_type&amp; <span class="title">top</span><span class="params">()</span></span>; <span class="comment">//获得栈顶元素引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">//删除栈顶元素</span></span><br></pre></td></tr></table></figure><h3 id="Java">Java<a class="anchor" href="#Java">·</a></h3><h4 id="1-数组">1.数组<a class="anchor" href="#1-数组">·</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m=<span class="number">5</span>,n=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>[] nums=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">boolean</span>[][] visited=<span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">nums.length --&gt;获得数组长度</span><br></pre></td></tr></table></figure><h4 id="2-字符串String">2.字符串String<a class="anchor" href="#2-字符串String">·</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="string">"Hello,world"</span>;</span><br><span class="line"><span class="keyword">char</span> c=s1.charAt(<span class="number">2</span>); <span class="comment">//返回字符串中第2个字符</span></span><br><span class="line"><span class="keyword">char</span>[] chars=s1.toCharArray();  <span class="comment">//字符串转字符数组</span></span><br><span class="line">chars[<span class="number">1</span>]=<span class="string">'a'</span>;</span><br><span class="line">String s2=<span class="keyword">new</span> String(chars); <span class="comment">//字符数组转字符串</span></span><br><span class="line">System.out.println(s2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(s1.equals(s2))&#123;</span><br><span class="line">    <span class="comment">//s1==s2</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//s1!=s2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String s3=s1+<span class="string">"!"</span>; <span class="comment">//+的效率比较低</span></span><br><span class="line">StringBuilder sb=<span class="keyword">new</span> StringBuilder(); <span class="comment">//一般用StringBuilder append方法好一点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">char</span> c=<span class="string">'a'</span>;c&lt;<span class="string">'f'</span>;c++)&#123;  </span><br><span class="line">    sb.append(c);</span><br><span class="line">&#125;</span><br><span class="line">sb.append(<span class="string">'a'</span>).append(<span class="string">"avx"</span>).append(<span class="number">1234</span>) <span class="comment">//支持拼接字符串，字符，数字</span></span><br><span class="line">    </span><br><span class="line">String s=sb.toString();<span class="comment">//转为字符串类型</span></span><br><span class="line"><span class="comment">//注:字符串比较尽量用s.equals(s1),否则可能出意想不到的问题</span></span><br></pre></td></tr></table></figure><h4 id="3-动态数组ArrayList">3.动态数组ArrayList<a class="anchor" href="#3-动态数组ArrayList">·</a></h4><p>类似<code>C++</code>的<code>vector</code></p><p><code>E</code>代表元素,下同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; nums=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">ArrayList&lt;Integer&gt; strings=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>; <span class="comment">//获得数组大小</span></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>; <span class="comment">//获得index处元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>; <span class="comment">//尾部添加元素</span></span><br></pre></td></tr></table></figure><h4 id="4-双链表LinkedList">4.双链表LinkedList<a class="anchor" href="#4-双链表LinkedList">·</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;String&gt; strings=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>; <span class="comment">//获得数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>; <span class="comment">//时间复杂度为O(n),比较慢</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addFirst</span><span class="params">(E e)</span></span>; <span class="comment">//头部添加元素</span></span><br><span class="line"><span class="function">E <span class="title">removeFirst</span><span class="params">()</span></span>;<span class="comment">//delete first element</span></span><br><span class="line"><span class="function">E <span class="title">removeLast</span><span class="params">()</span></span>;<span class="comment">//delete last element</span></span><br></pre></td></tr></table></figure><h4 id="5-哈希表HashMap">5.哈希表HashMap<a class="anchor" href="#5-哈希表HashMap">·</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer,String&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">HashMap&lt;String,<span class="keyword">int</span>[]&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">//字符串到数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常用方法</span></span><br><span class="line"><span class="comment">//K代表键值，V代表类型</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span></span>; <span class="comment">//判断是否存在键key</span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(Object key)</span></span>;<span class="comment">//获得key对应value值</span></span><br><span class="line"><span class="function">V <span class="title">put</span><span class="params">(K key,V value)</span></span>; <span class="comment">//存入哈希表</span></span><br><span class="line"><span class="function">V <span class="title">remove</span><span class="params">(Object key)</span></span>; <span class="comment">//删除key并返回对应值</span></span><br><span class="line"><span class="function">V <span class="title">getOrDefault</span><span class="params">(Object key,defaultValue)</span> <span class="comment">//返回key对应value值，不存在则返回default值</span></span></span><br><span class="line"><span class="function">Set&lt;k&gt; <span class="title">keySet</span><span class="params">()</span> <span class="comment">//获得Hash表中所有key</span></span></span><br><span class="line"><span class="function">V <span class="title">putIfAbsent</span><span class="params">(K key,V value)</span></span>;<span class="comment">//存在则不做事,不存在就插入</span></span><br></pre></td></tr></table></figure><h4 id="6-哈希集合HashSet">6.哈希集合HashSet<a class="anchor" href="#6-哈希集合HashSet">·</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">//init</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>; <span class="comment">//add an element</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>; <span class="comment">//集合是否存在元素o</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>; <span class="comment">//若o存在则删除</span></span><br></pre></td></tr></table></figure><h4 id="7-队列Queue">7.队列Queue<a class="anchor" href="#7-队列Queue">·</a></h4><p><code>Queue</code>是一个接口,初始化方式相对特别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;String&gt; q=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span></span>; <span class="comment">//返回队头元素</span></span><br><span class="line"><span class="function">E <span class="title">poll</span><span class="params">()</span></span>; <span class="comment">//删除并返回队尾元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>; <span class="comment">//将元素e插入队尾</span></span><br></pre></td></tr></table></figure><h4 id="8-堆栈Stack">8.堆栈Stack<a class="anchor" href="#8-堆栈Stack">·</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;integer&gt; s=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">push</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span></span>; <span class="comment">//返回栈顶元素</span></span><br><span class="line"><span class="function">E <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">//删除并返回栈顶元素</span></span><br></pre></td></tr></table></figure><h3 id="Python">Python<a class="anchor" href="#Python">·</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list</span><br><span class="line">tuple</span><br><span class="line">set</span><br><span class="line">dict</span><br></pre></td></tr></table></figure><h2 id><a class="anchor" href="#">·</a></h2>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据科学 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记</title>
      <link href="2021/07/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>2021/07/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="《岛上书店》">《岛上书店》<a class="anchor" href="#《岛上书店》">·</a></h2><img src="/2021/07/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/岛上书店.png" style="zoom:33%;"><p><strong>作者</strong>：加·泽文 （美）</p><p><strong>初次阅读时间</strong>：2021.7.1</p><p><strong>简述</strong>：讲述了中年鳏夫<strong>A·J费克里</strong>的故事。<strong>阿米莉娅</strong>因为到岛上书店推销书籍与他结识，初次见面两人并不投机。之后的日子里，养女<strong>玛雅</strong>的出现让本来沉浸于丧妻之痛的A·J振作起来，之后的日子里，他不仅重拾了生活的信心，还用自己的善意帮助着警察兰比亚斯找到了对阅读的兴趣，成功撮合了妻姐伊斯梅和兰比亚斯的婚姻，最终也用真诚和对书的热爱成功牵手艾米(阿米莉娅)，每个人的生活都迎来了转机。</p><h3 id="书评摘录">书评摘录<a class="anchor" href="#书评摘录">·</a></h3><p>每个人的生命中，都有着无比艰难的那一年，将人生变得美好而辽阔</p><p>岛上书店是间维多利亚风格的小屋，门廊上挂着褪色的招牌，上面写着：<strong>没有谁是一座孤岛，每本书都是一个世界</strong></p><p>《岛上书店》写的是书店老板的一生，但真正讲述的，是全人类的阅读，生活和爱。</p><p>爱与被爱的能力，付出与接受的意愿，能拯救陷于孤独绝境中的我们。</p><h3 id="语句摘录">语句摘录<a class="anchor" href="#语句摘录">·</a></h3><p>扉页：来吧，亲爱的，且让我们来相爱，趁你我尚在人世。——鲁米</p><p>尾页：我们不全是长篇小说，也不全是短篇故事，最后的最后，我们成为一部人生故事集</p><p>无人为孤岛；一书一世界</p><h3 id="亮点记录">亮点记录<a class="anchor" href="#亮点记录">·</a></h3><p>书中的书，以书名作为章节名，一共有13章，也对应了13本书</p><p>看似书名和小说情节关系不大，实则每一章都和对应书的内容有重合之处</p><h4 id="1-一根羊腿，成为了杀夫的工具——《待宰的羔羊》-罗尔德·达尔-英国作家-《詹姆斯与巨桃》-《查理与巧克力工厂》-童书创作">1.一根羊腿，成为了杀夫的工具——《待宰的羔羊》 罗尔德·达尔 英国作家 《詹姆斯与巨桃》 《查理与巧克力工厂》 童书创作<a class="anchor" href="#1-一根羊腿，成为了杀夫的工具——《待宰的羔羊》-罗尔德·达尔-英国作家-《詹姆斯与巨桃》-《查理与巧克力工厂》-童书创作">·</a></h4><p>主人公刚刚经历了丧气的痛苦，就像只待宰的羔羊，无情的被生活所摧残</p><h4 id="2-钻石制作的小镇里每个人的故事——《像里兹饭店那样大的钻石》菲茨杰拉德">2.钻石制作的小镇里每个人的故事——《像里兹饭店那样大的钻石》菲茨杰拉德<a class="anchor" href="#2-钻石制作的小镇里每个人的故事——《像里兹饭店那样大的钻石》菲茨杰拉德">·</a></h4><p>主要讲述了艾丽丝岛每个人的大致情况</p><h4 id="3-采矿营里收养了一个印第安人宝宝——《咆哮营里的幸运儿》-布莱特·哈特">3.采矿营里收养了一个印第安人宝宝——《咆哮营里的幸运儿》 布莱特·哈特<a class="anchor" href="#3-采矿营里收养了一个印第安人宝宝——《咆哮营里的幸运儿》-布莱特·哈特">·</a></h4><p>玛雅被遗落在书店里，AJ开始了父亲之旅</p><h4 id="4-和爷爷一起生活的胖女孩参加体操训练，并去表演——《世界的感觉》理查德·鲍什">4.和爷爷一起生活的胖女孩参加体操训练，并去表演——《世界的感觉》理查德·鲍什<a class="anchor" href="#4-和爷爷一起生活的胖女孩参加体操训练，并去表演——《世界的感觉》理查德·鲍什">·</a></h4><p>AJ与可爱女儿的亲情故事</p><h4 id="5-全家出游出了岔子——《好人难寻》-弗兰纳里·奥康纳">5.全家出游出了岔子——《好人难寻》 弗兰纳里·奥康纳<a class="anchor" href="#5-全家出游出了岔子——《好人难寻》-弗兰纳里·奥康纳">·</a></h4><p>AJ开始追求阿米莉娅</p><p>意趣相投是多么重要</p><p>关于政治，上帝和爱，人们都讲些无聊的谎话。想要了解一个人，你只需要问一个问题：“你最喜欢哪本书？”</p><h4 id="6-嗜赌之人与其被打败的青蛙——《卡拉维拉县驰名的跳蛙》-马克吐温">6.嗜赌之人与其被打败的青蛙——《卡拉维拉县驰名的跳蛙》 马克吐温<a class="anchor" href="#6-嗜赌之人与其被打败的青蛙——《卡拉维拉县驰名的跳蛙》-马克吐温">·</a></h4><p>AJ和艾米结婚了</p><p>吐温信笔书写的文字，他自己比读者更快乐</p><h4 id="7-《穿夏裙的女孩》-欧文·肖">7.《穿夏裙的女孩》 欧文·肖<a class="anchor" href="#7-《穿夏裙的女孩》-欧文·肖">·</a></h4><p>兰比亚斯开始喜欢伊斯梅，丹尼尔在车祸中去世，在自己小说中的描写里离去。这个穿夏裙的女孩，指当年的玛丽安，现在的伊斯梅，也指一切正在追求美好爱情的姑娘们。</p><p>要是有谁觉得你在一屋子人中是独一无二的，就选那个人吧！</p><h4 id="8-垂死的父亲和女儿争论何为讲故事的最佳方式——《与父亲的对话》-格雷斯·佩利">8.垂死的父亲和女儿争论何为讲故事的最佳方式——《与父亲的对话》  格雷斯·佩利<a class="anchor" href="#8-垂死的父亲和女儿争论何为讲故事的最佳方式——《与父亲的对话》-格雷斯·佩利">·</a></h4><p>玛雅的创意写作过程</p><h4 id="9-《逮香蕉鱼的最佳日子》——-J·D塞林格">9.《逮香蕉鱼的最佳日子》—— J·D塞林格<a class="anchor" href="#9-《逮香蕉鱼的最佳日子》——-J·D塞林格">·</a></h4><p>《海滩一日》还原了玛雅母亲玛丽安的遭遇，平淡温和的笔触中，蕴含着巨大的悲怆感</p><h4 id="10-《泄密的心》——埃德加·爱伦·坡">10.《泄密的心》——埃德加·爱伦·坡<a class="anchor" href="#10-《泄密的心》——埃德加·爱伦·坡">·</a></h4><p>兰比亚斯知道了当年那本《帖木尔》在伊斯梅这。</p><h4 id="11-《铁头》——艾梅·本德">11.《铁头》——艾梅·本德<a class="anchor" href="#11-《铁头》——艾梅·本德">·</a></h4><p>AJ看病发现了自己的肿瘤</p><h4 id="12-《当我们在谈论爱情时我们在谈论什么》——雷蒙德·卡佛">12.《当我们在谈论爱情时我们在谈论什么》——雷蒙德·卡佛<a class="anchor" href="#12-《当我们在谈论爱情时我们在谈论什么》——雷蒙德·卡佛">·</a></h4><p>作家无法真正描写一间病房，尤其是当你所爱之人住在里面。</p><p>我们写我们不喜爱、讨厌、承认有缺点的事物，要比写我们喜爱的事物容易的多。</p><h4 id="13-《书店老板》——罗尔德·达尔">13.《书店老板》——罗尔德·达尔<a class="anchor" href="#13-《书店老板》——罗尔德·达尔">·</a></h4><p>书店老板的意义何在呢？跟人沟通</p><h2 id="《杀死一只知更鸟》">《杀死一只知更鸟》<a class="anchor" href="#《杀死一只知更鸟》">·</a></h2><img src="/2021/07/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/杀死一只知更鸟.jpeg" style="zoom:50%;"><p>作者：哈珀·李 （美）</p><h3 id="语句摘录-2">语句摘录<a class="anchor" href="#语句摘录-2">·</a></h3><p>第一部</p><p>“这并不恶劣啊，只是刺激它一下罢了——又不是把它扔到火堆里。”杰姆愤愤不平地咕哝道。“你怎么知道火柴不会伤着它？”“傻瓜，乌龟感觉不到疼。”“哈！你当过乌龟？”</p><p>那座老房子丝毫未变，还是一副没精打采的样子，但是当我们隔着街道凝望着它，似乎看到里面的百叶窗动了一下。飞快的一闪。那么轻微，几乎让人察觉不到，然后整座房子又归于死寂。</p><p>第二章</p><p>九月初，迪尔离开我们，回默里迪恩去了。我们送他上了五点钟的长途汽车。没有了他，我有些闷闷不乐，幸好想起再过一个星期我就要上学了。我还从来没有这么急切地盼望过什么。冬天，我经常在树屋里一待就是好几个钟头，往学校操场张望，用杰姆给我的双倍望远镜悄悄观察那一大群孩子，偷学他们正在玩的游戏；有时候他们围成一个个圆圈玩“摸人”游戏，我就在那扭来扭去的一个个圆圈里追踪杰姆的红夹克，暗自分享他们的坏运气和小小的胜利。我渴望加入到他们中间。 开学第一天，杰姆屈尊带我去学校——一般来说，这是父母亲的职责，可是阿迪克斯说，杰姆很乐意把我送到教室里。我猜想，在这桩交易中，肯定有钱在他们两人之间秘密转手，因为当我们小跑着经过拉德利家附近的拐角时，我听见杰姆的口袋里发出一种奇怪的叮当声。快到校园的时候，我们慢下了脚步，杰姆不厌其烦地向我做交代：在学校期间，我不能去打扰他，不能找他一起扮演一段《人猿泰山与蚁人》，不能提起他的私生活让他感到尴尬，也不能在课间和中午休息的时候像尾巴一样跟在他身后；我必须和一年级学生待在一起，而他必须和五年级学生待在一起。总而言之，我绝对不能去找他。 “你的意思是，我们俩再也不能一起玩了吗？”我问。 “在家里我们还照常一起玩，”他说，“可学校完全是另一回事儿——你会明白的。” 果不其然。第一天上午还没结束，我们的老师卡罗琳·费希尔小姐就把我揪到教室前面，用一把尺子打了我的手掌心，还让我站在墙角，一直到中午。 卡罗琳小姐顶多才二十一岁。她长着一头光滑的红褐色头发，脸颊白里透红，指甲涂成了深红色。她脚踩高跟鞋，身穿一条红白条纹的裙子，不论是看上去还是闻起来都像一颗薄荷糖。她寄宿在我们家斜对面的莫迪·阿特金森小姐家，住的是楼上的正房。莫迪小姐第一次把我们介绍给她的时候，杰姆一连好几天都像是在云里雾里。 卡罗琳小姐用印刷体把自己的名字写在黑板上，说：“这是我的名字：卡罗琳·费希尔。我来自北亚拉巴马州的温斯顿县。”教室里立刻响起了一阵不安的嘀嘀咕咕声，因为大家担心她将来会暴露出与生俱来的地域特征。（亚拉巴马州于一八六一年一月十一日宣布脱离联邦政府的时候，温斯顿县也从亚拉巴马州脱离了出去——这在梅科姆是每个孩子都知道的事实。）</p><p>第三章</p><p>你永远也不可能真正了解一个人，除非你站在他的角度考虑问题……”</p><p>第七章</p><p>去掉那些形容词，剩下的就是事实了。</p><p>第十章</p><p>我本以为疯狗都是口吐白沫，上蹿下跳，见人就扑上去撕咬喉咙，而且还以为只有在八月份疯狗才会发作。如果蒂姆·约翰逊也是那样的话，我可能就不会这么害怕了。</p><p>空荡荡的街道上，人们心惊胆战地等待危险来临——没有什么比这更要命的了。树木纹丝不动，知更鸟静默无声，给莫迪小姐盖房子的木工也都四散而去。我听见泰特先生吸了几下鼻子，又擤了擤鼻子。我看见他把枪换了个位置，夹在臂弯里。我看见斯蒂芬妮小姐把脸贴在她家前门的玻璃上，莫迪小姐也冒了出来，站在她身旁。阿迪克斯把一只脚踏在椅子的横档上，手放在大腿外侧，慢慢向下摩挲。</p><p>第十一章</p><p>空气中已经有了一丝夏天的气息——背阴的地方还有些凉意，但是太阳已经暖洋洋的了，这意味着好时光即将到来：暑假，还有迪尔。</p><p>我在接受他人之前，首先要接受自己。有一种东西不能遵循从众原则，那就是人的良心。</p><p>勇敢就是，在你还没开始的时候就知道自己注定会输，但依然义无反顾地去做，并且不管发生什么都坚持到底。一个人很少能赢，但也总会有赢的时候。杜博斯太太赢了，全凭她那九十八磅重的身躯。用她的话来说，她死得无牵无挂，不亏欠任何人，也不依赖任何东西。她是我见过的最勇敢的人。”</p><p>第二部</p><p>“一个人没必要把自己懂的东西都展现出来。这不是淑女的做派——再说了，人们不喜欢他们身边有什么人比他们懂得多。这会让他们气不打一处来。你使用的语言再标准，也改变不了他们。除非他们自己想学，否则一点儿办法也没有。你要么闭上嘴巴，要么跟他们说一样的话。”</p><p>第十三章</p><p>我说自己非常高兴，其实这是个谎言，可是在特定情况下，还有在无能为力的时候，人不得不撒谎。</p><p>我不明白她为什么对遗传这么痴迷。我也不知道自己从哪儿得来这样一个印象：“优秀的人”就是凭自己的心智尽力而为的人，而姑姑半遮半掩地表达过她的观点，那就是——一个家族守在一块土地上的时间越长，这个家族就越优秀。“照这么来说，尤厄尔家算是优秀人等啰。”杰姆说道。</p><p>第十五章</p><p>“你真是这么认为的吗？”这是一句杀伤力极强的问话。</p><p>阿迪克斯开着这辆车出差，跑过不少路，不过他每天上下班，来回四趟，加起来差不多有两英里，都是走路往返。他说走路是他唯一的运动。在梅科姆，要是某个人毫无目的地在路上行走，那么就可以准确无误地断定这个人的脑子不是很清楚。</p><p>阿迪克斯说过，与人交谈的礼貌做法是谈论对方感兴趣的事情，而不是大谈特谈自己的兴趣点。</p><p>第十六章</p><p>那场面真像是过节。公共拴马栏里已经挤得满满当当，每棵树下都拴着骡子和大车。县政府大楼所在的广场上到处都是坐在报纸上就餐的人。有的正就着罐头瓶里装的热牛奶吞下糖浆饼，还有的在大啃冷鸡肉和炸猪排。手头宽裕一点儿的人从杂货店里买来装在大肚饮料瓶里的可口可乐，边吃边喝。满脸油渍的孩子们在人群里窜来窜去，玩“抽鞭子”游戏，婴儿们在母亲怀里吃他们的午饭。在广场远处的一个角落里，黑人们静静地坐在太阳底下，嚼着沙丁鱼和饼干，喝着味道更冲的“尼海”可乐[插图]。多尔夫斯·雷蒙德先生也和他们坐在一起。</p><p>他当然不是，河对岸的所有土地都是属于他的，还有一点我要告诉你，他出身于一个真正的世家。”</p><p>哇，当然愿意。”杰姆答道。我们兴高采烈地跑在塞克斯牧师前面冲进了法庭，又上了一段后楼梯，然后停在门口等着。塞克斯牧师气喘吁吁地赶了上来，小心地引导我们穿过看台上的黑人观众。有四个黑人主动站起来，把他们的前排座位让给了我们。</p><p>地方检察官面前的桌子上摆放着一本褐色的书，还有几本黄色笔记簿；阿迪克斯的桌上空空如也。</p><p>第十七章</p><p>他是个秃顶，脸颊光溜溜的，年龄呢，可以是四十到六十之间的任何一个数字。虽然他此时背对着我们，我们也知道他有一只眼睛略微有点儿斜视，不过他把这个缺陷转化成了自己的优势：有时候他似乎在盯着某个人，但实际上全无此意，就因为这个，陪审员和证人都畏惧他三分。陪审员们以为自己正处在密切监视之下，会更加专心致志；证人们也一样，因为他们也有同样的错觉。</p><p>第十八章</p><p>“阿迪克斯，我们继续吧，法庭记录上要写明证人没有受到无礼对待，她的想法和事实恰恰相反。”</p><p>我心里暗想，她长这么大，有人用“女士”或者“马耶拉小姐”称呼过她吗？估计从来没有过，因为她把日常礼仪都当成了一种冒犯。她究竟过着什么样的生活呢？这个问题很快就有了答案。</p><p>慢慢地，阿迪克斯问这些问题的意图越来越清晰地显现在我头脑中：通过问一些不会让吉尔莫先生认为与本案无关或者微不足道而提出反对的问题，阿迪克斯不露声色地在陪审团面前勾勒出一幅尤厄尔家家庭生活的图景。陪审团了解到如下情况</p><p>马耶拉的敌对情绪本来已经平息了许多，变成了默默的怨恨，这下子又爆发了。“芬奇先生，你又在取笑我吗？”</p><p>第十九章</p><p>“我才不管呢。反正那样做不对，不应该用那种态度对待他们。谁也没有权利用那种口气对人说话——简直让人恶心透了。”</p><p>第二十章</p><p>我们又朝楼下望去。阿迪克斯正讲得如行云流水一般，带着一种超然物外的态度，跟他口授信件的时候一样。他在陪审团面前慢慢地来回踱步，而那些陪审团成员似乎在全神贯注地倾听：他们仰着头，目光始终追随着阿迪克斯，眼睛里仿佛流露出欣赏的神情。我猜，这是因为阿迪克斯从不慷慨激昂地大吼大叫。阿迪克斯</p><p>托马斯·杰斐逊曾经说过，人人生而平等</p><p>我能想到的最可笑的例子，是那些公共教育管理者，他们让愚笨懒惰的学生和聪明勤奋的学生一样升学，因为‘人人生而平等’，教育者们还会郑重其事地告诉你，留级的孩子会产生强烈的自卑感。我们都知道，某些人灌输给我们的‘人人生而平等’，实际上是个谬论——事实上，有些人就是比别人聪明睿智，有些人就是比别人享有更多的机会，因为他们生来如此，有些男人比别的男人挣钱多，有些女士做的蛋糕比别的女士更胜一筹——总而言之，有些人天生就比大多数普通人具有更高的天赋和才华。</p><p>第二十三章</p><p>在我们生活的这个世界上，总有什么东西让人丧失理智——即使他们努力想做到公平，结果还是事与愿违。</p><p>一个白人只要对黑人做了这种伤天害理的事情，不管他是什么人，不管他多么富有，也不管他出身多么高贵，这个白人就是人渣。</p><p>这个世界上最让我厌恶的事情，莫过于下等白人利用黑人的单纯无知欺骗他们。休要自欺欺人——这些行为一天一天积累起来，我们早晚要为此付出代价。我希望不是你们这一代去偿还。</p><p>你可以把沃尔特·坎宁安从头到脚洗得一尘不染，你可以给他穿上鞋子和新衣服，但他举手投足永远也不会跟杰姆一样。</p><p>芬奇家的女孩子对那种人没有半点儿兴趣。”“姑——姑，”杰姆说，“她还不到九岁呢。”</p><p>我脑子里充满了好奇和兴趣，想到她家去做客，瞧瞧她是怎么生活的，有些什么样的朋友。要说起来，我还想看看月亮的背面是什么样子呢！</p><p>兴许她当初来和我们住在一起的原因，就是为了帮助我们拣选朋友。</p><p>我并没有说你不能向他表示友好啊。你应该友好、礼貌地对待他。亲爱的，你应该对所有人都彬彬有礼。但是，你没必要请他到家里来。</p><p>阿迪克斯说过，你可以选择自己的朋友，但你不能选择自己的家人，所以不管你是否承认，他们都和你有血缘关系，而且不承认事实会让你显得很愚蠢。”</p><p>因——为——他——是——渣——滓</p><p>一种是像我们和街坊邻居这样的普通人，一种是跟坎宁安家一样住在林子里的人，一种是像尤厄尔家一样生活在垃圾场旁边的人，还有一种是黑人。”</p><p>第二十四章</p><p>我还是在父亲的世界里感觉更自在</p><p>在一个律师家庭里，你学到的第一点就是，凡事无定论。芬奇先生在没有十分把握之前，不能那样随便乱说。”</p><p>第二十五章</p><p>阿迪克斯拿出一个自由人所能采取的一切手段来拯救汤姆·鲁宾逊，但在人们内心深处的秘密法庭里，根本就没有什么诉讼可言。从马耶拉·尤厄尔开口叫嚷的那一刻起，汤姆就是死路一条。</p><p>第二十六章</p><p>我们每周有一节时事讲评课，要求每个孩子从报纸上剪下一则新闻，把内容记得烂熟于心，然后讲给全班同学听。据说这个做法能帮助孩子们克服种种缺点：站在自己的同学面前发言，可以促使一个孩子做到身姿挺拔，镇定自若；做一个简短的演讲能培养孩子有意识地遣词造句；记诵时事新闻能提高孩子的记忆力；被单独拉出来完成一件事儿还会让孩子更渴望回到集体中去。</p><p>第二十八章</p><p>“不想，我要穿着。”我说。这身行头起码能掩盖我的满面羞愧。“你们想搭车回家吗？”有人问道。“不用了，谢谢您，先生。”杰姆说，“我们只有一小段路。”“当心鬼魂啊，”那个声音戏谑道，“更要紧的是，要警告那些鬼魂当心斯库特。”</p><p>杰姆说，“过来，斯库特，让我扶着你这个——大火腿。你可别失去平衡一头栽倒。”“我能看清路。”“好吧，不过你有可能会失去平衡啊。”我感到头上微微有点儿发紧，猜想杰姆大概已经抓住了火腿的顶端。“你抓住我了？”“哦，嗯。”</p><p>夜静得出奇。我都能清清楚楚地听见身边传来杰姆的呼吸声。偶尔会有一阵小风倏地掠过，吹在我的光腿上，不过这只是预报中所说的大风夜甩下的小尾巴。这是暴风雨来临之前的沉寂。我们屏息凝神。</p><p>我说这话更多的是为了让自己安心，而不是为了说服杰姆，因为我们刚一迈开步子往前走，我也听到了他所说的沙沙声。那分明不是我的演出服发出来的。</p><p>亚历山德拉姑姑把紧箍在我身上的布片和铁丝网一点点拉开，我发现她的手指都在哆嗦。“亲爱的，你没事儿吧？”她一边费劲儿地把我解脱出来，一边问了一遍又一遍。</p><p>第二十九章</p><p>如果我们一直被感觉牵着鼻子走，就会像猫一样追着自己的尾巴转圈子。</p><p>第三十章</p><p>“如果我们掩盖了事情的真相，那就等于完全违背了我一直以来教育杰姆如何做人的原则。有时候，我觉得自己作为一个父亲很失败，简直一无是处，可我就是他们所拥有的全部。在这个世界上，杰姆最先看的人是我，然后才去看别人，我一直努力让自己活得堂堂正正，能够直视他的目光……如果我默许这种事情发生，坦率地说，我从此以后再也无法坦然面对他的眼睛，如果是这样的话，我就知道自己已经永远失去了他。我不想失去他和斯库特，因为他们是我的一切。”</p><p>第三十一章</p><p>你永远也不可能真正了解一个人，除非你穿上他的鞋子走来走去，站在他的角度考虑问题。</p><p>“斯库特，大多数人都是善良的，等你最终了解他们之后就会发现</p>]]></content>
      
      
      <categories>
          
          <category> Life Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OO-Unit4小结及课程总结</title>
      <link href="2021/06/26/OO-Unit4%E5%B0%8F%E7%BB%93%E5%8F%8A%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
      <url>2021/06/26/OO-Unit4%E5%B0%8F%E7%BB%93%E5%8F%8A%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="OO-Unit4小结-课程总结">OO-Unit4小结&amp;课程总结<a class="anchor" href="#OO-Unit4小结-课程总结">·</a></h1><p>终于迎来了OO的终章——UML解析器编写。今天还刚好是考完航概的烤漆最后一天，在这样的日子里来写这篇博客自然要放松点啦，这篇就把这学期的一些体会感悟都好好记录一下，算是对艰苦奋战“<strong>昆仑课程</strong>”一学期的完美留念。</p><h2 id="本单元作业架构设计">本单元作业架构设计<a class="anchor" href="#本单元作业架构设计">·</a></h2><p>本单元需要对各个<code>UML</code>类进行解析建模。官方包已经提供了对于特定的<code>json</code>数据的输出处理以及相应的官方<code>Uml</code>的一些基本类，但是这些考虑到基本类只包含了<code>id name</code>等基本属性，而缺少某些<code>Uml</code>类的重要数据属性，因此需要对每次作业中一些涉及到评测的类进行单独的<strong>自定义类建模</strong>，与此同时在初始化中也需要加入的中间变量或容器对这些自定义类进行初始化。这一单元的架构大体上是将初始化过程，主类的各个评测函数，以及各个需要用到的自定义类进行分块包装，最终组合起来形成<code>Uml</code>解析器。</p><p>本单元经历了充分的测试，终于是第一次AK了，虽然很大程度上还是要感谢ch大佬的数据支持，感觉应该给他专门颁发一个特殊的奖才能感谢他帮我们找出的这么多bug！</p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit4/hw13.png" style="zoom:50%;"><p>第一次作业的要求相对简单，是对类图的解析。于是大体上在主类里实现了<code>init</code>函数，各个具体的返回值函数，以及建立了有必要的<code>MyClass</code>、<code>MyInterface</code>、<code>MyOperation</code>三个类，这三个自定义类里包含了有用的各种内部属性和方法。其中<code>MyClass</code>引用了其他两个类，而这三个类在<code>MyUmlInteraction</code>都有相应的引用。</p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit4/hw14.png" alt="hw14" style="zoom: 25%;"><p>第二次作业在第一次作业基础上实现了对时序图和状态转移图的解析。在第一次基础上新增了<code>MyInteraction</code>和<code>MyStateMachine</code>两个自定义类对新增的两种图的数据和方法进行实现。</p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit4/hw15.png" alt="hw15" style="zoom: 25%;"><p>第三次作业新增了一个<code>init</code>类对开始的初始化操作和初始化变量进行操作从而减少主功能类的行数，代码架构更合理，每个类的功能更独立。</p><h2 id="四个单元中架构设计及OO方法理解的演进">四个单元中架构设计及OO方法理解的演进<a class="anchor" href="#四个单元中架构设计及OO方法理解的演进">·</a></h2><p>四次作业中唯一的一次重构就发生在第一单元的求导计算的1-2次作业中，由于没有想到之后的第二三次作业的改动力度之大且刚开始面向对象，没有那么好的封装思路。之后的三个单元均是在之前架构基础上微调或者增量开发。</p><p>第一次作业中对于对于三角函数，多项式，项等各个部分进行单独的封装，同时对各个求导规则和方法进行单独的封装，体现了层次化结构化的思想。</p><p>第二次作业中对于多线程的原理和应用进行了学习和实践，学习了生产者消费者模式和worker-threads模式。采用了集中式调度，调度器和输入线程为一对生产者消费者，调度器和各个电梯间也形成了生产者消费者关系。</p><p>第三单元了解了JML规格编写和阅读方法，知道了如何用形式化的语言来描述和检查代码。这一单元的代码架构固定，只建立了个别必要的图管理类。</p><p>第四单元了解了UML可视化代码规格方式，知道了如何形象的对代码从类图，代码时序动态图，状态图等方面进行描述。建立了抽象分离初始化，具体功能类，返回函数主类三个层次的体系。</p><h2 id="四个单元中测试理解与实践的演进">四个单元中测试理解与实践的演进<a class="anchor" href="#四个单元中测试理解与实践的演进">·</a></h2><p>四个单元的学习过程中，评测机不断扩充完善。造数据和<code>debug</code>能力也不断增强。总的来说的方法还是三个，形式验证（比对指导书需求，看代码），黑盒测试（与他人或标答对拍），白盒测试。</p><p>第一单元主要采用了<code>xeger</code>根据正则表达式生成一定强度的数据，以及递归下降构造数据的方式。然后利用<code>sympy</code>库计算结果或化简表达式进行对拍和评测的方式。</p><p>第二单元由于事情繁多，只完成了基本的导出结果的功能。投放数据采用<code>subprocess</code>库来完成。这一单元主要是合理利用强测数据，多尝试，多跑点，就能找出很多bug。</p><p>第三单元采用<code>Junit</code>白盒单元测试和黑盒测试相结合，针对每次作业的核心耗时算法构造出相应的数据点进行性能测试，构造长随机指令覆盖用例对正确性进行测试。</p><p>第四单元和第三单元类似，也是单元测试+黑盒测试结合的方式，而针对这次作业的特点，我采用了手动<code>Uml</code>图并实现<code>利用官方包的命令自动导出相应的json数据-&gt;解析json数据-&gt;自动构造这个图能够出现的所有指令-&gt;组合成一个数据</code>，总的来说就是物尽其用的思想，由于没有精力实现像第三单元一样的随机生成的代码，那就只能尽可能<strong>压榨</strong>每一个<code>Uml</code>图的价值。对每一个<code>Uml</code>图都生成出所有可能出现的图模型和相应的所有指令。这样虽然不能保证图的复杂性，但是至少保证了每个数据都是这个图的最全数据。具体的效果如下图所示，对于每个图都导出了所有的模型和相应的数据，同时保存了对于每个数据点的描述方便之后<code>debug</code>。</p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit4/t1.png" style="zoom:67%;"><p>总的来说，本学期OO的评测机我的思路就是将评测分成<code>时间评测和获取输出</code>、<code>评测正确性</code>两步走的思路。前一部分向每个不同程序投喂输入数据，检测运行时间和CPU时间是否超时，并保存相应的输出结果。后一部分将每个数据的标准输出或者多人的输出进行对拍，找少数派或者直接评价正确性。</p><p>而数据构造则也分为了对于每个数据点的构造，一组数据点的构造，和具体的构造函数。大体上实现解耦。</p><p>从刚开始到最后一次的评测机，我的<code>OO-test</code>项目一直有一些新东西，这个过程是不断完善测试体验和提高测试效率的过程。以下记录一下点自认为觉得写的较好的功能。</p><ol><li><p>让<code>Pycharm</code>里的评测输出<strong>五颜六色</strong>、花哨、完整起来，丰富的颜色让测试变得有趣。还看到有的同学写了<code>GUI</code>（太神仙了），本来也想尝试但是觉得没太大必要就作罢了。还有ch大佬的丰富多样、有趣的调试信息也是值得学习的。我的输出主要包含了时间性能评测信息，对拍评测信息。如果测试对象只有两个人会显示具体哪一行不同，1/3/4单元还会显示具体是什么指令/数据的错误，最后一单元还给出了可能错误的原因。这些贴心的输出都为debug提供了极大的便利，很多时候稍微造一造数据跑出来就可以知道错误是什么原因（不过数据还是根本，还是要感谢各位大佬的数据支援）。</p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit4/t2.png" style="zoom: 80%;"></li><li><p>一个<code>test</code>搞定一切。实现了一个<code>test</code>函数，输入为一个<code>jar</code>名字列表，同时在外围实现了<code>beatTest</code>、<code>testWithOther</code>、<code>testSingle</code>、<code>init</code>等方法对单独测试，双人对拍，多人运动进行单独封装，根据名字列表长度调用相关函数做相应的测试。如下图所示。</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit4/t3.png" alt></p></li></ol><p>最后的评测机大概就这样了。基本每个单元都会有一个生成数据的代码和测试代码。</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit4/t4.png" alt></p><h2 id="课程收获">课程收获<a class="anchor" href="#课程收获">·</a></h2><p>本学期的OO课程从层次化，多线程，规格化，模型化四个方面进行了学习，知识上学习了层次化架构设计，线程安全与一般设计模式，JML结构化语言描述，UML模型。工具链上，对于<code>IDEA</code>内的各种代码分析插件以及调试插件，<code>Pycharm</code>内的一些插件，<code>StarUML</code>等有了一定的使用心得。了解了一般的面向对象的编写方式，以及从前期需求对接，到增量迭代开发、重构优化，到测试交付以及bug修复的软件开发全流程体验，这个过程中<code>Java</code>的面向对象编程能力和基于<code>Python</code>的测试能力也不断提升，对于基本的程序测试也有了一定的认知，不过需要改进的地方就是缺少了对于数据本身的强度评测，具体来说就是没有对每个分支的覆盖程度进行反馈，之后的评测中需要加入相应的代码进行更全面的测试。</p><p>另外，OO研讨课上我做了两次分享，第一次主要介绍了包括黑盒测试，白盒测试，灰盒测试和评测机架构在内的测试理论实践知识，最后一次介绍了代码注释，博客编写和课程体会，这两次研讨的PPT我都花了至少4个小时进行制作，虽然内容并不是非常硬核，但是这个过程中对于这些知识的理解确实也更到位了，也体会到了分享的乐趣，当知道真的有个别同学觉得我的讲解有一点用处时，内心还是很充实而欣慰的。同时，写博客，阅读他人博客和代码，听其他同学的研讨分享也学到了很多东西，可以说，OO这门课除了让我们打好了面向对象的基础，也让我增强了技术分享、表达和向他人学习的能力。同时，这种可以阅读、hack他人代码，几乎全透明的学习方式也让人感到耳目一新，体验极佳，启发了更多的学习方式。</p><p>此外对于每次作业还有一些小的碎碎念，在最后一次研讨课我也分享了一下，这里偷个懒，直接搬运过来。作为补充总结。</p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit4/4.png" style="zoom: 33%;"><h2 id="对于课程的具体改进建议">对于课程的具体改进建议<a class="anchor" href="#对于课程的具体改进建议">·</a></h2><ol><li>博客环节可以适当改善。可以鼓励大家多阅读他人博客，并积极写评论进行交流。感觉一学期下来虽然写了四篇博客，但并不是所有同学都非常清楚一篇好的博客到底是什么样的以及写这个的意义和目的。可以尝试让同学进行互评，适当公开评价细则，设置自定义任务模块（比如可以让同学们写某个方面技术分享博客，根据质量给相应奖励之类，不过感觉这样又和评论区重复了）等鼓励同学们写更多的优质博客。</li><li>研讨课可以安排更多的活动，比如没有人讲的时候可以组织包括辩论赛（针对某个热点信息科技话题进行辩论），圆桌会议（讨论技术热点和未来的研究方向，头脑风暴，对于OO课内的一些技术的创新点进行讨论），甚至是翻转课堂的形式（让同学们代替老师讲授某一部分内容，减轻老师的教学压力），或者如果可爱的助教大大们愿意讲点啥课程组也不能拒绝对吧😀。</li><li>课外可以安排一些其他的任务，比如类似软院软工项目图书管理系统，飞机订票系统之类的小软件项目，可以考虑提供前后端框架代码让大家进行补全，也可以自定义题目让大家自行从0开发。让有兴趣的同学自行组队完成并进行一定的展示和加分。通过一些有实际功能的实际系统可以让大家更好地掌握面向对象知识在实际开发中的使用方式。</li><li>每次互测可以让大家评选出本房间内彼此的代码进行打分和评价，鼓励互测房内同学更好地学习彼此代码。官方也可以分享和总结一些好的代码思路，比如提供几份公认较好的架构思路供大家参考。可以让同学们写一写自己在互测中读到的好代码好在哪，学到和借鉴到了什么东西。</li><li>可以从第一次作业开始鼓励同学们写好注释，按照<code>javadoc</code>规范来写，每个单元结束时生成一份<code>javadoc</code>。而且好的注释可以帮助他人阅读自己代码，节省大家宝贵的互测时间。</li><li>完善前期的<code>java</code>先修课程，稍微增加一些对于java细枝末节知识的介绍，完善现有的教程。也可以考虑在现有的部分课程基础上加一些视频讲解之类。课程内容可以增加一些对于java的目前应用内容，比如具体的Spring后端开发，hadoop大数据分析等方面的简单讲解。</li></ol><p>最后的最后，还是感谢一起在这么多个日日夜夜一起对拍的阿强和阿勇两位舍友，以及给过我很多帮助的战哥，昊哥，lyj、lkl助教，吴老师，以及各位大佬们，没有你们，可能无数次迎接我的都是：</p><p>$\color{green} {恭喜你在强测中获得0分！}$</p><p>$\color{red} {不存在此互测成员}$</p><p>这样的消息吧！希望未来可以把学到的面向对象的知识用于实际工程中，不断提升自己OO的能力！OO课完结撒花了！！</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-OO-2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散数学3</title>
      <link href="2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/"/>
      <url>2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-导论"><a href="#第一章-导论" class="headerlink" title="第一章 导论"></a>第一章 导论</h1><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/1-1.png" style="zoom:50%;"></p><h2 id="组合数学主要学习内容"><a href="#组合数学主要学习内容" class="headerlink" title="组合数学主要学习内容"></a>组合数学主要学习内容</h2><ul><li>排列与组合（基础） </li><li>鸽巢原理（存在性） </li><li>生成排列和组合（生成算法） </li><li>二项式系数 （组合数） </li><li>容斥原理（排列数） </li><li>递推关系和生成函法（ 重要） </li><li>特殊计数序列 </li><li>图匹配、互异代表系统 </li><li>Polya 计数</li></ul><h2 id="知识图"><a href="#知识图" class="headerlink" title="知识图"></a>知识图</h2><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/1-2.png" alt></p><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/1-3.png" alt></p><h1 id="第二章-排列与组合"><a href="#第二章-排列与组合" class="headerlink" title="第二章 排列与组合"></a>第二章 排列与组合</h1><h2 id="2-1-基本计数原理"><a href="#2-1-基本计数原理" class="headerlink" title="2.1 基本计数原理"></a>2.1 基本计数原理</h2><h3 id="加法原理Addition-Principle"><a href="#加法原理Addition-Principle" class="headerlink" title="加法原理Addition Principle"></a>加法原理Addition Principle</h3><h3 id="乘法原理Multiplication-Principle"><a href="#乘法原理Multiplication-Principle" class="headerlink" title="乘法原理Multiplication Principle"></a>乘法原理Multiplication Principle</h3><h3 id="减法原理-Subtraction-Principle"><a href="#减法原理-Subtraction-Principle" class="headerlink" title="减法原理 Subtraction Principle"></a>减法原理 Subtraction Principle</h3><p>减去不符合要求的</p><h3 id="除法原理-Division-Principle"><a href="#除法原理-Division-Principle" class="headerlink" title="除法原理 Division Principle"></a>除法原理 Division Principle</h3><h2 id="2-2-集合的排列"><a href="#2-2-集合的排列" class="headerlink" title="2.2 集合的排列"></a>2.2 集合的排列</h2><h3 id="集合的线性排列"><a href="#集合的线性排列" class="headerlink" title="集合的线性排列"></a>集合的线性排列</h3><p>n元素集合的r-排列——n个元素中取出r个元素有序摆放</p><p>全部r-排列数：$P(n,r)$</p><p>当$r&gt;n$时$P(n,r)=0$</p><p>$P(n,r)=n!/(n-r)!$</p><p>$0!=1$</p><h3 id="排列P-n-r-的递推关系"><a href="#排列P-n-r-的递推关系" class="headerlink" title="排列P(n,r)的递推关系"></a>排列P(n,r)的递推关系</h3><ol><li>P(n, r)=n*P(n-1, r-1)<ul><li>分步递归 </li><li>选择1号盒子放一个球*从n-1个球中选r-1个放入r-1个盒子中</li></ul></li><li>P(n, r)=P(n-1,r)+rP(n-1,r-1) <ul><li>分类递推</li><li>不选第一个球+选了第一个球</li></ul></li></ol><h3 id="组合模型"><a href="#组合模型" class="headerlink" title="组合模型"></a>组合模型</h3><p>$C(n,r)=n!/((n-r)!*r!)$</p><p>$C(n,r)=C(n,n-r)$</p><p>$C(n,r)C(r,k)=C(n,k)C(n-k, r-k)$</p><ul><li>先选出r个班委，再选出k个常委</li><li>等价于先选出k个常委，再选出r-k个其他班委</li></ul><h3 id="集合的多种类型排列"><a href="#集合的多种类型排列" class="headerlink" title="集合的多种类型排列"></a>集合的多种类型排列</h3><h4 id="循环排列"><a href="#循环排列" class="headerlink" title="循环排列"></a>循环排列</h4><p>n个元素集合的循环r排列个数为</p><p>$\frac {P(n,r)}r = \frac {n!}{r(n-r)!}$</p><p>n元素循环排列个数：(n-1)!</p><h4 id="项链排列"><a href="#项链排列" class="headerlink" title="项链排列"></a>项链排列</h4><p>即循环排列的一半即可</p><p>$\frac {P(n,r)}{2r} = \frac {n!}{2r(n-r)!}$</p><h2 id="2-3-集合的组合"><a href="#2-3-集合的组合" class="headerlink" title="2.3 集合的组合"></a>2.3 集合的组合</h2><p>普通集合r-组合：$C(n,r)$ </p><p>$\sum_{i=1}^nC_n^i=2^n$</p><h2 id="2-4-多重集的排列"><a href="#2-4-多重集的排列" class="headerlink" title="2.4 多重集的排列"></a>2.4 多重集的排列</h2><h4 id="无限重复数"><a href="#无限重复数" class="headerlink" title="无限重复数"></a>无限重复数</h4><p>S有k种不同元素，每种元素都可以重复无限次，则S的r-排列个数为$k^r$</p><p>无限次可以放到每种元素个数都大于等于r</p><h4 id="有限重复数"><a href="#有限重复数" class="headerlink" title="有限重复数"></a>有限重复数</h4><h5 id="多重集排列"><a href="#多重集排列" class="headerlink" title="多重集排列"></a>多重集排列</h5><p>S＝{n1*a1, n2*a2,…, nk*ak}​</p><p>$n_1+n_2+..+n_k=n$</p><p>S排列数为 $\frac {n!} {n_1!n_2!…n_k!}$</p><h5 id="多重集排列的另一种解释"><a href="#多重集排列的另一种解释" class="headerlink" title="多重集排列的另一种解释"></a>多重集排列的另一种解释</h5><p>对n个元素集合划分为指定大小的多个部分(n个小球放入不同标号的若干个盒子中)</p><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/5.png" style="zoom: 50%;"></p><h2 id="2-5-多重集组合"><a href="#2-5-多重集组合" class="headerlink" title="2.5 多重集组合"></a>2.5 多重集组合</h2><p>集合S有k种不同的元素，每种元素数量无限，r-组合数量</p><h3 id="隔板法"><a href="#隔板法" class="headerlink" title="隔板法"></a>隔板法</h3><ul><li>相当于将r个元素分成k个不同区域</li><li>r个相同元素间插入k-1个隔板，分成k份</li><li>C(k+r-1，k-1) = C(k+r-1，r)  </li><li>(k-1)+r个位置取出r个位置</li></ul><h3 id="两个整数解问题"><a href="#两个整数解问题" class="headerlink" title="两个整数解问题"></a>两个整数解问题</h3><ul><li>$n_1+n_2+…+n_k=r$ 的非负整数解个数C(k+r-1, r) </li><li>$n_1+n_2+…+n_k=r$ 的正整数解个数 C(r-1, k-1)</li></ul><h1 id="第三章-鸽巢原理"><a href="#第三章-鸽巢原理" class="headerlink" title="第三章 鸽巢原理"></a>第三章 鸽巢原理</h1><p>又称为抽屉原理，狄里克雷原理</p><h2 id="3-1-鸽巢原理的简单形式"><a href="#3-1-鸽巢原理的简单形式" class="headerlink" title="3.1 鸽巢原理的简单形式"></a>3.1 鸽巢原理的简单形式</h2><p>n+1个物体放进n个盒子中，至少有一个盒子包含两个或者更多的物体</p><h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><p>令 m, n是互素的正整数，a和b分别是小于m和n的非负整数。</p><p>那么，存在正整数 x，使得 x 除以m余数为a, 且除以n余数为b，即 x＝pm+a，x =qn+b。</p><h4 id="中国剩余定理一般形式"><a href="#中国剩余定理一般形式" class="headerlink" title="中国剩余定理一般形式"></a>中国剩余定理一般形式</h4><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/3-1.png" style="zoom:50%;"></p><h3 id="连续时间型问题"><a href="#连续时间型问题" class="headerlink" title="连续时间型问题"></a>连续时间型问题</h3><blockquote><p>某学生有37天来完成一个课外科技项目，而学生需 要不超过60小时的课外时间，他还希望每天至少安排一 小时。证明：无论如何安排工作时间（每天都是整数小时）， 都存在连续的若干天，在此期间他恰好工作了13个小时。 </p></blockquote><p>设到第n天已经工作的时间为$s_n$</p><p>则$1\leq s<em>1 \leq s_2…\leq s</em>{37} \leq 60$</p><p>且$14\leq s<em>1+13 \leq s_2+13…\leq s</em>{37}+13 \leq 73$</p><p>根据鸽巢原理，上述74个数中必有$1\leq i\leq j\leq 37$，使得$s_i+13 = s_j$</p><h2 id="3-2-鸽巢原理的加强形式"><a href="#3-2-鸽巢原理的加强形式" class="headerlink" title="3.2 鸽巢原理的加强形式"></a>3.2 鸽巢原理的加强形式</h2><p>令q1, q2 , …, qn为正整数。若将q1+q2+…+qn – n+1个物体被放进n个盒子内，那么，</p><ul><li>或者第1个盒子至少含有q1个物体 </li><li>或者第2个盒子至少含有q2个物体</li><li>…</li><li>或者第n个盒子至少含有qn个物体</li></ul><h2 id="3-3-Ramsey定理"><a href="#3-3-Ramsey定理" class="headerlink" title="3.3 Ramsey定理"></a>3.3 Ramsey定理</h2><h3 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h3><p>在6个人中</p><ul><li>或者有3个人，他们中每两个人都互相认识； </li><li>或者有3个人，他们中的每两个人都彼此不认识。</li></ul><h3 id="n阶完全图"><a href="#n阶完全图" class="headerlink" title="n阶完全图"></a>n阶完全图</h3><p>上述引理可以描述为，给图K6的任意边着红、蓝色，一定存在一个红色K3或者一个蓝色K3</p><p>即K6—&gt;K3,K3</p><h3 id="Ramsey定理"><a href="#Ramsey定理" class="headerlink" title="Ramsey定理"></a>Ramsey定理</h3><p>如果m ≥ 2及n ≥ 2是两个整数，则存在正整数p，使得$K_p\rightarrow K_m，K_n$</p><h4 id="Ramsey数"><a href="#Ramsey数" class="headerlink" title="Ramsey数"></a>Ramsey数</h4><p>使$K_p\rightarrow K_m,K_n$成立的最小整数p</p><h3 id="相关结论"><a href="#相关结论" class="headerlink" title="相关结论"></a>相关结论</h3><p>$R(m,n)\leq R(m-1,n)+R(m,n-1)$</p><p>$R(n,2)=2$</p><p>$R(3,3)=6$</p><p>证明拉姆齐数 $R(3,4)=9$</p><p>知乎：<a href="https://www.zhihu.com/question/263833856" target="_blank" rel="noopener">https://www.zhihu.com/question/263833856</a></p><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/1.png" style="zoom: 67%;"></p><p>也可用分类讨论证明$r(3,4)&lt;=9$</p><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/2.jpg" style="zoom: 33%;"></p><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/3.jpg" alt="3" style="zoom:33%;"></p><p>再举反例证明不等于8</p><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/4.png" alt></p><h1 id="第四章-生成排列和组合"><a href="#第四章-生成排列和组合" class="headerlink" title="第四章 生成排列和组合"></a>第四章 生成排列和组合</h1><h2 id="4-1-生成排列"><a href="#4-1-生成排列" class="headerlink" title="4.1 生成排列"></a>4.1 生成排列</h2><h3 id="递归生成算法"><a href="#递归生成算法" class="headerlink" title="递归生成算法"></a>递归生成算法</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>先排好1~n-1的，然后再对每一种排列插入n</p><p>递归进行以上过程</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>3 1 2</p><p>1 3 2</p><p>1 2 3</p><p>3 2 1</p><p>2 3 1</p><p>2 1 3</p><h3 id="邻位对换算法"><a href="#邻位对换算法" class="headerlink" title="邻位对换算法"></a>邻位对换算法</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>生成{1, 2, …, n}的排列算法:</p><ol><li><p>初始：<img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/4-1.png" style="zoom:40%;">；</p></li><li><p>while 存在活动整数时，do</p><p>  (1) 求出最大的活动整数m<br>  (2) 交换m和其箭头指向的相邻整数的位置<br>  (3) 改变所有满足p&gt;m的整数 p 的箭头方向。</p></li><li><p>不存在活动整数时，算法结束。</p></li></ol><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p>1 2 3</p><p>1 3 2</p><p>3 1 2</p><p>3 2 1</p><p>2 3 1</p><p>2 1 3</p><h2 id="4-2-排列中的逆序"><a href="#4-2-排列中的逆序" class="headerlink" title="4.2 排列中的逆序"></a>4.2 排列中的逆序</h2><h3 id="排列的逆序"><a href="#排列的逆序" class="headerlink" title="排列的逆序"></a>排列的逆序</h3><p>令$i_1 i_2 ,…, i_n$ 是集合$\begin{Bmatrix}{1, 2, …, n}\end{Bmatrix}$的一个排列，如果$0\leq k &lt; l \leq n$, 且$i_k &gt; i_l$ , 称数对（$i_k , i_l$）是排列的一个逆序。</p><h3 id="逆序数"><a href="#逆序数" class="headerlink" title="逆序数"></a>逆序数</h3><p>逆序数$a_j$是排列中先于整数j并大于j的整数个数，度量j的反序程度。</p><h3 id="逆序列"><a href="#逆序列" class="headerlink" title="逆序列"></a>逆序列</h3><p>$a_j$表示一个排列$i_1,i_2…i_n$中数$j$的逆序数，则$a_1,a_2…a_n$为排列$i_1,i_2…i_n$的逆序列</p><p>每个逆序列满足如下条件：</p><ul><li>$\forall 1\leq i \leq n,0\leq a_i \leq n-i$ 特殊的，$i=n$时，$a_n=0$</li></ul><p>对于任意一个满足上述条件的整数序列$b_1,b_2…b_n$都存在集合$\begin{Bmatrix}{1, 2, …, n}\end{Bmatrix}$的唯一一个排列的逆序列为$b_1b_2..b_n$</p><h3 id="由一个逆序列构造一个排列"><a href="#由一个逆序列构造一个排列" class="headerlink" title="由一个逆序列构造一个排列"></a>由一个逆序列构造一个排列</h3><p><strong>从最大数开始</strong>：先把最大数写上，从大到小一个个推理位置</p><p>也可以<strong>从最小数开始</strong></p><h3 id="奇排列、偶排列"><a href="#奇排列、偶排列" class="headerlink" title="奇排列、偶排列"></a>奇排列、偶排列</h3><p>逆序个数为奇数，逆序个数为偶数</p><p>$i_1i_2…i_n$的逆序列为$b_1b_2…b_n$，$k=b_1+b_2+..+b_n$为逆序数，可以通过k次交换相邻两个数转换为$12…n$</p><h2 id="4-3-生成组合"><a href="#4-3-生成组合" class="headerlink" title="4.3 生成组合"></a>4.3 生成组合</h2><p>n元集合$\begin{Bmatrix}{x_1, x_2, …, x_n}\end{Bmatrix}$的组合与长度为n的二进制数一一对应</p><p>只需要从小到大的顺序写出$0到2^n-1$所有数的二进制形式即可</p><p>算法2：反射Gray码序生成算法</p><h2 id="4-4-生成r-组合算法"><a href="#4-4-生成r-组合算法" class="headerlink" title="4.4 生成r-组合算法"></a>4.4 生成r-组合算法</h2><h3 id="基于字典序的算法"><a href="#基于字典序的算法" class="headerlink" title="基于字典序的算法"></a>基于字典序的算法</h3><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/4-2.png" style="zoom: 67%;"></p><h1 id="第五章-二项式系数"><a href="#第五章-二项式系数" class="headerlink" title="第五章 二项式系数"></a>第五章 二项式系数</h1><h2 id="5-1-帕斯卡三角形"><a href="#5-1-帕斯卡三角形" class="headerlink" title="5.1 帕斯卡三角形"></a>5.1 帕斯卡三角形</h2><p>别称：杨辉三角、贾宪三角</p><p>Pascal公式：$C<em>n^k=C</em>{n-1}^k+C_{n-1}^{k-1}$</p><p>证明：即不包含1的k子集个数和包含1的k子集个数之和</p><h2 id="5-2-二项式定理"><a href="#5-2-二项式定理" class="headerlink" title="5.2 二项式定理"></a>5.2 二项式定理</h2><p>$(x+y)^n=\sum_{k=0}^nC_n^kx^{n-k}y^k$</p><h3 id="二项式系数其他等式"><a href="#二项式系数其他等式" class="headerlink" title="二项式系数其他等式"></a>二项式系数其他等式</h3><p>$kC<em>n^k=n*C^{k-1}</em>{n-1}$</p><p>n个人中选k人组成球队，且其中一人为队长</p><p>$2^n=\sum_{k=0}^nC_n^k$</p><p>$\sum<em>{k=0}^n(C_n^k)^2=C</em>{2n}^n$</p><p>$\sum_{k=0}^n(-1)^kC_n^k=0$</p><p>$C_n^0+C_n^2+…=C_n^1+C_n^3+…=2^{n-1}$</p><h2 id="5-3-二项式系数的单峰性"><a href="#5-3-二项式系数的单峰性" class="headerlink" title="5.3 二项式系数的单峰性"></a>5.3 二项式系数的单峰性</h2><p>n为<strong>偶数</strong></p><ul><li>$C_n^0<C_n^1<...<C_n^{\frac n 2},c_n^{\frac 2}>…&gt;C_n^{n-1}&gt;C^n_n$</C_n^1<...<C_n^{\frac></li></ul><p>n为<strong>奇数</strong></p><ul><li>$C_n^0<C_n^1<...<C_n^{\frac {n-1} 2},c_n^{\frac {n+1} 2}>…&gt;C_n^{n-1}&gt;C^n_n$</C_n^1<...<C_n^{\frac></li></ul><h3 id="Sperner定理"><a href="#Sperner定理" class="headerlink" title="Sperner定理"></a>Sperner定理</h3><p>令S是n个元素的集合, C 是S的子集的集合</p><ul><li>若C中任意两个不同的子集都存在包含关系,则称C是S的一个<strong>链</strong>。 </li><li>若C中任意一个子集都不包含在其他子集内， 即任意两个不同的子集都不存在包含关系，则 称C是S的一个<strong>反链</strong>。</li></ul><p>反链个数最多为$C_n^{\lfloor \frac n 2 \rfloor}$</p><h4 id="最大链"><a href="#最大链" class="headerlink" title="最大链"></a>最大链</h4><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/5-2.png" style="zoom:50%;"></p><h4 id="链与反链的关系"><a href="#链与反链的关系" class="headerlink" title="链与反链的关系"></a>链与反链的关系</h4><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/5-3.png" style="zoom:50%;"></p><h2 id="5-4-多项式定理"><a href="#5-4-多项式定理" class="headerlink" title="5.4 多项式定理"></a>5.4 多项式定理</h2><p>$(x_1+x_2+…+x_t)^n$</p><h4 id="多项式系数"><a href="#多项式系数" class="headerlink" title="多项式系数"></a>多项式系数</h4><p>$n_1+n_2+…+n_t=n$</p><p> <img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/5-4.png" style="zoom:67%;"></p><p> 重数分别为$n_1,n_2,…,n_t$的t种不同类型物品多重集的排列数</p><h2 id="5-5-牛顿二项式定理"><a href="#5-5-牛顿二项式定理" class="headerlink" title="5.5 牛顿二项式定理"></a>5.5 牛顿二项式定理</h2><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/5-1.png" style="zoom: 50%;"></p><h1 id="第六章-容斥原理及应用"><a href="#第六章-容斥原理及应用" class="headerlink" title="第六章 容斥原理及应用"></a>第六章 容斥原理及应用</h1><h2 id="6-1-容斥原理"><a href="#6-1-容斥原理" class="headerlink" title="6.1 容斥原理"></a>6.1 容斥原理</h2><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/6-1.png" style="zoom:50%;"></p><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/6-2.png" style="zoom:50%;"></p><h2 id="6-2-带重复的组合"><a href="#6-2-带重复的组合" class="headerlink" title="6.2 带重复的组合"></a>6.2 带重复的组合</h2><h3 id="容斥原理在多重集组合中的作用"><a href="#容斥原理在多重集组合中的作用" class="headerlink" title="容斥原理在多重集组合中的作用"></a>容斥原理在多重集组合中的作用</h3><h3 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h3><h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/6-3.png" style="zoom:50%;"></p><h4 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h4><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/6-4.png" style="zoom:50%;"></p><h2 id="6-3-错位排列"><a href="#6-3-错位排列" class="headerlink" title="6.3 错位排列"></a>6.3 错位排列</h2><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/6-5.png" style="zoom:50%;"></p><p>即<strong>每个位置i</strong>上的数字<strong>都不是i</strong>。</p><p>利用容斥原理，设i位置上数字是i为事件$A_i$</p><p>则$D_n=|\overline {A_1\cup A_2\cup…\cup A_n}|=|\overline {A_1}\cap \overline {A_2} \cap … \cap \overline {A_n}|=n!-C_n^1<em>(n-1)!+…+(-1)^nC^n_n</em>0!$</p><p>$=n!(1-\frac 1 {1!}+\frac 1 {2!}+…+(-1)^n*\frac 1 {n!})$</p><h3 id="递推关系"><a href="#递推关系" class="headerlink" title="递推关系"></a>递推关系</h3><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/6-6.png" style="zoom:50%;"></p><h2 id="6-4-带有禁止位置的排列"><a href="#6-4-带有禁止位置的排列" class="headerlink" title="6.4 带有禁止位置的排列"></a>6.4 带有禁止位置的排列</h2><p>利用容斥原理即可</p><h2 id="6-5-另一个禁止位置问题"><a href="#6-5-另一个禁止位置问题" class="headerlink" title="6.5 另一个禁止位置问题"></a>6.5 另一个禁止位置问题</h2><h2 id="6-6-莫比乌斯反演"><a href="#6-6-莫比乌斯反演" class="headerlink" title="6.6 莫比乌斯反演"></a>6.6 莫比乌斯反演</h2><h1 id="第七章-递推关系和生成函数"><a href="#第七章-递推关系和生成函数" class="headerlink" title="第七章 递推关系和生成函数"></a>第七章 递推关系和生成函数</h1><h2 id="7-1-若干数列"><a href="#7-1-若干数列" class="headerlink" title="7.1 若干数列"></a>7.1 若干数列</h2><p>等差、等比、斐波那契数列</p><h2 id="7-2-生成函数"><a href="#7-2-生成函数" class="headerlink" title="7.2 生成函数"></a>7.2 生成函数</h2><p>计算多重集组合数时使用</p><h3 id="几个常见展开式"><a href="#几个常见展开式" class="headerlink" title="几个常见展开式"></a>几个常见展开式</h3><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/7-3.png" style="zoom:50%;"></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/7-1.png" style="zoom:50%;"></p><p>一个数列确定了一个生成函数，反之，一个生成函数也可以确定一个数列</p><h3 id="利用生成函数求解带有约束的多重集的组合个数"><a href="#利用生成函数求解带有约束的多重集的组合个数" class="headerlink" title="利用生成函数求解带有约束的多重集的组合个数"></a>利用生成函数求解带有约束的多重集的组合个数</h3><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/7-2.png" style="zoom:50%;"></p><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/7-4.png" style="zoom:50%;"></p><h2 id="7-3-指数生成函数"><a href="#7-3-指数生成函数" class="headerlink" title="7.3 指数生成函数"></a>7.3 指数生成函数</h2><p>计算多重集排列数时使用</p><h3 id="展开式"><a href="#展开式" class="headerlink" title="展开式"></a>展开式</h3><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/7-5.png" style="zoom:50%;"></p><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/7-6.png" style="zoom:50%;"></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/7-7.png" style="zoom:50%;"></p><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/7-8.png" style="zoom:50%;"></p><h2 id="7-4-求解线性齐次递推关系"><a href="#7-4-求解线性齐次递推关系" class="headerlink" title="7.4 求解线性齐次递推关系"></a>7.4 求解线性齐次递推关系</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/7-9.png" style="zoom:50%;"></p><h3 id="特征方程法"><a href="#特征方程法" class="headerlink" title="特征方程法"></a>特征方程法</h3><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/7-10.png" style="zoom:50%;"></p><h2 id="7-5-非齐次递推关系"><a href="#7-5-非齐次递推关系" class="headerlink" title="7.5 非齐次递推关系"></a>7.5 非齐次递推关系</h2><h3 id="一般非齐次递推关系的通解"><a href="#一般非齐次递推关系的通解" class="headerlink" title="一般非齐次递推关系的通解"></a>一般非齐次递推关系的通解</h3><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/7-11.png" style="zoom:50%;"></p><p>即先将$b_n$抹去，算出<strong>齐次通解</strong></p><p>再用齐次通解加上<strong>非齐次特解</strong>得到通解</p><p>一般非齐次特解需要猜测一个带参数的形式并代入原表达式计算各个参数值</p><p>最后根据初始条件确定齐次通解的常系数</p><h1 id="第8章-特殊计数序列"><a href="#第8章-特殊计数序列" class="headerlink" title="第8章 特殊计数序列"></a>第8章 特殊计数序列</h1><h2 id="8-1-Catalan数"><a href="#8-1-Catalan数" class="headerlink" title="8.1 Catalan数"></a>8.1 Catalan数</h2><h3 id="Catalan数列"><a href="#Catalan数列" class="headerlink" title="Catalan数列"></a>Catalan数列</h3><p>把凸n+1多边形区域分成三角形区域的方法数</p><p>$C<em>n=\frac 1 {n+1} C</em>{2n}^n(n=0,1,2…)$</p><p>$\frac {C<em>n} {C</em>{n-1}}=\frac {4n-2} {n+1}$</p><p>$C<em>n=C_0C</em>{n-1}+C<em>1C</em>{n-2}+…+C_{n-1}C_0$</p><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/8-1.png" style="zoom:50%;"></p><h2 id="8-2-差分序列和Stirling数"><a href="#8-2-差分序列和Stirling数" class="headerlink" title="8.2 差分序列和Stirling数"></a>8.2 差分序列和Stirling数</h2><h3 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h3><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/8-2.png" style="zoom:50%;"></p><h3 id="差分递归定义"><a href="#差分递归定义" class="headerlink" title="差分递归定义"></a>差分递归定义</h3><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/8-3.png" style="zoom:50%;"></p><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/8-4.png" style="zoom:50%;"></p><p>上述结论可用于求前n项和</p><p>$\sum<em>{k=0}^n C_k^p=C</em>{n+1}^{p+1}$</p><p><img src="/2021/06/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A63/8-5.png" style="zoom: 50%;"></p><h3 id="Stirling数"><a href="#Stirling数" class="headerlink" title="Stirling数"></a>Stirling数</h3><h4 id="第一类斯特林数"><a href="#第一类斯特林数" class="headerlink" title="第一类斯特林数"></a>第一类斯特林数</h4><p>$s(p,k)$</p><p>将p个物品排成<strong>k个非空</strong>的<strong>循环排列</strong>方法数</p><p>$s(n,1)=(n-1)!(n\ge 1)$</p><p>$s(n,n-1)=C_n^2(n\ge 1)$</p><p>$若1\leq k \leq p-1,则:s(p,k)=(p-1)s(p-1,k)+s(p-1,k-1)$</p><h4 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h4><p>$S(p,k)$</p><p>把 p个元素的集合划分到 <strong>k个不可区分</strong>的盒子且<strong>没有空盒子</strong>的划分的个数</p><p>$若1\leq k \leq p-1,则:S(p,k)=kS(p-1,k)+S(p-1,k-1)$</p><h4 id="S-p-k"><a href="#S-p-k" class="headerlink" title="$S^#(p,k)$"></a>$S^#(p,k)$</h4><p>把p元素划分到k个<strong>非空</strong>、<strong>可区分</strong>的盒子 的划分数</p><h3 id="Bell数"><a href="#Bell数" class="headerlink" title="Bell数"></a>Bell数</h3><p>Bell数是将 p个元素的集合分成非空、不可区分的盒子的划分数(至少一个盒子，至多p个盒子)</p><h2 id="8-3-分拆数"><a href="#8-3-分拆数" class="headerlink" title="8.3 分拆数"></a>8.3 分拆数</h2><h3 id="整数拆分的组合含义"><a href="#整数拆分的组合含义" class="headerlink" title="整数拆分的组合含义"></a>整数拆分的组合含义</h3><p>把 $n$个无区别的球放入无区别的盒子的放法（各盒子中可放入$t$ 个球, $1≤t≤n$）</p><h3 id="分拆的表示"><a href="#分拆的表示" class="headerlink" title="分拆的表示"></a>分拆的表示</h3><p>$n=na<em>n+(n-1)a</em>{n-1}+…+2a_2+1a_1$</p><p>上述n的一个拆分记为: $\lambda=n^{a_n}…2^{a_2}1^{a_1}$</p><h3 id="分拆的几何表示-Ferrers图"><a href="#分拆的几何表示-Ferrers图" class="headerlink" title="分拆的几何表示: Ferrers图"></a>分拆的几何表示: Ferrers图</h3><p>如10的拆分3+3+2+2   $3^22^2$记为：</p><p>● ● ●</p><p>● ● ●</p><p>● ●</p><p>● ●</p><h4 id="共轭分拆"><a href="#共轭分拆" class="headerlink" title="共轭分拆"></a>共轭分拆</h4><p>分拆的矩阵的转置称为共轭分拆</p><p>上述矩阵的共轭分拆为4+4+2 即$4^22^1$</p><p>● ● ● ●</p><p>● ● ● ●</p><p>● ●</p><h4 id="自共轭分拆"><a href="#自共轭分拆" class="headerlink" title="自共轭分拆"></a>自共轭分拆</h4><p>和共轭分拆完全相同的分拆</p><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p>有3个1克砝码，2个2克砝码，2个4克砝码，问能称出几种重量？有几种方法？</p><p>$G(x)=(1+x+x^2+x^3)(1+x^2+x^4)(1+x^4+x^8)$</p><ul><li>将每个括号内的x换成对应的$x_1,x_2,x_4$再展开就可以得到具体的每个重量的称重方法</li><li>计算出来后每一项的指数就是能称出的重量</li><li>系数就是对应方法数</li></ul>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Combinatorics </tag>
            
            <tag> Discrete Mathematics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS理论课笔记-IO/磁盘管理/文件系统/安全/分布式OS</title>
      <link href="2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-2/"/>
      <url>2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-2/</url>
      
        <content type="html"><![CDATA[<h1 id="第五章-输入输出系统">第五章 输入输出系统<a class="anchor" href="#第五章-输入输出系统">·</a></h1><h2 id="5-1-I-O硬件基本原理">5.1 I/O硬件基本原理<a class="anchor" href="#5-1-I-O硬件基本原理">·</a></h2><h3 id="I-O设备分类">I/O设备分类<a class="anchor" href="#I-O设备分类">·</a></h3><p><strong>传输速度</strong>：低速中速高速</p><p><strong>信息交换单位</strong>：块设备和字符设备</p><p><strong>共享属性</strong>：独占设备，共享设备，虚拟设备</p><h2 id="5-2-I-O软件基本原理">5.2 I/O软件基本原理<a class="anchor" href="#5-2-I-O软件基本原理">·</a></h2><h3 id="I-O控制技术">I/O控制技术<a class="anchor" href="#I-O控制技术">·</a></h3><h4 id="程序控制I-O-PIO-Programmed-I-O">程序控制I/O(PIO,Programmed I/O)<a class="anchor" href="#程序控制I-O-PIO-Programmed-I-O">·</a></h4><p>轮询或查询方式IO</p><p>CPU代进程向IO模块发出指令，之后忙等，直到操作完成进程继续执行</p><h4 id="中断驱动方式-Interrupt-driven-I-O">中断驱动方式(Interrupt-driven I/O)<a class="anchor" href="#中断驱动方式-Interrupt-driven-I-O">·</a></h4><p>I/O操作结束后由设备控制器主动通知程序结束信息，不用轮询</p><p>外设数据处理时CPU不需等待，但是每输入输出一个数据CPU都要中断，浪费CPU时间</p><h4 id="直接存储访问方式-DMA-Direct-Memory-Access">直接存储访问方式(DMA, Direct Memory Access)<a class="anchor" href="#直接存储访问方式-DMA-Direct-Memory-Access">·</a></h4><p><strong>直接存储器访问</strong>方式</p><p>由一个<strong>专门的控制器</strong>完成数据从<strong>内存到设备</strong>或者<strong>设备到内存</strong>的传输工作，是数据块的传输</p><h5 id="优点-10">优点<a class="anchor" href="#优点-10">·</a></h5><ul><li>CPU只干预I/O操作的<strong>开始</strong>和<strong>结束</strong>， 而当中的数据读写过程无需CPU控制，适于<strong>高速设备</strong></li></ul><h5 id="缺点-10">缺点<a class="anchor" href="#缺点-10">·</a></h5><ul><li>数据<strong>传送的方向、存放数据的内存地址及传送数据的长度</strong>等都由CPU控制，占 用了CPU时间。</li><li><strong>每个设备</strong>占用<strong>一个</strong>DMA 控制器，当设备增加时，需要增加新的DMA 控制器</li></ul><h4 id="通道技术（Channel）">通道技术（Channel）<a class="anchor" href="#通道技术（Channel）">·</a></h4><p>与DMA几乎一样</p><p>通道是一个<strong>特殊功能的处理器</strong>，有自己的指令体系，专门负责数据输入输出的传输控制，与CPU分别使用内存，实现运算与IO的并行</p><p>执行一个通道程序可完成几组IO操作，减少了CPU干预，但费用较高</p><p>可<strong>同时控制多种设备</strong>，区别于DMA只能控制一台或少数几台同类设备</p><h3 id="缓冲技术">缓冲技术<a class="anchor" href="#缓冲技术">·</a></h3><p>匹配CPU和外设不同处理速度，减少CPU中断次数，提高并行性</p><ul><li><strong>单缓冲</strong>： 1个缓冲区，CPU外设轮流使用</li><li><strong>双缓冲</strong>： 2个缓冲区，CPU和外设可以连续处理，但要求速度相近</li><li><strong>环形缓冲</strong>：<strong>生产者—消费者</strong>问题</li></ul><h4 id="缓冲池">缓冲池<a class="anchor" href="#缓冲池">·</a></h4><p>缓冲区队列：</p><ul><li>空闲缓冲区</li><li>输入缓冲区</li><li>输出缓冲区</li></ul><h3 id="设备分配">设备分配<a class="anchor" href="#设备分配">·</a></h3><p>对进程使用外设过程的管理。</p><p><strong>两个做法</strong>：</p><ol><li>在进程间切换使用外设，如<strong>键盘</strong>和<strong>鼠标</strong>；</li><li>通过一个虚拟设备把<strong>外设与应用进程隔开</strong>，只由<strong>虚拟设备</strong>来使用设备。</li></ol><h4 id="数据结构-2">数据结构<a class="anchor" href="#数据结构-2">·</a></h4><ol><li>设备控制表  DCT 每个设备一张</li><li>控制器控制表  I/O控制器的配置和状态</li><li>通道控制表  每个通道一张</li><li>系统设备表 系统内一张 记录所有设备状态和对应的控制表入口</li></ol><h4 id="单通道IO设备系统分配">单通道IO设备系统分配<a class="anchor" href="#单通道IO设备系统分配">·</a></h4><p>一个设备对应一个控制器，一个控制器对应一个通道</p><h4 id="多通道IO系统设备分配">多通道IO系统设备分配<a class="anchor" href="#多通道IO系统设备分配">·</a></h4><p><strong>一个设备</strong>与<strong>几个控制器</strong>相连，<strong>一个控制器</strong>与<strong>几个通道</strong>相连</p><h4 id="假脱机技术SPOOLing">假脱机技术SPOOLing<a class="anchor" href="#假脱机技术SPOOLing">·</a></h4><p>把<strong>独享设备</strong>转变成具有<strong>共享特征的虚拟设备</strong>，从而提高设备利用率</p><h3 id="中断处理程序">中断处理程序<a class="anchor" href="#中断处理程序">·</a></h3><ul><li>关中断</li><li>保存现场</li><li>转入设备中断处理程序</li><li>进行中断处理</li><li>恢复被中断进程的现场</li><li>开中断</li><li>设置MMU以执行下一个进程</li></ul><h3 id="设备驱动程序">设备驱动程序<a class="anchor" href="#设备驱动程序">·</a></h3><ul><li>将抽象I/O请求转换为对物理设备的请求</li><li>检查I/O请求的合法性</li><li>初始化设备</li><li>启动设备</li><li>发出I/O命令</li><li>响应中断请求</li><li>构造通道程序</li></ul><h2 id="5-3-OS设备管理实例">5.3 OS设备管理实例<a class="anchor" href="#5-3-OS设备管理实例">·</a></h2><h1 id="第六章-磁盘存储管理">第六章 磁盘存储管理<a class="anchor" href="#第六章-磁盘存储管理">·</a></h1><h2 id="6-1-磁盘存储的工作原理">6.1 磁盘存储的工作原理<a class="anchor" href="#6-1-磁盘存储的工作原理">·</a></h2><p>温切斯特盘</p><h3 id="基本概念-3">基本概念<a class="anchor" href="#基本概念-3">·</a></h3><ul><li><strong>扇区</strong>（sector） 盘片被分成许多<strong>扇形的区域</strong></li><li><strong>磁道</strong>（track） 盘片上以盘片中心为圆心，不同半径的<strong>同心圆</strong>。</li><li><strong>柱面</strong>（cylinder) 硬盘中，不同盘片相同半径的磁道所组成的<strong>圆柱</strong>。</li><li>每个<strong>磁盘有两个面</strong>，每个面都有一个<strong>磁头</strong>(head)。</li></ul><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-2/6-1.png" style="zoom:50%;"><h3 id="磁盘的组织">磁盘的组织<a class="anchor" href="#磁盘的组织">·</a></h3><p>读一个扇区需要<strong>柱面/磁头/扇区</strong>。</p><p>一维逻辑块数组按照顺序映射到磁盘扇区</p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-2/6-2.png" style="zoom: 33%;"><h3 id="磁盘访问时间">磁盘访问时间<a class="anchor" href="#磁盘访问时间">·</a></h3><p>磁盘延迟=软件的Queue处理+Disk Service Time(寻道+旋转+传输)</p><h4 id="寻道时间">寻道时间<a class="anchor" href="#寻道时间">·</a></h4><p>磁头从当前位置移到指定磁道上所经历时间</p><p>$s:启动磁盘时间$</p><p>$m:磁头移动一条磁道所花时间$</p><p>$T_s=m*n+s$</p><h4 id="旋转延迟时间">旋转延迟时间<a class="anchor" href="#旋转延迟时间">·</a></h4><p>平均$T_r$为$50到100ms$</p><p>$T_r=1/(2r)$</p><h4 id="传输时间">传输时间<a class="anchor" href="#传输时间">·</a></h4><p>$T_t$为与磁盘进行数据交换（读出或写入）的时间</p><p>$T_t$的大小与每次所<strong>读／写的字节数</strong>b，<strong>旋转速度r</strong>以及磁道上的<strong>字节数N</strong>有关</p><p>$T_t = b/(rN)$</p><p>$b/N—需要多少转$</p><p>$r—多少转/s$</p><p>传输数据的大小 (通常是1个扇区): 512B</p><p>旋转速度：3600 RPM ~ 15000 RPM</p><p>典型的传输速度：2MB~50 MB/秒</p><h4 id="总访问时间">总访问时间<a class="anchor" href="#总访问时间">·</a></h4><p>$T_a=T_s+1/(2r)+b/(rN)$</p><h3 id="磁盘调度算法">磁盘调度算法<a class="anchor" href="#磁盘调度算法">·</a></h3><h4 id="先来先服务-FCFS">先来先服务 FCFS<a class="anchor" href="#先来先服务-FCFS">·</a></h4><p>按访问请求先后次序服务</p><h4 id="最短寻道时间优先-SSTF">最短寻道时间优先 SSTF<a class="anchor" href="#最短寻道时间优先-SSTF">·</a></h4><p>优先选择<strong>距当前磁头最近的访问请求</strong>进行服务，主要考虑<strong>寻道优先</strong>。</p><p>可能导致饥饿，即一些请求长时间得不到服务</p><h4 id="扫描算法-SCAN-电梯调度">扫描算法 SCAN 电梯调度<a class="anchor" href="#扫描算法-SCAN-电梯调度">·</a></h4><p>磁盘臂沿特定方向移动到最后一层, 满足路径中的所有请求。</p><p>然后转回并反向移动至最低层, 满足路径中的所有请求。</p><h4 id="循环扫描算法-CSCAN">循环扫描算法 CSCAN<a class="anchor" href="#循环扫描算法-CSCAN">·</a></h4><ul><li>按照所要访问的柱面位置的次序去选择访问者。</li><li>移动臂到达最后一个柱面后，<strong>立即</strong>带动读写磁头快速<strong>返回到0号柱面</strong>。</li><li>返回时<strong>不为任何的等待</strong>访问者<strong>服务</strong>。</li><li>返回后可再次进行扫描。</li></ul><p>SCAN算法偏向于处理最里或最外的磁道访问请求，CSCAN可以避免</p><h4 id="LOOK算法">LOOK算法<a class="anchor" href="#LOOK算法">·</a></h4><p>SCAN算法改进</p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-2/6-4.png" style="zoom:80%;"><h4 id="CLOOK算法">CLOOK算法<a class="anchor" href="#CLOOK算法">·</a></h4><p>CSCAN算法改进</p><p>每次向一个方向移动到最高请求柱面，之后返回最低请求柱面，不理会返回路径上的请求</p><h2 id="6-2-保证磁盘可靠性">6.2 保证磁盘可靠性<a class="anchor" href="#6-2-保证磁盘可靠性">·</a></h2><h3 id="RAID">RAID<a class="anchor" href="#RAID">·</a></h3><p><strong>廉价冗余磁盘阵列</strong>,Redundant arrays of inexpensive disks</p><ul><li>冗余技术提高可靠性</li><li>并行提高性能</li></ul><p>数据分段并行交叉存取</p><p>组成磁盘阵列的不同方式称为RAID级别，分为0-6 7个级别，还有一个RAID10</p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-2/6-3.png" style="zoom:67%;"><h2 id="6-3-提高I-O访问速度">6.3 提高I/O访问速度<a class="anchor" href="#6-3-提高I-O访问速度">·</a></h2><h3 id="主要途径">主要途径<a class="anchor" href="#主要途径">·</a></h3><ul><li>选择性能好的磁盘</li><li>并行化</li><li>采用适当的调度算法</li><li>设置磁盘高速缓冲区</li></ul><h3 id="提高磁盘I-O速度——缓存">提高磁盘I/O速度——缓存<a class="anchor" href="#提高磁盘I-O速度——缓存">·</a></h3><ul><li>独立缓存/以虚拟内存为缓存</li><li>置换算法 LRU</li><li>周期性写回</li></ul><h3 id="优化数据布局">优化数据布局<a class="anchor" href="#优化数据布局">·</a></h3><ul><li>优化物理块的分布</li><li>优化索引节点的分布</li></ul><h3 id="其他方法">其他方法<a class="anchor" href="#其他方法">·</a></h3><ul><li>提前读</li><li>延迟写</li><li>虚拟盘</li></ul><h2 id="6-4-磁盘管理的实例">6.4 磁盘管理的实例<a class="anchor" href="#6-4-磁盘管理的实例">·</a></h2><h1 id="第七章-文件系统">第七章 文件系统<a class="anchor" href="#第七章-文件系统">·</a></h1><h2 id="7-1-文件系统基本概念">7.1 文件系统基本概念<a class="anchor" href="#7-1-文件系统基本概念">·</a></h2><p>文件作为数据的存储和访问单位</p><p>文件包括：</p><ul><li>文件体：文件本身内容 （data）</li><li>文件说明：文件存储和管理的相关信息，如：文件名、文件内部标识、文件存储地址、访问权限、访问时间等；（meta-data）</li></ul><p>文件可以视为与进程地址空间无关的一段单独连续的逻辑地址空间</p><p>现代OS：一切皆文件</p><h2 id="7-2-文件系统实现方法">7.2 文件系统实现方法<a class="anchor" href="#7-2-文件系统实现方法">·</a></h2><p>文件系统管理对象：</p><ul><li>文件</li><li>目录</li><li>磁盘存储空间</li></ul><h3 id="文件控制块-FCB">文件控制块 FCB<a class="anchor" href="#文件控制块-FCB">·</a></h3><h4 id="基本信息">基本信息<a class="anchor" href="#基本信息">·</a></h4><ul><li>文件名</li><li>物理位置</li><li>文件逻辑结构 有无结构</li><li>文件物理结构 （顺序、索引）</li></ul><h4 id="访问控制信息">访问控制信息<a class="anchor" href="#访问控制信息">·</a></h4><ul><li>文件所有者 创建的用户</li><li>访问权限 读、写、执行、删除</li></ul><h4 id="使用信息">使用信息<a class="anchor" href="#使用信息">·</a></h4><ul><li>创建时间，上一次修改时间，当前使用信息等等</li></ul><h3 id="文件逻辑结构和物理结构">文件逻辑结构和物理结构<a class="anchor" href="#文件逻辑结构和物理结构">·</a></h3><h4 id="文件逻辑结构（文件组织）">文件逻辑结构（文件组织）<a class="anchor" href="#文件逻辑结构（文件组织）">·</a></h4><h4 id="文件物理结构">文件物理结构<a class="anchor" href="#文件物理结构">·</a></h4><p>文件存放方式，在存储介质上的位置、链接和编目方法</p><p>主要结构：连续结构（顺序存取，适用于变化不大的顺序访问文件）、索引结构、串联结构（随机存取，采用链接指针，动态性好，易于扩充）</p><h3 id="索引结构-※※※">索引结构 ※※※<a class="anchor" href="#索引结构-※※※">·</a></h3><p>为每个文件建立<strong>逻辑块号与物理块号的对照表</strong>：<strong>索引表</strong>。</p><p>文件由<strong>数据文件</strong>和<strong>索引表</strong>构成，这种文件称为：<strong>索引文件</strong>。</p><p>索引表位置：文件目录中，文件开头</p><p>索引表大小：固定/非固定大小</p><p>索引文件在存储区占两个区，<strong>索引区–放索引表</strong>，<strong>数据区–放数据文件本身</strong>。</p><h4 id="访问索引文件">访问索引文件<a class="anchor" href="#访问索引文件">·</a></h4><ul><li>先查文件索引号，由<strong>逻辑块号查得物理块号</strong></li><li>由此<strong>物理块号</strong>获得所要求的信息</li></ul><h4 id="索引表的组织">索引表的组织<a class="anchor" href="#索引表的组织">·</a></h4><ul><li>链接模式<ul><li>多个索引表链接起来</li></ul></li><li>多级索引</li><li>综合模式<ul><li>直接索引与间接索引结合</li></ul></li></ul><h3 id="目录">目录<a class="anchor" href="#目录">·</a></h3><h4 id="目录的实现">目录的实现<a class="anchor" href="#目录的实现">·</a></h4><p>直接法：目录项=文件名+FCB</p><p>间接法：目录项=文件名+FCB地址</p><h4 id="符号文件目录的查询">符号文件目录的查询<a class="anchor" href="#符号文件目录的查询">·</a></h4><h5 id="顺序查寻法">顺序查寻法<a class="anchor" href="#顺序查寻法">·</a></h5><p>依次比对名字</p><h5 id="Hash方法">Hash方法<a class="anchor" href="#Hash方法">·</a></h5><p>将符号名唯一的变换为符号表中的表目索引</p><h3 id="磁盘空间管理">磁盘空间管理<a class="anchor" href="#磁盘空间管理">·</a></h3><h4 id="空闲表法">空闲表法<a class="anchor" href="#空闲表法">·</a></h4><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">第一空闲盘块号</th><th style="text-align:center">空闲盘块数</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">3</td></tr></tbody></table><h4 id="空闲链表法">空闲链表法<a class="anchor" href="#空闲链表法">·</a></h4><p>分为<strong>空闲盘区链</strong>和<strong>空闲盘块链</strong></p><h4 id="位示图（位图法）">位示图（位图法）<a class="anchor" href="#位示图（位图法）">·</a></h4><h4 id="成组链表法">成组链表法<a class="anchor" href="#成组链表法">·</a></h4><p>每组的<strong>第一个空闲块</strong>记录下一组空闲块的<strong>物理盘块号</strong>和<strong>空闲块总数</strong>。</p><h3 id="保护文件的方法">保护文件的方法<a class="anchor" href="#保护文件的方法">·</a></h3><ul><li>建立副本</li><li>定时转储</li><li>规定文件的权限</li></ul><h2 id="7-3-文件系统实例分析">7.3 文件系统实例分析<a class="anchor" href="#7-3-文件系统实例分析">·</a></h2><h3 id="FAT">FAT<a class="anchor" href="#FAT">·</a></h3><h3 id="EXT2">EXT2<a class="anchor" href="#EXT2">·</a></h3><h3 id="Linux-VFS">Linux VFS<a class="anchor" href="#Linux-VFS">·</a></h3><h3 id="LFS">LFS<a class="anchor" href="#LFS">·</a></h3><h1 id="习题">习题<a class="anchor" href="#习题">·</a></h1><h2 id="文件系统-2">文件系统<a class="anchor" href="#文件系统-2">·</a></h2><p>一个Unix文件系统采用2KB大小的数据块和4字节的数据块地址。每个i节点包括10个直接索引，1个一级间接索引和1个二级间接索引。（1）该文件系统中文件最大为多少KB？（本小题5分）（2）假设磁盘上一半的文件大小恰好为2KB，另一半文件的大小恰好为1.5KB，那么磁盘空间的利用率是多少？如果数据块大小改为1KB，磁盘空间利用率是多少？（只考虑存储文件数据的磁盘块）（本小题6分）（3）小明编写了一个读取文件的程序，可以从不同大小的文件中随机读取一定量数据，结果发现读取大文件时的平均性能有明显下降。请分析主要原因，并尝试给出解决该问题的思路。（本小题4分）</p><p>(1)</p><p>2KB/4=512个磁盘块</p><p>(10+1*512+1*512*512)*2KB=</p><p>(2)</p><p>(2/2+1.5/2)/2=0.875</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-OS-2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS理论课笔记-系统引导/内存管理/进程与并发程序设计</title>
      <link href="2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/"/>
      <url>2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/</url>
      
        <content type="html"><![CDATA[<h1 id="第1章-引论">第1章 引论<a class="anchor" href="#第1章-引论">·</a></h1><p>操作系统是一个程序，是一组管理计算机硬件资源的软件集合，向计算机程序提供共性服务。</p><ol><li>控制计算机资源；</li><li>给用户提供<strong>接口</strong>或<strong>虚拟机</strong>。</li></ol><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/1-1.png" style="zoom:67%;"><h2 id="OS的历史沿革">OS的历史沿革<a class="anchor" href="#OS的历史沿革">·</a></h2><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/1-2.png" style="zoom: 50%;"><p><strong>批处理</strong>：用户提交作业成批送入计算机，由作业调度程序自动选择作业运行。涉及到<strong>Mainframe基本功能，排队论、统筹学</strong>。</p><p><strong>批处理系统</strong>，分为<strong>联机批处理系统</strong>（作业的输入/输出由CPU来处理）和<strong>脱机批处理系统</strong>（输入/输出脱离主机控制）。 两者均有CPU空闲，均为<strong>单道程序系统</strong></p><p><strong>多道程序系统</strong>：多个程序同时进入内存，交替使用I/O设备和CPU。</p><p>多道程序系统的出现，标志着操作系统<strong>渐趋成熟</strong>的阶段，先后出现了<strong>作业调度管理</strong>、<strong>处理机管理</strong>、<strong>存储器管理</strong>、<strong>外部设备管理</strong>、<strong>文件系统管理</strong>等功能。</p><p><strong>分时系统</strong>：多个用户分享使用同一台计算机。多个程序分时共享硬件和软件资源</p><p>两种典型分时系统：</p><ol><li><p>Multics/Unix (1968/1970)</p></li><li><p>IBM VM 360/370 (1966/1972)</p></li></ol><p>Unix、DOS、Windows、Linux（使用GNU）</p><p><strong>分布式网络化</strong></p><h2 id="小结-8">小结<a class="anchor" href="#小结-8">·</a></h2><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/1-3.png" style="zoom: 60%;"><h2 id="操作系统基本实现机制">操作系统基本实现机制<a class="anchor" href="#操作系统基本实现机制">·</a></h2><h3 id="异常-exception-陷阱-trap-和中断-interrupt">异常(exception): 陷阱(trap)和中断(interrupt)<a class="anchor" href="#异常-exception-陷阱-trap-和中断-interrupt">·</a></h3><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/1-4.png" style="zoom:50%;"><h2 id="操作系统的基本类型">操作系统的基本类型<a class="anchor" href="#操作系统的基本类型">·</a></h2><ul><li>批处理系统</li><li>分时系统</li><li>实时系统</li><li>混合型</li></ul><h2 id="操作系统的功能">操作系统的功能<a class="anchor" href="#操作系统的功能">·</a></h2><h3 id="处理机管理">处理机管理<a class="anchor" href="#处理机管理">·</a></h3><p>核心任务：分配CPU时间 ——进程、线程管理——公平分配、保证非阻塞、按优先级分配</p><p>进程管理：程序是静态实体，进程是执行中的程序。进程的调度：创建、挂起、激活。进程间通信：同步，互斥，死锁。</p><h3 id="存储器-内存-管理">存储器(内存)管理<a class="anchor" href="#存储器-内存-管理">·</a></h3><p>管理缓存、主存、磁盘等所形成的多级存储架构，为多道程序的并发提供良好的环境。</p><p>– 内存分配和存储无关性：方便用户– 内存保护：互不干扰– 内存扩充：虚拟存储器</p><h3 id="设备管理">设备管理<a class="anchor" href="#设备管理">·</a></h3><p>管理输入/输出设备，屏蔽差异性，提供并发访问</p><p>– 设备无关性：逻辑设备-&gt;物理设备– 设备分配：独享、共享和虚拟– 设备的传输控制：中断、通道</p><h3 id="文件系统">文件系统<a class="anchor" href="#文件系统">·</a></h3><p>将磁盘变成一个很容易使用的存储媒介提供给用户使用。– 文件存储空间的管理– 目录管理– 文件读、写管理– 文件保护– 向用户提供接口</p><h3 id="作业控制">作业控制<a class="anchor" href="#作业控制">·</a></h3><ul><li>作业调度</li><li>作业控制。<ul><li>批量型作业</li><li>终端型作业</li></ul></li></ul><h1 id="第2章-系统引导">第2章 系统引导<a class="anchor" href="#第2章-系统引导">·</a></h1><h2 id="BootLoader">BootLoader<a class="anchor" href="#BootLoader">·</a></h2><p>引导加载程序，是系统<strong>加电后</strong>运行的第一段软件代码，是操作系统<strong>内核运行之前</strong>运行的一段小程序</p><p><strong>BootLoader</strong>是<strong>Booter</strong>和<strong>Loader</strong>的合写，前者要<strong>初始化系统硬件</strong>使之运行起来，至少是<strong>部分运行</strong>起来；后者将<strong>操作系统映像加载到内存</strong>中，并跳转到操作系统的代码运行。</p><ul><li><strong>MIPS</strong>处理器大多用于<strong>嵌入式系统</strong>，嵌入式系统常用<strong>U-boot</strong>作为OS启动装载程序，U-Boot，全称 Universal Boot Loader；</li><li><strong>X86</strong>处理器通常采用<strong>LILO</strong>和<strong>GRUB</strong>。</li></ul><h2 id="U-Boot启动流程">U-Boot启动流程<a class="anchor" href="#U-Boot启动流程">·</a></h2><p>大多数BootLoader都分为<strong>stage1</strong>和<strong>stage2</strong>两大部分，U-boot也不例外。</p><ul><li>依赖于cpu体系结构的代码（如设备初始化代码等）通常都放在stage1且可以用<strong>汇编语言</strong>来实现；</li><li>stage2则通常用<strong>C语言</strong>来实现，这样可以实现复杂的功能，而且有更好的可读性和移植性。</li></ul><h2 id="启动及OS引导">启动及OS引导<a class="anchor" href="#启动及OS引导">·</a></h2><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/2-1.png" alt></p><h4 id="启动第一步——加载BIOS">启动第一步——加载BIOS<a class="anchor" href="#启动第一步——加载BIOS">·</a></h4><p>BIOS进行硬件自检以及读取启动顺序</p><h4 id="启动第二步——读取MBR，装载MBR到内存特定地址">启动第二步——读取MBR，装载MBR到内存特定地址<a class="anchor" href="#启动第二步——读取MBR，装载MBR到内存特定地址">·</a></h4><h4 id="启动第三步——Boot-Loader，运行主引导程序">启动第三步——Boot Loader，运行主引导程序<a class="anchor" href="#启动第三步——Boot-Loader，运行主引导程序">·</a></h4><h1 id="第3章-内存管理">第3章 内存管理<a class="anchor" href="#第3章-内存管理">·</a></h1><h2 id="3-1-多道程序的存储管理">3.1 多道程序的存储管理<a class="anchor" href="#3-1-多道程序的存储管理">·</a></h2><p>固定（静态）式分区分配，程序适应分区。系统初始化时将存储空间分为若干个区域，之后再将这些区域分配给用户作业。</p><p>可变（动态）式分区分配，分区适应程序。动态确定分区边界。</p><p>内外碎片造成巨大空间浪费</p><p><strong>跟踪</strong>内存使用情况？<strong>位图表示法（分区表）<strong>和</strong>链表表示法（分区链表）</strong>。</p><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/2-2.png" style="zoom:40%;"><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/2-3.png" alt="2-3" style="zoom:40%;"></p><p>位图表示法空间成本固定，时间成本低，容错能力差（不知道被占用的原因）。</p><p>链表表示法时间成本高，容错能力较好。</p><h3 id="可变分区管理">可变分区管理<a class="anchor" href="#可变分区管理">·</a></h3><p>内存分配采用两张表：<strong>已分配分区表</strong>和<strong>未分配分区表</strong>。操作为分配、回收内存。</p><h3 id="基于顺序搜索的分配算法">基于顺序搜索的分配算法<a class="anchor" href="#基于顺序搜索的分配算法">·</a></h3><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-1.png" style="zoom: 50%;"><h3 id="基于索引搜索的动态分区分配算法">基于索引搜索的动态分区分配算法<a class="anchor" href="#基于索引搜索的动态分区分配算法">·</a></h3><p>大中型系统采用</p><h4 id="快速适应算法（分类搜索法）">快速适应算法（分类搜索法）<a class="anchor" href="#快速适应算法（分类搜索法）">·</a></h4><p>把空闲分区<strong>按容量大小</strong>进行分类，经常用到长度的空闲区设立单独的<strong>空闲区链表</strong>。为多个空闲链表设立一张<strong>管理索引表</strong>。</p><h3 id="伙伴系统">伙伴系统<a class="anchor" href="#伙伴系统">·</a></h3><p>介于固定分区与可变分区之间的动态分区技术</p><p>在分配存储块时将一个<strong>大的存储块</strong>分裂成<strong>两个大小相等的小块</strong>。</p><p>已分配和空闲分区大小均为2的整数次幂。每次有一个新的大小请求先看有无最靠近这个大小的幂次的分区，没有就向上查找并分裂。</p><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-2.png" style="zoom:45%;"><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-3.png" style="zoom:45%;"></p><h2 id="3-2-程序从存储到执行">3.2 程序从存储到执行<a class="anchor" href="#3-2-程序从存储到执行">·</a></h2><h3 id="存储分配三种方式">存储分配三种方式<a class="anchor" href="#存储分配三种方式">·</a></h3><ul><li>直接指定。直接使用实际地址</li><li>静态分配</li><li>动态分配</li></ul><h4 id="可重定位分区分配">可重定位分区分配<a class="anchor" href="#可重定位分区分配">·</a></h4><p>定时的或在内存紧张时，移动某些已分配区中的信息，把存储空间中<strong>所有的空白区</strong>合<strong>并为</strong>一个<strong>大的连续区</strong>。</p><h3 id="程序的链接和装入">程序的链接和装入<a class="anchor" href="#程序的链接和装入">·</a></h3><ul><li><strong>编译</strong>(compile)：由编译程序将用户源程序<strong>编译</strong>成<strong>若干个目标模块</strong>。</li><li><strong>链接</strong>(linking)：由链接程序将<strong>目标模块</strong>和相应的<strong>库函数</strong>链接成<strong>可装载模块</strong>（<strong>可执行文件</strong>）。</li><li><strong>装入</strong>(loading)：由装载程序将可装载模块<strong>装入内存</strong>。一般采用动态运行时装入方式</li></ul><h4 id="链接方式">链接方式<a class="anchor" href="#链接方式">·</a></h4><ul><li><p>静态链接 直接将共享库中代码链接如程序代码中</p></li><li><p>动态链接 需要时才链接特定的模块</p></li></ul><h4 id="重定位">重定位<a class="anchor" href="#重定位">·</a></h4><p>在装入时对目标程序中的指令和数据地址的修改，或映射过程。</p><h4 id="多重分区分配">多重分区分配<a class="anchor" href="#多重分区分配">·</a></h4><p>一个作业往往由相对独立的程序段和数据段组成，将这些片段分别装入到存储空间中不同的区域内的分配方式。</p><h3 id="程序段">程序段<a class="anchor" href="#程序段">·</a></h3><p>一个程序本质上都是由 bss段、data段、text段三个组成的。</p><p><strong>bss段</strong>：（bss segment）用来存放程序中<strong>未初始化的全局变量</strong>的一块内存区域。bss是英文Block Started by Symbol的简称。bss段属于<strong>静态内存分配</strong>。</p><p><strong>data段</strong>：数据段（data segment）用来存放程序中<strong>已初始化的全局变量</strong>的一块内存区域。数据段属于<strong>静态内存分配</strong>。</p><p><strong>text段</strong>：代码段（code segment/text segment）用来存放<strong>程序执行代码</strong>的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于<strong>只读</strong>(某些架构也允许代码段为可写，即允许修改程序)。在代码段中，也有可能包含一些只读的常数变量，例如<strong>字符串常量</strong>等。</p><p><strong>栈(stack)</strong>：存放、交换<strong>临时数据</strong>的内存区</p><ul><li><p>用户存放<strong>程序局部变量</strong>的内存区域，（但不包括static声明的变量，<strong>static</strong>意味着在<strong>数据段中存放变量</strong>）。</p></li><li><p><strong>保存/恢复调用现场</strong>。在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。</p></li></ul><p><strong>堆（heap）</strong>：存放进程运行中<strong>动态分配</strong>的内存段</p><ul><li>它的大小并不固定，可动态扩张或缩减。当进程调用<strong>malloc等函数分配内存</strong>时，新分配的内存就被动态添加到堆上（<strong>堆被扩张</strong>）；当利用<strong>free</strong>等函数释放内存时，被释放的内存从堆中被剔除（<strong>堆被缩减</strong>）。</li></ul><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-4.png" alt></p><p>C语言各个段地址解析：</p><p>https://blog.csdn.net/zhengshifeng123/article/details/79756830</p><h3 id="gcc编译与链接">gcc编译与链接<a class="anchor" href="#gcc编译与链接">·</a></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gcc -o main main.c extra.c #-o 编译+链接</span><br><span class="line">./main #运行main</span><br><span class="line"></span><br><span class="line">gcc -c main.c</span><br><span class="line">gcc -c extra.c #只编译</span><br><span class="line"></span><br><span class="line">gcc main.o extra.o -o main</span><br><span class="line">./main #只链接</span><br></pre></td></tr></table></figure><p><strong>gcc调用</strong>包含的几个<strong>工具</strong>：</p><ul><li>cc1：预处理器和编译器</li><li>as：汇编器</li><li>collect2：链接器</li></ul><h3 id="Linux下可执行文件的格式">Linux下可执行文件的格式<a class="anchor" href="#Linux下可执行文件的格式">·</a></h3><p>ELF（Executable and Linkable Format）文件</p><ol><li><strong>可重定位（relocatable）文件</strong>，保存着代码和适当的数据，用来和其他的object文件一起来创建一个可执行文件或者是一个共享文件。</li><li><strong>可执行（executable）文件</strong>，保存着一个用来执行的程序，该文件指出了exec（BA_OS）如何来创建程序进程映像</li><li><strong>共享object文件</strong>，保存着代码和合适的数据，用来被下面的两个链接器链接。第一个是链接编辑器（静态链接），可以和其他的可重定位和共享object文件一起来创建object文件；第二个是动态链接器，联合一个可执行文件和其他的共享object文件来创建一个进程映象。</li></ol><p><strong>编译，链接，重定位，装载，运行</strong>。五个步骤完成程序的执行全流程。</p><h2 id="3-3-页式内存管理">3.3 页式内存管理<a class="anchor" href="#3-3-页式内存管理">·</a></h2><h3 id="程序、进程和作业">程序、进程和作业<a class="anchor" href="#程序、进程和作业">·</a></h3><p><strong>程序</strong>—<strong>静止</strong>的，是存放在磁盘上的可执行文件</p><p><strong>进程</strong>—<strong>动态</strong>的，包括程序和程序处理对象，是分配资源的基本单位。</p><ul><li><p>完成操作系统功能的进程是<strong>系统进程</strong>。</p></li><li><p>完成用户功能的进程称为<strong>用户进程</strong>。</p></li></ul><p><strong>作业</strong>—是用户需要计算机完成的<strong>某项任务</strong>，是要求计算机<strong>所做工作的集合</strong>。</p><p>一个<strong>作业</strong>划分为<strong>多个进程</strong>来完成，一个进程又由其<strong>实体</strong>—<strong>程序和数据集合</strong>来组成。</p><h3 id="分页式存储管理">分页式存储管理<a class="anchor" href="#分页式存储管理">·</a></h3><p><strong>纯分页系统</strong>：没有页面置换功能。所有页<strong>一次性全部装入主存</strong>。</p><p><strong>页</strong>：每个作业的<strong>地址空间</strong>分成一些<strong>大小相等的片</strong>，称之为<strong>页面</strong>或<strong>页</strong>。</p><p><strong>存储块</strong>：主存的<strong>存储空间</strong>也分成和<strong>页面相同大小的片</strong>，称为<strong>存储块</strong>，或<strong>页框</strong>。</p><p><strong>分页地址结构</strong>：</p><h5 id="逻辑地址">逻辑地址<a class="anchor" href="#逻辑地址">·</a></h5><table><thead><tr><th style="text-align:center">31-12</th><th style="text-align:center">11-0</th></tr></thead><tbody><tr><td style="text-align:center">页号p</td><td style="text-align:center">页内偏移w</td></tr></tbody></table><h5 id="物理地址">物理地址<a class="anchor" href="#物理地址">·</a></h5><table><thead><tr><th style="text-align:center">21-12</th><th style="text-align:center">11-0</th></tr></thead><tbody><tr><td style="text-align:center">块号</td><td style="text-align:center">块内偏移d</td></tr></tbody></table><p>现代操作系统中最常用的页面大小为4KB</p><h4 id="内存分配基本思想">内存分配基本思想<a class="anchor" href="#内存分配基本思想">·</a></h4><ul><li>以<strong>页</strong>为单位进行分配，并按程序（作业）的**长度（页数）**进行分配；</li><li><strong>逻辑上相邻</strong>的页，<strong>物理上不一定相邻</strong>。</li></ul><h4 id="数据结构">数据结构<a class="anchor" href="#数据结构">·</a></h4><p>每个进程有一个<strong>进程页表</strong>，描述该进程<strong>占用的物理页面</strong>及<strong>逻辑排列顺序</strong>。</p><p>整个系统有一个<strong>物理页面表</strong>，描述物理内存空间<strong>分配使用</strong>情况。</p><p>整个系统有一个<strong>请求表</strong>，描述系统内各个<strong>进程页表的位置</strong>和<strong>大小</strong>，用于<strong>地址转换</strong>，也可以结合到各进程的PCB里。</p><h4 id="地址变换—页表查找">地址变换—页表查找<a class="anchor" href="#地址变换—页表查找">·</a></h4><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-5.png" style="zoom: 80%;"><h4 id="关于页表">关于页表<a class="anchor" href="#关于页表">·</a></h4><ul><li>页表<strong>放置在内存中</strong>，记录了进程的<strong>现场信息</strong>。记录进程的<strong>内存分配情况</strong>以及实现进程运行时的<strong>动态重定位</strong>。</li><li>访问一个数据需要访问内存<strong>两次</strong>（页表一次，内存一次）。</li><li>页表的<strong>基址</strong>及<strong>长度</strong>由<strong>页表寄存器</strong>给出。</li></ul><h4 id="地址转换机构">地址转换机构<a class="anchor" href="#地址转换机构">·</a></h4><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-6.png" style="zoom:80%;"><p>逻辑地址分为页号和页内地址两部分。先进行越界保护。之后进行页表定位：页表始址+页号*页表项长度</p><p>查询页表，读出块号。物理地址=块号+块内地址（块内地址=页内地址）</p><h3 id="提高分页效率">提高分页效率<a class="anchor" href="#提高分页效率">·</a></h3><ul><li>减少页表大小</li><li>提高地址映射速度</li></ul><h4 id="解决问题方法">解决问题方法<a class="anchor" href="#解决问题方法">·</a></h4><ul><li>动态调入页表：只将需用的部分页表项调入内存</li><li>多级页表</li></ul><p><strong>二级页表</strong>：</p><ul><li>一级目录：页目录表</li><li>二级目录：页表</li></ul><p>参考博客：<a href="https://www.jianshu.com/p/51c2286a6268" target="_blank" rel="noopener">https://www.jianshu.com/p/51c2286a6268</a></p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-7.jpg" style="zoom: 67%;"><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-8.png" style="zoom:67%;"><blockquote><p>如果是64位操作系统，内存也是4G，每个页面大小也为4KB，采用三级页表，需要字对齐，则虚拟地址应该为多少位？</p></blockquote><p>首先每一级页表的所占空间大小应该都是一个页面的大小。即4KB（因为自映射机制）</p><p>又由于64位操作系统需要字对齐，所以实际上每一级目录只占用12-3=9位。</p><p>因此三级目录就需要9*3+12=39位</p><p>多级页表带来访存效率低下问题</p><h3 id="页表快速访问机制——MMU">页表快速访问机制——MMU<a class="anchor" href="#页表快速访问机制——MMU">·</a></h3><p>CPU内部增加了一个硬件单元，称为<strong>存储管理单元MMU</strong>（Memory Management Unit）</p><ul><li><strong>页表Cache</strong>：又称为<strong>TLB</strong>，用于存放<strong>虚拟地址</strong>与<strong>相应</strong>的<strong>物理地址</strong>；</li><li><strong>TLB控制单元</strong>：TLB内容<strong>填充、刷新、覆盖，以及越界检查</strong>。</li><li><strong>页表（遍历）查找单元</strong>：若TLB未命中，自动查找多级页表，将找到的物理地址<strong>送与TLB控制单元</strong>。（可用软件实现）</li></ul><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-21.png" alt></p><h3 id="反向页表、哈希页表">反向页表、哈希页表<a class="anchor" href="#反向页表、哈希页表">·</a></h3><h3 id="页的保护">页的保护<a class="anchor" href="#页的保护">·</a></h3><ul><li>地址<strong>越界</strong>保护</li><li>页表中设置<strong>保护位</strong>（只读，读写，执行）</li></ul><h3 id="页面大小习题">页面大小习题<a class="anchor" href="#页面大小习题">·</a></h3><p>假设进程的平均大小是1MB(s=1MB)，每个页表项需要8个字节(e=8B)。页面大小设置为多少字节比较好？</p><p>答：$f§=s*e/p+p/2，求minf§$ $为4kB$</p><h3 id="多级页表再理解">多级页表再理解<a class="anchor" href="#多级页表再理解">·</a></h3><p>指令给出的地址除<strong>偏移地址之外</strong>的<strong>各部分</strong>全是各级页表的<strong>页表号</strong>或<strong>页号</strong>，且都是<strong>物理页号</strong></p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-9.png" style="zoom: 67%;"><h2 id="3-4-分段存储管理">3.4 分段存储管理<a class="anchor" href="#3-4-分段存储管理">·</a></h2><p>逻辑地址结构为：<strong>段号S+位移量W</strong></p><p><strong>段表</strong>记录了段与内存位置对应关系，保存在内存中。</p><p>段表<strong>基地址</strong>和<strong>长度</strong>由段表寄存器给出。访问一个字节数据/指令需要<strong>访问内存两次</strong>（段表1次，内存1次）。</p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-10.png" style="zoom:80%;"><p>先比较段号S和段表长度TL，不越界则检查段内地址d是否超过段长。</p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-11.png" style="zoom:80%;"><p><strong>信息共享</strong>——<strong>可重入代码</strong>（<strong>纯代码Pure Code</strong>），允许多个进程<strong>同时访问</strong>，但<strong>不允许</strong>任何进程对其进行<strong>修改</strong>。</p><p>可采用<strong>分段共享</strong>，</p><h3 id="段页式存储管理">段页式存储管理<a class="anchor" href="#段页式存储管理">·</a></h3><p><strong>分段方法</strong>——分配和管理<strong>虚拟存储器</strong></p><p><strong>分页方法</strong>——分配和管理<strong>实存储器</strong></p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-12.png" style="zoom:80%;"><h2 id="3-5-虚拟存储管理（※）">3.5 虚拟存储管理（※）<a class="anchor" href="#3-5-虚拟存储管理（※）">·</a></h2><p><strong>虚拟地址空间</strong>：并不真实存在，格式按<strong>字节从0开始编址</strong>所形成的空间</p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-13.png" style="zoom: 67%;"><h3 id="虚拟存储的基本原理">虚拟存储的基本原理<a class="anchor" href="#虚拟存储的基本原理">·</a></h3><ul><li>按需装载</li><li>缺页调入</li><li>不用调出</li></ul><h3 id="缺页错误（-Page-Fault）处理机制">缺页错误（ Page Fault）处理机制<a class="anchor" href="#缺页错误（-Page-Fault）处理机制">·</a></h3><p>当进程执行过程中需访问的页面不在物理存储器中时，会引发发生缺页中断，进行所需页面换入，步骤如下：</p><ol><li>陷入内核态，保存必要的信息（OS及用户进程状态相关的信息）。（现场保护）</li><li>查找出来发生页面中断的虚拟页面（进程地址空间中的页面）。这个虚拟页面的信息通常会保存在一个硬件寄存器中，如果没有的话，操作系统必须检索程序计数器，取出这条指令，用软件分析该指令，通过分析找出发生页面中断的虚拟页面。（页面定位）</li><li>检查虚拟地址的有效性及安全保护位。如果发生保护错误，则杀死该进程。（权限检查）</li><li>查找一个空闲的页框(物理内存中的页面)，如果没有空闲页框则需要通过页面置换算法找到一个需要换出的页框。（新页面调入（1））</li><li>如果找的页框中的内容被修改了，则需要将修改的内容保存到磁盘上。（注：此时需要将页框置为忙状态，以防页框被其它进程抢占掉）（旧页面写回）</li><li>页框“干净”后，操作系统将保存在磁盘上的页面内容复制到该页框中。（新页面调入（2））此时会引起一个磁盘读写调用，发生上下文切换（在等待磁盘读写的过程中让其它进程运行）。</li><li>当磁盘中的页面内容全部装入页框后，向操作系统发送一个中断。操作系统更新内存中的页表项，将虚拟页面映射的页框号更新为写入的页框，并将页框标记为正常状态。（更新页表）</li><li>恢复缺页中断发生前的状态，将程序指针重新指向引起缺页中断的指令。（恢复现场）</li><li>程序重新执行引发缺页中断的指令，进行存储访问。（继续执行）缺页处理过程涉及了用户态和内核态之间的切换，虚拟地址和物理地址之间的转换（这个转换过程需要使用MMU和TLB）</li></ol><h2 id="3-6-页面置换">3.6 页面置换<a class="anchor" href="#3-6-页面置换">·</a></h2><h3 id="1-最优置换-OPT">1.最优置换 OPT<a class="anchor" href="#1-最优置换-OPT">·</a></h3><ul><li><p>需要用<strong>先验知识</strong>，无法实现，作为<strong>基准</strong>衡量其他算法效果。</p></li><li><p>置换掉<strong>未来最久不被使用</strong>的页</p></li></ul><h3 id="2-FIFO类算法">2.FIFO类算法<a class="anchor" href="#2-FIFO类算法">·</a></h3><h4 id="先进先出-FIFO">先进先出 FIFO<a class="anchor" href="#先进先出-FIFO">·</a></h4><p>用一个<strong>队列</strong>维护</p><p><strong>性能较差</strong>，因为<strong>较早调入</strong>的页往往<strong>访问频率高</strong></p><h4 id="Belady-现象">Belady 现象<a class="anchor" href="#Belady-现象">·</a></h4><p>FIFO容易出现</p><p>分配页面增多，<strong>缺页率</strong>反而<strong>增高</strong></p><h4 id="改进FIFO—Second-Chance">改进FIFO—Second Chance<a class="anchor" href="#改进FIFO—Second-Chance">·</a></h4><p>每个页面增加一个<strong>访问标志位</strong>，标识进入<strong>缓存队列</strong>后是否再次被访问过</p><p>如果一个页面进入后被访问，则设置标识位为1。在将要淘汰A时，将A标识位设成0，并将A移动到<strong>队列头（视为新加入的）</strong></p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-15.png" style="zoom: 80%;"><h4 id="改进FIFO—Clock">改进FIFO—Clock<a class="anchor" href="#改进FIFO—Clock">·</a></h4><p>Second Chance的改进版，也叫最近未使用算法</p><p>使用<strong>环形队列</strong>，缺页时当前指针指向的P如果访问标记为1，则清零并移动指针到P的下一个</p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-14.png" style="zoom:67%;"><p>FIFO类算法命中率较低，<strong>实际应用</strong>较少。</p><h4 id="FIFO算法性能比较">FIFO算法性能比较<a class="anchor" href="#FIFO算法性能比较">·</a></h4><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-16.png" style="zoom: 50%;"><h3 id="3-最近最少使用-LRU算法">3.最近最少使用 LRU算法<a class="anchor" href="#3-最近最少使用-LRU算法">·</a></h3><p><strong>核心思想</strong>：最近被访问过，将来被访问概率增高</p><p>淘汰掉<strong>最先进入队列</strong>里且被<strong>访问次数最少</strong>的页面，可采用链表实现</p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-17.png" style="zoom: 50%;"><h3 id="4-其他替换算法">4.其他替换算法<a class="anchor" href="#4-其他替换算法">·</a></h3><ul><li><p>LRU类：LRU2， Two queues（2Q）， Multi Queue（MQ）</p></li><li><p>LFU类： LFU（Least Frequently Used）， LFU-Aging， LFU*-Aging， Window-LFU；</p></li><li><p>其它： Most Recently Used（MRU），Adaptive Replacement Cache（ARC），Working Set（WS），Working Set Clock（WSclock）</p></li></ul><h3 id="写时复制">写时复制<a class="anchor" href="#写时复制">·</a></h3><ul><li><strong>两个进程共享</strong>同一块物理内存，每个页面都被标志成了<strong>写时复制</strong>。共享的物理内存中每个页面都是只读的。</li><li>如果某个进程想改变某个页面时，就会与<strong>只读标记</strong>冲突，而系统在检测出页面是<strong>写时复制</strong>的，则会在内存中复制一个页面，然后进行写操作。</li><li>新复制的页面对执行写操作的进程是私有的，对其他共享写时复制页面的进程是不可见的。</li></ul><h2 id="3-7-页目录自映射">3.7 页目录自映射<a class="anchor" href="#3-7-页目录自映射">·</a></h2><p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-18.png" style="zoom: 40%;"><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-19.png" style="zoom:40%;"><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-20.png" style="zoom:40%;"></p><h1 id="第4章-进程与并发程序设计">第4章 进程与并发程序设计<a class="anchor" href="#第4章-进程与并发程序设计">·</a></h1><h2 id="4-1-进程与线程">4.1 进程与线程<a class="anchor" href="#4-1-进程与线程">·</a></h2><h3 id="并发与并行">并发与并行<a class="anchor" href="#并发与并行">·</a></h3><p>并发：两个活动都处在各自的<strong>起点到终点间的某一处</strong>。</p><p>并行：<strong>同一时间度量</strong>下<strong>同时运行</strong>在<strong>不同的处理机</strong>上</p><p>并发不一定是并行</p><h4 id="并行性的确定—Bernstein条件">并行性的确定—Bernstein条件<a class="anchor" href="#并行性的确定—Bernstein条件">·</a></h4><p>程序并发执行出现<strong>竞争</strong></p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/4-1.png" style="zoom:50%;"><p>归结为：<strong>不存在一个数据集</strong>两个进程<strong>同时需要写</strong></p><h3 id="进程概念">进程概念<a class="anchor" href="#进程概念">·</a></h3><p><strong>结构特征</strong>：包含<strong>程序段，数据段，进程控制块（PCB）</strong></p><p>一个进程应该包括：</p><ul><li>程序的代码；</li><li>程序的数据；</li><li>PC中的值，用来指示下一条将运行的指令；</li><li>一组通用的寄存器的当前值，堆、栈；</li><li>一组系统资源（如打开的文件）</li></ul><h3 id="进程状态与控制">进程状态与控制<a class="anchor" href="#进程状态与控制">·</a></h3><p>进程控制实现：<strong>原语</strong>——常驻内存，只在内核态下执行，指令序列连续不可分割</p><p>创建原语(fork exec)</p><p>撤销原语(kill)</p><h4 id="进程三种基本状态">进程三种基本状态<a class="anchor" href="#进程三种基本状态">·</a></h4><p>就绪(Ready)：已获得处理机外所需资源，等待CPU的分配</p><p>执行(Running)：<strong>占用处理机</strong>资源。无进程可执行时，自动执行系统idle进程（相当于空操作）</p><p>阻塞(Blocked)：正在执行的进程，因等待某事件，<strong>暂时无法</strong>继续执行，放弃处理机处于<strong>暂停</strong>状态</p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/4-2.png" style="zoom: 67%;"><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/4-3.png" style="zoom: 80%;"><h4 id="挂起进程模型">挂起进程模型<a class="anchor" href="#挂起进程模型">·</a></h4><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/4-4.png" style="zoom: 67%;"><h4 id="进程控制块">进程控制块<a class="anchor" href="#进程控制块">·</a></h4><ul><li><strong>进程标识符</strong> （进程ID）</li><li><strong>程序、数据地址</strong></li><li><strong>当前状态</strong> 系统会把相同状态的进程组成队列</li><li><strong>现场保护区</strong> 需要等待时保存CPU各种状态信息</li><li><strong>同步与同步机制</strong> 实现进程间互斥同步、通信所需的信号量</li><li><strong>优先级</strong></li><li><strong>资源清单</strong> 拥有的除CPU外的资源记录</li><li><strong>链接字</strong> 该进程所在队列中下一个进程PCB首地址</li></ul><h3 id="线程概念">线程概念<a class="anchor" href="#线程概念">·</a></h3><p>进程 (process task) 包含了两个概念：<strong>资源拥有者</strong>和<strong>可执行单元</strong></p><p>可执行单元——线程(thread)  将<strong>资源与计算</strong>分离，提高并发效率</p><p><strong>进程</strong>是<strong>资源分配</strong>的基本单位，<strong>线程</strong>是<strong>处理机调度</strong>的基本单位</p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/4-5.png" style="zoom:50%;"><h3 id="线程的实现方式-※※">线程的实现方式 ※※<a class="anchor" href="#线程的实现方式-※※">·</a></h3><h4 id="用户级线程：User-level-threads-ULT">用户级线程：User level threads(ULT)<a class="anchor" href="#用户级线程：User-level-threads-ULT">·</a></h4><p>线程在用户空间,通过library模拟的thread</p><h4 id="内核级线程：Kernel-level-threads-KLT">内核级线程：Kernel level threads (KLT)<a class="anchor" href="#内核级线程：Kernel-level-threads-KLT">·</a></h4><p>kernel有好几个分身 多线程内核</p><h4 id="混合实现方式">混合实现方式<a class="anchor" href="#混合实现方式">·</a></h4><p>使用内核级线程，将<strong>用户级线程</strong>与<strong>某些</strong>或者<strong>全部</strong>内核线程<strong>多路复用</strong>起来，形成混合的线程实现方式。</p><h4 id="线程模型">线程模型<a class="anchor" href="#线程模型">·</a></h4><ul><li><strong>Many-to-One Model</strong> 多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。<ul><li>优点：线程管理在用户空间进行，<strong>效率高</strong></li><li>缺点：一个线程被阻塞，整个进程被阻塞；<strong>多个线程不能并行</strong>运行在多处理机上</li></ul></li><li><strong>One-to-one Model</strong>  将每个用户级线程映射到一个内核级线程<ul><li>优点：一个进程阻塞可以让另一线程继续，<strong>并发能力强</strong></li><li>缺点：每创1个用户级线程都需要创1个内核级线程，<strong>开销大</strong></li></ul></li><li><strong>Many-to-Many Model</strong>  将 n 个用户级线程映射到m 个内核级线程上，要求m &lt;= n。<ul><li>特点：集前2者之长</li></ul></li></ul><h2 id="4-2-同步与互斥">4.2 同步与互斥<a class="anchor" href="#4-2-同步与互斥">·</a></h2><p>互斥-间接制约：多个进程不能同时进入<strong>同一组共享变量临界区域</strong></p><p>同步-直接制约：有效地共享资源、相互合作</p><h3 id="基于忙等的方式">基于忙等的方式<a class="anchor" href="#基于忙等的方式">·</a></h3><p>软硬件方法都不可取</p><p>Lamport面包店算法、Eisenberg算法</p><h3 id="基于信号量的方法">基于信号量的方法<a class="anchor" href="#基于信号量的方法">·</a></h3><h4 id="经典信号量机制">经典信号量机制<a class="anchor" href="#经典信号量机制">·</a></h4><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单表述</span></span><br><span class="line">P(S): <span class="keyword">while</span> S&lt;=<span class="number">0</span> <span class="keyword">do</span> skip</span><br><span class="line">  S:=S-<span class="number">1</span>;</span><br><span class="line">V(S): S:=S+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//详细表述</span></span><br><span class="line"><span class="keyword">Type</span> semaphore = <span class="keyword">record</span></span><br><span class="line">    value : integer;</span><br><span class="line">    L : list <span class="keyword">of</span> process;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">Procedure</span> <span class="title">P</span><span class="params">(S)</span></span></span><br><span class="line"><span class="function">    <span class="title">var</span> <span class="title">S</span> :</span> semaphore;</span><br><span class="line">    <span class="keyword">begin</span> </span><br><span class="line">        S.value := S.value -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> S.value&lt;<span class="number">0</span> <span class="keyword">then</span> block(S.L);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">V</span><span class="params">(S)</span></span></span><br><span class="line"><span class="function">    <span class="title">var</span> <span class="title">S</span> :</span> semaphore;</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        S.value := S.value + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> S.value&lt;=<span class="number">0</span> <span class="keyword">then</span> wakeup(S.L);</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>信号量必须且只能置一次初值，且只能由P/V操作来改变</p><h4 id="物理意义">物理意义<a class="anchor" href="#物理意义">·</a></h4><ul><li>S.value为正时表示<strong>资源的个数</strong></li><li>S.value为负时表示<strong>等待进程</strong>的<strong>个数</strong></li><li>P操作<strong>分配</strong>资源</li><li>V操作<strong>释放</strong>资源</li></ul><h4 id="应用">应用<a class="anchor" href="#应用">·</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#互斥 初始化S=1</span></span><br><span class="line"><span class="comment">#有限n并发可以把S初始值设为n</span></span><br><span class="line">P(S)   P(S)</span><br><span class="line">临界区  临界区</span><br><span class="line">V(S)   V(S)</span><br><span class="line"></span><br><span class="line"><span class="comment">#同步 初始化S=0 先运行code1 再运行code2</span></span><br><span class="line">P(S)   code1</span><br><span class="line">code2  V(S)</span><br></pre></td></tr></table></figure><h3 id="基于管程的同步与互斥">基于管程的同步与互斥<a class="anchor" href="#基于管程的同步与互斥">·</a></h3><p>管程：高级同步原语</p><p>把<strong>分散的临界区集中</strong>起来，为每个可共享资源设计一个<strong>专门机构</strong>来<strong>统一管理</strong>各进程对该资源的访问，这个<strong>专门机构</strong>称为管程。</p><p>管程互斥进入，由编译器进行实现、</p><h3 id="进程间通信-Inter-Process-Comm">进程间通信(Inter-Process-Comm)<a class="anchor" href="#进程间通信-Inter-Process-Comm">·</a></h3><ul><li>管道（Pipe）及命名管道（Named pipe或FIFO）</li><li>消息队列（Message） 两个通信原语<ul><li>send(destination, &amp;message)</li><li>receive(source, &amp;message)</li></ul></li><li>共享内存（Shared memory）<ul><li>最有用,最快</li><li>同一块物理内存被映射到进程A、B各自的进程地址空间</li><li>共享内存可以同时读但不能同时写，则需要<strong>同步机制</strong>约束</li></ul></li><li>信号量（Semaphore）</li><li>套接字（Socket）</li><li>信号（Signal）</li></ul><h2 id="4-3-经典进程同步问题">4.3 经典进程同步问题<a class="anchor" href="#4-3-经典进程同步问题">·</a></h2><h3 id="生产者－消费者问题-the-producer-consumer-problem">生产者－消费者问题(the producer consumer problem)<a class="anchor" href="#生产者－消费者问题-the-producer-consumer-problem">·</a></h3><blockquote><p>若干进程通过有限的共享缓冲区交换数据。其中，“生产者”进程不断写入，而 “消费者”进程不断读出；共享缓冲区共有 N个；任何时刻只能有一个进程可对共享缓冲区进行操作。</p></blockquote><h4 id="信号量写法">信号量写法<a class="anchor" href="#信号量写法">·</a></h4><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/4-6.png" style="zoom:50%;"><h4 id="管程写法">管程写法<a class="anchor" href="#管程写法">·</a></h4><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/4-7.png" style="zoom: 67%;"><h3 id="读者－写者问题-the-readers-writers-problem">读者－写者问题(the readers-writers problem)<a class="anchor" href="#读者－写者问题-the-readers-writers-problem">·</a></h3><blockquote><p>问题描述：对共享资源的读写操作，任一时刻 “写者”最多只允许一个，而 “读者”则允许多个，即 “读－写”互斥，“写－写”互斥，“读－读”允许</p></blockquote><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.读者占优势算法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//wmutex表示“允许写”，初值是1。 </span></span><br><span class="line"><span class="comment">//公共变量readcount表示“正在读”的进程数，初值是0； </span></span><br><span class="line"><span class="comment">//mutex表示对readcount的互斥操作，初值是1。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Writer</span></span><br><span class="line">P(wmutex);</span><br><span class="line"><span class="keyword">write</span></span><br><span class="line">V(wmutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Reader</span></span><br><span class="line">P(mutex);</span><br><span class="line">    <span class="keyword">if</span> readcount=<span class="number">0</span> <span class="keyword">then</span> P(wmutex);</span><br><span class="line">    readcount := readcount +<span class="number">1</span>;</span><br><span class="line">V(mutex);</span><br><span class="line"><span class="keyword">read</span></span><br><span class="line">P(mutex);</span><br><span class="line">    readcount := readcount -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> readcount=<span class="number">0</span> <span class="keyword">then</span> V(wmutex);</span><br><span class="line">V(mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.读写公平算法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//新增读写互斥变量rwmutex=1</span></span><br><span class="line"><span class="comment">//相当于读完1个之后不能继续下一个人读</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Writer</span></span><br><span class="line">P(rwmutex);</span><br><span class="line">P(wmutex);</span><br><span class="line"><span class="keyword">write</span></span><br><span class="line">V(wmutex);</span><br><span class="line">V(rwmutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Reader</span></span><br><span class="line">P(rwmutex);</span><br><span class="line">P(mutex);</span><br><span class="line">    <span class="keyword">if</span> readcount=<span class="number">0</span> <span class="keyword">then</span> P(wmutex);</span><br><span class="line">    readcount := readcount +<span class="number">1</span>;</span><br><span class="line">V(mutex);</span><br><span class="line">V(rwmutex);  <span class="comment">//释放rwmutex从而让写者先写</span></span><br><span class="line"><span class="keyword">read</span></span><br><span class="line">P(mutex);</span><br><span class="line">    readcount := readcount -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> readcount=<span class="number">0</span> <span class="keyword">then</span> V(wmutex);</span><br><span class="line">V(mutex);</span><br></pre></td></tr></table></figure><h3 id="哲学家进餐问题-the-dining-philosophers-problem">哲学家进餐问题(the dining philosophers problem)<a class="anchor" href="#哲学家进餐问题-the-dining-philosophers-problem">·</a></h3><blockquote><p>问题描述：（由Dijkstra首先提出并解决）5个哲学家围绕一张圆桌而坐，桌子上放着5支筷子，每两个哲学家之间放一支；</p><p>哲学家的动作包括思考和进餐，进餐时需要同时拿起他左边和右边的两支筷子，思考时则同时将两支筷子放回原处。</p><p>如何保证哲学家们的动作有序进行？如：不出现相邻者同时进餐；不出现有人永远拿不到筷子。</p></blockquote><h3 id="理发师问题">理发师问题<a class="anchor" href="#理发师问题">·</a></h3><blockquote><p>理发店里有一位理发师、一把理发椅和n把供等候理发的顾客坐的椅子；</p><p>如果没有顾客，理发师便在理发椅上睡觉，当一个顾客到来时，叫醒理发师；</p><p>如果理发师正在理发时，又有顾客来到，则如果有空椅子可坐，就坐下来等待，否则就离开。</p></blockquote><h3 id="吸烟者问题">吸烟者问题<a class="anchor" href="#吸烟者问题">·</a></h3><blockquote><p>三个吸烟者在一间房间内，还有一个香烟供应者。为了制造并抽掉香烟，每个吸烟者需要三样东西：烟草、纸和火柴。供应者有丰富的货物提供。</p><p>三个吸烟者中，第一个有自己的烟草，第二个有自己的纸，第三个有自己的火柴。</p><p>供应者将两样东西放在桌子上，允许一个吸烟者吸烟。当吸烟者完成吸烟后唤醒供应者，供应者再放两样东西（随机地）在桌面上，然后唤醒另一个吸烟者。</p><p>试为吸烟者和供应者编写程序解决问题。</p></blockquote><h2 id="4-4调度">4.4调度<a class="anchor" href="#4-4调度">·</a></h2><h3 id="基本概念-2">基本概念<a class="anchor" href="#基本概念-2">·</a></h3><p>控制协调多个进程对CPU的竞争</p><h4 id="调度类型">调度类型<a class="anchor" href="#调度类型">·</a></h4><ul><li>高级调度：接纳多少个作业，接纳哪些作业</li><li>中级调度：内外存交换</li><li>低级调度：CPU资源角度，非抢占式和抢占式（时间片原则，优先权原则，短作业（进程）优先</li></ul><h3 id="设计调度算法要考虑的问题（设计要点）">设计调度算法要考虑的问题（设计要点）<a class="anchor" href="#设计调度算法要考虑的问题（设计要点）">·</a></h3><h4 id="进程优先级（数）">进程优先级（数）<a class="anchor" href="#进程优先级（数）">·</a></h4><p>优先数反映了某个优先级</p><p>静态优先级、动态优先级</p><h4 id="进程就绪队列组织">进程就绪队列组织<a class="anchor" href="#进程就绪队列组织">·</a></h4><p>按优先级排队方式</p><h4 id="占用CPU的方式">占用CPU的方式<a class="anchor" href="#占用CPU的方式">·</a></h4><ul><li><strong>不可抢占式方式</strong>。一直占用处理器，直到该进程自己因调用原语操作，或等待I/O等原因进入阻塞状态，或时间片用完时才让出处理器，重新进行。</li><li><strong>抢占式方式</strong>。就绪队列中一旦有优先级高于当前运行进程优先级的进程存在时，便立即进行进程调度，把处理器转给优先级高的进程</li></ul><h4 id="进程的分类">进程的分类<a class="anchor" href="#进程的分类">·</a></h4><h4 id="分类1">分类1<a class="anchor" href="#分类1">·</a></h4><ul><li>I/O Bound（I/O密集型）</li><li>CPU bound（CPU密集型）</li></ul><h4 id="分类2">分类2<a class="anchor" href="#分类2">·</a></h4><ul><li>批处理进程（Batch Process) 编译器，科学计算</li><li>交互式进程（Interactive Process) Word 触控性GUI</li><li>实时进程（Real-time Process) 视频、音频</li></ul><h3 id="批处理系统的调度算法">批处理系统的调度算法<a class="anchor" href="#批处理系统的调度算法">·</a></h3><h4 id="吞吐量、平均等待时间和平均周转时间">吞吐量、平均等待时间和平均周转时间<a class="anchor" href="#吞吐量、平均等待时间和平均周转时间">·</a></h4><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/4-8.png" style="zoom: 67%;"><h4 id="批处理常用调度算法">批处理常用调度算法<a class="anchor" href="#批处理常用调度算法">·</a></h4><ul><li><strong>先来先服务</strong>（FCFS：First Come First Serve)。<ul><li>按先后次序分派CPU，当前进程或作业直到执行完或阻塞才让出CPU。唤醒进程后等到当前作业或进程让出CPU。</li><li>利于长作业，不利于短作业</li><li>利于CPU密集型，不利于IO密集型</li></ul></li><li><strong>最短作业优先</strong>（SJF：Shortest Job First)<ul><li>对长作业不利</li></ul></li><li><strong>最短剩余时间优先</strong>（SRTF：Shortest Remaining Time First）<ul><li><strong>短作业改进</strong>为<strong>抢占式</strong>。新就绪进程比当前进程完成时间更短，则抢占。</li></ul></li><li><strong>最高响应比优先</strong>（HRRF：Highest Response Ratio First）<ul><li>响应比：$RP=1+\frac {已等待时间} {要求运行时间}$</li><li>既照顾了短作业，又不让长作业等太久</li></ul></li></ul><h3 id="交互式系统">交互式系统<a class="anchor" href="#交互式系统">·</a></h3><ul><li><p><strong>时间片轮转</strong>(RR：Round Robin)</p><ul><li>排队(FCFS原则)—轮转(每次就绪队列队首进程执行一个时间片)—中断(时间片结束发生中断)—抢占（暂停当前进程并移到就绪队列末尾)—出让(可以未使用完时间片就出让)</li><li>静态动态优先级</li></ul></li><li><p><strong>多级队列</strong>(MQ：Multi-level Queue)</p><ul><li>引入多个就绪队列，并区别对待各个队列</li></ul></li><li><p><strong>多级反馈队列</strong>(MFQ： Multi-level Feedback Queue)</p></li></ul><h3 id="实时系统">实时系统<a class="anchor" href="#实时系统">·</a></h3><ul><li>静态表调度Static table-driven scheduling</li><li>单调速率调度RMS：Rate Monotonic Scheduling</li><li>最早截止时间优先算法EDF：Earliest Deadline First</li></ul><h3 id="多处理机调度">多处理机调度<a class="anchor" href="#多处理机调度">·</a></h3><ul><li>自调度</li><li>成组调度</li><li>专用处理机调度</li></ul><h2 id="4-5-死锁">4.5 死锁<a class="anchor" href="#4-5-死锁">·</a></h2><blockquote><p><strong>死锁定义</strong>：一组进程中，每个进程都<strong>无限等待</strong>被该组进程中其它进程所占有的资源，在无外力介入的条件下，将因<strong>永远分配不到资源</strong>而<strong>无法运行</strong>的现象。</p></blockquote><p><strong>发生原因</strong></p><ul><li>资源<strong>竞争</strong></li><li>并行<strong>执行顺序</strong>不当</li></ul><h3 id="死锁发生的四个必要条件">死锁发生的四个必要条件<a class="anchor" href="#死锁发生的四个必要条件">·</a></h3><ul><li>互斥条件</li><li>请求和占有条件</li><li>不可剥夺条件</li><li>环路等待条件</li></ul><h3 id="死锁预防-2">死锁预防<a class="anchor" href="#死锁预防-2">·</a></h3><ul><li>打破互斥条件</li><li>打破占有且申请条件</li><li>打破不可剥夺条件</li><li>打破循环等待条件</li></ul><h3 id="资源分配图（RAG）算法">资源分配图（RAG）算法<a class="anchor" href="#资源分配图（RAG）算法">·</a></h3><p>有向图G的顶点为资源或进程，从<strong>资源R到进程P</strong>的边表示<strong>R已分配给P</strong>，从<strong>进程P到资源R</strong>的边表示<strong>P正因请求R</strong>而处于<strong>等待</strong>状态。</p><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/4-10.png" style="zoom:80%;"><h4 id="封锁进程">封锁进程<a class="anchor" href="#封锁进程">·</a></h4><p>是指某个进程由于请求了超过了系统中现有的未分配资源数目的资源，而被系统封锁的进程。</p><h4 id="非封锁进程">非封锁进程<a class="anchor" href="#非封锁进程">·</a></h4><p>即没有被系统封锁的进程</p><h4 id="资源分配图的化简方法">资源分配图的化简方法<a class="anchor" href="#资源分配图的化简方法">·</a></h4><p>假设某个RAG中存在一个进程Pi，此刻Pi是非封锁进程，那么可以进行如下化简：</p><p>当Pi有请求边时，首先将其请求边变成分配边(即满足Pi的资源请求)，而一旦Pi的所有资源请求都得到满足，Pi就能在有限的时间内运行结束，并释放其所占用的全部资源，此时Pi只有分配边，删去这些分配边（实际上相当于消去了Pi的所有请求边和分配边），使Pi成为孤立结点。（反复进行）</p><h4 id="死锁定理">死锁定理<a class="anchor" href="#死锁定理">·</a></h4><p>系统中某个时刻<strong>t为死锁状态</strong>的充要条件是t时刻系统的<strong>资源分配图是不可完全化简</strong>的。</p><p>在经过<strong>一系列的简化</strong>后，若<strong>能消去图中的所有边</strong>，使所有的进程都成为孤立结点，则称该图是<strong>可完全化简</strong>的；反之的是不可完全化简的</p><h3 id="安全序列与安全状态">安全序列与安全状态<a class="anchor" href="#安全序列与安全状态">·</a></h3><p><strong>安全状态</strong>：系统存在一个进程执行序列&lt;p1,p2,…pn&gt;可顺利完成（里面有一个进程需要的附加资源可以被当前系统中可用资源加上上所有进程Pj（j &lt; i）当前占有资源之和所满足</p><p>不安全状态不一定死锁，但死锁一定不安全</p><h4 id="安全与不安全示例">安全与不安全示例<a class="anchor" href="#安全与不安全示例">·</a></h4><img src="/2021/06/07/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/4-9.png" style="zoom:67%;">]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-OS-2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OO-Unit3-总结</title>
      <link href="2021/05/31/OO-Unit3-%E5%B0%8F%E7%BB%93/"/>
      <url>2021/05/31/OO-Unit3-%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>OO第三单元JML规格设计学习总结与分析</p><h1 id="OO-Unit3-总结">OO-Unit3-总结<a class="anchor" href="#OO-Unit3-总结">·</a></h1><h2 id="1-JML规格设计策略">1.JML规格设计策略<a class="anchor" href="#1-JML规格设计策略">·</a></h2><p>由于JML的规格描述较复杂，本单元的JML规格设计我往往采用<strong>由简入难</strong>的<strong>迭代开发</strong>策略。</p><p>即一开始不着急开发出最为复杂，性能最好的代码，先<strong>严格按照JML</strong>描述写一遍代码，<strong>实现基本功能</strong>。比如类似<code>public instance model non_null Person[] acquaintance;</code>这样的规格，第9次作业开始时先直接按照<code>ArrayList</code>处理，这样各个函数中实际的代码和JML描述近乎一致，<strong>方便检查</strong>。之后在完成了基本功能后，在已经理解了基本功能描述后，对各个容器和方法算法性能进行<strong>优化设计迭代</strong>。</p><p>同时，一般简单的方法和容器设计虽然性能较差，但正确性一般较好，因此个人认为也可以作为之后的迭代优化版本的<strong>正确性测试参考的标程</strong>（不过实际开发过程中也不可能先开发一版低性能保证正确性，所以还是直接全盘考虑好再写高效一点）。</p><p>对于每个方法而言。先确定<code>normal_behavior</code>和<code>exceptional_behavior</code>。确定进入函数后不同参数对应的<strong>分支条件</strong>。并把<strong>条件判断语句</strong>写好，搭好基本框架。之后再看<code>assignable</code>会涉及到的变量。再根据<code>ensures</code>确定<strong>结果返回值</strong>和应该如何<strong>改动变量</strong>。对于异常处理里的分支逻辑也是类似的编写方式。此外，每个方法编写时也可以通过函数名字推敲涵义，从而提高正确性。</p><p>同时对于迭代增量开发，每次都要重新阅读<strong>之前实现过的方法内的JML规格</strong>，因为可能会发生变化，比如第二次到第三次作业中的<code>sendMessage</code>方法。此外要特别注意<strong>JML没写出</strong>，但是你<strong>需要实现</strong>的代码，比如<code>MyGroup内的delPerson方法</code>，如果输入的<code>person</code>是个<code>null</code>需要直接返回；<code>MyPerson</code>类内需要加一个<code>addAcquaitance</code>方法以及<code>getAcquaitance</code>方法等。</p><h2 id="2-JML测试方法和策略">2.JML测试方法和策略<a class="anchor" href="#2-JML测试方法和策略">·</a></h2><p>本单元的JML规格设计由于JML细节较多，很难保证某一份代码是完全正确的，因此测试上最方便最简单的当然就是<strong>多人对拍找少数派</strong>（即<s>多人运动</s>）的方式了。这个方法在<strong>第一单元</strong>中也用到过，总结来说，对于这种<strong>输入一样</strong>，<strong>输出结果</strong>就应该一样的代码，这种方式测试效率还是很高的。此外，还有Junit单元测试，以及openJML等其他JML工具。</p><h3 id="Junit单元测试">Junit单元测试<a class="anchor" href="#Junit单元测试">·</a></h3><p>Junit测试简单，可以进行对类内每个方法编写自己的测试逻辑。IDEA里最简单的使用方式就是<code>右键点击代码里的类名--&gt;点击Go to--&gt;点击Test</code>，选择<strong>需要测试的函数</strong>和<strong>选项</strong>，就生成了<strong>测试文件</strong>。</p><p>本单元中主要针对一些比较容易出现错误的方法比如<code>isCircle</code>和<code>queryBlockSum</code>进行了测试，以这两个函数为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.oocourse.spec3.exceptions.PersonIdNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.assertEquals;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.assertFalse;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.assertTrue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNetworkTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyPerson pa = <span class="keyword">new</span> MyPerson(<span class="number">1</span>, <span class="string">"a"</span>, <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyPerson pb = <span class="keyword">new</span> MyPerson(<span class="number">2</span>, <span class="string">"b"</span>, <span class="number">13</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyPerson pc = <span class="keyword">new</span> MyPerson(<span class="number">3</span>, <span class="string">"c"</span>, <span class="number">14</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyPerson pd = <span class="keyword">new</span> MyPerson(<span class="number">4</span>, <span class="string">"d"</span>, <span class="number">15</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyPerson pe = <span class="keyword">new</span> MyPerson(<span class="number">5</span>, <span class="string">"e"</span>, <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyPerson pf = <span class="keyword">new</span> MyPerson(<span class="number">6</span>, <span class="string">"f"</span>, <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">private</span> MyNetwork net = <span class="keyword">new</span> MyNetwork();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        net.addPerson(pa);</span><br><span class="line">        net.addPerson(pb);</span><br><span class="line">        net.addPerson(pc);</span><br><span class="line">        net.addPerson(pd);</span><br><span class="line">        net.addPerson(pe);</span><br><span class="line">        net.addPerson(pf);</span><br><span class="line">        net.addRelation(<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">        net.addRelation(<span class="number">1</span>, <span class="number">3</span>, <span class="number">20</span>);</span><br><span class="line">        net.addRelation(<span class="number">3</span>, <span class="number">4</span>, <span class="number">10</span>);</span><br><span class="line">        net.addRelation(<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">        net.addRelation(<span class="number">3</span>, <span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">isCircle</span><span class="params">()</span> <span class="keyword">throws</span> PersonIdNotFoundException </span>&#123;</span><br><span class="line">        assertTrue(net.isCircle(<span class="number">1</span>, <span class="number">4</span>));</span><br><span class="line">        assertFalse(net.isCircle(<span class="number">1</span>, <span class="number">6</span>));</span><br><span class="line">        assertTrue(net.isCircle(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">queryBlockSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(<span class="number">2</span>, net.queryBlockSum());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后就会出现<strong>令人舒适</strong>的评测信息，这样的单元测试，怎能不爱😍。</p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit3/8.png" style="zoom:80%;"><p>一般来说就在<code>BeforeEach</code>和<code>AfterEach</code>里分别编写数据构造和初始化以及其他的评测信息。但是注意到这样的测试方式是对于每个<code>@Test</code>处的函数都分别调用了一次测试，即每个这样的函数对应一个点。这样有时体现不出一个类整体连续性，比如某几个方法之间的联系。参考官网写出了连续的测试方式，相当于所有方法在一次程序执行内跑完。</p><p>同时，Junit实在太强大，几乎可以测试所有的情况，比如空指针，异常抛出等，用以下代码举例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nested</span></span><br><span class="line">  <span class="meta">@DisplayName</span>(<span class="string">"when new"</span>)</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">WhenNew</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> MyPerson pa = <span class="keyword">new</span> MyPerson(<span class="number">1</span>, <span class="string">"a"</span>, <span class="number">12</span>);</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> MyPerson pb = <span class="keyword">new</span> MyPerson(<span class="number">2</span>, <span class="string">"b"</span>, <span class="number">13</span>);</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> MyPerson pc = <span class="keyword">new</span> MyPerson(<span class="number">3</span>, <span class="string">"c"</span>, <span class="number">14</span>);</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> MyPerson pd = <span class="keyword">new</span> MyPerson(<span class="number">4</span>, <span class="string">"d"</span>, <span class="number">15</span>);</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> MyPerson pe = <span class="keyword">new</span> MyPerson(<span class="number">5</span>, <span class="string">"e"</span>, <span class="number">16</span>);</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> MyPerson pf = <span class="keyword">new</span> MyPerson(<span class="number">6</span>, <span class="string">"f"</span>, <span class="number">16</span>);</span><br><span class="line">      <span class="keyword">private</span> MyNetwork net = <span class="keyword">new</span> MyNetwork();</span><br><span class="line"></span><br><span class="line">      <span class="meta">@BeforeEach</span></span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">createNewNetwork</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">          net = <span class="keyword">new</span> MyNetwork();</span><br><span class="line">          net.addPerson(pa);</span><br><span class="line">          net.addPerson(pb);</span><br><span class="line">          net.addPerson(pc);</span><br><span class="line">          net.addPerson(pd);</span><br><span class="line">          net.addPerson(pe);</span><br><span class="line">          net.addPerson(pf);</span><br><span class="line">          net.addRelation(<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">          net.addRelation(<span class="number">1</span>, <span class="number">3</span>, <span class="number">20</span>);</span><br><span class="line">          net.addRelation(<span class="number">3</span>, <span class="number">4</span>, <span class="number">10</span>);</span><br><span class="line">          net.addRelation(<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">          net.addRelation(<span class="number">3</span>, <span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Test</span></span><br><span class="line">      <span class="meta">@DisplayName</span>(<span class="string">"throws MyPersonIdNotFoundException when query a unexist id"</span>)</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">throwsMyPersonIdNotFoundException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          assertThrows(MyPersonIdNotFoundException<span class="class">.<span class="keyword">class</span>, () -&gt; <span class="title">net</span>.<span class="title">addRelation</span>(1, 7, 10))</span>; <span class="comment">//这里的()-&gt;是个啥实在没理解，但是加上就可以这么测试了</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Nested</span></span><br><span class="line">      <span class="meta">@DisplayName</span>(<span class="string">"after init"</span>)</span><br><span class="line">      <span class="class"><span class="keyword">class</span> <span class="title">AfterInit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Test</span></span><br><span class="line">          <span class="meta">@DisplayName</span>(<span class="string">"contains"</span>)</span><br><span class="line">          <span class="function"><span class="keyword">void</span> <span class="title">containsTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              assertTrue(net.contains(<span class="number">4</span>));</span><br><span class="line">              assertFalse(net.contains(<span class="number">10</span>));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Test</span></span><br><span class="line">          <span class="meta">@DisplayName</span>(<span class="string">"qps test"</span>)</span><br><span class="line">          <span class="function"><span class="keyword">void</span> <span class="title">queryPeopleSumTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              assertEquals(<span class="number">6</span>, net.queryPeopleSum());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="Python对拍评测">Python对拍评测<a class="anchor" href="#Python对拍评测">·</a></h3><p>与第一单元类似，主要分为<strong>双人对拍</strong>和<strong>多人运动</strong>。本次作业单独写了两个文件。<code>relation_testdata</code>产生测试数据。<code>relationTest</code>进行对拍测试。</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit3/2.png" alt></p><p>测试数据产生主要分为<strong>随机生成用例</strong>和生成复杂的<strong>卡时间的用例</strong>。具体的生成的方式都封装在<code>getOneTestPoint()</code>方法中。根据<strong>作业次数</strong>和<strong>数据特点变量</strong>生成相应用例。其中随机生成用例要保证一定的强度，比如每个测试点都是5000条指令，保证每个测试点覆盖了所有的指令（对每个指令的个数进行计数）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">datas_src = <span class="string">"test_data/"</span></span><br><span class="line">n = <span class="number">100</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        src = datas_src + <span class="string">"%d.txt"</span> % (i + <span class="number">1</span>)</span><br><span class="line">        writeToFile(getOneTestPoint(), src)</span><br></pre></td></tr></table></figure><p>对拍测试中先进行<strong>多人团建</strong>。挨个检查所有每个文件对测试点的CPU使用时间测试性能。之后再通过比对所有人的答案检验正确性。如果大家答案均一样且没有人超时，则认为所有人正确。这里使用的是<code>test</code>函数，对输入的一个<code>jar</code>文件名字列表进行处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    nameList = [<span class="string">'Archer.jar'</span>, <span class="string">'Saber.jar'</span>, <span class="string">'Rider.jar'</span>, <span class="string">'Caster.jar'</span>, <span class="string">'Berserker.jar'</span>, <span class="string">'Assassin.jar'</span>]</span><br><span class="line">    test(nameList)</span><br></pre></td></tr></table></figure><p>效果如下</p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit3/3.png" style="zoom:80%;"><p>在一波多人运动后，一般会发现团队中有个别成员（比如自己的代码）存在一定的问题，这时就可以选择<code>1-2</code>个优秀的成员作为<strong>标程</strong>和其他代码进行对拍。使用<code>beatTest</code>函数进行<strong>重点爆破</strong>，提高寻找<code>bug</code>的效率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beatTest(<span class="string">'homework11.jar'</span>, <span class="string">'Berserker.jar'</span>)</span><br></pre></td></tr></table></figure><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit3/6.png" style="zoom:80%;"><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit3/7.png" style="zoom:80%;"><p>总的来说，1、3单元对多人的代码进行测试的方式比较可取的就是每个人单独跑数据看时间，使用多人对拍评价正确性。</p><h3 id="openJML工具使用">openJML工具使用<a class="anchor" href="#openJML工具使用">·</a></h3><p>代码静态检查命令如下，感觉输出好奇怪，调了半天也没调好，只好放弃了。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java <span class="literal">-jar</span> .\openjml.jar <span class="literal">-exec</span> (SMT Solvers的路径) .\Solvers<span class="literal">-windows</span>\z3<span class="literal">-4</span>.<span class="number">7.1</span>.exe <span class="literal">-esc</span> <span class="literal">-dir</span> (项目目录)</span><br><span class="line">java <span class="literal">-jar</span> .\openjml.jar <span class="literal">-exec</span> .\Solvers<span class="literal">-windows</span>\z3<span class="literal">-4</span>.<span class="number">7.1</span>.exe <span class="literal">-esc</span> <span class="literal">-dir</span> ..\test_src\Archer\src\</span><br><span class="line">java <span class="literal">-jar</span> openjml.jar <span class="literal">-esc</span> <span class="literal">-progress</span> MyPerson.java</span><br></pre></td></tr></table></figure><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit3/9.png" alt></p><h3 id="JMLUnitNG">JMLUnitNG<a class="anchor" href="#JMLUnitNG">·</a></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -jar jmlunitng.jar test/MyGroup.java</span><br><span class="line">javac -cp jmlunitng.jar test/MyGroup.java</span><br><span class="line">java -cp jmlunitng.jar test.MyGroup_JML_Test</span><br></pre></td></tr></table></figure><p>这种方式只检查了边界数据，因此只是简单了解了一下，没有怎么使用。</p><h2 id="3-容器选择与使用">3.容器选择与使用<a class="anchor" href="#3-容器选择与使用">·</a></h2><p>由于本单元作业需要对容器内元素进行高频率增删改查的操作，选用普通数组实现JML效率非常低下，因此大部分容器都采用<code>HashMap</code>进行设计。</p><h3 id="homework9">homework9<a class="anchor" href="#homework9">·</a></h3><p>本次作业由于性能要求较低，除了为了<code>isCircle</code>函数的广度优先搜索算法编写的<code>visit</code>数组使用了<code>HashMap&lt;MyPerson,Boolean&gt;</code>外其余的容器均使用<code>ArrayList</code>，即<code>acquaintance/value/people</code>。使用时基本和<code>JML</code>描述写法一致。</p><h3 id="homework10-homework11">homework10/homework11<a class="anchor" href="#homework10-homework11">·</a></h3><p>在这两次作业中由于指令数量增多，性能要求提升，将第9次作业中所有的<code>ArrayList</code>全部替换成了<code>HashMap</code>。包括<code>MyNetwork</code>类中的<code>people/id2group/id2message/id2bossid</code>以及<code>MyPerson</code>中的<code>acquaintance</code>。同时新增的方法和变量也尽量使用了<code>HashMap</code>保证性能要求。</p><h2 id="4-bug分析">4.bug分析<a class="anchor" href="#4-bug分析">·</a></h2><p>本单元的bug主要集中在两方面，即：</p><ul><li>因为JML阅读不细致导致的程序<strong>正确性</strong>问题。</li><li>因为算法/容器设计不合理导致的<strong>CPU时间</strong>问题。</li></ul><h3 id="homework9-2">homework9<a class="anchor" href="#homework9-2">·</a></h3><h4 id="自己的bug-7">自己的bug<a class="anchor" href="#自己的bug-7">·</a></h4><p>这一次作业性能要求不高，但由于没有仔细思考，采用了<code>dfs</code>算法进行<code>isCircle</code>函数设计，同时在<code>qbs</code>函数中直接采用二层循环进行遍历查找，导致非常慢，出现了性能问题。强测被hack一个点，互测被hack7个点，全部是<code>CTLE</code>。修复<code>bug</code>时将<code>isCircle</code>采用<code>bfs</code>实现<code>qbs</code>和<code>isCircle</code>函数。</p><h4 id="他人的bug-7">他人的bug<a class="anchor" href="#他人的bug-7">·</a></h4><p>测试时由于这一单元正确性较简单，主要针对多人的复杂网络进行了数据构造，至少增加200人以及200条关系之后在最后的几百条指令全部用<code>qbs</code>和<code>qci</code>进行轰炸。效果还可，很快就刀到了两个同样使用<code>dfs</code>的难兄难弟，之后基本就收手了，看了房间里被hack的代码都是这两个的性能问题导致。</p><h3 id="homework10">homework10<a class="anchor" href="#homework10">·</a></h3><p>本次作业个人测试时主要注重性能，没有很关注正确性，导致代码里有大量正确性问题，导致第一次没进互测，心态崩溃的同时，也对各个写错的地方认真进行了审视。</p><h4 id="自己的bug-8">自己的bug<a class="anchor" href="#自己的bug-8">·</a></h4><ul><li><code>MyGroup</code>类内删除人的时候没有把总年龄和减去删除的人的年龄导致错误。</li><li><code>MyNetwork</code>类<code>addToGroup</code>方法内不存在新加的人且<code>group</code>内人数大于等于1111时没有直接返回而是进入了异常。异常里存在这个人时。<code>addMessage</code>内当加入的邮件里两个人id相同时抛出异常使用的id是<code>messageId</code>。</li><li><code>sendMeesage</code>方法内当类型为0时没有把<code>person1</code>加入<code>person2</code>的关系数组里。</li><li><code>getReceivedMessages</code>方法内误以为只返回一个小于等于3的<code>Message</code>数组，实际上是返回一个小于等于4的<code>Message</code>数组。</li></ul><p>这次作业的bug主要都是因为在阅读JML代码时过于草率，很多地方都是漏看了一句话导致了问题的出现，且测试不够充分。这启发我在以后的JML规格编写时要认真细致地阅读每一行说明，编写后要进行充分细致的单元测试和黑箱测试。此外，本次作业在自己构造数据时往往关注时间，构造了和第一次差不多的数据，对第二次作业涉及的指令覆盖很有限，这也导致了问题的出现。同时之后也发现自己的测试脚本中也是有问题的，很多时候可能测试数据里只有第一次的指令，因此问题也很难找出来。所以以后对自己的测试数据生成脚本不能过于自信，要仔细审查。</p><p>正确性虽然被<code>hack</code>惨了，但是时间性能上由于使用了<strong>并查集</strong>进行搜索，没有出现问题。并查集对每个新进入的人先设置他的<code>bossid</code>为他自己的<code>id</code>，之后新增的关系中，如果他们的bossid不一样，则把一个人的最高级的<code>bossid</code>（<code>p.bossid==p.id</code>)设置为另一个人的最高级<code>bossid</code>即可。</p><h3 id="homework11">homework11<a class="anchor" href="#homework11">·</a></h3><h4 id="自己的bug-9">自己的bug<a class="anchor" href="#自己的bug-9">·</a></h4><p>本次强测互测均未被hack。</p><p>有了上一次的惨痛教训，本次在测试时非常细致，结合了ch大佬的数据和自己的数据进行了多轮校验。这次自测时仍然找出来了与上次作业中类似的正确性的错误，对于各个类中的方法进行了多次修改，值得一提的是很多错误都是由于想当然以为上次的方法这次不变导致的，这一点以后也需要注意。同时重点设计了最短路径查找算法，使用了堆优化的<code>Dijistra</code>算法，新增一个Node节点类保存了距离和id，使用优先队列模拟堆，避免了每一轮循环都进行全部的遍历查找，保证了时间性能。此外在<code>MyGroup</code>类中加入了<code>valueSum</code>变量，每次有人员变动时就修改<code>valueSum</code>。从而保证了<code>qgvs</code>指令的性能。</p><h4 id="他人的bug-8">他人的bug<a class="anchor" href="#他人的bug-8">·</a></h4><p>本次由于限制了5000条指令，且上限为6s，从时间上hack是极难，尝试构造了很多复杂的数据都未成功。最后通过大量随机生成用例hack了一人。阅读代码发现是经典的问题：<code>isCircle</code>函数输入相同的<code>id</code>时没有返回<code>true</code></p><h2 id="5-作业架构设计">5.作业架构设计<a class="anchor" href="#5-作业架构设计">·</a></h2><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit3/Top-Level Package.png" style="zoom:80%;"><p>本单元作业架构相对固定且是官方给出的，每个基本类相对固定，活动空间主要是对于图模型的管理维护。由于代码量并不大，本单元我直接将全部的图相关算法和主要数据、方法都写在了<code>MyNetwork</code>类内，同时将具体算法函数与功能函数分开。在<code>isCircle</code>内调用不同的<code>find</code>方法从而方便优化性能，有过<code>dfsFind(id1,id2)  bfsFind(id1,id2)  unionFind(id1,id2)</code>共三个查找的算法函数。同时在<code>sendIndirectMessage</code>函数中也是调用<code>Dijistra</code>函数进行操作，且调动了一个外部类<code>Node</code>进行堆优化操作。同时，使用一个<code>HashMap</code>保存每个PersonId对应的<code>bossId</code>进行并查集数据管理。</p><p>同时，各个类内最终都基本使用了<code>HashMap</code>作为数组的实现容器，且这些都采用<code>id</code>作为<code>key</code>值进行查找。</p><p>本次的异常类采用<code>static</code>类<code>count</code>对异常数据进行管理，确定了统一接口进行查询和存储异常次数。每次新增时只需要新增新的<code>HashMap</code>的<code>key</code>值即可。</p><h2 id="6-感想与体会">6.感想与体会<a class="anchor" href="#6-感想与体会">·</a></h2><ul><li>本单元是圣杯战争最后一战了，回想参加的8次互测，整体来说体验还是很好的，在这个过程中学到了不少和测试相关的知识，也加深了对java和python这两门语言的理解。非常感谢课程组给我们设置的这种课程体制，让我们对测试这门艺术有所理解和掌握</li><li>JML对代码的限制还是很强的，之后在开发之前不妨先写上JML再进行后续的开发，这样正确性能够有大幅提升。同时，JML也确实太复杂了，感谢为我们的作业献出那么多力量的助教和老师们，真的辛苦你们了！</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-OO-2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OO-Unit2-总结</title>
      <link href="2021/04/24/OO-Unit2-%E5%B0%8F%E7%BB%93/"/>
      <url>2021/04/24/OO-Unit2-%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>OO第二单元电梯调度总结与分析。</p><h1 id="OO-Unit2-总结">OO-Unit2-总结<a class="anchor" href="#OO-Unit2-总结">·</a></h1><h2 id="一、程序结构分析-2">一、程序结构分析<a class="anchor" href="#一、程序结构分析-2">·</a></h2><h3 id="第五次作业">第五次作业<a class="anchor" href="#第五次作业">·</a></h3><h4 id="代码可视化与数据统计-4">代码可视化与数据统计<a class="anchor" href="#代码可视化与数据统计-4">·</a></h4><h5 id="程序类图-4">程序类图<a class="anchor" href="#程序类图-4">·</a></h5><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit2/hw5.png" style="zoom:80%;"><p>由于本次只有一台电梯，因此没有使用调度器，而是只设计了一个策略类<code>Scheduler</code>类来实现每到一个楼层根据当前等待的乘客和电梯中的乘客请求来确定目标楼层的功能。而电梯类和输入线程类则是本次作业的两个线程类，分别对应消费者和生产者。</p><h5 id="程序复杂度分析-4">程序复杂度分析<a class="anchor" href="#程序复杂度分析-4">·</a></h5><ul><li>类复杂度</li></ul><table><thead><tr><th>Class</th><th>OCavg</th><th>OCmax</th><th>WMC</th></tr></thead><tbody><tr><td>Elevator</td><td>4.5</td><td>7</td><td>18</td></tr><tr><td>InitQueue</td><td>1</td><td>1</td><td>7</td></tr><tr><td>InputThread</td><td>2</td><td>3</td><td>4</td></tr><tr><td>Main</td><td>2</td><td>2</td><td>2</td></tr><tr><td>Scheduler</td><td>8</td><td>16</td><td>40</td></tr><tr><td>WaitQueue</td><td>1</td><td>1</td><td>7</td></tr></tbody></table><p>可以看出，在<code>Elevator</code>类和<code>Scheduler</code>类中代码复杂度较高。两者构成了电梯的核心逻辑，包含较多分支。</p><ul><li>方法复杂度</li></ul><table><thead><tr><th>Method</th><th>CogC</th><th>ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>Elevator.Elevator(WaitQueue,InitQueue,String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.move(int)</td><td>6</td><td>3</td><td>3</td><td>5</td></tr><tr><td>Elevator.personFlow()</td><td>11</td><td>1</td><td>8</td><td>8</td></tr><tr><td>Elevator.run()</td><td>25</td><td>4</td><td>11</td><td>11</td></tr><tr><td>InitQueue.InitQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.addRequest(PersonRequest)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.clearQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.close()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.getRequests()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.isEnd()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.noWaiting()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InputThread.InputThread(WaitQueue,ElevatorInput)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InputThread.run()</td><td>7</td><td>3</td><td>4</td><td>4</td></tr><tr><td>Main.main(String[])</td><td>5</td><td>1</td><td>5</td><td>5</td></tr><tr><td>Scheduler.Scheduler(WaitQueue,InitQueue,String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Scheduler.getDesFloor(int)</td><td>49</td><td>13</td><td>15</td><td>21</td></tr><tr><td>Scheduler.getFloor(int,int)</td><td>26</td><td>7</td><td>3</td><td>15</td></tr><tr><td>Scheduler.getMorningFloor(int,int)</td><td>13</td><td>4</td><td>2</td><td>8</td></tr><tr><td>Scheduler.getNightFloor(int,int)</td><td>13</td><td>4</td><td>2</td><td>8</td></tr><tr><td>WaitQueue.WaitQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.addRequest(PersonRequest)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.clearQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.close()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.getRequests()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.isEnd()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.noWaiting()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>可以看到，<code>getDesFloor、getFloor</code>方法和电梯类中的<code>run</code>方法由于需要处理电梯的运行，调用了很多其他方法和变量，复杂度较高。</p><h5 id="程序行数统计-4">程序行数统计<a class="anchor" href="#程序行数统计-4">·</a></h5><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit2/hw5line.png" alt></p><p>与之前代码复杂度分析保持一致，仍然是<code>Elevator</code>类和<code>Scheduler</code>类的行数最多。总有效代码函数为423行。</p><h4 id="代码分析-4">代码分析<a class="anchor" href="#代码分析-4">·</a></h4><h5 id="原理分析-4">原理分析<a class="anchor" href="#原理分析-4">·</a></h5><p>本次作业定义了一个<code>waitqueue</code>作为生产者消费者之间的托盘，在各个类之间进行共享。当<code>Main</code>类开始后，先读入这份数据的到达模式，之后启动输入线程和电梯线程，输入线程不断读入新的请求，将请求加入到等待队列中，同时<code>Elevator</code>类不断处理等待队列中的请求，处理时每到一个新的楼层就会询问<code>Scheduler</code>类获得新的目标楼层。当输入到EOF时，输入线程结束。电梯内外的全部请求都处理结束时，电梯线程也结束，之后<code>Main</code>类主线程就会结束。</p><p>具体对于三种到达模式。<code>Random</code>直接使用了<code>ALS</code>进行调度。而<code>Morning</code>模式下则是先等待2s再开始接送乘客，且当电梯内没有乘客时自动返回1楼。<code>Night</code>模式下则是对当前的等待队列进行从大到小的排序，先接高楼层的乘客，接满后直接返回1层，反复如此进行下去。</p><h5 id="同步块的设置和锁的选择">同步块的设置和锁的选择<a class="anchor" href="#同步块的设置和锁的选择">·</a></h5><p>本次的共享变量主要有<code>waitqueue</code>和<code>initqueue</code>。前者被电梯类，策略类和输入类三者共享，后者只被电梯类和策略类两者共享（此处忽略了同样共享的主类）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Elevator.run</span></span><br><span class="line"><span class="keyword">if</span> (initQueue.noWaiting() &amp;&amp; waitQueue.noWaiting()) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (waitQueue) &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            waitQueue.wait(); <span class="comment">//等待队列为空，需要先等输入线程接受新的输入</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pattern.equals(<span class="string">"Night"</span>)) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (waitQueue.getRequests()) &#123; <span class="comment">//Night模式下需要排序，给waitQueue类里的请求列表加锁</span></span><br><span class="line">        waitQueue.getRequests()</span><br><span class="line">            .sort(Comparator.comparingInt(PersonRequest::getFromFloor)); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//InputThread.run</span></span><br><span class="line"><span class="keyword">synchronized</span> (waitQueue) &#123; <span class="comment">//给waitQueue加锁保证线程安全</span></span><br><span class="line">    <span class="keyword">if</span> (request == <span class="keyword">null</span>) &#123;</span><br><span class="line">        waitQueue.close();</span><br><span class="line">        waitQueue.notifyAll(); <span class="comment">//输入结束时唤醒等待队列，让Elevator类继续处理请求</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            elevatorInput.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        waitQueue.addRequest(request);</span><br><span class="line">        waitQueue.notifyAll(); <span class="comment">//有新的输入时唤醒等待队列，让Elevator类继续处理请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Main.main </span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    inputThread.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    elevator.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="comment">//等两个线程均结束，主线程才结束</span></span><br></pre></td></tr></table></figure><h5 id="优点-4">优点<a class="anchor" href="#优点-4">·</a></h5><p>架构较为清晰，每个类的功能都比较独立，且将策略类和电梯类分开，易于更换策略。对一个电梯的建模比较完整，便于第六次作业中增加电梯。</p><h5 id="缺点-4">缺点<a class="anchor" href="#缺点-4">·</a></h5><p><code>Random</code>模式下只采用了标准的ALS调度方式，导致性能较差。</p><h3 id="第六次作业">第六次作业<a class="anchor" href="#第六次作业">·</a></h3><h4 id="代码可视化与数据统计-5">代码可视化与数据统计<a class="anchor" href="#代码可视化与数据统计-5">·</a></h4><h5 id="程序类图-5">程序类图<a class="anchor" href="#程序类图-5">·</a></h5><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit2/hw6.png" alt></p><p>本次作业和上次作业相比改动幅度不大，只增加了一个调度器类。</p><h5 id="程序复杂度分析-5">程序复杂度分析<a class="anchor" href="#程序复杂度分析-5">·</a></h5><ul><li>类复杂度</li></ul><table><thead><tr><th>Class</th><th>OCavg</th><th>OCmax</th><th>WMC</th></tr></thead><tbody><tr><td>Dispatcher</td><td>3.5</td><td>10</td><td>21</td></tr><tr><td>Elevator</td><td>2.5</td><td>8</td><td>25</td></tr><tr><td>InitQueue</td><td>1</td><td>1</td><td>7</td></tr><tr><td>InputThread</td><td>3</td><td>5</td><td>6</td></tr><tr><td>Main</td><td>4</td><td>4</td><td>4</td></tr><tr><td>Scheduler</td><td>8</td><td>16</td><td>40</td></tr><tr><td>WaitQueue</td><td>1</td><td>1</td><td>7</td></tr></tbody></table><p>可以看出<code>Dispatcher</code>和<code>Elevator、Scheduler</code>类的复杂度较高。这三个类也是本次作业的核心类。</p><ul><li>方法复杂度</li></ul><table><thead><tr><th>Method</th><th>CogC</th><th>ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>Dispatcher.Dispatcher(WaitQueue,ArrayList<Elevator>,String)</Elevator></td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Dispatcher.dispatch()</td><td>39</td><td>3</td><td>12</td><td>12</td></tr><tr><td>Dispatcher.getMinElevatori()</td><td>3</td><td>1</td><td>2</td><td>3</td></tr><tr><td>Dispatcher.getMorningMinElevatori()</td><td>3</td><td>1</td><td>2</td><td>3</td></tr><tr><td>Dispatcher.getNightMinElevatori()</td><td>3</td><td>1</td><td>2</td><td>3</td></tr><tr><td>Dispatcher.run()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.Elevator(WaitQueue,InitQueue,String,String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.addRequest(PersonRequest)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.close()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.getInitReqNum()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.getReqNum()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.getWaitQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.getWaitReqNum()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.move(int)</td><td>6</td><td>3</td><td>3</td><td>5</td></tr><tr><td>Elevator.personFlow()</td><td>11</td><td>1</td><td>8</td><td>8</td></tr><tr><td>Elevator.run()</td><td>26</td><td>4</td><td>12</td><td>12</td></tr><tr><td>InitQueue.InitQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.addRequest(PersonRequest)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.clearQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.close()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.getRequests()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.isEnd()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.noWaiting()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InputThread.InputThread(WaitQueue,ElevatorInput,ArrayList<Elevator>,String)</Elevator></td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InputThread.run()</td><td>11</td><td>3</td><td>6</td><td>6</td></tr><tr><td>Main.main(String[])</td><td>6</td><td>1</td><td>6</td><td>6</td></tr><tr><td>Scheduler.Scheduler(WaitQueue,InitQueue,String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Scheduler.getDesFloor(int)</td><td>49</td><td>13</td><td>16</td><td>22</td></tr><tr><td>Scheduler.getFloor(int,int)</td><td>26</td><td>7</td><td>3</td><td>15</td></tr><tr><td>Scheduler.getMorningFloor(int,int)</td><td>13</td><td>4</td><td>2</td><td>8</td></tr><tr><td>Scheduler.getNightFloor(int,int)</td><td>13</td><td>4</td><td>2</td><td>8</td></tr><tr><td>WaitQueue.WaitQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.addRequest(PersonRequest)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.clearQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.close()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.getRequests()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.isEnd()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.noWaiting()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>本次复杂度较高的是调度器的<code>dispatch</code>方法，以及获得目标楼层的``getDesFloor<code>方法和电梯运行的</code>run`方法。</p><h5 id="程序行数统计-5">程序行数统计<a class="anchor" href="#程序行数统计-5">·</a></h5><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit2/hw6line.png" alt></p><p>本次作业代码量较大，总有效行数是571行。</p><h4 id="代码分析-5">代码分析<a class="anchor" href="#代码分析-5">·</a></h4><h5 id="原理分析-5">原理分析<a class="anchor" href="#原理分析-5">·</a></h5><p>本次作业在上一次作业基础上主要增加了调度器类，用来实现各个电梯的负载均衡调度，采用了分布式调度，即将一个大的请求队列分配给各个电梯自己的请求队列，由各个电梯对自己的请求队列进行处理。相当于采用了两对消费者-生产者，一对是输入线程和调度器线程，一对是调度器线程和各个电梯。输入线程终止条件与上次作业相同，而调度器线程终止条件则是没有新的输入且总的请求队列为空。各个电梯自己的终止条件是自身的请求等待队列为空。具体策略上，本次作业采用了和上次作业一致的策略。</p><h5 id="同步块的设置和锁的选择-2">同步块的设置和锁的选择<a class="anchor" href="#同步块的设置和锁的选择-2">·</a></h5><p>本次作业共享的变量为总请求等待队列，各个电梯自身的请求等待队列和电梯内请求队列。<code>Elevator</code>和<code>Scheduler</code>类的同步与上次一致，不再赘述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dispatcher.dispatch</span></span><br><span class="line"><span class="keyword">if</span> (waitQueue.isEnd() &amp;&amp; waitQueue.noWaiting()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Elevator elevator : elevators) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (elevator.getWaitQueue()) &#123; <span class="comment">//遍历时给每个电梯的等待队列类加上锁保证安全</span></span><br><span class="line">            elevator.getWaitQueue().close();</span><br><span class="line">            elevator.getWaitQueue().notifyAll(); </span><br><span class="line">            <span class="comment">//输入线程结束且总等待队列为空将所有电梯的等待队列关闭，同时唤醒所有电梯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (waitQueue.noWaiting()) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (waitQueue) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                waitQueue.wait(); <span class="comment">//总等待队列为空但输入线程并未结束时，先等待</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//InputThread.run</span></span><br><span class="line"><span class="keyword">synchronized</span> (waitQueue) &#123; <span class="comment">//给总等待队列加锁，防止与调度器线程冲突</span></span><br><span class="line">    <span class="keyword">if</span> (request == <span class="keyword">null</span>) &#123;</span><br><span class="line">        waitQueue.close(); <span class="comment">//关闭总请求队列</span></span><br><span class="line">        waitQueue.notifyAll(); <span class="comment">//输入结束时唤醒调度器内的总等待队列</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            elevatorInput.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (request <span class="keyword">instanceof</span> PersonRequest) &#123;</span><br><span class="line">            waitQueue.addRequest((PersonRequest) request);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request <span class="keyword">instanceof</span> ElevatorRequest) &#123;</span><br><span class="line">            Elevator elevator = <span class="keyword">new</span> Elevator(<span class="keyword">new</span> WaitQueue(), <span class="keyword">new</span> InitQueue(),</span><br><span class="line">                                             pattern, ((ElevatorRequest) request).getElevatorId());</span><br><span class="line">            <span class="keyword">synchronized</span> (elevators) &#123; <span class="comment">//给电梯数组加锁，保证线程安全</span></span><br><span class="line">                elevators.add(elevator);</span><br><span class="line">                elevator.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        waitQueue.notifyAll(); <span class="comment">//在新的请求进入等待队列中或者加入了新电梯后唤醒所有的等待队列。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="优点-5">优点<a class="anchor" href="#优点-5">·</a></h5><p>在没有非必要的对第五次作业的修改基础上，只通过新增一个调度器线程类对请求进行处理，复用了电梯类和策略类，层次架构较清晰，是一次比较好的增量开发。同时，调度器每次分配请求时对现有的每个电梯内的请求人数进行比较，较好的考虑了负载均衡。</p><h5 id="缺点-5">缺点<a class="anchor" href="#缺点-5">·</a></h5><p>因为写代码不谨慎，出现了一处潜在的死循环发生区。</p><h3 id="第七次作业">第七次作业<a class="anchor" href="#第七次作业">·</a></h3><h4 id="代码可视化与数据统计-6">代码可视化与数据统计<a class="anchor" href="#代码可视化与数据统计-6">·</a></h4><h5 id="程序类图-6">程序类图<a class="anchor" href="#程序类图-6">·</a></h5><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit2/hw7.png" alt></p><p>本次作业的架构与上次一致。</p><h5 id="程序复杂度分析-6">程序复杂度分析<a class="anchor" href="#程序复杂度分析-6">·</a></h5><ul><li>类复杂度</li></ul><table><thead><tr><th>Class</th><th>OCavg</th><th>OCmax</th><th>WMC</th></tr></thead><tbody><tr><td>Dispatcher</td><td>3.75</td><td>9</td><td>15</td></tr><tr><td>Elevator</td><td>2.93</td><td>8</td><td>41</td></tr><tr><td>InitQueue</td><td>1</td><td>1</td><td>7</td></tr><tr><td>InputThread</td><td>3</td><td>5</td><td>6</td></tr><tr><td>Main</td><td>3</td><td>3</td><td>3</td></tr><tr><td>Scheduler</td><td>6.6</td><td>14</td><td>33</td></tr><tr><td>WaitQueue</td><td>1</td><td>1</td><td>7</td></tr></tbody></table><ul><li>方法复杂度</li></ul><table><thead><tr><th>Method</th><th>CogC</th><th>ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>Dispatcher.Dispatcher(WaitQueue,ArrayList<Elevator>,HashSet<Integer>)</Integer></Elevator></td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Dispatcher.dispatch()</td><td>34</td><td>4</td><td>11</td><td>12</td></tr><tr><td>Dispatcher.getMinElevatori(PersonRequest)</td><td>6</td><td>1</td><td>2</td><td>4</td></tr><tr><td>Dispatcher.run()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.Elevator(WaitQueue,InitQueue,String,String,String,WaitQueue,HashSet<Integer>)</Integer></td><td>3</td><td>1</td><td>2</td><td>3</td></tr><tr><td>Elevator.addRequest(PersonRequest)</td><td>5</td><td>1</td><td>5</td><td>6</td></tr><tr><td>Elevator.canArrive(PersonRequest)</td><td>10</td><td>3</td><td>1</td><td>12</td></tr><tr><td>Elevator.canBOut(PersonRequest)</td><td>4</td><td>1</td><td>1</td><td>5</td></tr><tr><td>Elevator.canCOut(PersonRequest)</td><td>7</td><td>2</td><td>1</td><td>8</td></tr><tr><td>Elevator.close()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.getInitReqNum()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.getReqNum()</td><td>3</td><td>1</td><td>2</td><td>3</td></tr><tr><td>Elevator.getType()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.getWaitQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.getWaitReqNum()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.move(int)</td><td>8</td><td>3</td><td>3</td><td>6</td></tr><tr><td>Elevator.personFlow()</td><td>17</td><td>4</td><td>11</td><td>12</td></tr><tr><td>Elevator.run()</td><td>25</td><td>4</td><td>11</td><td>11</td></tr><tr><td>InitQueue.InitQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.addRequest(PersonRequest)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.clearQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.close()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.getRequests()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.isEnd()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.noWaiting()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InputThread.InputThread(WaitQueue,ElevatorInput,ArrayList<Elevator>,String,HashSet<Integer>)</Integer></Elevator></td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InputThread.run()</td><td>11</td><td>3</td><td>6</td><td>6</td></tr><tr><td>Main.main(String[])</td><td>5</td><td>1</td><td>5</td><td>5</td></tr><tr><td>Scheduler.Scheduler(WaitQueue,InitQueue,String,int)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Scheduler.getBFloor(int,int)</td><td>4</td><td>2</td><td>1</td><td>3</td></tr><tr><td>Scheduler.getCFloor(int,int)</td><td>7</td><td>2</td><td>1</td><td>6</td></tr><tr><td>Scheduler.getDesFloor(int)</td><td>38</td><td>10</td><td>14</td><td>17</td></tr><tr><td>Scheduler.getTakeFloor(int,int)</td><td>28</td><td>7</td><td>4</td><td>16</td></tr><tr><td>WaitQueue.WaitQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.addRequest(PersonRequest)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.clearQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.close()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.getRequests()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.isEnd()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.noWaiting()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><h5 id="程序行数统计-6">程序行数统计<a class="anchor" href="#程序行数统计-6">·</a></h5><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit2/hw7line.png" alt></p><p>本次代码量较上次增加了60行，主要增加了与电梯性质和换乘相关的代码。</p><h4 id="代码分析-6">代码分析<a class="anchor" href="#代码分析-6">·</a></h4><h5 id="原理分析-6">原理分析<a class="anchor" href="#原理分析-6">·</a></h5><p>本次作业架构与上次一致。对调度器内部的负载均衡判定方法除了考虑电梯现有请求队列人数，加入了判断是否能停留的逻辑和优先级的逻辑（速度快的优先级高）,加入了换乘的处理逻辑。同时，改变了调度器线程的终止条件，当且仅当输入线程终止且所有换乘乘客均已到达目的地，才结束。而调度器线程的结束也才会导致若干个电梯线程的结束。具体电梯的策略类和前两次作业保持一致。</p><h5 id="同步块的设置和锁的选择-3">同步块的设置和锁的选择<a class="anchor" href="#同步块的设置和锁的选择-3">·</a></h5><p>本次作业与前两次作业比起来，由于要处理换乘的情况，加入了一个记录换乘乘客id的集合<code>checkidset</code>用来判断调度器线程的终止条件。核心的线程安全问题也主要集中在对这个集合的处理上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Elevator.run</span></span><br><span class="line"><span class="keyword">if</span> (d == <span class="number">0</span>) &#123; <span class="comment">//乘客到达目的地时</span></span><br><span class="line">    ...</span><br><span class="line">    TimableOutput.println(</span><br><span class="line">        String.format(<span class="string">"OUT-%d-%d-%s"</span>, request.getPersonId(), floor, id));</span><br><span class="line">    <span class="keyword">synchronized</span> (checkidset) &#123;</span><br><span class="line">        checkidset.remove(request.getPersonId()); <span class="comment">//将这个id从换乘id集合中移除</span></span><br><span class="line">        checkidset.notifyAll(); <span class="comment">//唤醒换乘人集合，让调度器继续作业</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((type.equals(<span class="string">"B"</span>) &amp;&amp; canBOut(request))) &#123; <span class="comment">//到达中转站</span></span><br><span class="line">  ...</span><br><span class="line">    TimableOutput.println(String.format(<span class="string">"OUT-%d-%d-%s"</span>,</span><br><span class="line">                                        request.getPersonId(), floor, id));</span><br><span class="line">    <span class="keyword">synchronized</span> (allWaitQueue) &#123;</span><br><span class="line">        PersonRequest newrequest = <span class="keyword">new</span> PersonRequest(floor,</span><br><span class="line">                                                    request.getToFloor(), request.getPersonId());</span><br><span class="line">        allWaitQueue.addRequest(newrequest); <span class="comment">//总请求等待队列新增请求</span></span><br><span class="line">        allWaitQueue.notifyAll(); <span class="comment">//唤醒总请求等待对列，让调度器继续分配请求</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (checkidset) &#123; checkidset.notifyAll(); &#125; <span class="comment">//唤醒换乘人集合，让调度器继续作业</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dispatcher.dispatch</span></span><br><span class="line"><span class="keyword">if</span> (waitQueue.isEnd() &amp;&amp; waitQueue.noWaiting()) &#123; <span class="comment">//当输入线程已经终止时</span></span><br><span class="line">    <span class="keyword">synchronized</span> (checkidset) &#123; <span class="comment">//给换乘人集合加锁</span></span><br><span class="line">        <span class="keyword">if</span> (checkidset.size() &gt; <span class="number">0</span>) &#123; <span class="comment">//当前还有换乘的乘客没有到达目的地</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                checkidset.wait(); <span class="comment">//等待乘客到达目的地或者新的换乘请求加入</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (waitQueue) &#123; <span class="comment">//处理现在的请求</span></span><br><span class="line">                ArrayList&lt;PersonRequest&gt; requests = waitQueue.getRequests();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; requests.size(); i++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> mini = getMinElevatori(requests.get(i));</span><br><span class="line">                    elevators.get(mini).addRequest(requests.get(i));</span><br><span class="line">                    <span class="keyword">synchronized</span> (elevators.get(mini).getWaitQueue()) &#123;</span><br><span class="line">                        elevators.get(mini).getWaitQueue().notifyAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                    requests.remove(i);</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (checkidset.size() &gt; <span class="number">0</span>) &#123; <span class="comment">//如果还有没到达的换乘乘客，继续下一轮循环</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Elevator elevator : elevators) &#123; <span class="comment">//所有换乘乘客均已到达，可以关闭各个线程的等待队列了</span></span><br><span class="line">        <span class="keyword">synchronized</span> (elevator.getWaitQueue()) &#123;</span><br><span class="line">            elevator.getWaitQueue().close(); </span><br><span class="line">            elevator.getWaitQueue().notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;...&#125; <span class="comment">//输入线程未终止，正常分配请求</span></span><br></pre></td></tr></table></figure><h5 id="UML时序图">UML时序图<a class="anchor" href="#UML时序图">·</a></h5><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit2/hw7-0.png" alt></p><p>时序图说明：只保留了几个线程类，主要展示了整个时序流程而省略了实现细节。图中Elevator类是所有elevator的代表</p><h5 id="可扩展性分析">可扩展性分析<a class="anchor" href="#可扩展性分析">·</a></h5><ol><li><strong>功能设计</strong>上。由于上次作业架构较为合理，本次作业整体改动不大，同时，在完善了对电梯类型和电梯属性的扩展后，现在的电梯的可扩展性较强，之后改动时只需要针对不同的电梯种类在电梯类做出相应的改变和扩展即可。其他地方不用改变。</li><li><strong>性能设计</strong>上。本次作业实现了换乘，但是由于各种原因没有实现对所有电梯状态的整体把握和换乘考虑，因此性能表现一般。</li></ol><h2 id="二、bug分析-2">二、bug分析<a class="anchor" href="#二、bug分析-2">·</a></h2><h3 id="第五次作业-2">第五次作业<a class="anchor" href="#第五次作业-2">·</a></h3><h4 id="自己的bug-4">自己的bug<a class="anchor" href="#自己的bug-4">·</a></h4><h5 id="bug描述-6">bug描述<a class="anchor" href="#bug描述-6">·</a></h5><p>本次作业在强测中AK，在互测中被找出一个bug</p><p>原因是线程安全没考虑周全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"Thread-1"</span> java.util.ConcurrentModificationException</span><br><span class="line">at java.util.ArrayList.sort(ArrayList.java:<span class="number">1464</span>)</span><br><span class="line">at Elevator.run(Elevator.java:<span class="number">68</span>)</span><br></pre></td></tr></table></figure><p>问题原因其实就是源于以下的代码。即是因为<code>Elevator</code>类在<code>Night</code>模式下对等待请求队列排序的处理有误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pattern.equals(<span class="string">"Night"</span>)) &#123;</span><br><span class="line">        waitQueue.getRequests()</span><br><span class="line">            .sort(Comparator.comparingInt(PersonRequest::getFromFloor));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="bug修复总结-3">bug修复总结<a class="anchor" href="#bug修复总结-3">·</a></h5><p>是非常明显的线程安全问题，只要给<code>waitQueue.getRequests()</code>加锁就没问题了。出现原因本质上还是自己对多线程的理解不深刻，没有养成勤加锁的好习惯。</p><h4 id="他人的bug-4">他人的bug<a class="anchor" href="#他人的bug-4">·</a></h4><h5 id="bug描述-7">bug描述<a class="anchor" href="#bug描述-7">·</a></h5><p>本次共分别找到三个人的共计三个bug，都是由于线程安全所致，均导致了RTLE。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1 Random hack了3个同学 </span></span><br><span class="line">[1.0]Random</span><br><span class="line">[1.0]1-FROM-19-TO-1</span><br><span class="line">[1.0]2-FROM-19-TO-1</span><br><span class="line">[1.0]3-FROM-19-TO-1</span><br><span class="line">[1.0]4-FROM-19-TO-1</span><br><span class="line">[1.0]5-FROM-19-TO-1</span><br><span class="line">[1.0]133-FROM-19-TO-1</span><br><span class="line">[1.0]134-FROM-19-TO-1</span><br><span class="line">[1.0]135-FROM-19-TO-1</span><br><span class="line">[1.0]136-FROM-19-TO-1</span><br><span class="line">[1.0]137-FROM-19-TO-1</span><br><span class="line">[1.0]138-FROM-19-TO-1</span><br><span class="line">[1.0]139-FROM-19-TO-1</span><br><span class="line">[1.0]130-FROM-19-TO-1</span><br><span class="line">[1.0]6-FROM-19-TO-1</span><br><span class="line">[1.0]131-FROM-19-TO-1</span><br><span class="line">[1.0]132-FROM-19-TO-1</span><br><span class="line">[2.0]7-FROM-19-TO-1</span><br><span class="line">[2.0]8-FROM-19-TO-1</span><br><span class="line">[2.0]9-FROM-19-TO-1</span><br><span class="line">[2.0]10-FROM-19-TO-1</span><br><span class="line">[2.0]11-FROM-19-TO-1</span><br><span class="line">[2.0]12-FROM-19-TO-1</span><br><span class="line">[2.0]13-FROM-19-TO-1</span><br><span class="line">[10.0]14-FROM-19-TO-17</span><br><span class="line">[10.0]15-FROM-15-TO-19</span><br><span class="line">[10.0]16-FROM-18-TO-1</span><br><span class="line">[10.0]17-FROM-2-TO-20</span><br><span class="line">[10.0]18-FROM-20-TO-4</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">2 Night hack了1个同学</span></span><br><span class="line">[1.0]Night</span><br><span class="line">[1.0]1-FROM-19-TO-1</span><br><span class="line">[1.0]2-FROM-19-TO-1</span><br><span class="line">[1.0]3-FROM-19-TO-1</span><br><span class="line">[1.0]4-FROM-19-TO-1</span><br><span class="line">[1.0]5-FROM-19-TO-1</span><br><span class="line">[1.0]133-FROM-19-TO-1</span><br><span class="line">[1.0]134-FROM-19-TO-1</span><br><span class="line">[1.0]135-FROM-19-TO-1</span><br><span class="line">[1.0]136-FROM-19-TO-1</span><br><span class="line">[1.0]137-FROM-19-TO-1</span><br><span class="line">[1.0]138-FROM-19-TO-1</span><br><span class="line">[1.0]139-FROM-19-TO-1</span><br><span class="line">[1.0]130-FROM-19-TO-1</span><br><span class="line">[1.0]6-FROM-19-TO-1</span><br><span class="line">[1.0]131-FROM-19-TO-1</span><br><span class="line">[1.0]132-FROM-19-TO-1</span><br><span class="line">[1.0]7-FROM-19-TO-1</span><br><span class="line">[1.0]8-FROM-19-TO-1</span><br><span class="line">[1.0]9-FROM-19-TO-1</span><br><span class="line">[1.0]10-FROM-19-TO-1</span><br><span class="line">[1.0]11-FROM-19-TO-1</span><br><span class="line">[1.0]12-FROM-19-TO-1</span><br><span class="line">[1.0]13-FROM-19-TO-1</span><br><span class="line">[1.0]14-FROM-19-TO-1</span><br><span class="line">[1.0]15-FROM-19-TO-1</span><br><span class="line">[1.0]16-FROM-19-TO-1</span><br><span class="line">[1.0]17-FROM-19-TO-1</span><br><span class="line">[1.0]18-FROM-19-TO-1</span><br><span class="line">[1.0]19-FROM-19-TO-1</span><br></pre></td></tr></table></figure><h5 id="测试方式-4">测试方式<a class="anchor" href="#测试方式-4">·</a></h5><p>本单元由于与很多事情相撞，没完成评测机，所以只能一直采用阅读代码加上手动构造复杂的测试用例的方式来进行互测。基本原则就是构造请求数量和最大限制一样，且出现很多楼层跨度很大的电梯请求的测试数据。</p><h3 id="第六次作业-2">第六次作业<a class="anchor" href="#第六次作业-2">·</a></h3><h4 id="自己的bug-5">自己的bug<a class="anchor" href="#自己的bug-5">·</a></h4><p>本次强测中被hack1个点，互测中未被hack。</p><h5 id="bug描述-8">bug描述<a class="anchor" href="#bug描述-8">·</a></h5><p>RTLE，运行时间超过了210s</p><h5 id="bug修复总结-4">bug修复总结<a class="anchor" href="#bug修复总结-4">·</a></h5><p>原因如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (floor != desFloor1) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sleep(<span class="number">400</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    floor += step;</span><br><span class="line">    TimableOutput.println(</span><br><span class="line">        String.format(<span class="string">"ARRIVE-%d-%s"</span>, floor, id));</span><br><span class="line">    desFloor1 = scheduler.getDesFloor(floor);</span><br><span class="line">    <span class="comment">//缺少这行:step=floor&lt;desFloor1?:1:-1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即我每到一个楼层都会更新下一个目标楼层，而与此同时却没有更新方向。因此出现了问题。当出现新的请求与当前请求方向不一致时，会一直死循环，导致电梯通向天堂或者地狱。</p><h4 id="他人的bug-5">他人的bug<a class="anchor" href="#他人的bug-5">·</a></h4><p>本次未发现他人bug。</p><p>尝试用上次的强测用例修改后进行hack，没有成功。</p><h3 id="第七次作业-2">第七次作业<a class="anchor" href="#第七次作业-2">·</a></h3><h4 id="自己的bug-6">自己的bug<a class="anchor" href="#自己的bug-6">·</a></h4><p>本次强测被hack四个点，互测被hack四个点。主要原因是因为换乘导致的唤醒遗漏问题以及两处代码逻辑问题。</p><p><strong>唤醒遗漏</strong>主要发生在B电梯的换乘处理上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">TimableOutput.println(String.format(<span class="string">"OUT-%d-%d-%s"</span>,request.getPersonId(), floor, id));</span><br><span class="line"><span class="keyword">synchronized</span> (allWaitQueue) &#123;</span><br><span class="line">    PersonRequest newrequest = <span class="keyword">new</span> PersonRequest(floor,request.getToFloor(), request.getPersonId());</span><br><span class="line">    allWaitQueue.addRequest(newrequest);</span><br><span class="line">    allWaitQueue.notifyAll();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>代码中，显然只对总的等待请求队列做了唤醒处理，却没有对checkidset也就是换乘乘客id的集合做唤醒处理，导致了在Dispatcher类中一直卡死，无法结束线程。</p><p><strong>处理逻辑</strong>主要是对B电梯的处理上有问题。一处是当B电梯中有偶数层目的地的乘客时，在到达偶数层会一直循环卡死在这一层。通过设置B电梯且为偶数层跳过的逻辑就解决了。即：<code>if (type.equals(&quot;B&quot;) &amp;&amp; floor % 2 == 0) { continue; }</code>。另一处如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lenInit == maxnum || (!initReqs.contains(mainRequest) &amp;&amp; lenInit == maxnum - <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> mainDesFloor;</span><br><span class="line">&#125;</span><br><span class="line">mainDesFloor = maxnum == <span class="number">6</span> ? getBFloor(floor, mainDesFloor) : mainDesFloor;</span><br></pre></td></tr></table></figure><p>当B电梯进行换乘时，我的代码逻辑在某些情况直接返回了主请求的目的地，而不是经过<code>getBFloor</code>函数转换后再做将进一步处理。于是导致了问题。只需要将转换的代码放在前面即可</p><p>如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mainDesFloor &#x3D; maxnum &#x3D;&#x3D; 6 ? getBFloor(floor, mainDesFloor) : mainDesFloor;</span><br><span class="line">if (lenInit &#x3D;&#x3D; maxnum || (!initReqs.contains(mainRequest) &amp;&amp; lenInit &#x3D;&#x3D; maxnum - 1)) &#123;</span><br><span class="line">    return mainDesFloor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="他人的bug-6">他人的bug<a class="anchor" href="#他人的bug-6">·</a></h4><p>本次未发现他人bug。</p><h2 id="三、心得体会">三、心得体会<a class="anchor" href="#三、心得体会">·</a></h2><h4 id="线程安全">线程安全<a class="anchor" href="#线程安全">·</a></h4><ul><li>一定要勤给变量加锁，同时也要注意锁的先后顺序避免出现死锁。</li><li>加锁后如果进行了<code>wait</code>操作一定要注意在合适的地方进行唤醒，否则就会一直卡死。这个时候最好枚举出所有需要唤醒的情况。</li><li>共享变量的维护很重要，尽量减少共享变量，同时对于共享变量一定要加锁进行操作。</li><li>一定要注意每个线程的终止条件，要考虑到尽可能全面的情况，比如第七次作业的输入结束后又产生新的换乘请求的情况。一般需要加一个新的变量来处理。</li></ul><h4 id="层次化设计">层次化设计<a class="anchor" href="#层次化设计">·</a></h4><ul><li>在进行系统设计时，往往需要多线程模式。而这就往往需要对一些对象进行精细的不依赖于上层的建模，比如本次的单台电梯。只要写好一个电梯线程，就可以加无数个电梯，便于之后的扩展。建模过程中要注意不同模块之间的解耦，比如本单元作业就可以将电梯类和策略类分开，便于之后更换策略。</li><li>写之前要理清不同线程、不同类之间的交互关系和共享变量，并尽可能使得关系更加简洁，共享变量尽可能少。关系清晰了，才不容易出线程安全错误。</li></ul><h4 id="经验教训">经验教训<a class="anchor" href="#经验教训">·</a></h4><ul><li><p>对一个版本底气不足时不如老老实实交把握大的版本。第7次作业最后一次交的时候自知换乘的版本有很多问题，但是时间原因没法进一步debug了，就交上去了。但其实选择更稳妥的没换乘的方式至少正确性可能会好很多。</p></li><li><p>评测机很重要！！上一单元因为有较完善的评测机互测自测都很顺利。本单元没有实现评测机导致很多时候比较被动。</p></li><li><p>修复bug的时候最重要的是通过，所以修改的时候可以不考虑性能，纯考虑正确性来进行修改。另外<s>修复bug的时候不要按<code>Alt+Ctrl+L</code></s>，原因懂得都懂。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-OO-2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++面向对象</title>
      <link href="2021/04/22/C_C++/"/>
      <url>2021/04/22/C_C++/</url>
      
        <content type="html"><![CDATA[<p>C++的部分知识复习，为了准备考试</p><a id="more"></a><h1 id="C">C++<a class="anchor" href="#C">·</a></h1><h2 id="C-面向对象">C++面向对象<a class="anchor" href="#C-面向对象">·</a></h2><h3 id="1-类-对象">1.类&amp;对象<a class="anchor" href="#1-类-对象">·</a></h3><h4 id="基本操作">基本操作<a class="anchor" href="#基本操作">·</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">#类定义</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> &#123;</span></span><br><span class="line">    <span class="comment">//范围修饰符: 开头定义变量与函数</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//变量定义</span></span><br><span class="line">    <span class="keyword">double</span> weight;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//函数定义</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getWeight</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age2set)</span></span>;</span><br><span class="line">    People(); <span class="comment">//构造函数</span></span><br><span class="line">    People(<span class="keyword">int</span> age2set,weight2set);</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在类定义外定义函数 在返回值类型和函数名之间加上 类名+范围解析运算符 :: </span></span><br><span class="line">People::People()&#123;</span><br><span class="line">    weight=<span class="number">70</span>;</span><br><span class="line">    age=<span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">People::People(<span class="keyword">int</span> age2set,<span class="keyword">double</span> weight2set)&#123;</span><br><span class="line">age=age2set;</span><br><span class="line">    weight=weight2set;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造函数另一种写法:初始化列表来初始化字段 与上一种写法等价</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">People::People( double age2set, double weight2set): age(age2set),weight(weight2set)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  ...</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">People::getWeight</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">People::set</span><span class="params">(<span class="keyword">int</span> age2set)</span></span>&#123;</span><br><span class="line">    age=age2set;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建People类变量</span></span><br><span class="line">People jack;</span><br><span class="line"><span class="function">People <span class="title">xiaoming</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>; <span class="comment">//创建时自动调用了构造函数</span></span><br></pre></td></tr></table></figure><h4 id="析构函数">析构函数<a class="anchor" href="#析构函数">·</a></h4><p>在每次<strong>删除</strong>创建的对象时执行。<strong>类似构造</strong>函数，函数名与类名相同。只是函数名前要加一个<code>~</code>。</p><p>这个函数<strong>不能有返回值和参数</strong>。有助于在跳出程序前<strong>释放资源</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ~Obj();</span><br><span class="line">&#125;;</span><br><span class="line">Obj::~Obj()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Obj is being deleted"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拷贝构造函数">拷贝构造函数<a class="anchor" href="#拷贝构造函数">·</a></h4><p><strong>特殊</strong>的构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形式</span></span><br><span class="line">classname (<span class="keyword">const</span> classname &amp;obj) &#123;</span><br><span class="line">   <span class="comment">// 构造函数的主体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Obj(<span class="keyword">int</span> len);</span><br><span class="line">   Obj(<span class="keyword">const</span> Obj &amp;obj);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line">Obj::Obj(<span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    p=<span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    *p=len; <span class="comment">//构造函数</span></span><br><span class="line">&#125;</span><br><span class="line">Obj::Obj(<span class="keyword">const</span> Obj &amp;obj)</span><br><span class="line">&#123;</span><br><span class="line">    p=<span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    *p=*obj.p; <span class="comment">//拷贝</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Obj <span class="title">obja</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">Obj objb = obja; <span class="comment">//调用了拷贝构造函数</span></span><br></pre></td></tr></table></figure><h4 id="友元函数">友元函数<a class="anchor" href="#友元函数">·</a></h4><p><code>friend</code> 关键字对函数进行声明即可，友元函数可以访问这个类的所有成员。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">printa</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassB</span>;</span> <span class="comment">//ClassB中所有函数都成为了Obj对象的友元函数</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内联函数">内联函数<a class="anchor" href="#内联函数">·</a></h4><p>加上<code>inline</code> 关键字即可。一种用<strong>空间换时间</strong>的方式，在编译时会在每个调用这个函数的位置放置这个函数副本，所以<strong>空间开销大</strong>。</p><p>一般要使用最好行数较短，<strong>1-5行</strong>为宜，不要出现分支。</p><p>比如<code>Max</code>,<code>Min</code>等。</p><h4 id="对象指针">对象指针<a class="anchor" href="#对象指针">·</a></h4><h5 id="this指针">this指针<a class="anchor" href="#this指针">·</a></h5><p>是一个指向自身的指针，用<code>this-&gt;变量/方法名</code>来使用。</p><p><strong>普通对象指针</strong>用法与this一样。</p><h4 id="静态成员">静态成员<a class="anchor" href="#静态成员">·</a></h4><p><code>static</code> 关键词来定义。</p><h5 id="变量">变量<a class="anchor" href="#变量">·</a></h5><p>创建第一个类对象时若<strong>无其他初始化语句</strong>，所有的静态数据会<strong>清0</strong>。之后所有<strong>新创建的同类</strong>都<strong>共享</strong>这个数据。</p><h5 id="函数-2">函数<a class="anchor" href="#函数-2">·</a></h5><p>不能使用<strong>this</strong>指针。必须使用<code>classname::fun()</code>的形式来调用。</p><h3 id="2-C-继承">2.C++继承<a class="anchor" href="#2-C-继承">·</a></h3><p><strong>基本形式</strong>是<code>class A:access-specifier B;</code></p><p>同时，也可以<strong>多继承</strong>。如下代码所示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;派生类名&gt;:</span>&lt;继承方式<span class="number">1</span>&gt;&lt;基类名<span class="number">1</span>&gt;,&lt;继承方式<span class="number">2</span>&gt;&lt;基类名<span class="number">2</span>&gt;,…</span><br><span class="line">&#123;</span><br><span class="line">&lt;派生类类体&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>修饰符</strong>是<code>public/protected/private</code>，一般用<code>public</code>，即父类的<code>public/protected</code>成员都作为相同的权限被定义在子类中。其他两种则是将父类的<code>public/protected</code>成员作为相应的权限被定义。同时，三种定义皆不能访问到父类的<code>private</code>成员。</p><p>C++<strong>继承函数</strong>比较麻烦。</p><p>以下三种是不会继承的。其他符合权限限制的都可以访问。</p><ul><li>基类的<strong>构造函数</strong>、<strong>析构函数</strong>和<strong>拷贝构造函数</strong>。</li><li>基类的<strong>重载运算符</strong>。</li><li>基类的<strong>友元函数</strong>。</li></ul><p>这里实在太复杂，先简单罗列一下最常用的<strong>构造函数的继承使用说明</strong>。</p><p>构造原则如下（这里参考了这篇博客 <a href="https://blog.csdn.net/lzbzclz/article/details/105062566" target="_blank" rel="noopener">https://blog.csdn.net/lzbzclz/article/details/105062566</a>)：</p><ol><li>在类的继承的过程中，如果子类<strong>没有定义构造函数</strong>，程序就会<strong>自动调用父类</strong>的<strong>构造函数</strong>。</li><li>如果子类<strong>定义了构造函数</strong>且父类是<strong>无参</strong>的构造函数，那么创建类的时候会自动<strong>先调用父类的构造函数</strong>，再调用子类的构造函数。</li><li>如果子类<strong>定义了构造函数</strong>且没有显示调用父类中<strong>唯一的带参构造函数</strong>，程序会报错。</li><li>调用父类构造函数的时候得用<strong>初始化父类成员对象</strong>的方式。</li></ol><p>举例如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//报错的代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> a);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line">A::A(<span class="keyword">int</span> a)&#123;</span><br><span class="line">    <span class="keyword">this</span>.a=a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    B(<span class="keyword">int</span> b);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line">B::B(<span class="keyword">int</span> b)&#123;</span><br><span class="line">    <span class="keyword">this</span>.b=b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">B <span class="title">b</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> a);</span><br><span class="line">    <span class="comment">//在这里加一个不带参数的构造函数也可</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line">A::A(<span class="keyword">int</span> a)&#123;</span><br><span class="line">    <span class="keyword">this</span>.a=a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    B(<span class="keyword">int</span> b);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line">B::B(<span class="keyword">int</span> b):A(<span class="number">10</span>)&#123;</span><br><span class="line">    <span class="keyword">this</span>.b=b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">B <span class="title">b</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-重载运算符和重载函数">3.重载运算符和重载函数<a class="anchor" href="#3-重载运算符和重载函数">·</a></h3><p><strong>函数</strong>和<strong>运算符</strong>都可以进行重载</p><p>调用时编译器通过<strong>使用的参数类型</strong>与<strong>定义</strong>中的进行比较，选择合适的，称为<strong>重载决策</strong>。</p><h4 id="函数重载">函数重载<a class="anchor" href="#函数重载">·</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"No Parameter!"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">string</span> a)</span> </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt; <span class="string">"p1:"</span> &lt;&lt; a;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">A a;</span><br><span class="line">A.<span class="built_in">print</span>();</span><br><span class="line">A.print1(<span class="string">"a"</span>);</span><br></pre></td></tr></table></figure><h4 id="运算符重载">运算符重载<a class="anchor" href="#运算符重载">·</a></h4><p>关键字 <code>operator</code> 和其后要<strong>重载的运算符符号</strong>构成的，可以视为一个函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//如果在类内只需要传入一个Box参数</span></span><br><span class="line">        Box <span class="keyword">operator</span>+(<span class="keyword">const</span> Box&amp; b) &#123;</span><br><span class="line">            Box box;</span><br><span class="line">            box.a = <span class="keyword">this</span>-&gt;a+b-&gt;a;</span><br><span class="line">            box.b = <span class="keyword">this</span>-&gt;b+b-&gt;b;</span><br><span class="line">            <span class="keyword">return</span> box;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果在类外传入两个Box参数</span></span><br><span class="line">Box <span class="keyword">operator</span>+(<span class="keyword">const</span> Box&amp; b1,<span class="keyword">const</span> Box&amp; b2) &#123;</span><br><span class="line">    Box box;</span><br><span class="line">    box.a = b1-&gt;a+b2-&gt;a;</span><br><span class="line">    box.b = b1-&gt;b+b2-&gt;b;</span><br><span class="line">    <span class="keyword">return</span> box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-C-多态">4.C++多态<a class="anchor" href="#4-C-多态">·</a></h3><p><strong>继承关联</strong>时会用到<strong>多态</strong></p><p><strong>调用成员函数</strong>时<strong>根据对象类型</strong>执行不同函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> <span class="built_in">width</span>, <span class="built_in">height</span>;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      Shape( <span class="keyword">int</span> a=<span class="number">0</span>, <span class="keyword">int</span> b=<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">width</span> = a;</span><br><span class="line">         <span class="built_in">height</span> = b;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">"Parent class area :"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      Rectangle( <span class="keyword">int</span> a=<span class="number">0</span>, <span class="keyword">int</span> b=<span class="number">0</span>):Shape(a, b) &#123; &#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">area</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">"Rectangle class area :"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">         <span class="keyword">return</span> (<span class="built_in">width</span> * <span class="built_in">height</span>); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span>:</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      Triangle( <span class="keyword">int</span> a=<span class="number">0</span>, <span class="keyword">int</span> b=<span class="number">0</span>):Shape(a, b) &#123; &#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">area</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">"Triangle class area :"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">         <span class="keyword">return</span> (<span class="built_in">width</span> * <span class="built_in">height</span> / <span class="number">2</span>); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Shape *shape;</span><br><span class="line">   <span class="function">Rectangle <span class="title">rec</span><span class="params">(<span class="number">10</span>,<span class="number">7</span>)</span></span>;</span><br><span class="line">   <span class="function">Triangle  <span class="title">tri</span><span class="params">(<span class="number">10</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 存储矩形的地址</span></span><br><span class="line">   shape = &amp;rec;</span><br><span class="line">   <span class="comment">// 调用矩形的求面积函数 area</span></span><br><span class="line">   shape-&gt;area();</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 存储三角形的地址</span></span><br><span class="line">   shape = &amp;tri;</span><br><span class="line">   <span class="comment">// 调用三角形的求面积函数 area</span></span><br><span class="line">   shape-&gt;area(); </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，由于基类中实定义了函数，后面两处都输出 <code>Parent class area:</code></p><ul><li>这里也被称为 <strong>静态多态/静态链接</strong>，在程序执行前就已经将<code>area</code>函数定死了。</li></ul><p>只需要在基类的函数定义前加关键字<code>virtual</code>，进行<strong>虚定义</strong>，后面输出的就是正常的各自的输出。</p><p>这时就是根据不同的指针地址的位置的 <code>area</code> 函数来执行了。</p><h5 id="虚函数">虚函数<a class="anchor" href="#虚函数">·</a></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带实现的虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">area</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//纯虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">area</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="5-C-数据抽象与封装">5.C++数据抽象与封装<a class="anchor" href="#5-C-数据抽象与封装">·</a></h3><ul><li><p>数据抽象：仅向用户<strong>暴露接口</strong>而<strong>隐藏具体实现细节</strong>的机制。</p></li><li><p>数据封装：把数据和操作数据的函数捆绑在一起的机制。</p></li><li><p>数据成员和外界不需要的类内方法函数用<code>private</code>，外部接口方法用<code>public</code></p></li></ul><h3 id="6-C-接口（抽象类）">6.C++ 接口（抽象类）<a class="anchor" href="#6-C-接口（抽象类）">·</a></h3><p>接口：类中<strong>至少有一个函数</strong>被声明为<strong>纯虚函数</strong>，则这个类就是<strong>抽象类</strong></p><p>这个和<code>Java</code>中的<strong>接口</strong>是一样的，直接用接口去定义一个实例会报错，需要具体实现</p><p>比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="comment">// 纯虚函数</span></span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getVolume</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setLength</span><span class="params">(<span class="keyword">double</span> length)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>-&gt;length = length;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> length;      <span class="comment">// 长度</span></span><br><span class="line">      <span class="keyword">double</span> breadth;     <span class="comment">// 宽度</span></span><br><span class="line">      <span class="keyword">double</span> <span class="built_in">height</span>;      <span class="comment">// 高度</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoxChild</span>:</span><span class="keyword">public</span> Box</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getVolume</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;length;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="课程思维导图">课程思维导图<a class="anchor" href="#课程思维导图">·</a></h3><p><img src="/2021/04/22/C_C++/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210527063529.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS-C语言基础</title>
      <link href="2021/03/30/OS-C-Basic/"/>
      <url>2021/03/30/OS-C-Basic/</url>
      
        <content type="html"><![CDATA[<p>近期操作系统课上测试因为C语言的薄弱基础接连受到暴击，笔者痛下决心一定要开始一篇C语言基础总结的博客，时间有限，本次先将OS两次课上的坑总结一下，以后再补充其他的。</p><a id="more"></a><h2 id="数据类型与移位运算">数据类型与移位运算<a class="anchor" href="#数据类型与移位运算">·</a></h2><p><code>unsigned int</code> 是无符号整数</p><p><code>int</code>有符号整数</p><p>对上述两者赋值时，都是将右边的数字的补码存入相应地址中。</p><p>比如：<code>int a = -1;unsigned a = -1;</code>其实这两个<code>a</code>存的变量内容一样，都是<code>FFFFFFFF</code>（负数的首位为1不变，其他位取反然后整体+1.）</p><p>上述两者如果用<code>%d</code>输出，都会输出一个<code>-1</code>，但是如果输出一个<code>%u</code>则会输出32位无符号整数。另外,<code>%o</code>是8进制，<code>%x</code>是输出十六进制</p><p>同理对于其他的<code>char/unsigned char</code> <code>long/unsigned long</code>等。</p><p>同时，在C语言中默认为十进制数字，可以直接用0x开头表示十六进制，0开头表示8进制，0b开头表示二进制数字。如：<code>0x1af 0176 0b101</code></p><p>同时建立起一个意识就是OS课中C语言中的最小单位可以认为是char，即一个字节</p><h2 id="大小端转换">大小端转换<a class="anchor" href="#大小端转换">·</a></h2><p>那么再有了移位的运算符知识我们就可以实现lab1-1课上的Extra的大小端转换问题了。</p><p>大小端是针对字节来说的，对于一个数字0x12345678来说下图是一个<strong>小端存储</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">           -------------------------------------</span><br><span class="line">首地址0x4000|00010010|00110100|01010110|01111000|末尾地址0x4004</span><br><span class="line">           -------------------------------------</span><br></pre></td></tr></table></figure><p>而这张是一个<strong>大端存储</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">           -------------------------------------</span><br><span class="line">首地址0x4000|01111000|01010110|00110100|00010010|末尾地址0x4004</span><br><span class="line">           -------------------------------------</span><br></pre></td></tr></table></figure><p>即每个字节内其实都是按照所谓的&quot;小端存储&quot;，而大端存储相当于是把小端存储的字节序列倒序排列了。</p><p>一般的x86/ARM架构其实都是小端存储为主，但是也时常有解析大端存储数据的需求。</p><p>有了这些就可以进行转换了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1 = <span class="number">0xff</span>&lt;&lt;<span class="number">24</span>;</span><br><span class="line"><span class="keyword">int</span> a2 = <span class="number">0xff</span>&lt;&lt;<span class="number">16</span>;</span><br><span class="line"><span class="keyword">int</span> a3 = <span class="number">0xff</span>&lt;&lt;<span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> a4 = <span class="number">0xff</span>; <span class="comment">//本来以为必须要定义成unsigned，结果其实不用也可以</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0x12345678</span>;</span><br><span class="line"><span class="comment">//注意优先级，可以输出一下这个看看 a = (a &lt;&lt; 24) &amp; a1 + (a &lt;&lt; 8) &amp; a2 + (a &gt;&gt; 8) &amp; a3 + (a &gt;&gt; 24) &amp; a4; 结果为0</span></span><br><span class="line">a = ((a&lt;&lt;<span class="number">24</span>)&amp;a1) + ((a&lt;&lt;<span class="number">8</span>)&amp;a2) + ((a&gt;&gt;<span class="number">8</span>)&amp;a3) + ((a&gt;&gt;<span class="number">24</span>)&amp;a4); </span><br><span class="line"><span class="comment">// a = 0x78563412</span></span><br></pre></td></tr></table></figure><p>一旦遇到移位运算符，逻辑运算符，多加括号是个好习惯。</p><h2 id="指针与结构体">指针与结构体<a class="anchor" href="#指针与结构体">·</a></h2><p><code>sizeof(type)</code> 返回该变量所占字节数</p><p>指针本质上可以理解为一个<code>int</code>型变量，存着一个32位的地址数据，因为有内存里其他数据的辅助，可以解析相应地址的变量。</p><p>而数组和指针没有本质区别，即如下面所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *b=a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,a[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,b[<span class="number">1</span>]);<span class="comment">//b[1]和*(b+1)一样</span></span><br></pre></td></tr></table></figure><p>结构体的基本使用方式回顾</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s1</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s1</span> <span class="title">t1</span>;</span></span><br><span class="line">t1.a=<span class="number">12</span>;t1.b=<span class="string">'a'</span>;t1.c=<span class="string">'b'</span>;t1.d=<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s1</span> * <span class="title">t1p</span> = <span class="title">t1</span>;</span></span><br><span class="line">t1-&gt;a=<span class="number">13</span>; <span class="comment">//指针需要使用箭头的引用方式</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s1</span> * <span class="title">tp</span> = (<span class="title">struct</span> <span class="title">s1</span> *) <span class="title">addr</span>;</span><span class="comment">//将一个地址转换成结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s1</span> <span class="title">t</span> = *((<span class="title">struct</span> <span class="title">s1</span> *) <span class="title">addr</span>);</span><span class="comment">//将一个地址转换成结构体变量</span></span><br></pre></td></tr></table></figure><p>值得注意的是结构体内会很<strong>贴心</strong>的（一个哥们直接被这个坑了，挂了一次课上）将第二个b/c这两个char变量放在a变量后的连续两个字节里,然后空两个字节之后继续存d变量。即是下图这样的（一个*代表一个字节）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aaaabc  dddd</span><br><span class="line">************</span><br></pre></td></tr></table></figure><p>所以第二次课上如果想直接使用寻找四个变量的地址的方式，就应该先加一个<code>sizeof(int)</code>得到b，再加一个<code>sizeof(char)</code>得到c，再加两个<code>sizeof(char)</code>得到d</p><p>而笔者则是采用了直接将得到的变量利用结构体指针强制转换成结构体变量再进行使用的方式，但是课上测试时，在输出结构体变量内的数字时没有对符号进行清零导致了错误。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-OS-2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OO-Unit1-总结</title>
      <link href="2021/03/25/OO-Unit1-%E5%B0%8F%E7%BB%93/"/>
      <url>2021/03/25/OO-Unit1-%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>2021年北航OO课程的第一单元—表达式求导作业项目总结。</p><p>本单元中，有过因为疏忽大意出现重大错误导致被hack惨的痛苦经历，也有未被hack成功的喜悦体验，下面就来对这一单元的内容做一下梳理和回顾。</p><a id="more"></a><h1 id="OO-Unit1-总结">OO-Unit1-总结<a class="anchor" href="#OO-Unit1-总结">·</a></h1><h2 id="一、程序结构分析">一、程序结构分析<a class="anchor" href="#一、程序结构分析">·</a></h2><h3 id="第一次作业">第一次作业<a class="anchor" href="#第一次作业">·</a></h3><h4 id="代码可视化与数据统计">代码可视化与数据统计<a class="anchor" href="#代码可视化与数据统计">·</a></h4><h5 id="程序类图">程序类图<a class="anchor" href="#程序类图">·</a></h5><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit1/hw1.png" style="zoom:80%;"><p>可以看出，本次作业<code>Item</code>类中含有两个多余的方法，而整体架构上并没有严格遵循高内聚低耦合的原则，需要对各个类进行化简。</p><h5 id="程序复杂度分析">程序复杂度分析<a class="anchor" href="#程序复杂度分析">·</a></h5><table><thead><tr><th>Class</th><th>OCavg</th><th>OCmax</th><th>WMC</th></tr></thead><tbody><tr><td>Item</td><td>3.33</td><td>12</td><td>20</td></tr><tr><td>Main</td><td>2</td><td>2</td><td>4</td></tr><tr><td>Poly</td><td>4</td><td>12</td><td>20</td></tr></tbody></table><p>可以看出，在<code>Item</code>类和<code>Poly</code>类中代码复杂度较高，含有过多的判断语句。</p><h5 id="程序行数统计">程序行数统计<a class="anchor" href="#程序行数统计">·</a></h5><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit1/hw1_sta.png" style="zoom:80%;"><p>本次的<code>Main</code>类中的有效行数达到了31行，过多。</p><h4 id="代码分析">代码分析<a class="anchor" href="#代码分析">·</a></h4><h5 id="原理分析">原理分析<a class="anchor" href="#原理分析">·</a></h5><p><code>Main</code>类中含有对字符串的预处理<code>process</code>方法，包含去除空白字符和对加减号的替换。</p><p><code>Item</code>类中记录了一个项的系数和幂指数。</p><p><code>Poly</code>类中记录了一个多项式的系数和幂指数的幂指数到系数的<code>HashMap</code>，以及相应的求导化简方法。</p><p>具体运行时，先对输入的字符串做好预处理，同时产生一个<code>Item</code>类的列表，之后将这个列表存入<code>Poly</code>类中利用<code>initMap</code>方法转换成<code>HashMap</code>，转换同时进行了化简，之后再完成求导方法。</p><h5 id="优点">优点<a class="anchor" href="#优点">·</a></h5><p>针对本次任务，字符串处理后根据符号分割的速度快，操作简便。之后将表达式每一项先进行化简再进行求导操作，类之间耦合程度较低，同时化简效果较好。</p><h5 id="缺点">缺点<a class="anchor" href="#缺点">·</a></h5><p>可扩展性较弱，字符串处理的方法仅仅适用于本次作业，之后两次作业均不适用。</p><h3 id="第二次作业">第二次作业<a class="anchor" href="#第二次作业">·</a></h3><h4 id="代码可视化与数据统计-2">代码可视化与数据统计<a class="anchor" href="#代码可视化与数据统计-2">·</a></h4><h5 id="程序类图-2">程序类图<a class="anchor" href="#程序类图-2">·</a></h5><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit1/hw2.png" style="zoom: 50%;"><p>本次作业基本达到了高内聚低耦合的目的，每个类的功能相对独立，除了<code>Expression</code>类外没有特别臃肿的类。</p><h5 id="程序复杂度分析-2">程序复杂度分析<a class="anchor" href="#程序复杂度分析-2">·</a></h5><table><thead><tr><th>Class</th><th>OCavg</th><th>OCmax</th><th>WMC</th></tr></thead><tbody><tr><td>Constant</td><td>1</td><td>1</td><td>5</td></tr><tr><td>ExprFactor</td><td>1</td><td>1</td><td>6</td></tr><tr><td>ExprNode</td><td>2.62</td><td>7</td><td>21</td></tr><tr><td>Expression</td><td>3.33</td><td>8</td><td>40</td></tr><tr><td>FactorFather</td><td>1</td><td>1</td><td>9</td></tr><tr><td>Item</td><td>5.5</td><td>14</td><td>55</td></tr><tr><td>Main</td><td>1</td><td>1</td><td>1</td></tr><tr><td>PowerFun</td><td>3.43</td><td>13</td><td>24</td></tr><tr><td>TriFun</td><td>4.33</td><td>20</td><td>39</td></tr></tbody></table><p>可以看出<code>Expression</code>和<code>Item</code>类的复杂度较高。</p><h5 id="程序行数统计-2">程序行数统计<a class="anchor" href="#程序行数统计-2">·</a></h5><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit1/hw2_sta.png" style="zoom:80%;"><p>本次作业代码量较大，总有效行数是751行，其中代码行数最长地就是<code>Expression</code>类</p><h4 id="代码分析-2">代码分析<a class="anchor" href="#代码分析-2">·</a></h4><h5 id="原理分析-2">原理分析<a class="anchor" href="#原理分析-2">·</a></h5><p>本次作业使用了多叉树作为数据结构建立表达式树。采用了递归下降的方式对输入的表达式进行解析。</p><p>表达式树分为三个层次，如下图所示。</p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit1/pic.png" style="zoom:80%;"><p>其中表达式层可以看成是若干个项的对象组成的列表，项层可以看成是若干个因子对象组成的列表，而因子里的表达式因子里的表达式也符合这里的表达式定义。</p><p>对最小层次因子，本次作业我建立了<code>Factor</code>抽象类，同时使用一个父类<code>FactorFather</code>类对<code>Factor</code>类的各个方法进行实现，并让各个具体的因子类继承这个父类，达到了使用<code>Factor</code>对象就可以对所有的因子类进行无差别调用和管理的目的。<code>Factor</code>类主要的重写方法有<code>toString</code>输出原因子方法，<code>diff</code>求导方法，返回值都是字符串。</p><p><code>Item</code>类中主要有<code>diff</code>、<code>simplify</code>方法。分别对应求导，化简。求导具体是用递归的方式计算第一个因子的导数乘以后面所有因子的乘积加第一个因子乘以后面所有因子的乘积的导数。化简方法将项转换成$a<em>x<sup>k*sin(x)</sup>m</em>cos(x)^n*若干个表达式因子相乘$的形方便合并同类项。</p><p><code>ExprNode</code>类定义了表达式树的根节点。里面也含有<code>diff</code>、<code>simplify</code>方法。求导方法拼接每个项的求导输出，化简方法则是将相同的项进行合并。</p><p><code>Expression</code>类包含了一个<code>ExprNode</code>对象，具体的求导输出也是调用了相关接口。同时<code>Expression</code>类也包含了对输入字符串的递归下降的解析过程和相关方法。包含了<code>getExpression、getItem、getFactor、getExprFactor、getTriFun、getPowFun、getNumber、getConstant</code>等方法。最后调用<code>getExpression</code>方法对输入进行解析并将结果存入<code>exprNode</code>对象中。</p><p>求导之后，将导数的字符串重新进行解析化简，得到较为简单的结果。</p><h5 id="优点-2">优点<a class="anchor" href="#优点-2">·</a></h5><p>利用递归下降和表达式树对输入字符串进行了快速准确的解析，同时对同类项进行了一定程度的合并，可以达到较好的化简效果。</p><p>求导方法自下而上，各层之间关系清晰，且可以简便的使用同一种方式遍历所有的项和因子进行操作。</p><h5 id="缺点-2">缺点<a class="anchor" href="#缺点-2">·</a></h5><p>对于表达式的深合并和化简没有完成，同时没有定义清晰的复合求导，嵌套求导接口，对于比第三次作业更复杂的合并方式（比如增加各种嵌套）本次作业代码可扩展性一般。</p><h3 id="第三次作业">第三次作业<a class="anchor" href="#第三次作业">·</a></h3><h4 id="代码可视化与数据统计-3">代码可视化与数据统计<a class="anchor" href="#代码可视化与数据统计-3">·</a></h4><h5 id="程序类图-3">程序类图<a class="anchor" href="#程序类图-3">·</a></h5><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit1/hw3.png" style="zoom: 33%;"><h5 id="程序复杂度分析-3">程序复杂度分析<a class="anchor" href="#程序复杂度分析-3">·</a></h5><table><thead><tr><th>Class</th><th>OCavg</th><th>OCmax</th><th>WMC</th></tr></thead><tbody><tr><td>Constant</td><td>1</td><td>1</td><td>5</td></tr><tr><td>ExprFactor</td><td>1</td><td>1</td><td>6</td></tr><tr><td>ExprNode</td><td>2.62</td><td>7</td><td>21</td></tr><tr><td>Expression</td><td>5.31</td><td>11</td><td>69</td></tr><tr><td>FactorFather</td><td>1</td><td>1</td><td>9</td></tr><tr><td>Item</td><td>4.7</td><td>13</td><td>47</td></tr><tr><td>Main</td><td>2</td><td>2</td><td>2</td></tr><tr><td>PowerFun</td><td>3.43</td><td>13</td><td>24</td></tr><tr><td>TriFun</td><td>3.73</td><td>12</td><td>41</td></tr><tr><td>WFexception</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WFjudge</td><td>1.67</td><td>3</td><td>5</td></tr></tbody></table><h5 id="程序行数统计-3">程序行数统计<a class="anchor" href="#程序行数统计-3">·</a></h5><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit1/hw3_sta.png" style="zoom:80%;"><p>本次代码量较上次增加了150行，主要是增加了格式正确性判断的逻辑以及修改了部分解析表达式的代码。</p><h4 id="代码分析-3">代码分析<a class="anchor" href="#代码分析-3">·</a></h4><h5 id="原理分析-3">原理分析<a class="anchor" href="#原理分析-3">·</a></h5><p>本次代码在上次的代码基础上修改了对三角函数的解析函数以及增加了嵌套求导、正确格式检查（包含了对空白字符，非法字符的解析），改动量较小。具体原理与上次作业类似。</p><p>具体方法上，增加了<code>getWhite</code>方法读入空白字符而没有做预处理，同时如果代码中遇到了不符合格式规范的输入序列，直接抛出异常，在<code>Main</code>类中进行接受和处理。</p><h5 id="优点-3">优点<a class="anchor" href="#优点-3">·</a></h5><p>格式检查正确性较好，检查的比较完整。较上次作业改动不大，可以认为是比较符合设计模式中的开放-封闭原则。</p><h5 id="缺点-3">缺点<a class="anchor" href="#缺点-3">·</a></h5><p>为了求稳，化简效果较差，仅完成了和上次程度一样的化简。</p><h2 id="二、bug分析">二、bug分析<a class="anchor" href="#二、bug分析">·</a></h2><h3 id="第一次作业-2">第一次作业<a class="anchor" href="#第一次作业-2">·</a></h3><h4 id="自己的bug">自己的bug<a class="anchor" href="#自己的bug">·</a></h4><h5 id="bug描述">bug描述<a class="anchor" href="#bug描述">·</a></h5><p>本次作业在强测中AK，在互测中被找出一个bug</p><p>被一些比较长且负号很多的用例测的时候有可能会产生下述bug：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.IllegalArgumentException: Comparison method violates its general contract!</span><br><span class="line">at java.util.TimSort.mergeLo(TimSort.java:<span class="number">777</span>)</span><br><span class="line">at java.util.TimSort.mergeAt(TimSort.java:<span class="number">514</span>)</span><br><span class="line">at java.util.TimSort.mergeCollapse(TimSort.java:<span class="number">441</span>)</span><br><span class="line">at java.util.TimSort.sort(TimSort.java:<span class="number">245</span>)</span><br><span class="line">at java.util.Arrays.sort(Arrays.java:<span class="number">1512</span>)</span><br><span class="line">at java.util.ArrayList.sort(ArrayList.java:<span class="number">1462</span>)</span><br><span class="line">at java.util.Collections.sort(Collections.java:<span class="number">175</span>)</span><br><span class="line">at Poly.getOutput(Poly.java:<span class="number">51</span>)</span><br><span class="line">at Poly.diff(Poly.java:<span class="number">42</span>)</span><br><span class="line">at Main.main(Main.java:<span class="number">17</span>)</span><br></pre></td></tr></table></figure><p>问题原因其实就是源于以下的代码。以下代码位于<code>Poly.java</code>的输出函数中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(ls, (Comparator) (o1, o2) -&gt; &#123;</span><br><span class="line">    BigInteger i1 = (BigInteger) o1;</span><br><span class="line">    BigInteger i2 = (BigInteger) o2;</span><br><span class="line">    <span class="keyword">if</span> (miXiMap.get(i1).compareTo(BigInteger.valueOf(<span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (miXiMap.get(i2).compareTo(BigInteger.valueOf(<span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i2.compareTo(i1);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>简单来说就是对一个容器进行排序时（首先本次作业排序就没必要，但笔者非常脑残地进行了降幂排序），比较函数里不能出现两个相互矛盾返回值逻辑，或者至少不要调用除了这个对象外部的变量。比如我的上述代码例子里，其实就是想降幂排序的同时将负号的移到后面去以此来简化长度，这个过程调用了外部的<code>HashMap</code>中对应幂指数的系数，这就会和JDK的底层实现相矛盾，于是造成了错误。</p><h5 id="bug修复总结">bug修复总结<a class="anchor" href="#bug修复总结">·</a></h5><p>和找出我这个bug的同学交流了一下，其实该大佬根本没看出我这个代码有啥问题，单纯用大规模的随机数据把我刀了，所以建议大家如果遇到没有必要的需求千万不要一时兴起随意加入，即使要加入也要好好翻翻文档看看能不能这么用。</p><p>那么我是怎么修改的呢，其实非常简单，我只需要查找整个序列找到一个系数为负的把他和第一个交换一下就好了。</p><p>这次bug修复也让我意识到了，简单的功能用更少的代码不一定能实现更好的效果，有时候偷懒其实会害了自己。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (miXiMap.get(ls.get(<span class="number">0</span>)).compareTo(BigInteger.ZERO) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> j = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ls.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (miXiMap.get(ls.get(i)).compareTo(BigInteger.ZERO) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            j = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j != -<span class="number">1</span>) &#123;</span><br><span class="line">        BigInteger x = ls.get(j);</span><br><span class="line">        ls.remove(j);</span><br><span class="line">        ls.add(<span class="number">0</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="他人的bug">他人的bug<a class="anchor" href="#他人的bug">·</a></h4><h5 id="bug描述-2">bug描述<a class="anchor" href="#bug描述-2">·</a></h5><p>本次共分别找到两个人的共计三个bug，由于不太了解OO玩法，第一次多交了一些错误类型差不多的数据（第二次作业我交的少多了），这里向两位同学抱歉了，以后我保证不交那么多同质用例了，纯属浪费时间。</p><p>具体hack用例和结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1 符号parse有问题 hack 2人</span></span><br><span class="line">input:+++8*x*x**+78+x**6504-+-3313147-++69209*x**-7375*x+--837214</span><br><span class="line">output:510347166*x**-7375-6504*x**-6505+632*x**78</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">2 对于没有指数的数字parse有误 抛出了异常 hack 1人</span></span><br><span class="line">input:-+-2048*52*x++9-++6*-6*x**+138-x*x+x*+406*x**36+1-+-7320*+01+x**266*-530*4---458-+-622+x*5872*+51+-1343+x**13*x**0*x**465+x*x*579713++x**-8029*x*353*9463-+79*x**+239*x-+-681--x*-8200+++9223*x+x**867*851*1*-5--x**0*-4</span><br><span class="line">output:</span><br><span class="line">Exception in thread "main" java.lang.NumberFormatException: Zero length BigInteger</span><br><span class="line">at java.math.BigInteger.&lt;init&gt;(BigInteger.java:420)</span><br><span class="line">at java.math.BigInteger.&lt;init&gt;(BigInteger.java:606)</span><br><span class="line">at Term.&lt;init&gt;(Term.java:53)</span><br><span class="line">at Box.&lt;init&gt;(Box.java:26)</span><br><span class="line">at Main.main(Main.java:14)</span><br></pre></td></tr></table></figure><p>第一个bug主要是这两位同学都采用了字符串预处理的方式，但是并没有涵盖所有的情况，比如<code>---</code>、<code>-+-</code>这样的三符号情况导致出错。</p><p>第二个bug因为一位同学在解析数字时将空串传给了<code>BigInteger</code>对象。</p><h5 id="测试方式">测试方式<a class="anchor" href="#测试方式">·</a></h5><p>本次采用了<strong>大规模随机数据生成和评测</strong>寻找不同类型bug，遇到有错误的再<strong>查看代码进行定点爆破</strong>的方式。</p><p>由于第一次的表达式较简单，直接采用了<code>sympy</code>库的<code>sympify</code>方法转换每个<code>jar</code>文件的输出和<code>sympy</code>库的输出进行比对进行测试。</p><p>同时由于这种方式有时候会parse错误，我还采用了比对房内7个人地结果找少数派的方式，加大了找到bug的概率。</p><p>笔者对生成输入数据的正则表达式加以控制，让每个可以重复的地方次数不超过4次以此控制复杂度。共生成了6组数据，每组有1000个表达式。这样的测试方式就找到了上述的bug。</p><h3 id="第二次作业-2">第二次作业<a class="anchor" href="#第二次作业-2">·</a></h3><h4 id="自己的bug-2">自己的bug<a class="anchor" href="#自己的bug-2">·</a></h4><h5 id="bug描述-3">bug描述<a class="anchor" href="#bug描述-3">·</a></h5><p>本次作业在强测中<code>WA</code>了五个点，互测被刀了12下，全是一个同质bug。</p><p>在遇到以下用例时会出现问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(x)</span><br><span class="line">错误输出:(<span class="number">1</span>)</span><br><span class="line">-(-(x))</span><br><span class="line">错误输出:((<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>简单来说就是一个负号与一个表达式因子相连时，求导会无视负号的存在。</p><h5 id="bug修复总结-2">bug修复总结<a class="anchor" href="#bug修复总结-2">·</a></h5><p>这个bug根植于设计的不够合理。我的设计是先parse输入获得一个简单的表达式树，再对每一项进行化简，而化简时将项内的每个因子的符号进行连乘（代码中是符号因子的异或运算）得到项的符号，而最后将项的符号设置到这一项的系数因子上。而实际写代码时对于表达式因子的符号，不小心写出了如下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fact.setNeg(flag != fact.getNeg());</span><br></pre></td></tr></table></figure><p><code>flag</code>即是项的符号，这里本应将<code>flag</code>的值更新，然后将<code>fact</code>的<code>neg</code>符号设置为<code>false</code>，但是却手残写成了这样。</p><p>只要改为以下代码即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flag &#x3D; flag !&#x3D; fact.getNeg();</span><br><span class="line">fact.setNeg(false);</span><br></pre></td></tr></table></figure><p>同时，我的这种方法必须要化简后才能对表达式因子做出正确输出，而表达式因子类中并没有调用化简方法，导致了表达式因子中的表达式因子输出有误。</p><p>只需要在<code>ExprFactor</code>类中增加两行代码即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exprNode.simplify();</span><br><span class="line">exprNode.mergeItems();</span><br></pre></td></tr></table></figure><h4 id="他人的bug-2">他人的bug<a class="anchor" href="#他人的bug-2">·</a></h4><h5 id="bug描述-4">bug描述<a class="anchor" href="#bug描述-4">·</a></h5><p>本次一共找出两个人共3个bug</p><p>用例和结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1 对常数求导处理有误 hack了1人</span></span><br><span class="line">in:--1837*-4816</span><br><span class="line">out:</span><br><span class="line"></span><br><span class="line">in:-6489+--595*x**8245*7592*-7893</span><br><span class="line">out:595*(+8245*x**8244*(7592*-7893)+x**8245*())</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">2 对表达式因子符号处理有误 hack了1人</span></span><br><span class="line">in:-(-x**-2-(-x**-2-(-x-(-x-(-x-sin(x))))))</span><br><span class="line">out:((0*(x)+1*(-1))+(0+((0*(x)+1*(-1))+(0+((0*(x)+1*(-1))+(0*(sin(x))+cos(x)*(-1)))))))</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">3 表达式因子求导错误 hack了1人</span></span><br><span class="line">in:--(+cos(x)**+4219*+7970+3497*-8451*x**8072*x)-+(+6179)</span><br><span class="line">out:(0+0)</span><br></pre></td></tr></table></figure><p>本次作业较上次作业主要增加的难度就在于表达式因子。需要格外注意表达式因子的<code>parse</code>和求导的符号输出。</p><h5 id="测试方式-2">测试方式<a class="anchor" href="#测试方式-2">·</a></h5><p>本次代码量太大且复杂，仍然采用了一定规模数据集测试+有针对性阅读代码的方式进行测试，仍然使用<code>python</code>评测机。</p><p>测试时将用例进行了分类，分为了多层表达式因子嵌套类，三角函数类，常数类，杂类。测试数据构造也采用递归下降的方式，简单来说也是<code>get a Expression--&gt;get many Items--&gt;get many Factors</code>这样的形式，对于每个因子采用正则表达式生成字母加上<code>python</code>随机数生成指数的方式。同时使用全局变量来记录调用<code>getExprFactor</code>方法的次数，以及在<code>getExpression</code>方法内通过判断当前字符串长度来决定是否直接返回当前字符串还是继续获得随机生成的项，同时生成数据时如果大于了长度限制就继续生成，直到长度小于等于50。用这两个方法就可以构造出符合第二次作业互测数据要求的数据点了。</p><p>对拍数据采用了官方给出的评测方式即在$[-10,10]$上随机生成$1000$个点将这些结果和<code>sympy</code>求导结果进行比对的方式，必须要全对才算这个点通过。</p><p>同时由于本次作业表达式较复杂，求导时间长，采用了多个点复用一组1000个点的数据的方式加快评测进度。同时每一组表达式的用例个数从之前的1000个降到了100个。</p><h3 id="第三次作业-2">第三次作业<a class="anchor" href="#第三次作业-2">·</a></h3><h4 id="自己的bug-3">自己的bug<a class="anchor" href="#自己的bug-3">·</a></h4><p>本次作业强测和互测中均未发现bug</p><h4 id="他人的bug-3">他人的bug<a class="anchor" href="#他人的bug-3">·</a></h4><h5 id="bug描述-5">bug描述<a class="anchor" href="#bug描述-5">·</a></h5><p>找出了一个同学的一个bug</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1 输出的字符串中右括号未输出导致错误</span></span><br><span class="line">in:-((-cos((-sin(x)))*x+cos(85)**48*x*-25))</span><br><span class="line">out:(-x*sin((-sin(x)))*cos(x)-cos((-sin(x)))-25*cos(85)**48</span><br></pre></td></tr></table></figure><h5 id="测试方式-3">测试方式<a class="anchor" href="#测试方式-3">·</a></h5><p>本次测试方式与上次类似，只是修改了测试数据生成的程序，加入了对空白字符的生成以及三角嵌套的生成，同时针对这次作业与上次作业的主要不同点三角嵌套进行了重点生成，获得了三角多层嵌套数据，然而有些数据因为长度过长，实在无法缩减，最后没有成功hack到人。</p><h2 id="三、重构经历总结">三、重构经历总结<a class="anchor" href="#三、重构经历总结">·</a></h2><h3 id="第二次作业重构">第二次作业重构<a class="anchor" href="#第二次作业重构">·</a></h3><h4 id="重构过程">重构过程<a class="anchor" href="#重构过程">·</a></h4><p>本单元主要在第二次作业开发时被迫重构了<strong>输入的解析方式</strong>和整个<strong>求导的数据结构和方法</strong>。</p><p>第一次作业时，由于表达式结构简单，笔者并没有考虑递归下降，表达式树这些方法，而是直接采用了字符串预处理和简单的项求导合并的方式。然而到了第二次作业，引入了表达式因子和三角函数，简单的正负号替换等预处理方式已经解决不了问题，而且对于表达式因子这样的嵌套求导规则并不能用简单的每项直接求导这样简单的方式了。</p><p>于是进行了重构，基本是整个项目<strong>推倒重来</strong>。</p><p>定义了因子的抽象类，以及各个具体的因子类。同时在<code>Expression</code>类中用递归下降的方式对表达式的输入进行了解析。</p><p>重构时曾经纠结过表达式树的结构问题，曾经在一个晚上想了很久二叉树应该如何建立，最终也没有想的很完善，考虑到二叉树建树和<strong>化简求导操作比较麻烦</strong>，在时间紧急的情况下，抛弃了二叉树，转而采用了<strong>多叉树</strong>的方式。而多叉树开始建立时已经到了周六上午，时间所剩无几，决定边做边思考，最终参考助教在讨论区的帖子，解析出了表达式，并利用多叉树进行了求导，效果还可以，1个上午就通过了中测。</p><h4 id="经验总结">经验总结<a class="anchor" href="#经验总结">·</a></h4><ul><li>一开始就要将之后的几次作业内容大概了解，知道最终需要做成什么样子，不要在一开始就随心所欲地设计一个简单的只符合该次要求的结构。</li><li>如果一开始并不明确之后会做成什么样子，那么应该对程序的各个部分进行解耦，比如本单元作业的字符串解析，求导，化简其实可以分属为三个部分，如果将每一部分都解开，之后重构或者增量开发时思路也会更清晰，效率也会更高。</li><li>对于一个需求，尽可能不要钻这个需求的空子寻求捷径去完成，而要寻求本质的一般性解决办法，比如本单元作业中的表达式解析，指导书中明确给出了符号形式化表达，目的就是在于提示我们使用一般化的方法对输入进行处理。</li><li>同时，重构时也不能要求过高，如果时间紧迫时，拿出一种现阶段最可行最好实现的方式进行实现就好。同时，最好边实践边思考，不要空想，有时候，做出来比做完美更重要，一定要把思路落实到纸上或者电脑上。</li></ul><h2 id="四、心得体会">四、心得体会<a class="anchor" href="#四、心得体会">·</a></h2><ul><li><p>本单元的作业着眼于表达式求导这个基本问题，从第一次的简单的幂函数求导延申到最后的幂函数和三角嵌套的求导，增量开发的过程中，涉及了一个软件从开发到测试到交付的各个环节，体验了重构，测试代码，bug修复等多个以后会经常遇到的环节，对于软件设计开发的流程有了一定的认识。</p></li><li><p>巩固了面向对象的基本知识，了解了常用的工厂模式，接口实现，层次化设计的方法，进一步加深了对于<code>java</code>语言的了解和掌握。同时，代码风格也由于<code>checkstyle</code>的介入越来越好。</p></li><li><p>增强了测试程序的编写能力，掌握了<code>multiprocessing/sympy/xeger/os</code>等常用库的使用方法和<code>java</code>文件的打包方式，了解了如何修改终端输出的颜色改善评测体验，已经可以熟练的使用<code>Python</code>搭建功能优良完善，架构清晰的评测机。</p></li><li><p>加深了对正则表达式的理解，学习到了如何使用递归下降来解析和生成输入数据。</p></li><li><p>增强了心理抗压能力，在面对ddl的压力时正确应对并解决困难后，心理更强大了。</p></li><li><p>磨炼了意志力，知道了不到最后一刻不放弃，多次OO互测在要放弃的时候用一个新的用例hack成功，只有不放弃，多尝试才有可能不断进步，不断收获新的惊喜和成果。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-OO-2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS-Lab0笔记</title>
      <link href="2021/03/10/OS-Lab0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/03/10/OS-Lab0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>OS课程Lab0学习笔记</p><a id="more"></a><h1 id="基础操作">基础操作<a class="anchor" href="#基础操作">·</a></h1><h2 id="命令行">命令行<a class="anchor" href="#命令行">·</a></h2><p>命令格式：<code>命令名 [选项] [参数]</code></p><p>Linux命令在系统中有两种类型：<code>内置Shell（外壳）命令</code>和<code>Linux命令</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf #删除所有文件</span><br></pre></td></tr></table></figure><h3 id="OS常用命令">OS常用命令<a class="anchor" href="#OS常用命令">·</a></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find ./ test.md #查找文件</span><br><span class="line">grep -r printf ./ #查找函数变量。。</span><br></pre></td></tr></table></figure><h3 id="vim常用命令">vim常用命令<a class="anchor" href="#vim常用命令">·</a></h3><img src="/2021/03/10/OS-Lab0%E7%AC%94%E8%AE%B0/vim常用操作.jpg" style="zoom: 80%;"><p>撤销重做：<code>u</code> <code>Ctrl+r</code></p><p>复制粘贴：<code>y</code> <code>p</code></p><p>剪切：<code>d</code></p><p>查找某个单词：<code>/word</code> 有多个则按n/N移到上一个或者下一个</p><p>查看某一行代码：<code>:n</code></p><p><strong>永久配置</strong>vim：在<code>~/.vimrc</code>文件中进行配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set nu</span><br><span class="line">set mouse=a</span><br><span class="line">set tabstop=2</span><br><span class="line">set tags=~/19373573-lab/tags</span><br></pre></td></tr></table></figure><h4 id="Ctags使用">Ctags使用<a class="anchor" href="#Ctags使用">·</a></h4><h5 id="配置-2">配置<a class="anchor" href="#配置-2">·</a></h5><ol><li>首先，在项目根目录（例如 <code>19373573-lab</code>）下面建立索引，即在根目录下敲：<code>ctags -R *</code></li><li>在 vim 配置文件 <code>.vimrc</code> 里面加上这句话，告诉 vim 我们 tags 文件的位置：<code>set tags=~/19373573-lab/tags</code></li></ol><h5 id="使用">使用<a class="anchor" href="#使用">·</a></h5><ul><li><p>光标放在某函数/变量上，<code>Ctrl+N</code>或者<code>Ctrl+P</code>进行代码补全。<code>Ctrl+]</code>进入代码的定义位置，<code>Ctrl+T</code>返回。</p></li><li><p>同时，<code>Ctrl+W+]</code>可以在新窗口打开其他代码。<code>Ctrl+W K</code>/<code>Ctrl+W J</code>在窗口间移动 <code>:q</code>退出窗口</p></li></ul><h3 id="git">git<a class="anchor" href="#git">·</a></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">回退版本时常用</span></span><br><span class="line">git reset hashid --hard</span><br><span class="line">git checkout .</span><br><span class="line">git add . &amp;&amp; git commit -m "1" &amp;&amp; git push --force</span><br></pre></td></tr></table></figure><h2 id="运行小操作系统">运行小操作系统<a class="anchor" href="#运行小操作系统">·</a></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/OSLAB/gxemul -E testmips -C R3000 -M 64 gxemul/vmlinux #直接运行</span><br><span class="line">/OSLAB/gxemul -E testmips -C R3000 -M 64 -V gxemul/vmlinux #调试</span><br></pre></td></tr></table></figure><p>由于OS实验经常需要使用<code>gexmul</code>模拟器，所以我直接写了一个<code>test</code>脚本封装这个指令，如下所示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash </span></span><br><span class="line">if [$1 = ''];then</span><br><span class="line">/OSLAB/gxemul -E testmips -C R3000 -M 64 gxemul/vmlinux</span><br><span class="line">else</span><br><span class="line">/OSLAB/gxemul -E testmips -C R3000 -M 64 -V gxemul/vmlinux</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="bash">breakpoint add addr (addr--&gt;usually <span class="keyword">function</span> name)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">continue</span> (<span class="built_in">continue</span> execute to next breakpoint)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">step n   (execute n steps asm code)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">lookup name|addr</span></span><br><span class="line"><span class="meta">#</span><span class="bash">dump addr</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">help</span> (get cmd <span class="built_in">help</span>)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">quit</span></span><br></pre></td></tr></table></figure><p>再给它加上权限<code>chmod +x test</code></p><p>就可以使用<code>./test</code> 直接运行操作系统</p><p>加一个任意的参数比如<code>./test 1</code>则进入调试模式</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-OS-2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OO-评测机搭建学习</title>
      <link href="2021/03/09/OO-%E8%AF%84%E6%B5%8B%E6%9C%BA%E6%90%AD%E5%BB%BA%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/03/09/OO-%E8%AF%84%E6%B5%8B%E6%9C%BA%E6%90%AD%E5%BB%BA%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>关于OO作业评测机搭建的探索</p><a id="more"></a><h3 id="将java项目打包成jar文件并运行">将java项目打包成jar文件并运行<a class="anchor" href="#将java项目打包成jar文件并运行">·</a></h3><h4 id="在IDEA中打包">在IDEA中打包<a class="anchor" href="#在IDEA中打包">·</a></h4><p><code>File-&gt;project structure</code></p><p>在弹窗最左侧选中 <code>Artifacts-&gt;&quot;+&quot;</code> ,选 <code>jar</code>，选择 <code>from modules with dependencies</code></p><p>此处需要注意两点：</p><ul><li>需要选择jar包默认运行的入口类</li><li>需要设置MANIFEST.MF的位置</li></ul><p>之后点<code>Build-&gt;Build Artifacts-&gt;在选项中点击build即可</code></p><h4 id="运行">运行<a class="anchor" href="#运行">·</a></h4><p><code>java -jar hello.jar</code></p><h3 id="生成数据—xeger">生成数据—xeger<a class="anchor" href="#生成数据—xeger">·</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xeger <span class="keyword">import</span> Xeger</span><br><span class="line">str=<span class="string">"你的正则表达式"</span></span><br><span class="line">x=Xeger(limit=<span class="number">10</span>) <span class="comment">#初始化，设置最大长度</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">x.xeger(str) <span class="comment">#循环生成字符串</span></span><br></pre></td></tr></table></figure><h3 id="驱动文件获得输出—subprocess">驱动文件获得输出—subprocess<a class="anchor" href="#驱动文件获得输出—subprocess">·</a></h3><p>最简单的就用<code>os.system(&quot;java 1.jar &lt;&lt; 1.txt &gt;&gt; out.txt&quot;)</code>的方式即可</p><h3 id="正确性判定—sympy">正确性判定—sympy<a class="anchor" href="#正确性判定—sympy">·</a></h3><p>用到的<code>sympy</code>库函数有 <code>Symbol、diff、sympify</code></p><p>此外可能需要<code>eval</code>来去掉字符串的外围双引号</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-OO-2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OO-Pre-学习笔记</title>
      <link href="2021/03/08/OO-PRE-%E7%AC%94%E8%AE%B0/"/>
      <url>2021/03/08/OO-PRE-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>2021年OO的Pre部分学习笔记</p><a id="more"></a><h2 id="工具">工具<a class="anchor" href="#工具">·</a></h2><h3 id="gitlab维护代码">gitlab维护代码<a class="anchor" href="#gitlab维护代码">·</a></h3><h4 id="Command-line-instructions">Command line instructions<a class="anchor" href="#Command-line-instructions">·</a></h4><h5 id="Git-global-setup">Git global setup<a class="anchor" href="#Git-global-setup">·</a></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name "冯张驰"</span><br><span class="line">git config --global user.email "19373573@buaa.edu.cn"</span><br></pre></td></tr></table></figure><h5 id="Create-a-new-repository">Create a new repository<a class="anchor" href="#Create-a-new-repository">·</a></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitlab.buaaoo.top/oo_homeworks_2021/仓库名.git</span><br><span class="line">cd oo_2021_pre2_19373573_pre2_task2</span><br><span class="line">touch README.md</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m "add README"</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h5 id="Existing-folder">Existing folder<a class="anchor" href="#Existing-folder">·</a></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd existing_folder</span><br><span class="line">git init</span><br><span class="line">git remote add origin https://gitlab.buaaoo.top/oo_homeworks_2021/仓库名.git</span><br><span class="line">git add .</span><br><span class="line">git commit -m "Initial commit"</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h5 id="Existing-Git-repository">Existing Git repository<a class="anchor" href="#Existing-Git-repository">·</a></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd existing_repo</span><br><span class="line">git remote rename origin old-origin</span><br><span class="line">git remote add origin https://gitlab.buaaoo.top/oo_homeworks_2021/仓库名.git</span><br><span class="line">git push -u origin --all</span><br><span class="line">git push -u origin --tags</span><br></pre></td></tr></table></figure><h4 id="补充-实验1git学习">补充-实验1git学习<a class="anchor" href="#补充-实验1git学习">·</a></h4><h5 id="step-1-新建仓库">step 1 新建仓库<a class="anchor" href="#step-1-新建仓库">·</a></h5><p>在本地新建一个空文件夹，在此目录下打开终端（bash/git bash/power shell/…）</p><p>输入</p><blockquote><p>git init</p></blockquote><p>从而得到一个新的<code>git</code>仓库</p><h5 id="step-2-关联远程仓库">step 2 关联远程仓库<a class="anchor" href="#step-2-关联远程仓库">·</a></h5><p>目前为止，<code>step 1</code>建立的文件夹还是一个空文件夹，需要关联两个远程仓库，首先考虑第一个远程仓库</p><p>第一个远程仓库是课程组提供的远程公共仓库<code>share</code></p><blockquote><p>git remote add share git@gitlab.buaaoo.top:oo_2021_public/experiment/exp1_public.git</p></blockquote><h5 id="step-3-从远程仓库拉取文件">step 3 从远程仓库拉取文件<a class="anchor" href="#step-3-从远程仓库拉取文件">·</a></h5><p>关联后可以从远程仓库拉取文件</p><p>执行命令</p><blockquote><p>git pull share master</p></blockquote><p>从<code>share</code>仓库的<code>master</code>分支下得到两个文件夹</p><h5 id="step-4-忽略不必要的文件">step 4 忽略不必要的文件<a class="anchor" href="#step-4-忽略不必要的文件">·</a></h5><p>文件夹<code>share</code>中的内容是实现了<code>Comparable</code>接口并按序输出的例程，可以尝试跑通</p><p>文件夹<code>poly</code>中的内容是任务二中需要完善的程序，是需要提交的，而且实验要求，提交时<strong>忽略</strong><code>share</code>文件夹下的所有内容，故需要使用<code>.gitignore</code></p><p>在当前工作的<strong>根目录</strong>下新建文件<code>.gitignore</code></p><p>在其中写入</p><blockquote><p>share/*</p></blockquote><p>表示<code>push</code>时忽略子目录<code>share</code>下的所有文件</p><h5 id="step-5-删除暂存区文件">step 5 删除暂存区文件<a class="anchor" href="#step-5-删除暂存区文件">·</a></h5><p>为了保证<code>.gitignore</code>正常工作，需要删除暂存区的文件</p><blockquote><p>git rm --cached . -r</p></blockquote><h5 id="step-6-删除与远程仓库的关联">step 6 删除与远程仓库的关联<a class="anchor" href="#step-6-删除与远程仓库的关联">·</a></h5><p>为了避免不必要的干扰，需要删除与远程仓库<code>share</code>的关联</p><blockquote><p>git remote remove share</p></blockquote><h5 id="step-7-关联个人实验1仓库，并尝试一次提交">step 7 关联个人实验1仓库，并尝试一次提交<a class="anchor" href="#step-7-关联个人实验1仓库，并尝试一次提交">·</a></h5><blockquote><p>git remote add origin 你的个人实验1的远程仓库链接</p><p>git add .</p><p>git commit -m “anything you want to write”</p><p>git push -u origin master</p></blockquote><p>关联到远程仓库<code>origin</code>，并尝试提交</p><p>至此，任务一的内容已全部介绍完毕，如果按照上述步骤操作后得到预期结果（例如可以正常<code>pull</code>和<code>push</code> ，且<code>.gitignore</code>文件生效等），即可开始进行任务二，课程组会对你的<code>git</code>操作进行评判</p><h4 id="平时常用操作">平时常用操作<a class="anchor" href="#平时常用操作">·</a></h4><h5 id="在IDEA里使用git">在IDEA里使用git<a class="anchor" href="#在IDEA里使用git">·</a></h5><p>点击工具栏的<code>VCS</code>，选择 <code>Import into Vision Control</code> 里的 <code>Create Git Repository </code></p><p>之后就可以在IDEA里完成 <code>commit</code> <code>push</code> 的操作了（右上角的对钩和绿色箭头），第一次 <code>push</code> 时可以设置远程仓库关联。还有<code>rollback</code>等操作</p><h5 id="一行shell代码完成更新提交">一行shell代码完成更新提交<a class="anchor" href="#一行shell代码完成更新提交">·</a></h5><h6 id="初次提交">初次提交<a class="anchor" href="#初次提交">·</a></h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add . &amp;&amp; git commit -m "Initial commit" &amp;&amp; git push -u origin master</span><br></pre></td></tr></table></figure><h6 id="之后提交">之后提交<a class="anchor" href="#之后提交">·</a></h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add . &amp;&amp; git commit -m &quot;Initial commit&quot; &amp;&amp; git push</span><br></pre></td></tr></table></figure><h5 id="代码回退">代码回退<a class="anchor" href="#代码回退">·</a></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git log #查看历史版本</span><br><span class="line">git reset --hard xxx #xxx为对应版本的hashcode </span><br><span class="line">git push origin HEAD --force #远程也更新为当前版本</span><br></pre></td></tr></table></figure><h5 id="一个项目配置多个远程源">一个项目配置多个远程源<a class="anchor" href="#一个项目配置多个远程源">·</a></h5><p>更改源的名字</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rename origin task1</span><br></pre></td></tr></table></figure><p>一次性添加好所有 task 的 remote：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">projectName=<span class="string">"pre3"</span></span><br><span class="line">ID=19XXXXXX</span><br><span class="line">taskNum=6</span><br><span class="line"><span class="keyword">for</span> ((i=1;i&lt;=<span class="variable">$taskNum</span>;++i))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    git remote add task<span class="variable">$&#123;i&#125;</span> git@gitlab.buaaoo.top:oo_homeworks_2021/oo_2021_<span class="variable">$&#123;projectName&#125;</span>_<span class="variable">$&#123;ID&#125;</span>_<span class="variable">$&#123;projectName&#125;</span>_task<span class="variable">$&#123;i&#125;</span>.git</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>然后 push 的时候 specify 一下 push 到哪个 remote，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push task3 master</span><br></pre></td></tr></table></figure><p>如果某个 task 反复 push，可以将其设置为当前 branch 的 upstream：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u task3 master</span><br></pre></td></tr></table></figure><p>之后直接使用 <code>git push</code> 即可。</p><p>也可以在 IDEA 内直接进行 push 操作。选择 Git &gt; Push…，出现操作框。左侧显示你的 branch 和 commit，上面显示你要 push 的 remote 和 branch，点击可以选择具体要 push 的内容 / 具体要 push 到哪个 remote。</p><h3 id="IDEA">IDEA<a class="anchor" href="#IDEA">·</a></h3><h4 id="使用checkstyle">使用checkstyle<a class="anchor" href="#使用checkstyle">·</a></h4><h5 id="配置">配置<a class="anchor" href="#配置">·</a></h5><p>最简单的配置方式是直接在<code>Settings -&gt; Plugins</code> 里安装好</p><p>然后在 <code>New Projects Settings -&gt; Settings for New Projects</code>里导入<code>config.xml</code>文件或者选择自带的两种代码风格检查方式。（这个default的设置仅适用于2020版，<strong>IDEA 2018</strong> :  <code>File -&gt; Other Settings -&gt; Default Settings</code>  <strong>IDEA 2019</strong> :  <code>File -&gt; Other Settings -&gt; Settings for New Projects</code> ）</p><h5 id="平时使用">平时使用<a class="anchor" href="#平时使用">·</a></h5><p><code>鼠标右键 -&gt; Check Current File</code></p><p>或者点击左下角窗口里的<code>checkstyle</code>的按钮也可</p><h4 id="配置符合课程要求">配置符合课程要求<a class="anchor" href="#配置符合课程要求">·</a></h4><h5 id="设置不自动-import-xx">设置不自动 <code>import xx.*</code><a class="anchor" href="#设置不自动-import-xx">·</a></h5><p><code>File -&gt; setting -&gt; Editor -&gt; Code Style -&gt; Java -&gt; Imports</code>设置两个count为大于100的数字</p><h3 id="评论区规范">评论区规范<a class="anchor" href="#评论区规范">·</a></h3><h4 id="提问方式">提问方式<a class="anchor" href="#提问方式">·</a></h4><p>针对作业内容答疑区</p><ul><li>作业内容，请使用“【作业内容】”</li><li>评测要求，请使用“【评测要求】”</li></ul><p>针对公共讨论区</p><ul><li>课程规则，请使用“【课程规则】“</li><li>系统使用，请使用”【系统使用】“</li><li>技术交流，请使用”【技术交流】“</li></ul><h2 id="Pre2">Pre2<a class="anchor" href="#Pre2">·</a></h2><h3 id="task1">task1<a class="anchor" href="#task1">·</a></h3><p><strong>封装</strong>：是指隐藏对象的属性和实现细节（属性变量和内部方法用<code>private</code>修饰），仅对外提供公共访问⽅法 （访问方法使用<code>public</code>）。</p><h3 id="task2">task2<a class="anchor" href="#task2">·</a></h3><p>java<strong>常用容器</strong>：HashSet，HashMap，ArrayList</p><p>容器<strong>常用方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建</span></span><br><span class="line">ArrayList&lt;Bookset&gt; booksArrayList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">Bookset book = <span class="keyword">new</span> Bookset(name, price, num);</span><br><span class="line"><span class="comment">// 添加新元素</span></span><br><span class="line">booksArrayList.add(book);</span><br><span class="line"><span class="comment">// 判断是否存在</span></span><br><span class="line"><span class="keyword">if</span> (booksArrayList.contains(book)) &#123;</span><br><span class="line">    System.out.println(<span class="string">"We have it!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历所有元素</span></span><br><span class="line"><span class="keyword">for</span> (Bookset item : booksArrayList) &#123;</span><br><span class="line">    System.out.println(item.getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出容器规模</span></span><br><span class="line">System.out.println(booksArrayList.size());</span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">booksArrayList.remove(book);</span><br></pre></td></tr></table></figure><p>主要的坑在 <code>BigDecimal</code> <code>BigInteger</code> 类的使用上</p><p>需要用 <code>BigDecimal ans = BigDecimal.valueOf(price);</code> 这样的方式来维持精度，如果直接用 <code>BigDecimal(price)</code> 会丢失精度</p><h3 id="task3">task3<a class="anchor" href="#task3">·</a></h3><h4 id="工厂模式">工厂模式<a class="anchor" href="#工厂模式">·</a></h4><p>参考菜鸟教程https://www.runoob.com/design-pattern/factory-pattern.html</p><p>步骤如下</p><h5 id="1-创建一个接口">1.创建一个接口<a class="anchor" href="#1-创建一个接口">·</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-创建实体类">2.创建实体类<a class="anchor" href="#2-创建实体类">·</a></h5><p>注意实体类是可以使用接口的方法去<strong>调用类内的属性值</strong>的</p><p>同时可以认为这些实体类都是<strong>Shape</strong>类型的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(a);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookFace</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getType</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getNum</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getOutput</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bookset</span> <span class="keyword">implements</span> <span class="title">BookFace</span> </span>&#123;</span><br><span class="line"><span class="comment">//定义各个变量</span></span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> num;   </span><br><span class="line">    <span class="keyword">private</span> String output; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bookset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        init(); <span class="comment">//调用init函数进行初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重写各个方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookShape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bookset <span class="title">getShape</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"Other"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Bookset();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"OtherA"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> OtherA();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"Novel"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Novel();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"Poetry"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Poetry();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"OtherS"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> OtherS();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"Math"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Math1();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"Computer"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Computer();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BookFace book = BookShape.getShape(type);</span><br></pre></td></tr></table></figure><p>同时也可以对一个实体类进行继承，子类也是实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">child</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(a);</span><br><span class="line">      System.out.println(b);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-创建工厂，生成指定类型对象">3.创建工厂，生成指定类型对象<a class="anchor" href="#3-创建工厂，生成指定类型对象">·</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">   <span class="comment">//使用 getShape 方法获取形状类型的对象</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(shapeType == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;        </span><br><span class="line">      <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"RECTANGLE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"child"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> child();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-使用该工厂，通过传递类型信息来获取实体类的对象。">4.使用该工厂，通过传递类型信息来获取实体类的对象。<a class="anchor" href="#4-使用该工厂，通过传递类型信息来获取实体类的对象。">·</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ShapeFactory factory = <span class="keyword">new</span> ShapeFactory();</span><br><span class="line">Shape a = factory.getShape(<span class="string">"RECTANGLE"</span>);</span><br><span class="line">a.draw();</span><br></pre></td></tr></table></figure><h3 id="task4">task4<a class="anchor" href="#task4">·</a></h3><h4 id="异常处理">异常处理<a class="anchor" href="#异常处理">·</a></h4><p>我写这里的时候用了比较拉跨的<code>if else</code>写法，不展示了，参考Roife的博客，记录一下怎么写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> exceptions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BooksetExistedException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BooksetExistedException</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"Oh, no! The "</span> + name + <span class="string">" exist."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> exceptions.BooksetExistedException;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    bookshelves.get(i).addNewBookset(bookset);</span><br><span class="line">&#125; <span class="keyword">catch</span> (BooksetExistedException e) &#123;</span><br><span class="line">    System.out.println(e.getMessage());</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123; <span class="comment">// 想想为啥要放在 finally 里面</span></span><br><span class="line">    scanner.nextLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="task5">task5<a class="anchor" href="#task5">·</a></h3><h4 id="clone和equals方法">clone和equals方法<a class="anchor" href="#clone和equals方法">·</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getClass() != obj.getClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        BookFace other = (BookFace) obj;</span><br><span class="line">        <span class="comment">//其他比较逻辑</span></span><br><span class="line">        <span class="keyword">if</span>(other.a==<span class="keyword">this</span>.a) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>() &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于基本类型可以直接继承主类方法即可，String是不可变类型</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BookFace <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pre3">Pre3<a class="anchor" href="#Pre3">·</a></h2><p>正则表达式菜鸟教程：https://www.runoob.com/regexp/regexp-tutorial.html</p><p>java正则表达式用法：https://www.runoob.com/java/java-regular-expressions.html</p><p>一篇补充的博客：https://blog.csdn.net/baidu_28289725/article/details/80414445</p><h2 id="测试方法">测试方法<a class="anchor" href="#测试方法">·</a></h2><p>https://blog.csdn.net/asdx1020/article/details/104956074</p><p>https://blog.csdn.net/asdx1020/article/details/104870918</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> BUAA-OO-2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript学习笔记</title>
      <link href="2021/03/02/%E5%89%8D%E7%AB%AF-javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/03/02/%E5%89%8D%E7%AB%AF-javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>前端的javascript资源整理和学习笔记</p><a id="more"></a><h2 id="资源整理-2">资源整理<a class="anchor" href="#资源整理-2">·</a></h2><h3 id="菜鸟教程">菜鸟教程<a class="anchor" href="#菜鸟教程">·</a></h3><p>https://www.runoob.com/js/js-tutorial.html</p><h3 id="w3school">w3school<a class="anchor" href="#w3school">·</a></h3><p>https://www.w3school.com.cn/js/index.asp</p><h2 id="慕课网教程笔记-2">慕课网教程笔记<a class="anchor" href="#慕课网教程笔记-2">·</a></h2><p>教程网站：</p><p>https://www.imooc.com/learn/36  入门篇—对应本部分1-3</p><p>https://www.imooc.com/learn/10  进阶篇—对应本部分4-8</p><h3 id="1-入门">1.入门<a class="anchor" href="#1-入门">·</a></h3><h4 id="引入JS">引入JS<a class="anchor" href="#引入JS">·</a></h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.插入<span class="selector-tag">JS</span></span><br><span class="line">&lt;script type="text/javascript"&gt;表示:</span><br><span class="line">在&lt;script&gt;&lt;/script&gt;之间的是文本类型(text)</span><br><span class="line"><span class="selector-tag">javascript</span>是为了告诉浏览器里面的文本是属于<span class="selector-tag">JavaScript</span>语言</span><br><span class="line"></span><br><span class="line">&lt;script type="text/javascript"&gt;</span><br><span class="line"><span class="selector-tag">document</span><span class="selector-class">.write</span>("开启<span class="selector-tag">JS</span>之旅!"); </span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">2.外部引用 使用<span class="selector-tag">src</span></span><br><span class="line">&lt;script src="script.js"&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">3.页面中位置</span><br><span class="line">一般放在<span class="selector-tag">head</span>或<span class="selector-tag">body</span>部分</span><br><span class="line">放在&lt;<span class="selector-tag">head</span>&gt;部分:</span><br><span class="line">最常用的方式是在页面中<span class="selector-tag">head</span>部分放置&lt;<span class="selector-tag">script</span>&gt;元素，浏览器解析<span class="selector-tag">head</span>部分就会执行这个代码，然后才解析页面的其余部分。</span><br><span class="line">放在&lt;<span class="selector-tag">body</span>&gt;部分:</span><br><span class="line"><span class="selector-tag">JavaScript</span>代码在网页读取到该语句的时候就会执行。</span><br></pre></td></tr></table></figure><p>注意: javascript作为一种脚本语言<strong>可以放在html页面中任何位置</strong>，但是浏览器<strong>解释html</strong>时是<strong>按先后顺序</strong>的，所以前面的script就先被执行。比如进行<strong>页面显示初始化的js必须放在head里面</strong>，因为初始化都要求提前进行（如给页面body设置css等）；而如果是通过<strong>事件调用</strong>执行的function那么<strong>对位置没什么要求</strong>的。</p><h4 id="语句和符号">语句和符号<a class="anchor" href="#语句和符号">·</a></h4><p>基本格式：<code>语句;</code> 分号也可不加</p><h4 id="注释">注释<a class="anchor" href="#注释">·</a></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行</span></span><br><span class="line"><span class="comment">/* 多行 */</span></span><br></pre></td></tr></table></figure><h4 id="变量声明">变量声明<a class="anchor" href="#变量声明">·</a></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> b,c;</span><br><span class="line">a=<span class="number">1</span>;</span><br><span class="line">b=<span class="string">"abs"</span></span><br><span class="line">c=<span class="literal">true</span>;</span><br><span class="line">c=<span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h4 id="基本语句-和java、C一样">基本语句 和java、C一样<a class="anchor" href="#基本语句-和java、C一样">·</a></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件)</span><br><span class="line">&#123; 条件成立时执行的代码 &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>()</span><br><span class="line">&#123; 条件不成立时执行的代码 &#125;</span><br><span class="line"><span class="keyword">else</span>&#123; &#125;</span><br><span class="line">还有<span class="keyword">do</span>...while/<span class="keyword">while</span>/<span class="keyword">for</span>/<span class="keyword">switch</span>-<span class="keyword">case</span></span><br></pre></td></tr></table></figure><h4 id="函数">函数<a class="anchor" href="#函数">·</a></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     函数代码;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以有返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add2</span>(<span class="params">x,y</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   sum = x + y;</span><br><span class="line">   <span class="keyword">return</span> sum; <span class="comment">//返回函数值,return后面的值叫做返回值。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-常用互动方法">2.常用互动方法<a class="anchor" href="#2-常用互动方法">·</a></h3><h4 id="输出内容（document-write）">输出内容（document.write）<a class="anchor" href="#输出内容（document-write）">·</a></h4><h5 id="第一种-输出内容用-“括起，直接输出”-号内的内容。">第一种:输出内容用&quot;“括起，直接输出”&quot;号内的内容。<a class="anchor" href="#第一种-输出内容用-“括起，直接输出”-号内的内容。">·</a></h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type="text/javascript"&gt;</span><br><span class="line">  document.write("I love JavaScript！"); //内容用""括起来，""里的内容直接输出。</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h5 id="第二种-通过变量，输出内容">第二种:通过变量，输出内容<a class="anchor" href="#第二种-通过变量，输出内容">·</a></h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type="text/javascript"&gt;</span><br><span class="line">  var mystr="hello world!";</span><br><span class="line">  document.write(mystr);  //直接写变量名，输出变量存储的内容。</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h5 id="第三种-输出多项内容，内容之间用-号连接。">第三种:输出多项内容，内容之间用+号连接。<a class="anchor" href="#第三种-输出多项内容，内容之间用-号连接。">·</a></h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type="text/javascript"&gt;</span><br><span class="line">  var mystr="hello";</span><br><span class="line">  document.write(mystr+"I love JavaScript"); //多项内容之间用+号连接</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h5 id="第四种-输出HTML标签，并起作用，标签使用-括起来。">第四种:输出HTML标签，并起作用，标签使用&quot;&quot;括起来。<a class="anchor" href="#第四种-输出HTML标签，并起作用，标签使用-括起来。">·</a></h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type="text/javascript"&gt;</span><br><span class="line">  var mystr="hello";</span><br><span class="line">document.write(mystr+"&lt;br&gt;");//输出hello后，输出一个换行符</span><br><span class="line">  <span class="selector-tag">document</span><span class="selector-class">.write</span>("<span class="selector-tag">JavaScript</span>");</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>关于JS输出空格问题，请查看wiki中&quot; <a href="http://www.imooc.com/wiki/view?pid=167" target="_blank" rel="noopener">JS如何输出空格</a> &quot;</p><h4 id="警告（alert-消息对话框）">警告（alert 消息对话框）<a class="anchor" href="#警告（alert-消息对话框）">·</a></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(字符串或变量);</span><br></pre></td></tr></table></figure><p><strong>注意</strong>:</p><ol><li>在点击对话框&quot;确定&quot;按钮前，不能进行任何其它操作。</li><li>消息对话框通常可以用于调试程序。</li><li>alert输出内容，可以是字符串或变量，与document.write 相似。</li></ol><h4 id="确认（confirm-消息对话框）">确认（confirm 消息对话框）<a class="anchor" href="#确认（confirm-消息对话框）">·</a></h4><h5 id="语法">语法:<a class="anchor" href="#语法">·</a></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">confirm(str);</span><br></pre></td></tr></table></figure><h5 id="参数说明">参数说明:<a class="anchor" href="#参数说明">·</a></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str：在消息对话框中要显示的文本</span><br><span class="line">返回值: <span class="built_in">Boolean</span>值</span><br></pre></td></tr></table></figure><h5 id="返回值">返回值:<a class="anchor" href="#返回值">·</a></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当用户点击<span class="string">"确定"</span>按钮时，返回<span class="literal">true</span></span><br><span class="line">当用户点击<span class="string">"取消"</span>按钮时，返回<span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>注1:</strong> 通过返回值可以判断用户点击了什么按钮</p><p><strong>注2</strong>: 消息对话框是排它的，即用户在点击对话框按钮前，不能进行任何其它操作。</p><h4 id="提问（prompt-消息对话框）">提问（prompt 消息对话框）<a class="anchor" href="#提问（prompt-消息对话框）">·</a></h4><p>弹出消息对话框（包含一个<strong>确定按钮</strong>、<strong>取消按钮</strong>与一个<strong>文本输入框</strong>）。</p><h5 id="语法-2">语法:<a class="anchor" href="#语法-2">·</a></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prompt(str1, str2);</span><br></pre></td></tr></table></figure><h5 id="参数说明：">参数说明：<a class="anchor" href="#参数说明：">·</a></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1: 要显示在消息对话框中的文本，不可修改</span><br><span class="line">str2：文本框中的内容，可以修改</span><br></pre></td></tr></table></figure><h5 id="返回值-2">返回值:<a class="anchor" href="#返回值-2">·</a></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 点击确定按钮，文本框中的内容将作为函数返回值</span><br><span class="line"><span class="number">2.</span> 点击取消按钮，将返回<span class="literal">null</span></span><br></pre></td></tr></table></figure><h4 id="打开新窗口（window-open）">打开新窗口（window.open）<a class="anchor" href="#打开新窗口（window-open）">·</a></h4><p>open() 方法可以查找一个已经存在或者新建的浏览器窗口。</p><p><strong>语法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.open([URL], [窗口名称], [参数字符串])</span><br></pre></td></tr></table></figure><p><strong>参数说明:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">URL：可选参数，在窗口中要显示网页的网址或路径。如果省略这个参数，或者它的值是空字符串，那么窗口就不显示任何文档。</span><br><span class="line">窗口名称：可选参数，被打开窗口的名称。</span><br><span class="line">    <span class="number">1.</span>该名称由字母、数字和下划线字符组成。</span><br><span class="line">    <span class="number">2.</span><span class="string">"_top"</span>、<span class="string">"_blank"</span>、<span class="string">"_self"</span>具有特殊意义的名称。</span><br><span class="line">       _blank：在新窗口显示目标网页</span><br><span class="line">       _self：在当前窗口显示目标网页</span><br><span class="line">       _top：框架网页中在上部窗口中显示目标网页</span><br><span class="line">    <span class="number">3.</span>相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。</span><br><span class="line">    <span class="number">4.n</span>ame 不能包含有空格。</span><br><span class="line">参数字符串：可选参数，设置窗口参数，各参数用逗号隔开。</span><br></pre></td></tr></table></figure><p><strong>参数表:</strong></p><p><strong><a href="http://img.mukewang.com/52e3677900013d6a05020261.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/52e3677900013d6a05020261.jpg" alt="img"></a></strong></p><p>例如:打开http://www.imooc.com网站，大小为300px * 200px，无菜单，无工具栏，无状态栏，有滚动条窗口：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type="text/javascript"&gt; window.open('http://www.imooc.com','_blank','width=300,height=200,menubar=no,toolbar=no, status=no,scrollbars=yes')</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type="text/javascript"&gt;</span><br><span class="line">  <span class="selector-tag">function</span> <span class="selector-tag">Wopen</span>()&#123;</span><br><span class="line">    window.open("http://www.imooc.com","_blank"); </span><br><span class="line">  &#125; </span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;input name="button" type="button" onClick="Wopen()" value="点击我，打开新窗口!" /&gt;</span><br></pre></td></tr></table></figure><p>**注意：**运行结果考虑浏览器兼容问题。</p><h4 id="关闭窗口（window-close）">关闭窗口（window.close）<a class="anchor" href="#关闭窗口（window-close）">·</a></h4><p><strong>用法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.close();   <span class="comment">//关闭本窗口</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;窗口对象&gt;.close();   <span class="comment">//关闭指定的窗口</span></span><br></pre></td></tr></table></figure><h3 id="3-DOM操作">3.DOM操作<a class="anchor" href="#3-DOM操作">·</a></h3><h4 id="DOM介绍">DOM介绍<a class="anchor" href="#DOM介绍">·</a></h4><p>文档对象模型<strong>DOM</strong>（Document Object Model）定义访问和处理HTML文档的标准方法。</p><p>DOM 将HTML文档呈现为<strong>带有元素、属性和文本</strong>的<strong>树结构</strong>（<strong>节点树</strong>）。</p><h4 id="通过ID获取元素">通过ID获取元素<a class="anchor" href="#通过ID获取元素">·</a></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mychar= <span class="built_in">document</span>.getElementById(<span class="string">"con"</span>);</span><br></pre></td></tr></table></figure><p>注:获取的元素是一个对象，如想对元素进行操作，我们要通过它的属性或方法。</p><h4 id="innerHTML-属性">innerHTML 属性<a class="anchor" href="#innerHTML-属性">·</a></h4><p>用于获取或替换 HTML 元素的内容</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type="text/javascript"&gt;</span><br><span class="line">  var mychar=document.getElementById("con");</span><br><span class="line">  mychar.innerHTML="hello world!"; //利用innerHTML属性修改标签内容</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="改变-HTML-样式">改变 HTML 样式<a class="anchor" href="#改变-HTML-样式">·</a></h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.style.property=new style;</span><br><span class="line">var mychar = document.getElementById("pcon");</span><br><span class="line">mychar.style.color="red";</span><br><span class="line">mychar.style.fontSize="20";</span><br></pre></td></tr></table></figure><p>**注意:**Object是获取的元素对象，如通过document.getElementById(“id”)获取的元素。</p><p><strong>基本属性表（property）:</strong></p><p><strong><a href="http://img.mukewang.com/52e4d4240001dd6c04850229.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/52e4d4240001dd6c04850229.jpg" alt="img"></a></strong></p><p>**注意:**该表只是一小部分CSS样式属性，其它样式也可以通过该方法设置和修改。</p><h4 id="显示和隐藏（display属性）">显示和隐藏（display属性）<a class="anchor" href="#显示和隐藏（display属性）">·</a></h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.style.display = value</span><br></pre></td></tr></table></figure><h5 id="value取值">value取值:<a class="anchor" href="#value取值">·</a></h5><p><strong><a href="http://img.mukewang.com/52e4dba5000179da04110095.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/52e4dba5000179da04110095.jpg" alt="img"></a></strong></p><h4 id="控制类名（className-属性）">控制类名（className 属性）<a class="anchor" href="#控制类名（className-属性）">·</a></h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object.className = classname</span><br></pre></td></tr></table></figure><h4 id="本章思路小结">本章思路小结<a class="anchor" href="#本章思路小结">·</a></h4><pre class="mermaid">graph LRa[document.getElementById方法通过ID获取元素-即DOM对象]-->b[修改对象的属性]b-->c[Object.innerHTML改变代码]b-->d[Object.style.property改变样式]b-->e[Object.display改变隐藏与否]b-->f[Object.classname改变类名]</pre><h3 id="4-数组">4.数组<a class="anchor" href="#4-数组">·</a></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myarray=<span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">//创建 括号内可以设置个数</span></span><br><span class="line"><span class="keyword">var</span> myarray = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">66</span>,<span class="number">80</span>,<span class="number">90</span>,<span class="number">77</span>,<span class="number">59</span>);<span class="comment">//创建数组同时赋值</span></span><br><span class="line"><span class="keyword">var</span> myarray = [<span class="number">66</span>,<span class="number">80</span>,<span class="number">90</span>,<span class="number">77</span>,<span class="number">59</span>];<span class="comment">//直接输入一个数组（称 “字面量数组”）</span></span><br><span class="line"><span class="comment">//数组存储的数据可以是任何类型（数字、字符、布尔值等）</span></span><br><span class="line">myarray[<span class="number">5</span>]=<span class="number">88</span>; <span class="comment">//使用一个新索引，为数组增加一个新元素</span></span><br><span class="line">myarray.length; <span class="comment">//获得数组myarray的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二维数组的定义方法一</span></span><br><span class="line"><span class="keyword">var</span> myarr=<span class="keyword">new</span> <span class="built_in">Array</span>();  <span class="comment">//先声明一维 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;   <span class="comment">//一维长度为2</span></span><br><span class="line">   myarr[i]=<span class="keyword">new</span> <span class="built_in">Array</span>();  <span class="comment">//再声明二维 </span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;   <span class="comment">//二维长度为3</span></span><br><span class="line">   myarr[i][j]=i+j;   <span class="comment">// 赋值，每个数组元素的值为i+j</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//二维数组的定义方法二</span></span><br><span class="line"><span class="keyword">var</span> Myarr = [[<span class="number">0</span> , <span class="number">1</span> , <span class="number">2</span> ],[<span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span>]]</span><br></pre></td></tr></table></figure><h3 id="5-事件响应">5.事件响应<a class="anchor" href="#5-事件响应">·</a></h3><p>事件是<strong>可以被 JavaScript 侦测到的行为</strong>。 网页中的每个元素都可以产生某些可以触发 JavaScript 函数或程序的事件。</p><h5 id="主要事件表">主要事件表<a class="anchor" href="#主要事件表">·</a></h5><p><a href="http://img.mukewang.com/53e198540001b66404860353.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/53e198540001b66404860353.jpg" alt="img"></a></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">form</span>&gt;</span><br><span class="line">&lt;input name="button" type="button" value="点击提交" onclick="add2()" /&gt;</span><br><span class="line">&lt;input name="确定" type="button" value="确定" onmouseover="add()"/&gt; </span><br><span class="line">&lt;a href="http://www.imooc.com" onmouseout="message()"&gt;点击我&lt;/a&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>onfocus和onblur是相对于一个区域的焦点说的</p><h5 id="加载事件（onload）">加载事件（onload）<a class="anchor" href="#加载事件（onload）">·</a></h5><p>事件会在页面加载完成后，立即发生，同时执行被调用的程序。</p><p>注意：加载页面时，触发onload事件，事件写在<code>&lt;body&gt;</code>标签内。</p><h5 id="卸载事件（onunload）">卸载事件（onunload）<a class="anchor" href="#卸载事件（onunload）">·</a></h5><p>当用户退出页面时（页面关闭、页面刷新等），触发onUnload事件，同时执行被调用的程序。</p><p>注意：不同浏览器对onunload事件支持不同。</p><h3 id="6-JS内置对象">6.JS内置对象<a class="anchor" href="#6-JS内置对象">·</a></h3><h4 id="Date日期对象">Date日期对象<a class="anchor" href="#Date日期对象">·</a></h4><p>定义一个时间对象 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Udate=<span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">/*使 Udate 成为日期对象，并且已有初始值：当前时间(当前电脑系统时间)。*/</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>:使用关键字new，Date()的首字母必须大写。</p><p>如果要自定义初始值，可以用以下方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2012</span>, <span class="number">10</span>, <span class="number">1</span>);  <span class="comment">//2012年10月1日</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'Oct 1, 2012'</span>); <span class="comment">//2012年10月1日</span></span><br></pre></td></tr></table></figure><p>我们最好使用下面介绍的<strong>方法</strong>来严格定义时间。</p><p><strong>访问方法语法：</strong>“&lt;日期对象&gt;.&lt;方法&gt;”</p><p>Date对象中处理时间和日期的常用方法：</p><p><a href="http://img.mukewang.com/555c650d0001ae7b04180297.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/555c650d0001ae7b04180297.jpg" alt="img"></a></p><h4 id="String-字符串对象">String 字符串对象<a class="anchor" href="#String-字符串对象">·</a></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"I Love Beijing"</span>;</span><br><span class="line">str=str.toUpperCase(); <span class="comment">//转换为大写字母 还有toLowerCase()</span></span><br><span class="line"><span class="keyword">var</span> len=str.length; <span class="comment">//获取长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取指定位置字符</span></span><br><span class="line">stringObject.charAt(index)</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回指定的字符串首次出现的位置</span></span><br><span class="line">stringObject.indexOf(substring, startpos)</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串分割split()</span></span><br><span class="line">stringObject.split(separator,limit) <span class="comment">//limit--&gt;分割的最大次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提取字符串substring()</span></span><br><span class="line">stringObject.substring(startPos,stopPos) </span><br><span class="line"></span><br><span class="line"><span class="comment">//提取指定数目的字符substr()</span></span><br><span class="line">stringObject.substr(startPos,length) <span class="comment">//提取从 startPos位置开始的指定数目的字符串。</span></span><br></pre></td></tr></table></figure><h4 id="Math对象">Math对象<a class="anchor" href="#Math对象">·</a></h4><p>Math 对象是一个<strong>固有的对象</strong>，<strong>无需创建它</strong>，<strong>直接</strong>把 Math <strong>作为对象使用</strong>就<strong>可以调用</strong>其所有属性和方法。这是它与Date,String对象的<strong>区别</strong>。</p><h5 id="常用的属性、方法">常用的属性、方法<a class="anchor" href="#常用的属性、方法">·</a></h5><p>属性：<code>Math.PI</code></p><p>方法：<code>Math.ceil()</code> (向上取整)  <code>Math.floor()</code> (向下取整) <code>Math.round()</code> (四舍五入)  <code>Math.random()</code> (随机数，返回一个$[0,1]$区间内的随机数)</p><h5 id="Math-对象属性">Math 对象属性<a class="anchor" href="#Math-对象属性">·</a></h5><p><a href="http://img.mukewang.com/532fe7cf0001e7b505170269.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/532fe7cf0001e7b505170269.jpg" alt="img"></a></p><h5 id="Math-对象方法">Math 对象方法<a class="anchor" href="#Math-对象方法">·</a></h5><p><a href="http://img.mukewang.com/532fe841000174db05160622.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/532fe841000174db05160622.jpg" alt="img"></a></p><h4 id="Array-数组对象">Array 数组对象<a class="anchor" href="#Array-数组对象">·</a></h4><h5 id="数组定义的方法">数组定义的方法<a class="anchor" href="#数组定义的方法">·</a></h5><p>1.定义了一个空数组:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组名= <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br></pre></td></tr></table></figure><p>2.定义时指定有n个空元素的数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组名 =<span class="keyword">new</span> <span class="built_in">Array</span>(n);</span><br></pre></td></tr></table></figure><p>3.定义数组的时候，直接初始化数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组名 = [&lt;元素<span class="number">1</span>&gt;, &lt;元素<span class="number">2</span>&gt;, &lt;元素<span class="number">3</span>&gt;...];</span><br></pre></td></tr></table></figure><p>我们定义myArray数组，并赋值，<strong>代码如下：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray = [<span class="number">2</span>, <span class="number">8</span>, <span class="number">6</span>];</span><br></pre></td></tr></table></figure><p>**说明：**定义了一个数组 myArray，里边的元素是：<code>myArray[0] = 2; myArray[1] = 8; myArray[2] = 6。</code></p><h5 id="数组元素使用">数组元素使用<a class="anchor" href="#数组元素使用">·</a></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名[下标] = 值;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>: 数组的下标用方括号括起来，从0开始。</p><h5 id="数组属性">数组属性<a class="anchor" href="#数组属性">·</a></h5><p>length 用法：&lt;数组对象&gt;.length；返回：数组的长度，即数组里有多少个元素。它等于数组里最后一个元素的下标加一。</p><h5 id="数组方法">数组方法<a class="anchor" href="#数组方法">·</a></h5><p><a href="http://img.mukewang.com/533295ab0001dead05190599.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/533295ab0001dead05190599.jpg" alt="img"></a></p><h5 id="常用方法">常用方法<a class="anchor" href="#常用方法">·</a></h5><p><code>arrayObject.concat(array1,array2,...,arrayN)</code>  返回一个新数组，原数组不改变</p><p><code>arrayObject.join(分隔符)</code>  把数组中的<strong>所有元素放入一个字符串</strong>。元素是通过<strong>指定的分隔符</strong>进行<strong>分隔</strong>的。</p><p><code>arrayObject.reverse()</code>  颠倒数组中元素的顺序。原数组改变</p><p><code>arrayObject.slice(start,end)</code>  返回一个新的数组，包含从 start 到 end （<strong>不包括该元素</strong>）的 arrayObject 中的元素。类似<code>python</code>的切片</p><p><code>arrayObject.sort(方法函数)</code></p><p><strong>注意</strong>: 该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：</p><p>若返回值**&lt;=-1**，则表示 <strong>A</strong> 在排序后的序列中<strong>出现在 B 之前</strong>。若返回值**&gt;-1 &amp;&amp; &lt;1**，则表示 <strong>A 和 B</strong> 具有<strong>相同</strong>的排序顺序。若返回值**&gt;=1**，则表示 <strong>A</strong> 在排序后的序列中<strong>出现在 B 之后</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortNum</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line"> <span class="comment">//升序，如降序，把“a - b”改成“b - a”</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myarr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"80"</span>,<span class="string">"16"</span>,<span class="string">"50"</span>,<span class="string">"6"</span>,<span class="string">"100"</span>,<span class="string">"1"</span>);</span><br><span class="line"><span class="built_in">document</span>.write(myarr + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"><span class="built_in">document</span>.write(myarr.sort(sortNum));</span><br></pre></td></tr></table></figure><h3 id="7-window对象">7.window对象<a class="anchor" href="#7-window对象">·</a></h3><p>window对象是BOM的核心，window对象指<strong>当前的浏览器窗口</strong>。</p><h4 id="window对象方法">window对象方法<a class="anchor" href="#window对象方法">·</a></h4><p><strong><a href="http://img.mukewang.com/535483720001a54506670563.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/535483720001a54506670563.jpg" alt="img"></a></strong></p><h3 id="8-认识DOM">8.认识DOM<a class="anchor" href="#8-认识DOM">·</a></h3><p>HTML文档可以说由节点构成的集合，DOM节点有:</p><p><strong>1.</strong> <strong>元素节点：</strong><code>&lt;html&gt;、&lt;body&gt;、&lt;p&gt;</code>等都是元素节点，即标签。</p><p><strong>2.</strong> **文本节点:**向用户展示的内容，如<code>&lt;li&gt;...&lt;/li&gt;</code>中的文本。</p><p><strong>3.</strong> **属性节点:**元素属性，如<code>&lt;a&gt;</code>标签的链接属性href=“http://www.imooc.com”。</p><h5 id="节点属性">节点属性<a class="anchor" href="#节点属性">·</a></h5><p><a href="http://img.mukewang.com/5375c953000117ee05240129.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/5375c953000117ee05240129.jpg" alt="img"></a></p><h5 id="遍历节点树">遍历节点树<a class="anchor" href="#遍历节点树">·</a></h5><p><a href="http://img.mukewang.com/53f17a6400017d2905230219.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/53f17a6400017d2905230219.jpg" alt="img"></a></p><h5 id="DOM操作">DOM操作<a class="anchor" href="#DOM操作">·</a></h5><p><a href="http://img.mukewang.com/538d29da000152db05360278.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/538d29da000152db05360278.jpg" alt="img"></a></p><p>**注意:**前两个是document方法。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>薛兆丰经济学讲义笔记</title>
      <link href="2021/02/28/%E8%96%9B%E5%85%86%E4%B8%B0%E7%BB%8F%E6%B5%8E%E5%AD%A6%E8%AE%B2%E4%B9%89%E7%AC%94%E8%AE%B0/"/>
      <url>2021/02/28/%E8%96%9B%E5%85%86%E4%B8%B0%E7%BB%8F%E6%B5%8E%E5%AD%A6%E8%AE%B2%E4%B9%89%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>阅读薛兆丰的《经济学讲义》的读书笔记</p><a id="more"></a><h1 id="前言-人类的四大约束">前言 人类的四大约束<a class="anchor" href="#前言-人类的四大约束">·</a></h1><p>人类的四大约束：东西不够，生命有限，互相依赖，需要协调</p><h1 id="第1章-稀缺—为何商业是最大的慈善">第1章 稀缺—为何商业是最大的慈善<a class="anchor" href="#第1章-稀缺—为何商业是最大的慈善">·</a></h1><h2 id="真实世界-经济学的视角">真实世界|经济学的视角<a class="anchor" href="#真实世界-经济学的视角">·</a></h2><h3 id="1-战俘营里的经济组织">1.战俘营里的经济组织<a class="anchor" href="#1-战俘营里的经济组织">·</a></h3><p>二战德国战俘营里也产生了经济组织，有交易，有货币（香烟），有价格波动，有通胀紧缩</p><h3 id="2-马粪争夺案">2.马粪争夺案<a class="anchor" href="#2-马粪争夺案">·</a></h3><p>鼓励人们创造财富，社会才会越变越好</p><p>本案中法官将公路上的马粪所有权最终判给了搬马粪的原告，从而鼓励了该地区的人民劳动积极性</p><p><strong>公正和公平</strong>的背后是<strong>效率</strong>考量，是对整体社会<strong>长远发展的效率</strong>的考量</p><h3 id="3-看得见的和看不见的">3.看得见的和看不见的<a class="anchor" href="#3-看得见的和看不见的">·</a></h3><p><strong>破窗理论</strong>——有破坏才有进步</p><p>变种1：国家发展需要大的灾难</p><p>变种2：工人就业（机器取代工人，工人没有工作做）（机器取代工人，工人也不一定能找到新工作）</p><p>变种3：少用塑料袋</p><p>做决策时不仅要考虑到看的见的损失，也要考虑隐形的净损失（另一种方案或者情况也许有更大收益）</p><h3 id="4-区分愿望和结果">4.区分愿望和结果<a class="anchor" href="#4-区分愿望和结果">·</a></h3><p>现代经济学研究的是<strong>事与愿违</strong>的现象。</p><p>美好愿望不一定带来理想结果，坏人干坏事的影响也相对有限，好人好心不一定干好事。</p><p>比如：</p><ul><li><strong>最低工资制度</strong>本想保护穷人，但穷人仍然穷</li><li><strong>同工同酬制度</strong>本想保护弱势群体最后却伤害了他们</li><li><strong>福利制度</strong>让没有依靠的人更惨</li><li><strong>保护动物的法律</strong>让动物减少</li><li><strong>政府立法不是问题的终点</strong>，上有法律，下有对策。</li></ul><h2 id="人性观-人是理性和自私的吗">人性观|人是理性和自私的吗<a class="anchor" href="#人性观-人是理性和自私的吗">·</a></h2><h3 id="5-不确定性、进化与经济理论">5.不确定性、进化与经济理论<a class="anchor" href="#5-不确定性、进化与经济理论">·</a></h3><p><strong>阿曼阿尔钦</strong>的论文**《不确定性、进化与经济理论》**认为万物存活看条件，与理性与否无关。</p><p>经济学基础不是人是理性的，而是人应该如何存活。经济学关心的是<strong>存活的条件</strong>。</p><p>随着时代和条件变化，存活条件始终在变化，物竞天择，适者生存（进化论）。</p><h3 id="6-亚当斯密的人性观">6.亚当斯密的人性观<a class="anchor" href="#6-亚当斯密的人性观">·</a></h3><p>亚当斯密的《国富论》主张人是自私的，认为人在只追求自己福利同时，也会隐形地推动社会进步。他的《道德情操论》讲的是人应该有道德。</p><p>亚当斯密的观点如下：</p><ul><li><p>人性自私完全不自私甚至对自己自暴自弃的人得不到他人尊重</p></li><li><p>人不仅是自私的，也具有同情心和爱心</p></li><li><p>人的爱心有限，随着距离拉远而减弱</p></li><li><p>仅靠爱心不够，陌生人互助需要市场协调。我们让他人帮助自己往往需要说出唤起他们的利己心话。</p></li><li><p>人际互动二分法：小圈子靠爱心，大世界靠市场</p></li></ul><h3 id="7-铅笔的故事">7.铅笔的故事<a class="anchor" href="#7-铅笔的故事">·</a></h3><p>《我，铅笔的故事》——伦纳德.里德</p><p>市场让很多互不认识不一样的人一起参与制作了铅笔</p><h3 id="8-商业是最大的慈善">8.商业是最大的慈善<a class="anchor" href="#8-商业是最大的慈善">·</a></h3><p>世界银行扶贫失败；哈利波特商业奇迹，2005年7月16日英美两国将900万册哈6送到了读者手里。</p><p>两者透露出行善和商业这两个模式存在本质区别。</p><p>行善扶贫难见成效四大原因：</p><ul><li><strong>缺乏反馈机制</strong>。行善者不能确定自己的行善行为是否是正确有效的。</li><li><strong>委托代理问题</strong>。负责行善的人花的不是自己的钱，不认真。</li><li><strong>所托非人问题</strong>。将钱交给贫困根源的地方政府。</li><li><strong>养懒汉效应</strong>。持续扶贫造成人们的依赖和懒惰，人们甚至考虑如何保住贫困的帽子。</li></ul><p>商业行为由于市场协调机制和鼓励人们分工合作，大幅持续高效的改进了人们的福利。商业是大量陌生人给予的慈善，商业是最大的慈善。</p><h2 id="区别对待-选择的标准">区别对待|选择的标准<a class="anchor" href="#区别对待-选择的标准">·</a></h2><h3 id="9-稀缺">9.稀缺<a class="anchor" href="#9-稀缺">·</a></h3><p>经济学大厦应当建立在<strong>稀缺</strong>这个基础上。</p><p>稀缺的原因</p><ol><li>我们想要的东西别人也想要</li><li>人的需求在不断变化和升级，即人的欲望是无限的。</li></ol><h3 id="10-选择和歧视">10.选择和歧视<a class="anchor" href="#10-选择和歧视">·</a></h3><p><strong>稀缺</strong>，<strong>选择</strong>，<strong>区别对待</strong>，<strong>歧视</strong>四个概念融为一体，有了一个也有了其他三个。因此歧视不可避免</p><p>因为想消除歧视，而导致了<strong>逆向歧视</strong>。美国的白人在有些方面却因为不是黑人而得不到一些福利。</p><p>真正重要的是<strong>如何歧视</strong>。</p><h3 id="11-凡歧视必得付代价">11.凡歧视必得付代价<a class="anchor" href="#11-凡歧视必得付代价">·</a></h3><p>因为歧视（以偏概全）的认识成本最低，所以人很容易先入为主。</p><p>对人歧视越多，付出代价也越大。因为市场往往需要让人放下偏见，通力合作。</p><p><strong>市场竞争</strong>让人心胸宽广。偏远小镇的歧视比繁华的大都市严重很多。</p><h3 id="12-歧视的作用和限制歧视的恶果">12.歧视的作用和限制歧视的恶果<a class="anchor" href="#12-歧视的作用和限制歧视的恶果">·</a></h3><p>东南亚华人把当地人按照姓氏，方言，国籍分成7等，不同距离关系的人做生意条款不一样，这样反而使人生地不熟的他们得到了很好的发展。</p><p>20世纪初美国针对买房借贷的平权运动，最终导致政府强制银行多借贷，导致次贷危机。反歧视运动导致恶果。</p><p>说明某些歧视未必有害，可能是有效率的。</p><h1 id="第2章-成本—不要只盯着钱">第2章 成本—不要只盯着钱<a class="anchor" href="#第2章-成本—不要只盯着钱">·</a></h1><h2 id="选择偏好-一句话给成本下定义">选择偏好|一句话给成本下定义<a class="anchor" href="#选择偏好-一句话给成本下定义">·</a></h2><h3 id="13-一句话给成本下定义">13.一句话给成本下定义<a class="anchor" href="#13-一句话给成本下定义">·</a></h3><p>采石场旁边买一块空地，防止有开发商开发房地产影响采石场。实际是采石场的消费者买下了这块地。</p><p>成本是放弃了的最大代价。即被选中的选项是所有放弃的选项中价值最高的。</p><p>沉没成本：已经发生不可收回的支出。——其实不是成本，因为已经没办法收回或放弃，成本是向前看的。</p><h3 id="14-你的成本由被人来决定">14.你的成本由被人来决定<a class="anchor" href="#14-你的成本由被人来决定">·</a></h3><p>负面的感受不是成本</p><p>你的成本由他人决定</p><p>你的职业范围由社会决定</p><h3 id="15-别只盯着钱">15.别只盯着钱<a class="anchor" href="#15-别只盯着钱">·</a></h3><p>货币成本不等于全部成本，比如假货货币成本低，但是有维权成本。</p><p>志愿兵制优于义务征兵制（义务征兵看似成本低但是使得一些科学家等也变成了士兵）</p><p>中间商赚差价，让价格更便宜。因为中间商也要竞争，同时可以免去消费者的一些麻烦。</p><h2 id="资源的价值-重新理解盈利和亏损">资源的价值|重新理解盈利和亏损<a class="anchor" href="#资源的价值-重新理解盈利和亏损">·</a></h2><h3 id="16-从成本角度理解盈利和亏损">16.从成本角度理解盈利和亏损<a class="anchor" href="#16-从成本角度理解盈利和亏损">·</a></h3><p>盈利是意外的，提升了资源使用的成本</p><p>亏损降低了资源使用成本</p><h3 id="17-最终产品的供需决定原材料的成本">17.最终产品的供需决定原材料的成本<a class="anchor" href="#17-最终产品的供需决定原材料的成本">·</a></h3><p>关于产品价格的形成过程，有成本决定论和供需决定论。</p><p>成本决定价格肯定是错误的</p><p>供需关系决定商品价格，商品价格决定资源成本</p><h3 id="18-“租”是对资产的付费">18.“租”是对资产的付费<a class="anchor" href="#18-“租”是对资产的付费">·</a></h3><p>租，是对资产的付费</p><p>资产—能够带来收入的资源，含义很广，包括土地，矿山，人的才能，发明创造…</p><p>猫王成为歌星前当司机的收入为10万/年，成为歌星后收入为1000万，多出的990万即为租。因为即使他的收入降低100万，900万，他还是会当歌星。</p><p>政府安排的出租车牌有价—垄断带来的收入，也是租—垄断租</p><p>租是旱涝保收的收入</p><p>租看似是白赚的，但是如果本身不努力打理，租也会下降很多。</p><h3 id="19-寻租—乞丐没有白拿施舍">19.寻租—乞丐没有白拿施舍<a class="anchor" href="#19-寻租—乞丐没有白拿施舍">·</a></h3><p>寻租概念起源：贼没有减少社会总财富，但是增加了人们造锁的成本，消耗了资源。</p><p>政府管制下资源消耗：企业之间为了争夺政策福利付出代价，竞争成本造成的内耗超过了政策本身的价值。</p><p>乞丐之间也是通过竞争才可以拿到施舍，没有白拿。</p><p>寻找能够带来收入的资产，分为两类：一类是努力工作提升自我，增加了社会财富。另一类是内卷竞争，消耗社会财富，即寻租。</p><p>贫穷国家制度不合理，寻租行为非常普遍，所以相对贫穷。</p><h2 id="科斯定律-从社会成本看问题">科斯定律|从社会成本看问题<a class="anchor" href="#科斯定律-从社会成本看问题">·</a></h2><h3 id="20-社会成本问题">20.社会成本问题<a class="anchor" href="#20-社会成本问题">·</a></h3>]]></content>
      
      
      <categories>
          
          <category> Life Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经济管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows问题和解决方案、相应网站工具</title>
      <link href="2021/02/21/windows%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3/"/>
      <url>2021/02/21/windows%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>windows遇到的系统问题和对应解决方法积累。最近遇到了Powershell异常的问题，找了微软工程师没解决，最后自己在一个论坛上找到了类似的解决了，记录一下这次排坑经历，顺便以后积累一下其他常见问题。</p><a id="more"></a><h2 id="问题1-Powershell找不到驱动器">问题1 Powershell找不到驱动器<a class="anchor" href="#问题1-Powershell找不到驱动器">·</a></h2><h3 id="问题起因和描述">问题起因和描述<a class="anchor" href="#问题起因和描述">·</a></h3><p>最近装了很多编辑器，配置了很多环境变量，也删除更新了很多文件，于是再打开Powershell时便遇到了以下问题。</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/windows%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98//2.png" alt></p><p>导致Vscode也用不了</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/windows%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98//1.png" alt></p><p>于是去找了微软官网找相关人员咨询，还接受了上海的工程师的电话帮助。但是都没有解决。顺便提一下，有问题的确可以和微软官方联系，不管你的windows版本，都会给你完整的咨询服务。不仅有机器自动服务，还有客服人员，技术人员的咨询支持。</p><p>工程师说这个没有通用解决办法，于是给我提供了四条基本没用看着很可怕的方法：使用系统修复命令，更新系统，重装系统，尝试卸载一些最近装的软件。</p><p>之后又找到一篇博客是关于vscode遇到这个问题的https://blog.csdn.net/yys190418/article/details/103767720</p><p>然而这个只是解决vscode中powershell用不了的小问题，对我的问题并不适用。</p><h3 id="问题解决">问题解决<a class="anchor" href="#问题解决">·</a></h3><p>最后，终于在下面这个网站上找到了问题。https://superuser.com/questions/1021310/powershell-a-drive-c-does-not-exist</p><p>原来就是环境变量的锅，只要将Path中每个变量前面的 <code>.</code> 去掉即可！根据我的实践是每个都要删，不光是开头的 <code>.</code> 以后配置环境真的要小心谨慎了，这次真的吓人</p><p>即如下图所示</p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/windows%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98//3.png" style="zoom:50%;"><h2 id="网站工具">网站工具<a class="anchor" href="#网站工具">·</a></h2><h3 id="社区">社区<a class="anchor" href="#社区">·</a></h3><p>https://superuser.com/ 貌似是在stackoverflow下属的一个机构的网站</p><p>https://stackoverflow.com/</p><h3 id="微软网站">微软网站<a class="anchor" href="#微软网站">·</a></h3><h4 id="联系微软">联系微软<a class="anchor" href="#联系微软">·</a></h4><p>https://support.microsoft.com/zh-cn/contactus</p><p>https://support.microsoft.com/zh-cn/contact/virtual-agent/?flowId=smc-contactus-entitlement&amp;partnerId=smc&amp;referrer=www.microsoft.com</p><h4 id="社区-2">社区<a class="anchor" href="#社区-2">·</a></h4><p>https://answers.microsoft.com/zh-hans</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模比赛总结</title>
      <link href="2021/02/12/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AC%94%E8%AE%B0/"/>
      <url>2021/02/12/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>关于已经参加的几次数学建模比赛的参赛总结。</p><a id="more"></a><h1 id="数学建模比赛总结与回顾">数学建模比赛总结与回顾<a class="anchor" href="#数学建模比赛总结与回顾">·</a></h1><h2 id="比赛流程梳理">比赛流程梳理<a class="anchor" href="#比赛流程梳理">·</a></h2><h3 id="美赛">美赛<a class="anchor" href="#美赛">·</a></h3><h4 id="第一天-数据处理分析与模型建立">第一天 数据处理分析与模型建立<a class="anchor" href="#第一天-数据处理分析与模型建立">·</a></h4><ul><li><p>6-8点。拿到题目，全队<strong>自行读题审题</strong>，按照我们队的重点读A/C/D题（数据相关），对每道题用md写一点自己的分析总结并在<strong>至少1.5小时</strong>后讨论</p></li><li><p>8-10点。基本确定题目。</p><p>每个人迅速<strong>查阅相关资料</strong>，<strong>收集文献</strong>。</p><p>如果是C/D题则全队先各自思考对数据集理解，再一起讨论确定完整的数据处理模型。如果是A题，则先找好数据再讨论。需要确定的数据处理内容有以下几个：</p><ul><li><strong>数据清洗与预处理方式</strong>（如何处理异常值，残缺值，重复值，标准化方法等）。</li><li>对于<strong>每道题</strong>都先定义<strong>单独的数据集</strong>，包含这个题需要用到的所有数据。</li><li>确立整体数据集，即<strong>体现出各题之间联系</strong>的或者<strong>多题需要用到</strong>的多用数据集。常用于开头的引入和数据处理部分以及结尾的写信部分的写作。</li></ul></li><li><p>10-12点。<strong>查文献</strong>和<strong>数据处理</strong>以及做探索性数据分析（EDA）。</p></li><li><p>14-15点。数据处理基本结束，全队先自行思考建模同学的思路并做出自己的补充，之后全队交流。</p></li><li><p>15-16点。和指导老师交流，明确思路和方向。</p></li><li><p>16点-晚上。</p><ul><li>完成数据处理和初步可视化，写作论文的问题重述、背景介绍、数据处理部分。</li><li>根据建模同学的数学原理跑出至少前两个问的模型。</li><li>建模同学至少给出<strong>前三题</strong>的<strong>大致解法</strong>。</li></ul></li></ul><h4 id="第二天-模型完善与模型计算">第二天 模型完善与模型计算<a class="anchor" href="#第二天-模型完善与模型计算">·</a></h4><ul><li>上午：跑完至少1题并顺便做相应可视化。</li><li>下午：跑完至少1题并顺便做相应可视化。建模同学大概把所有问题的模型建立完全，并对每道题的思路用中文表述，且确立符号表。</li><li>晚上：跑完至少1题并顺便做相应可视化。</li></ul><h4 id="第三天-模型跑完与可视化">第三天 模型跑完与可视化<a class="anchor" href="#第三天-模型跑完与可视化">·</a></h4><ul><li>所有模型的代码全部跑完，并做相应的可视化整理。</li><li>论文的中文版完善以及前几部分的英文版敲定。</li><li>模型优化与调参，模型和结果最后完善。</li></ul><h4 id="第四天-可视化与论文写作">第四天 可视化与论文写作<a class="anchor" href="#第四天-可视化与论文写作">·</a></h4><ul><li>每人分工翻译几个部分，并直接打到overleaf上（包括图片、表格、公式），同时完成对应部分时进行补充的可视化。</li><li>晚上20点前尽量完成论文的撰写，并给老师看。</li><li>20点一直到第二天8点根据老师意见进行修改，需要可视化的继续作图，并不断打磨文字。</li><li>第五天早上8点前完成论文提交。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据科学 </tag>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>missingCourseForCsers_note_stanford</title>
      <link href="2021/02/12/missingCourseForCsers-note-stanford/"/>
      <url>2021/02/12/missingCourseForCsers-note-stanford/</url>
      
        <content type="html"><![CDATA[<p>关于一些CS必备工具使用的笔记，根据斯坦福的缺失的一课课程以及一些其他网络教程整理得来。</p><a id="more"></a><p>https://missing-semester-cn.github.io/</p><h2 id="一、shell脚本">一、shell脚本<a class="anchor" href="#一、shell脚本">·</a></h2><p><code>Bourne Again SHell</code>——Bash</p><p>终端，文字接口，Shell</p><h3 id="使用shell执行程序">使用shell执行程序<a class="anchor" href="#使用shell执行程序">·</a></h3><p>如果执行的程序不是shell编程关键字，则咨询环境变量</p><p>shell使用空格分割命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">打开后看到的:</span></span><br><span class="line">muller:~$ #$表示不是root用户 muller--&gt;用户名下面的代码略去了用户名，只保留$后的</span><br><span class="line"><span class="meta">$</span><span class="bash"> date <span class="comment">#执行程序，打印当前时间</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> hello <span class="comment">#echo--&gt;打印函数 hello为参数 特殊字符(比如空格)可以用""、''将后面的参数括起来，也可以用转义字符</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$path</span> <span class="comment">#打印环境变量所在路径</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">which</span> <span class="built_in">echo</span> <span class="comment">#打印echo的环境变量路径</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /bin/<span class="built_in">echo</span> <span class="variable">$path</span> <span class="comment">#直接使用路径名执行echo程序</span></span></span><br></pre></td></tr></table></figure><h3 id="在shell中导航">在shell中导航<a class="anchor" href="#在shell中导航">·</a></h3><p><code>linux</code>系统中<code>/</code>开头的都是<strong>绝对路径</strong>。</p><p>命令后带<code>-</code>接受标记和选项</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">pwd</span> <span class="comment">#获取当前目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ../a <span class="comment">#cd 切换到上级目录中的a文件夹 .表示当前目录 ..表示上一级目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls <span class="comment">#查看目录下包含的文件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -<span class="built_in">help</span> <span class="comment">#或ls -h</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mv 1.txt a.txt <span class="comment">#重命名或移动文件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp 1.txt <span class="comment">#拷贝文件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir <span class="comment">#新建文件目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> man ls <span class="comment">#man获取ls的手册 使用q退出</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> touch 1.txt <span class="comment">#创建空文件</span></span></span><br></pre></td></tr></table></figure><h3 id="在程序间创建连接">在程序间创建连接<a class="anchor" href="#在程序间创建连接">·</a></h3><p>shell中有输入输出流</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> hello &gt; hello.txt <span class="comment">#最简单的重定向输出，如果不存在hello.txt文件则生成出来一个</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat hello txt <span class="comment">#获取文件内容</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat &lt; hello.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat &lt; hello.txt &gt; hello2.txt</span></span><br></pre></td></tr></table></figure><p>使用&gt;&gt;可以进行追加输出</p><p>根用户：<code>sudo </code> 命令开头，变为<code>root</code>用户</p><h3 id="变量，控制语句">变量，控制语句<a class="anchor" href="#变量，控制语句">·</a></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> a=1 <span class="comment">#变量赋值</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'$a'</span> <span class="comment">#打印出 $a</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span>"</span> <span class="comment">#打印出a变量的值，即1</span></span></span><br></pre></td></tr></table></figure><p>以**<code>'</code>定义<strong>的字符串为</strong>原义字符串**，其中的变量不会被转义，而 <strong><code>&quot;</code>定义</strong>的字符串会<strong>将变量值进行替换</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mcd () &#123;</span><br><span class="line">    mkdir -p "$1"</span><br><span class="line">    cd "$1"</span><br><span class="line">&#125;  #函数定义</span><br></pre></td></tr></table></figure><ul><li><code>$0</code> - 脚本名</li><li><code>$1</code> 到 <code>$9</code> - 脚本的参数。 <code>$1</code> 是第一个参数，依此类推。</li><li><code>$@</code> - 所有参数</li><li><code>$#</code> - 参数个数</li><li><code>$?</code> - 前一个命令的返回值</li><li><code>$$</code> - 当前脚本的进程识别码</li><li><code>!!</code> - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 <code>sudo !!</code>再尝试一次。</li><li><code>$_</code> - 上一条命令的最后一个参数。如果你正在使用的是交互式shell，你可以通过按下 <code>Esc</code> 之后键入 . 来获取这个值。</li></ul><p>命令通常使用 <code>STDOUT</code>来返回输出值，使用<code>STDERR</code> 来返回错误及错误码</p><p><strong>返回值0</strong>表示<strong>正常执行</strong>，其他所有<strong>非0的返回值</strong>都表示<strong>有错误发生</strong>。</p><p>可以使用<code>false</code>和<code>true</code>以及<code>&amp;&amp;</code> <code>||</code>等逻辑表达式来作为条件，例如：<code>false || echo &quot;1234&quot;</code></p><h3 id="Shell工具">Shell工具<a class="anchor" href="#Shell工具">·</a></h3><h4 id="查找文件">查找文件<a class="anchor" href="#查找文件">·</a></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查找所有名称为src的文件夹</span></span><br><span class="line">find . -name src -type d</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找所有文件夹路径中包含<span class="built_in">test</span>的python文件</span></span><br><span class="line">find . -path '**/test/**/*.py' -type f</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找前一天修改的所有文件</span></span><br><span class="line">find . -mtime -1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找所有大小在500k至10M的tar.gz文件</span></span><br><span class="line">find . -size +500k -size -10M -name '*.tar.gz'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">对找到文件进行操作</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Delete all files with .tmp extension</span></span><br><span class="line">find . -name '*.tmp' -exec rm &#123;&#125; \;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Find all PNG files and convert them to JPG</span></span><br><span class="line">find . -name '*.png' -exec convert &#123;&#125; &#123;&#125;.jpg \;</span><br></pre></td></tr></table></figure><p><code>fd</code> <code>locate</code> 是另外两个查找工具</p><h4 id="查找代码">查找代码<a class="anchor" href="#查找代码">·</a></h4><p><code>grep</code> <code>ack</code> <code>ag</code> <code>rg</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查找所有使用了 requests 库的文件</span></span><br><span class="line">rg -t py 'import requests'</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找所有没有写 shebang 的文件（包含隐藏文件）</span></span><br><span class="line">rg -u --files-without-match "^#!"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找所有的foo字符串，并打印其之后的5行</span></span><br><span class="line">rg foo -A 5</span><br><span class="line"><span class="meta">#</span><span class="bash"> 打印匹配的统计信息（匹配的行和文件的数量）</span></span><br><span class="line">rg --stats PATTERN</span><br></pre></td></tr></table></figure><h4 id="查找shell命令">查找shell命令<a class="anchor" href="#查找shell命令">·</a></h4><p><code>history</code> 命令允许您以程序员的方式来访问shell中输入的历史命令</p><p>使用 <code>Ctrl+R</code> 对命令历史记录进行回溯搜索。可以配合 <a href="https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings#ctrl-r" target="_blank" rel="noopener"><code>fzf</code></a> 使用</p><h4 id="文件夹导航">文件夹导航<a class="anchor" href="#文件夹导航">·</a></h4><p>Fasd 基于 <a href="https://developer.mozilla.org/en/The_Places_frecency_algorithm" target="_blank" rel="noopener"><code>frecency</code></a> 对文件和文件排序，也就是说它会同时针对频率（frequency ）和时效（ recency）进行排序。</p><p>对于常用的目录，目录名子串前加入一个命令 <code>z</code> 就可以快速切换命令到该目录</p><p>还有一些更复杂的工具可以用来概览目录结构，例如 <a href="https://linux.die.net/man/1/tree" target="_blank" rel="noopener"><code>tree</code></a>, <a href="https://github.com/Canop/broot" target="_blank" rel="noopener"><code>broot</code></a> 或更加完整的文件管理器，例如 <a href="https://github.com/jarun/nnn" target="_blank" rel="noopener"><code>nnn</code></a> 或 <a href="https://github.com/ranger/ranger" target="_blank" rel="noopener"><code>ranger</code></a>。</p><h2 id="二、Vim编辑器">二、Vim编辑器<a class="anchor" href="#二、Vim编辑器">·</a></h2><h3 id="编辑模式">编辑模式<a class="anchor" href="#编辑模式">·</a></h3><ul><li>正常模式：在文件中四处移动光标进行修改（默认的模式）</li><li>插入模式：插入文本</li><li>替换模式：替换文本</li><li>可视化（一般，行，块）模式：选中文本块</li><li>命令模式：用于执行命令</li></ul><p>按下 <code>&lt;ESC&gt;</code> （退出键） 从任何其他模式返回正常模式。 正常模式和插入模式是最常用的两个模式</p><h4 id="正常模式与各个模式切换">正常模式与各个模式切换<a class="anchor" href="#正常模式与各个模式切换">·</a></h4><p>键入 <code>i</code> 进入插入 模式， <code>R</code> 进入替换模式</p><p><code>v</code> 进入可视（一般）模式， <code>V</code> 进入可视（行）模式， <code>&lt;C-v&gt;</code> （Ctrl-V, 有时也写作 <code>^V</code>）进入可视（块）模式，</p><p><code>:</code> 进入命令模式。</p><ul><li><code>:q</code> 退出 （关闭窗口）</li><li><code>:w</code> 保存 （写）</li><li><code>:wq</code> 保存然后退出</li><li><code>:e {文件名}</code> 打开要编辑的文件</li><li><code>:ls</code> 显示打开的缓存</li><li><code>:help {标题}</code>打开帮助文档<ul><li><code>:help :w</code> 打开 <code>:w</code> 命令的帮助文档</li><li><code>:help w</code> 打开 <code>w</code> 移动的帮助文档</li></ul></li></ul><h3 id="移动">移动<a class="anchor" href="#移动">·</a></h3><ul><li>基本移动: <code>hjkl</code> （左， 下， 上， 右）</li><li>词： <code>w</code> （下一个词）， <code>b</code> （词初）， <code>e</code> （词尾）</li><li>行： <code>0</code> （行初）， <code>^</code> （第一个非空格字符）， <code>$</code> （行尾）</li><li>屏幕： <code>H</code> （屏幕首行）， <code>M</code> （屏幕中间）， <code>L</code> （屏幕底部）</li><li>翻页： <code>Ctrl-u</code> （上翻）， <code>Ctrl-d</code> （下翻）</li><li>文件： <code>gg</code> （文件头）， <code>G</code> （文件尾）</li><li>行数： <code>:{行数}&lt;CR&gt;</code> 或者 <code>{行数}G</code> ({行数}为行数)</li><li>杂项： <code>%</code> （找到配对，比如括号或者 /* */ 之类的注释对）</li><li>查找：<code>f{字符}</code> <code>t{字符}</code> <code>F{字符}</code> <code>T{字符}</code><ul><li>查找/到 向前/向后 在本行的{字符}</li><li><code>,</code> / <code>;</code> 用于导航匹配</li></ul></li><li>搜索: <code>/{正则表达式}</code>, <code>n</code> / <code>N</code> 用于导航匹配</li></ul><h3 id="编辑">编辑<a class="anchor" href="#编辑">·</a></h3><ul><li><code>i</code>进入插入模式<ul><li>但是对于操纵/编辑文本，不单想用退格键完成</li></ul></li><li><code>O</code> / <code>o</code> 在之上/之下插入行</li><li><code>d{移动命令}</code> 删除 {移动命令}<ul><li>例如， <code>dw</code> 删除词, <code>d$</code> 删除到行尾, <code>d0</code> 删除到行头。</li></ul></li><li><code>c{移动命令}</code>改变 {移动命令}<ul><li>例如， <code>cw</code> 改变词</li><li>比如 <code>d{移动命令}</code> 再 <code>i</code></li></ul></li><li><code>x</code> 删除字符 （等同于 <code>dl</code>）</li><li><code>s</code> 替换字符 （等同于 <code>xi</code>）</li><li>可视化模式 + 操作<ul><li>选中文字, <code>d</code> 删除 或者 <code>c</code> 改变</li></ul></li><li><code>u</code> 撤销, <code>&lt;C-r&gt;</code> 重做</li><li><code>y</code> 复制 / “yank” （其他一些命令比如 <code>d</code> 也会复制）</li><li><code>p</code> 粘贴</li><li>更多值得学习的: 比如 <code>~</code> 改变字符的大小写</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据分析可视化笔记</title>
      <link href="2021/02/04/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AC%94%E8%AE%B0/"/>
      <url>2021/02/04/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>关于python数据科学相关的知识笔记</p><a id="more"></a><h1 id="Python数据分析可视化笔记">Python数据分析可视化笔记<a class="anchor" href="#Python数据分析可视化笔记">·</a></h1><h4 id="jupyter-lab好东西集合">jupyter lab好东西集合<a class="anchor" href="#jupyter-lab好东西集合">·</a></h4><p>https://www.cnblogs.com/feffery/p/13364668.html</p><h2 id="pandas基本操作和概念">pandas基本操作和概念<a class="anchor" href="#pandas基本操作和概念">·</a></h2><p><code>DataFrame</code>对象单独取出一行即：<code>df.loc[0]</code>和一列<code>df[&quot;a&quot;]</code>都是<code>Series</code>对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> nunpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df.columns <span class="comment">#DataFrame对象所有表头值组成的列表</span></span><br><span class="line">df.index <span class="comment">#DataFrame对象所有索引组成的列表</span></span><br></pre></td></tr></table></figure><h3 id="创建DataFrame对象">创建DataFrame对象<a class="anchor" href="#创建DataFrame对象">·</a></h3><p>最简单也最好用：根据两个列表创建</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">index=[i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>)]</span><br><span class="line">columns=[<span class="string">"a"</span>,<span class="string">"b"</span>]</span><br><span class="line">df=pd.DataFrame(index=index,columns=columns)</span><br><span class="line">l1=[i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>)]</span><br><span class="line">l2=[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">df[<span class="string">"a"</span>]=l1 <span class="comment">#直接用列表给df一列赋值</span></span><br><span class="line">df.loc[<span class="number">0</span>]=l2 <span class="comment">##直接用列表给df一行赋值</span></span><br></pre></td></tr></table></figure><h2 id="数据分析6步">数据分析6步<a class="anchor" href="#数据分析6步">·</a></h2><h3 id="一、读取数据">一、读取数据<a class="anchor" href="#一、读取数据">·</a></h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">pd.read_excel(<span class="string">"1.xlsx"</span>,)</span><br><span class="line">pd.read_csv(<span class="string">"1.csv"</span>)</span><br><span class="line"><span class="comment">#查询用法</span></span><br><span class="line">pd.read_excel?</span><br><span class="line">pd.*read*?</span><br></pre></td></tr></table></figure><h3 id="二、清洗数据">二、清洗数据<a class="anchor" href="#二、清洗数据">·</a></h3><h4 id="查找异常">查找异常<a class="anchor" href="#查找异常">·</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置最多显示十行</span></span><br><span class="line">pd.set_option(<span class="string">'max_rows'</span>, <span class="number">10</span>) </span><br><span class="line"><span class="comment">#查找异常</span></span><br><span class="line">df[df[<span class="string">"a"</span>].isnull()]</span><br><span class="line"><span class="comment">#查找完全重复的行</span></span><br><span class="line">df[df.duplicated()]</span><br><span class="line"><span class="comment"># 查找某⼀列重复的⾏</span></span><br><span class="line">df[df.编号.duplicated()]</span><br><span class="line"><span class="comment"># 查找a属性的所有唯⼀值</span></span><br><span class="line">df.a.unique()</span><br><span class="line"><span class="comment"># 查找a包含 30 的异常值</span></span><br><span class="line">df[df.a.isin([<span class="string">'30'</span>])]</span><br><span class="line"><span class="comment">#字符换匹配</span></span><br><span class="line">df[df.a.str.contains(<span class="string">"abc"</span>,na=<span class="literal">False</span>)]</span><br><span class="line"><span class="comment"># 查找a列值在1到5之间的⾏</span></span><br><span class="line">df[df.a.between(<span class="number">1</span>, <span class="number">5</span>)]</span><br><span class="line"><span class="comment">#逻辑运算</span></span><br><span class="line">df[(df.a &gt;= <span class="number">1</span>) &amp; (df.b &lt;= <span class="number">5</span>)]</span><br></pre></td></tr></table></figure><h4 id="排除重复">排除重复<a class="anchor" href="#排除重复">·</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df.drop_duplicates()</span><br><span class="line">df.drop_duplicates(inplace=<span class="literal">True</span>) <span class="comment">#直接改变原数据</span></span><br><span class="line">df.drop_duplicates([<span class="string">'a'</span>]) <span class="comment"># 按某⼀列排除重复，默认保留第⼀⾏ keep='last'--&gt;删除最后一行</span></span><br></pre></td></tr></table></figure><h4 id="删除缺失值">删除缺失值<a class="anchor" href="#删除缺失值">·</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">color.dropna()</span><br><span class="line">color.dropna(how=<span class="string">'all'</span>) <span class="comment"># 删除全部为空的⾏</span></span><br><span class="line">color.dropna(axis=<span class="number">1</span>) <span class="comment"># 删除包含缺失值的列</span></span><br></pre></td></tr></table></figure><h4 id="补全缺失值">补全缺失值<a class="anchor" href="#补全缺失值">·</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df.fillna(<span class="string">'a'</span>) <span class="comment">#所有缺失处补上"a" 实际工作时常补上0</span></span><br><span class="line">df.fillna(method=<span class="string">'bfill'</span>) <span class="comment">#⽤后⾯的值填充</span></span><br><span class="line">df.fillna( &#123;<span class="string">'花⾊'</span>: <span class="number">0</span>, <span class="string">'牌⾯'</span>: <span class="number">1</span>&#125; ) <span class="comment">#按照字典填充</span></span><br></pre></td></tr></table></figure><h4 id="完整例子">完整例子<a class="anchor" href="#完整例子">·</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 设置最多显示 10 ⾏</span></span><br><span class="line">pd.set_option(<span class="string">'max_rows'</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 从 Excel ⽂件中读取原始数据</span></span><br><span class="line">df = pd.read_excel(<span class="string">'待清洗的扑克牌数据集.xlsx'</span>,sheet_name=<span class="string">"name"</span>)</span><br><span class="line"><span class="comment"># 补全缺失值</span></span><br><span class="line">df = df.fillna(<span class="string">'Joker'</span>)</span><br><span class="line"><span class="comment"># 排除重复值</span></span><br><span class="line">df = df.drop_duplicates()</span><br><span class="line"><span class="comment"># 修改异常值</span></span><br><span class="line">df.loc[<span class="number">4</span>, <span class="string">'牌⾯'</span>] = <span class="number">3</span></span><br><span class="line"><span class="comment"># 增加⼀张缺少的牌</span></span><br><span class="line">df = df.append(&#123;<span class="string">'编号'</span>: <span class="number">4</span>,<span class="string">'花⾊'</span>: <span class="string">'⿊桃♠'</span>,<span class="string">'牌⾯'</span>: <span class="number">2</span>&#125;,ignore_index=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 按编号排序</span></span><br><span class="line">df = df.sort_values(<span class="string">'编号'</span>)</span><br><span class="line"><span class="comment"># 重置索引</span></span><br><span class="line">df = df.reset_index()</span><br><span class="line"><span class="comment"># 删除多余的列</span></span><br><span class="line">df = df.drop([<span class="string">'index'</span>], axis=<span class="number">1</span> )</span><br><span class="line"><span class="comment"># 把清洗好的数据保存到 Excel ⽂件</span></span><br><span class="line">df.to_excel(<span class="string">'完成清洗的扑克牌数据.xlsx'</span>,index=<span class="literal">False</span>)</span><br><span class="line">df</span><br></pre></td></tr></table></figure><h3 id="三、操作数据">三、操作数据<a class="anchor" href="#三、操作数据">·</a></h3><h4 id="增加数据">增加数据<a class="anchor" href="#增加数据">·</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">"b"</span>]=[i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>)] <span class="comment">#相当于把df对象当字典用</span></span><br><span class="line">df.insert(<span class="number">1</span>, <span class="string">'a'</span>, [<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">#指定位置插入列</span></span><br><span class="line"><span class="comment">#插入一行</span></span><br><span class="line">a=pd.DataFrame(&#123;<span class="string">"a"</span>:<span class="number">1</span>,<span class="string">"b"</span>:<span class="number">2</span>&#125;)</span><br><span class="line">df2=df.append(a,ignore_index=<span class="literal">True</span>,sort=<span class="literal">False</span>)</span><br><span class="line"><span class="comment">#拼接两个数据框</span></span><br><span class="line">pd.concat([df, a],ignore_index=<span class="literal">True</span>,sort=<span class="literal">False</span>)</span><br><span class="line">还有merge()/join()函数</span><br></pre></td></tr></table></figure><h4 id="删除数据">删除数据<a class="anchor" href="#删除数据">·</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df.drop([<span class="number">0</span>,<span class="number">2</span>]) <span class="comment">#删除0/2两行数据</span></span><br><span class="line">df.drop(<span class="string">"a"</span>,axis=<span class="number">1</span>) <span class="comment">#删除"a"列的数据</span></span><br><span class="line"><span class="keyword">del</span> df2[<span class="string">"a"</span>] <span class="comment">#直接删除原数据框中的a列数据</span></span><br></pre></td></tr></table></figure><h4 id="修改数据-2">修改数据<a class="anchor" href="#修改数据-2">·</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df.replace([<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="number">3</span>,<span class="number">4</span>],<span class="string">""</span>,regex=<span class="literal">True</span>) <span class="comment">#替换多个数据 regex--&gt;正则表达式</span></span><br><span class="line">df.loc[<span class="number">0</span>,<span class="string">"a"</span>]=<span class="string">"j"</span> <span class="comment">#修改第0行a属性的值</span></span><br><span class="line">df.columns = list(<span class="string">'AB'</span>) <span class="comment">#修改列名</span></span><br><span class="line">df.rename(&#123;<span class="string">"a"</span>:<span class="string">"b"</span>&#125;,axis=<span class="number">1</span>) <span class="comment">#修改指定列名</span></span><br><span class="line">df.rename(&#123;<span class="number">1</span>:<span class="number">3</span>,<span class="number">2</span>:<span class="number">3</span>&#125;) <span class="comment">#修改行名</span></span><br></pre></td></tr></table></figure><h4 id="查询数据-2">查询数据<a class="anchor" href="#查询数据-2">·</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">df.head()</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">df[df.a.str.match(<span class="string">'[jk]'</span>, flags=re.IGNORECASE, na=<span class="literal">False</span>)] <span class="comment">#re.IGNORECASE--&gt;不区分大小写</span></span><br><span class="line"><span class="comment">#使用query</span></span><br><span class="line">df.query(</span><br><span class="line"> <span class="string">'1 &lt;= index &lt;= 5 \</span></span><br><span class="line"><span class="string"> and 牌⾯ not in @card '</span></span><br><span class="line">)</span><br><span class="line">df.query(</span><br><span class="line"> <span class="string">'编号 &gt; 编号.mean() \</span></span><br><span class="line"><span class="string"> and 牌⾯ == "A" '</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="四、数据转换">四、数据转换<a class="anchor" href="#四、数据转换">·</a></h3><h4 id="转换为时间">转换为时间<a class="anchor" href="#转换为时间">·</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dateutil.parser <span class="keyword">import</span> parse</span><br><span class="line">df[<span class="string">"time"</span>]=df.Date.transform(parse).copy()</span><br><span class="line">parse(<span class="string">"10/9/2019"</span>,dayfirst=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h4 id="转换为数值">转换为数值<a class="anchor" href="#转换为数值">·</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pd.to_numeric(errors=<span class="string">'coerce'</span>) <span class="comment">#设置errors参数使得不能替换的值变为nan</span></span><br><span class="line">df.apply(pd.to_numeric,errors=<span class="string">'coerce'</span>) <span class="comment">#errors默认为ignore即略过不能转换的</span></span><br></pre></td></tr></table></figure><h4 id="类型转换">类型转换<a class="anchor" href="#类型转换">·</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.astype(str).dtypes</span><br><span class="line">对于时间型的数据，我们可以使⽤ strftime() 函数</span><br></pre></td></tr></table></figure><h4 id="转换为区间">转换为区间<a class="anchor" href="#转换为区间">·</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pd.cut() <span class="comment">#将数值切割为指定的区间</span></span><br><span class="line">bins=[float(<span class="string">"-inf"</span>),<span class="number">280</span>,float(<span class="string">"inf"</span>)]</span><br><span class="line">pd.cut(df.a,bins=bins,right=<span class="literal">True</span>) <span class="comment">#左开右闭，默认左闭右开</span></span><br><span class="line">pd.cut(df.a,bins=<span class="number">2</span>) <span class="comment">#按照2为间隔划分</span></span><br></pre></td></tr></table></figure><h4 id="分组转换">分组转换<a class="anchor" href="#分组转换">·</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(<span class="string">"a"</span>)[<span class="string">"b"</span>].transform(sum) <span class="comment">#在⾏数保持不变的情况下，对某列进⾏分组求和</span></span><br><span class="line"><span class="comment">#能够⽅便地计算每个数据对应各⾃分组的占⽐</span></span><br><span class="line">df.groupby(<span class="string">"a"</span>)[<span class="string">"b"</span>].apply(sum) <span class="comment">#返回组数个结果</span></span><br><span class="line">df.groupby(<span class="string">"a"</span>)[<span class="string">"b"</span>].agg([sum,np.mean,<span class="string">"count"</span>])</span><br><span class="line">df.groupby(<span class="string">"month"</span>).agg(</span><br><span class="line">    天数=(<span class="string">"Date"</span>,count),</span><br><span class="line">平均价格=(<span class="string">"Open"</span>,np.mean)) <span class="comment">#对不同列聚合，使用不同函数</span></span><br></pre></td></tr></table></figure><h4 id="标准化">标准化<a class="anchor" href="#标准化">·</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#min-max标准化</span></span><br><span class="line">(df.a-df.a.min())/(df.a.max()-df.a.min())</span><br></pre></td></tr></table></figure><h3 id="五、整理数据">五、整理数据<a class="anchor" href="#五、整理数据">·</a></h3><h4 id="外连接-相当于并集">外连接(相当于并集)<a class="anchor" href="#外连接-相当于并集">·</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.merge(df1,how=<span class="string">"outer"</span>,on=<span class="string">"用于连接的列名"</span>) <span class="comment">#缺失值用nan 得到两个表的所有⾏</span></span><br></pre></td></tr></table></figure><h4 id="内连接-相当于交集">内连接(相当于交集)<a class="anchor" href="#内连接-相当于交集">·</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.merge(df1) <span class="comment">#不指定on时以两个表共同的列名为参数</span></span><br><span class="line"><span class="comment">#只返回两个表相互匹配的数据。无nan</span></span><br></pre></td></tr></table></figure><h4 id="左连接与右连接">左连接与右连接<a class="anchor" href="#左连接与右连接">·</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.merge(df1,how=<span class="string">"left"</span>）<span class="comment">#df为左表，即使df1中某行值无也照样显示,同理右连接</span></span><br></pre></td></tr></table></figure><h4 id="交叉连接">交叉连接<a class="anchor" href="#交叉连接">·</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">操作:</span><br><span class="line">（<span class="number">1</span>）⽤ assign() 函数增加 key 列；</span><br><span class="line">（<span class="number">2</span>）⽤ merge() 函数进⾏连接；</span><br><span class="line">（<span class="number">3</span>）删掉 key 列。</span><br><span class="line">df.assign(key=<span class="number">1</span>).merge(df1.assign(key=<span class="number">1</span>),on=<span class="string">"key"</span>).drop(<span class="string">"key"</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="联合拼接">联合拼接<a class="anchor" href="#联合拼接">·</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.concat([df1,df2],sort=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h3 id="六、分析数据">六、分析数据<a class="anchor" href="#六、分析数据">·</a></h3><p>比较nb的三个数据分析库</p><p>参考文章：https://my.oschina.net/u/4581316/blog/4898542</p><h4 id="pandas-profiling">pandas_profiling<a class="anchor" href="#pandas-profiling">·</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas_profiling</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.set_style(<span class="string">"whitegrid"</span>,&#123;<span class="string">"font.sans-serif"</span>:[<span class="string">"simhei"</span>,<span class="string">"Arial"</span>]&#125;)</span><br><span class="line">x=pandas_profiling.ProfileReport(df)</span><br><span class="line">x.to_file(<span class="string">"name.html"</span>)</span><br></pre></td></tr></table></figure><h4 id="Sweetviz">Sweetviz<a class="anchor" href="#Sweetviz">·</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sweetviz <span class="keyword">as</span> sv</span><br><span class="line">my_report = sv.analyze(mpg)</span><br><span class="line">my_report.show_html()</span><br></pre></td></tr></table></figure><h4 id="pandasGUI">pandasGUI<a class="anchor" href="#pandasGUI">·</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandasgui <span class="keyword">import</span> show</span><br><span class="line"><span class="comment"># 部署GUI的数据集</span></span><br><span class="line">gui = show(mpg)</span><br></pre></td></tr></table></figure><h2 id="可视化">可视化<a class="anchor" href="#可视化">·</a></h2><h3 id="pyecharts">pyecharts<a class="anchor" href="#pyecharts">·</a></h3><p>官网：https://pyecharts.org/#/zh-cn/intro</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据科学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记</title>
      <link href="2021/02/01/Java-note/"/>
      <url>2021/02/01/Java-note/</url>
      
        <content type="html"><![CDATA[<p>Java学习笔记</p><a id="more"></a><h2 id="JAVA-HOW2J教程笔记">JAVA-HOW2J教程笔记<a class="anchor" href="#JAVA-HOW2J教程笔记">·</a></h2><h3 id="一、JAVA基础">一、JAVA基础<a class="anchor" href="#一、JAVA基础">·</a></h3><h4 id="1-hello-world与命令行运行">1.hello world与命令行运行<a class="anchor" href="#1-hello-world与命令行运行">·</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//code:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Helloworld</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; <span class="comment">//main--&gt;主方法，所有代码的入口</span></span><br><span class="line">    System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//run</span></span><br><span class="line">javac hello.java <span class="comment">//编译</span></span><br><span class="line">java hello <span class="comment">//运行class文件</span></span><br></pre></td></tr></table></figure><h4 id="2-面向对象">2.面向对象<a class="anchor" href="#2-面向对象">·</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span></span>&#123;</span><br><span class="line">    <span class="comment">//属性定义 名字一般为驼峰命名</span></span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">float</span> hp;</span><br><span class="line">    <span class="comment">//方法定义</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span></span>&#123; </span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">num=num+n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//创建</span></span><br><span class="line">Hero a= <span class="keyword">new</span> Hero(); <span class="comment">//实例化类</span></span><br><span class="line">a.num=<span class="number">12</span>;</span><br><span class="line">a.hp=<span class="number">100.0</span>;</span><br><span class="line">a.name=<span class="string">"a"</span>;</span><br></pre></td></tr></table></figure><h4 id="3-变量">3.变量<a class="anchor" href="#3-变量">·</a></h4><h5 id="基本类型">基本类型<a class="anchor" href="#基本类型">·</a></h5><pre class="mermaid">graph LRa[基本类型]--> b[整型:byte short int long]a-->c[浮点型:float double]a-->d[布尔型:boolean--true,false]a-->e[字符型:char]a-->f[注:String不是基本类型,Immutable-创建不可修改]</pre><h5 id="变量命名">变量命名<a class="anchor" href="#变量命名">·</a></h5><p>变量命名只能使用字母 数字 $ _，首字母不能用数字</p><h5 id="final">final<a class="anchor" href="#final">·</a></h5><p>一个变量被final修饰的时候，该变量只有<strong>一次赋值</strong>的机会</p><h4 id="4-操作符">4.操作符<a class="anchor" href="#4-操作符">·</a></h4><h5 id="使用Scanner类获取输入">使用Scanner类获取输入<a class="anchor" href="#使用Scanner类获取输入">·</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> a = s.nextInt();</span><br><span class="line">        System.out.println(<span class="string">"第一个整数："</span>+a);</span><br><span class="line">        <span class="keyword">float</span> b = s.nextFloat();</span><br><span class="line">        System.out.println(<span class="string">"第二个浮点数："</span>+b);</span><br><span class="line">        String str=s.nextLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-数组">5.数组<a class="anchor" href="#5-数组">·</a></h4><h5 id="基本知识">基本知识<a class="anchor" href="#基本知识">·</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//create</span></span><br><span class="line"><span class="keyword">int</span>[] a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]; </span><br><span class="line"></span><br><span class="line"><span class="comment">//3 ways to init</span></span><br><span class="line"><span class="keyword">int</span>[] c=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">int</span>[] c=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">int</span>[] c=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增强型for循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> each:values)&#123;</span><br><span class="line">    System.out.println(each);<span class="comment">//增强型for循环只能用来取值，却不能用来修改数组里的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//copy array</span></span><br><span class="line">System.arraycopy(src, srcPos, dest, destPos, length)</span><br><span class="line">    <span class="comment">//src: 源数组</span></span><br><span class="line">    <span class="comment">//srcPos: 从源数组复制数据的起始位置</span></span><br><span class="line">    <span class="comment">//dest: 目标数组</span></span><br><span class="line">    <span class="comment">//destPos: 复制到目标数组的启始位置</span></span><br><span class="line">    <span class="comment">//length: 复制的长度  </span></span><br><span class="line"><span class="keyword">int</span>[] b;</span><br><span class="line">System.arraycopy(a, <span class="number">0</span>, b, <span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//二维数组</span></span><br><span class="line"><span class="keyword">int</span> b[][] = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">   &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">   &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,</span><br><span class="line">   &#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="常见数组函数">常见数组函数<a class="anchor" href="#常见数组函数">·</a></h5><p>需要引入包 <code>import java.util.Arrays;</code></p><table><thead><tr><th style="text-align:center">数组函数</th><th style="text-align:center">对应操作</th></tr></thead><tbody><tr><td style="text-align:center">Arrays.copyOfRange(int[] original, int from, int to)</td><td style="text-align:center">int[] b = Arrays.copyOfRange(a, 0, 3);复制数组</td></tr><tr><td style="text-align:center">Arrays.toString(a)</td><td style="text-align:center">转换成&quot;[1,2,3,4]&quot;字符串形式</td></tr><tr><td style="text-align:center">Arrays.sort(a)</td><td style="text-align:center">排序</td></tr><tr><td style="text-align:center">Arrays.binarySearch(a, 62)</td><td style="text-align:center">二分查找</td></tr><tr><td style="text-align:center">Arrays.equals(a, b)</td><td style="text-align:center">判断是否相同</td></tr><tr><td style="text-align:center">Arrays.fill(a,5)</td><td style="text-align:center">使用同一个值，填充整个数组</td></tr></tbody></table><h4 id="6-类和对象">6.类和对象<a class="anchor" href="#6-类和对象">·</a></h4><h5 id="引用">引用<a class="anchor" href="#引用">·</a></h5><p>对象不是基本类型——即是引用（即指针）</p><p><code>Hero h = new Hero();</code>  h为引用，代表了右边创建的的Hero类型对象，即h指向右侧的这个对象</p><p><code>Hero h1 = h;</code> 则h1和h指向同一个对象</p><p><code>h = new Hero()</code> h指向新的对象</p><h5 id="继承">继承<a class="anchor" href="#继承">·</a></h5><p>extends关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Weapon</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> price;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Weapon</span> <span class="keyword">extends</span> <span class="title">Item</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> damage; <span class="comment">//攻击力 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="重载">重载<a class="anchor" href="#重载">·</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用方法attack的时候，会根据传递的参数类型以及数量，自动调用对应的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">(Hero h1)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">(Hero h1,Hero h2)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">(Hero h1,Hero h2,Hero h3)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//采用可变数量的参数,一个函数相当于上述三个函数 使用操作数组的方式处理参数heros即可</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">(Hero... heros)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heros.length; i++) &#123;</span><br><span class="line">        System.out.println(name + <span class="string">" 攻击了 "</span> + heros[i].name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="构造方法">构造方法<a class="anchor" href="#构造方法">·</a></h5><p>类里不显示写构造函数时，为隐式构造，即<code>Hero a=Hero()</code>这样的形式</p><p>写了就按照写的来，且可以重载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">(String heroname)</span></span>&#123; </span><br><span class="line">name = heroname;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="this">this<a class="anchor" href="#this">·</a></h5><p>在对象内部表示当前这个对象</p><p>在一个构造方法中，调用另一个构造方法，可以使用this()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName3</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    <span class="comment">//name代表的是参数name</span></span><br><span class="line">    <span class="comment">//this.name代表的是属性name this相当于是引用，打印this是地址</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="传参">传参<a class="anchor" href="#传参">·</a></h5><p><strong>基本类型</strong>传参：函数块内<strong>不能改变</strong>原变量值，传入的参数为函数内局部变量</p><p><strong>引用类型</strong>传参：函数块内<strong>能改变</strong>原变量值</p><h5 id="包">包<a class="anchor" href="#包">·</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> character; <span class="comment">//声明包的名字</span></span><br><span class="line"><span class="keyword">import</span> person.C <span class="comment">//引用其他包</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="访问修饰符">访问修饰符<a class="anchor" href="#访问修饰符">·</a></h5><p>用于修饰类或类里面的函数</p><table><thead><tr><th style="text-align:center">修饰符</th><th style="text-align:center">对应含义</th></tr></thead><tbody><tr><td style="text-align:center">private</td><td style="text-align:center">私有的</td></tr><tr><td style="text-align:center">package/friendly/default</td><td style="text-align:center">不写修饰符，默认状态</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">受保护的</td></tr><tr><td style="text-align:center">public</td><td style="text-align:center">公共的</td></tr></tbody></table><h6 id="类之间关系">类之间关系<a class="anchor" href="#类之间关系">·</a></h6><p>自身（访问）、同包子类（<strong>同包</strong>内的类<strong>继承</strong>）、不同包子类（<strong>不同包间</strong>的类<strong>继承</strong>）、同包类（<strong>同一个包</strong>内的<strong>访问</strong>）、其他类（<strong>不同包</strong>内的<strong>访问</strong>）</p><h6 id="四种修饰符及对应的访问限制">四种修饰符及对应的访问限制<a class="anchor" href="#四种修饰符及对应的访问限制">·</a></h6><table><thead><tr><th style="text-align:center">修饰符</th><th style="text-align:center">自身-访问</th><th style="text-align:center">同包子类-继承</th><th style="text-align:center">不同包子类-继承</th><th style="text-align:center">同包类-访问</th><th style="text-align:center">其他类-访问</th></tr></thead><tbody><tr><td style="text-align:center">private</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">package/friendly/default</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">public</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr></tbody></table><p>能不露就不露出来，<strong>作用范围最小</strong>原则</p><ul><li>属性用private封装</li><li>方法一般用public</li><li>会被子类继承的方法，用protected</li><li>package用的不多</li></ul><h5 id="类属性（静态属性）">类属性（静态属性）<a class="anchor" href="#类属性（静态属性）">·</a></h5><p>static修饰时，为类属性（<strong>静态</strong>属性），与之相对的是对象属性（<strong>实例属性</strong>，<strong>非静态</strong>属性）</p><p>类属性所有对象都<strong>共享</strong>一个相同值</p><p>访问可以用**<code>对象.类属性</code><strong>和</strong><code>类.类属性</code>**两种等价方式进行访问。</p><h5 id="类方法（静态方法）">类方法（静态方法）<a class="anchor" href="#类方法（静态方法）">·</a></h5><p>也用<code>static</code>修饰，与类属性类似，也与对象方法（实例方法，非静态方法）相对。</p><p>方法里访问了对象属性，必须用对象方法</p><p>没有访问对象属性，可以用类方法</p><h5 id="属性初始化">属性初始化<a class="anchor" href="#属性初始化">·</a></h5><h6 id="对象属性-三种办法初始化">对象属性-三种办法初始化<a class="anchor" href="#对象属性-三种办法初始化">·</a></h6><ol><li><p>声明该属性的时候初始化</p></li><li><p>构造方法中初始化</p></li><li><p>初始化块 如：<code>{ x=10 }</code></p></li></ol><h6 id="类属性-两种办法">类属性-两种办法<a class="anchor" href="#类属性-两种办法">·</a></h6><ol><li>声明该属性的时候初始化</li><li>静态初始化块</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> item=<span class="number">8</span>; <span class="comment">//声明时</span></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    item=<span class="number">6</span>; <span class="comment">//静态初始化块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="单例模式">单例模式<a class="anchor" href="#单例模式">·</a></h5><h6 id="饿汉式">饿汉式<a class="anchor" href="#饿汉式">·</a></h6><ul><li>只有一个，通过私有化其构造方法，使得外部无法通过new 得到新的实例。</li><li>提供了一个public static的getInstance方法，外部调用者通过该方法获取一个对象，而且每一次都是获取同一个对象。 从而达到单例的目的。</li><li>在getInstance方法外已经创建了一个实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GiantDragon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有化构造方法使得该类无法在外部通过new 进行实例化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">GiantDragon</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//准备一个类属性，指向一个实例化对象。 因为是类属性，所以只有一个</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> GiantDragon instance = <span class="keyword">new</span> GiantDragon();</span><br><span class="line">    </span><br><span class="line"><span class="comment">//public static 方法，提供给调用者获取定义的对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GiantDragon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="懒汉式">懒汉式<a class="anchor" href="#懒汉式">·</a></h6><ul><li>在getInstance方法内创建了一个实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GiantDragon</span> </span>&#123;</span><br><span class="line">    <span class="comment">//私有化构造方法使得该类无法在外部通过new 进行实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">GiantDragon</span><span class="params">()</span></span>&#123;        </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//准备一个类属性，用于指向一个实例化对象，但是暂时指向null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> GiantDragon instance;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//public static 方法，返回实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GiantDragon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//第一次访问的时候，发现instance没有指向任何对象，这时实例化一个对象</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span>==instance)&#123;</span><br><span class="line">    instance = <span class="keyword">new</span> GiantDragon();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回 instance指向的对象</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="两种方式选用">两种方式选用<a class="anchor" href="#两种方式选用">·</a></h6><p><strong>饿汉式</strong>，是<strong>立即加载</strong>的方式，无论是否会用到这个对象，都会加载。如果在构造方法里写了<strong>性能消耗较大</strong>，<strong>占时较久</strong>的代码，比如<strong>建立与数据库的连接</strong>，那么就会在启动的时候感觉稍微有些卡顿。</p><p><strong>懒汉式</strong>，是<strong>延迟加载</strong>的方式，只有使用的时候才会加载。 并且有<strong>线程安全</strong>的考量。使用懒汉式，在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化。 但是在<strong>第一次调用</strong>的时候，会进行实例化操作，感觉上就略慢。</p><p>看业务需求，如果业务上允许有比较<strong>充分的启动和初始化时间</strong>，就使用<strong>饿汉式</strong>，<strong>否则</strong>就使用<strong>懒汉式</strong></p><h6 id="单例模式三元素">单例模式三元素<a class="anchor" href="#单例模式三元素">·</a></h6><ol><li>构造方法私有化</li><li>静态属性指向实例</li><li>public static的 getInstance方法，返回第二步的静态属性</li></ol><h5 id="枚举类型">枚举类型<a class="anchor" href="#枚举类型">·</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Season &#123;</span><br><span class="line">SPRING,SUMMER,AUTUMN,WINTER <span class="comment">//分别代表1，2，3，4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Season season = Season.SPRING;</span><br><span class="line"><span class="keyword">switch</span> (season) &#123;</span><br><span class="line"><span class="keyword">case</span> SPRING:</span><br><span class="line">System.out.println(<span class="string">"春天"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SUMMER:</span><br><span class="line">System.out.println(<span class="string">"夏天"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> AUTUMN:</span><br><span class="line">System.out.println(<span class="string">"秋天"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WINTER:</span><br><span class="line">System.out.println(<span class="string">"冬天"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Season s : Season.values()) &#123;  <span class="comment">//增强型for循环遍历</span></span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-接口与继承">7.接口与继承<a class="anchor" href="#7-接口与继承">·</a></h4><h5 id="接口">接口<a class="anchor" href="#接口">·</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AD</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">physicAttack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AP</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">magicAttack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现接口 使用implements 可以同时实现多个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ADHero</span> <span class="keyword">extends</span> <span class="title">Hero</span> <span class="keyword">implements</span> <span class="title">AD</span>,<span class="title">AP</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">physicAttack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进行物理攻击"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="对象转型">对象转型<a class="anchor" href="#对象转型">·</a></h5><p>将等号右边的类型转换为等号左边的，本质上能不能转换主要是看右边的类型能不能当成左边的来用</p><h6 id="子类转父类（向上转型）">子类转父类（向上转型）<a class="anchor" href="#子类转父类（向上转型）">·</a></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hero h = <span class="keyword">new</span> Hero();</span><br><span class="line">ADHero ad = <span class="keyword">new</span> ADHero();</span><br><span class="line">h = ad; <span class="comment">//直接转换即可</span></span><br></pre></td></tr></table></figure><h6 id="父类转子类（向下转型）">父类转子类（向下转型）<a class="anchor" href="#父类转子类（向下转型）">·</a></h6><p>需要强制转化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ad = (ADHero) h; <span class="comment">//强制转换</span></span><br></pre></td></tr></table></figure><h6 id="没有继承关系的两个类，互相转换会失败">没有继承关系的两个类，互相转换会失败<a class="anchor" href="#没有继承关系的两个类，互相转换会失败">·</a></h6><h5 id="重写">重写<a class="anchor" href="#重写">·</a></h5><p>子类和父类定义名字一样的方法，调用时调用子类的，即重写</p><h5 id="多态">多态<a class="anchor" href="#多态">·</a></h5><h6 id="操作符的多态">操作符的多态<a class="anchor" href="#操作符的多态">·</a></h6><p>字符串相加表示拼接，数字相加表示加法</p><h6 id="类的多态">类的多态<a class="anchor" href="#类的多态">·</a></h6><p>即不同的子类，对同一个父类方法的重写</p><h5 id="隐藏">隐藏<a class="anchor" href="#隐藏">·</a></h5><p>子类调用父类的静态方法（类方法）</p><h5 id="super">super<a class="anchor" href="#super">·</a></h5><p>使用<code>super对象</code>调用父类的方法和属性</p><h5 id="Object类">Object类<a class="anchor" href="#Object类">·</a></h5><p>声明一个类的时候，默认是继承了Object</p><p><code>toString()</code>返回当前对象的<strong>字符串表达</strong></p><p><code>finalize()</code>一个对象没有任何引用指向时，满足回收条件，这个方法被<code>JVM</code>自动调用</p><p><code>equals()</code> 判断两个对象内容是否相同</p><p><code>==</code> 判断两个引用，是否指向了同一个对象</p><p><code>hashCode()</code>返回一个对象的哈希值</p><p>Object还提供<strong>线程同步</strong>相关方法</p><ul><li><code>wait()</code></li></ul><ul><li><code>notify()</code></li><li><code>notifyAll()</code></li></ul><p><code>getClass()</code> 返回一个对象的类对象</p><h5 id="final-2">final<a class="anchor" href="#final-2">·</a></h5><p>用final修饰的类不能被继承</p><p>修饰方法则不能被重写</p><p>修饰变量，则只有一次赋值机会</p><p>修饰引用，引用只有<strong>1</strong>次指向对象的机会</p><p>常量：<code>public static final int a = 6;</code></p><h5 id="抽象类">抽象类<a class="anchor" href="#抽象类">·</a></h5><p>abstract修饰符来修饰</p><p>当一个类有抽象方法的时候，该类必须被声明为抽象类</p><p>抽象类可以没有抽象方法</p><p><strong>子类必须提供</strong>不一样的attack方法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">float</span> hp;</span><br><span class="line">    <span class="keyword">float</span> armor;</span><br><span class="line">    <span class="keyword">int</span> moveSpeed;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 抽象方法attack</span></span><br><span class="line">    <span class="comment">// Hero的子类会被要求实现attack方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="抽象类和接口的区别">抽象类和接口的区别<a class="anchor" href="#抽象类和接口的区别">·</a></h6><p>区别1：</p><ul><li>子类只能继承一个抽象类，不能继承多个</li><li>子类可以实现<strong>多个</strong>接口</li></ul><p>区别2：</p><ul><li><p>抽象类可以定义</p><ul><li><p>public,protected,package,private</p></li><li><p>静态和非静态属性</p></li><li><p>final和非final属性</p></li></ul></li><li><p>但是接口中声明的属性，只能是</p><ul><li><p>public</p></li><li><p>静态</p></li><li><p>final的</p></li></ul><p>即便没有显式的声明(默认转换为<code>public static final</code>)</p></li></ul><p>注:抽象类和接口都可以有实体方法。 接口中的实体方法，叫做默认方法</p><h5 id="内部类">内部类<a class="anchor" href="#内部类">·</a></h5><p>分为四种：</p><ul><li><p>非静态内部类  可以直接在一个类里面定义，实例化必须建立在一个外部类对象的基础之上，即：<strong>new 外部类().new 内部类()</strong>，可以访问外部类的属性方法</p></li><li><p>静态内部类 可以直接实例化，不能访问外部类的实例属性方法，但是可以访问静态属性方法</p></li><li><p>匿名类 直接实例化一个抽象类，并“<strong>当场</strong>”实现其抽象方法。</p></li><li><p>本地类 有名字的匿名类</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hero h = <span class="keyword">new</span> Hero()&#123;</span><br><span class="line">            <span class="comment">//当场实现attack方法</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"新的进攻手段"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        h.attack();</span><br><span class="line">        <span class="comment">//通过打印h，可以看到h这个对象属于Hero$1这么一个系统自动分配的类名 </span></span><br><span class="line">        System.out.println(h);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//本地类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">SomeHero</span> <span class="keyword">extends</span> <span class="title">Hero</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println( name+ <span class="string">" 新的进攻手段"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        SomeHero h  =<span class="keyword">new</span> SomeHero();</span><br><span class="line">        h.name =<span class="string">"地卜师"</span>;</span><br><span class="line">        h.attack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="默认方法">默认方法<a class="anchor" href="#默认方法">·</a></h5><p>默认方法是JDK8新特性，指的是接口也可以提供具体方法了</p><p><code>default public void func(){}</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mortal</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">die</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">revive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"本英雄复活了"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="UML图——类之间的关系">UML图——类之间的关系<a class="anchor" href="#UML图——类之间的关系">·</a></h5><p>UML-Unified Module Language统一建模语言，可以很方便的用于描述类的属性，方法，以及类和类之间的关系</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置环境遇到的问题和解决办法积累</title>
      <link href="2021/01/31/%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%E7%A7%AF%E7%B4%AF/"/>
      <url>2021/01/31/%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%E7%A7%AF%E7%B4%AF/</url>
      
        <content type="html"><![CDATA[<p>笔者经常花很多的时间在配置环境上，出于不想总是这样浪费时间的考虑，写篇文章积累一下踩过的坑。</p><a id="more"></a><h3 id="配置java环境">配置java环境<a class="anchor" href="#配置java环境">·</a></h3><h4 id="命令行运行java代码时找不到或无法加载主类">命令行运行java代码时找不到或无法加载主类<a class="anchor" href="#命令行运行java代码时找不到或无法加载主类">·</a></h4><p>一般是先让你在系统变量中配<code>JAVA_HOME</code>再配<code>CLASS_PATH</code>再配<code>PATH</code>。操作完之后出现这个问题，则一般都是<strong>环境配置问题</strong>，其次可能是<strong>代码本身</strong>。</p><p>我最后是把三个环境变量配置在用户变量里也加了一遍就好了。（被坑惨了，实在不知道为什么这样就行了？？）</p><p>其他的可能解决办法还有：可以试试把所有的<code>%JAVA_HOME%</code>全部换成其本身的地址；查看一下CLASS_PATH是否设置错等。</p><h4 id="Android-studio-Sync-Project-with-Gradle-Files时卡住">Android studio Sync Project with Gradle Files时卡住<a class="anchor" href="#Android-studio-Sync-Project-with-Gradle-Files时卡住">·</a></h4><p>主要要切换一下镜像源</p><p>参考这篇文章：https://blog.csdn.net/xiaoxiangsss/article/details/113136127</p><h3 id="使用npm">使用npm<a class="anchor" href="#使用npm">·</a></h3><p>常常需要切换代理才可以成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h3 id="配置Python环境">配置Python环境<a class="anchor" href="#配置Python环境">·</a></h3><p><code>pip install</code>遇到 <code>Read timed out</code> 修改为 <code>pip --default-timeout=100 install package-name</code></p><p>有时<code>pip</code> 和<code>conda</code>可以都试试，如果都不行可以考虑换一下镜像或者更新一下<code>pip</code> 和<code>conda</code></p><h3 id="设置右键菜单中打开xxx为xxx项目">设置右键菜单中<code>打开xxx为xxx项目</code><a class="anchor" href="#设置右键菜单中打开xxx为xxx项目">·</a></h3><p>https://blog.csdn.net/weixin_44653409/article/details/102808839</p><h3 id="github-科学上网也clone不下来">github 科学上网也clone不下来<a class="anchor" href="#github-科学上网也clone不下来">·</a></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/BUAADreamer/Setest.git</span><br><span class="line">Cloning into 'Setest'...</span><br><span class="line"></span><br><span class="line">fatal: unable to access 'https://github.com/BUAADreamer/Setest.git/': OpenSSL SSL_read: Connection was reset, errno 10054</span><br></pre></td></tr></table></figure><p>解决：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.sslVerify "false"</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML+CSS笔记</title>
      <link href="2021/01/30/%E5%89%8D%E7%AB%AF-html5+css3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/01/30/%E5%89%8D%E7%AB%AF-html5+css3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>前端知识整理，以备不时之需。</p><a id="more"></a><p>写在开始：本文部分内容直接搬运自一些网站，仅用作个人和他人学习用途。</p><h2 id="资源整理">资源整理<a class="anchor" href="#资源整理">·</a></h2><h3 id="HTML">HTML<a class="anchor" href="#HTML">·</a></h3><p><a href="https://www.runoob.com/html/html-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a>   <a href="https://www.w3school.com.cn/html/index.asp" target="_blank" rel="noopener">w3school</a></p><h3 id="CSS">CSS<a class="anchor" href="#CSS">·</a></h3><p><a href="https://www.runoob.com/css/css-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a>  <a href="https://www.w3school.com.cn/css/index.asp" target="_blank" rel="noopener">w3school</a></p><h2 id="慕课网教程笔记">慕课网教程笔记<a class="anchor" href="#慕课网教程笔记">·</a></h2><p><a href="https://www.imooc.com/learn/9" target="_blank" rel="noopener">慕课网入门教程</a></p><h3 id="1-HTML文档结构">1.HTML文档结构<a class="anchor" href="#1-HTML文档结构">·</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span> 文档类型声明，表示该文件为 HTML5文件。<span class="meta">&lt;!DOCTYPE&gt;</span> 声明必须是 HTML 文档的第一行，位于 <span class="tag">&lt;<span class="name">html</span>&gt;</span> 标签之前</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span>  --&gt;head标签表示头部标签,通常用来嵌套meta、title、style等标签。 title:网页标题</span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>认识html文件基本结构<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>在本小节中，你将学会认识html文件基本结构<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-语义化标签">2.语义化标签<a class="anchor" href="#2-语义化标签">·</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>段落文本<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>自定义文本标签<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题标签 h1-h6来表示<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>块标签<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span>网页开头<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span>网页底部<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span>区域<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span>侧边栏<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-效果标签">3.效果标签<a class="anchor" href="#3-效果标签">·</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span> --&gt;换行标签</span><br><span class="line"><span class="symbol">&amp;nbsp;</span> --&gt;空格</span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span> --&gt;水平分割线</span><br></pre></td></tr></table></figure><h3 id="4-列表标签">4.列表标签<a class="anchor" href="#4-列表标签">·</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span> <span class="tag">&lt;/<span class="name">li</span>&gt;</span> --&gt;无序列表</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>abc<span class="tag">&lt;/<span class="name">li</span>&gt;</span> --&gt;有序列表</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>def<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-图片链接和表格标签">5.图片链接和表格标签<a class="anchor" href="#5-图片链接和表格标签">·</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"图片地址"</span> <span class="attr">alt</span>=<span class="string">"下载失败时的替换文本"</span> <span class="attr">title</span> = <span class="string">"鼠标滑过时的提示文本"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span>  <span class="attr">href</span>=<span class="string">"目标网址"</span>  <span class="attr">title</span>=<span class="string">"鼠标滑过显示的文本"</span> <span class="attr">target</span>=<span class="string">"_self(覆盖原网页)/_blank(打开新网页)"</span>&gt;</span>链接显示的文本<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">10</span> &gt;</span> --&gt;table表格标签 border属性为边框粗细</span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> --&gt;tr表示行</span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>知识点<span class="tag">&lt;/<span class="name">th</span>&gt;</span> --&gt;th表示第一行加粗的表格表头单元格</span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>html<span class="tag">&lt;/<span class="name">td</span>&gt;</span> --&gt;td表示普通单元格</span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">thead</span>&gt;</span>标签定义表格头部,<span class="tag">&lt;<span class="name">tbody</span>&gt;</span>标签来定义表格的内容,<span class="tag">&lt;<span class="name">tfoot</span>&gt;</span>来定义表格的底部,当长的表格被打印时，表格的表头和页脚可被打印在包含表格数据的每张页面上。</span><br></pre></td></tr></table></figure><h3 id="6-表单标签">6.表单标签<a class="anchor" href="#6-表单标签">·</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">"save.php"</span>&gt;</span> --&gt;action:浏览者输入的数据被传送到的地方,比如一个PHP页面(save.php) </span><br><span class="line">       --&gt;method:数据传送的方式（get/post）</span><br><span class="line">    <span class="comment">&lt;!--文本输入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"username"</span>&gt;</span>用户名:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">id</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">""</span> <span class="attr">placeholder</span>=<span class="string">""</span>/&gt;</span> --&gt;普通文本输入</span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"pass"</span>&gt;</span>密码:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"pass"</span> <span class="attr">id</span>=<span class="string">"pass"</span> <span class="attr">value</span>=<span class="string">""</span> <span class="attr">placeholder</span>=<span class="string">""</span>/&gt;</span> --&gt;加密文本输入</span><br><span class="line">    --&gt;for=id完成了和input标签的联动，和相应的输入框进行绑定</span><br><span class="line">    --&gt;type="num"--只允许输入数字 type="url"--只允许输入http/https协议的网址 type="email"--&gt;邮箱</span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span>  <span class="attr">rows</span>=<span class="string">"行数"</span> <span class="attr">cols</span>=<span class="string">"列数"</span>&gt;</span>文本<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span> --&gt;大段文字输入框</span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--选择框--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio/checkbox"</span> <span class="attr">value</span>=<span class="string">"值"</span> <span class="attr">name</span>=<span class="string">"名称"</span> <span class="attr">checked</span>=<span class="string">"checked"</span>/&gt;</span></span><br><span class="line">     --&gt;当 type="radio" 时，控件为单选框</span><br><span class="line">       当 type="checkbox" 时，控件为复选框</span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--下拉菜单--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span>&gt;</span> --&gt;下拉菜单 select标签里面只能放option标签，表示下拉列表的选项。option标签放选项内容，不放置其他标签</span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"看书"</span>&gt;</span>看书<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"旅游"</span>&gt;</span>旅游<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"运动"</span> <span class="attr">selected</span>=<span class="string">"selected"</span>&gt;</span>运动<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"购物"</span>&gt;</span>购物<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--按钮--&gt;</span> --&gt;对表单其他元素做相应的操作</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"确定"</span> <span class="attr">name</span>=<span class="string">"submit"</span> /&gt;</span>  --&gt;value：按钮上显示的文字</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"reset"</span> <span class="attr">value</span>=<span class="string">"重置"</span> <span class="attr">name</span>=<span class="string">"reset"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="几个常用属性">几个常用属性<a class="anchor" href="#几个常用属性">·</a></h4><p>value：提交数据到服务器的值（后台程序PHP使用）</p><p>name：为控件命名，以备后台程序 ASP、PHP 使用</p><p>checked：当设置 checked=“checked” 时，该选项被默认选中</p><h3 id="7-CSS样式基本使用">7.CSS样式基本使用<a class="anchor" href="#7-CSS样式基本使用">·</a></h3><p>css 样式由<strong>选择符</strong>和<strong>声明</strong>组成，而<strong>声明</strong>又由<strong>属性</strong>和<strong>值</strong>组成</p><p>注释：<code>/* */</code></p><h4 id="内联样式">内联样式<a class="anchor" href="#内联样式">·</a></h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p style="color:red;font-size:12px"&gt;这里文字是红色。&lt;/p&gt;</span><br></pre></td></tr></table></figure><h4 id="嵌入式">嵌入式<a class="anchor" href="#嵌入式">·</a></h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line">    <span class="selector-tag">span</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>:blue;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;span&gt;123&lt;/span&gt;</span><br></pre></td></tr></table></figure><h4 id="外联样式">外联样式<a class="anchor" href="#外联样式">·</a></h4><p>一般写在<code>&lt;head&gt;</code>标签内</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href="base.css" rel="stylesheet" type="text/css" /&gt;</span><br></pre></td></tr></table></figure><h4 id="三种方式优先级">三种方式优先级<a class="anchor" href="#三种方式优先级">·</a></h4><p>内联式 &gt; 嵌入式 &gt; 外部式</p><p>即<strong>就近原则</strong></p><h3 id="8-CSS选择器">8.CSS选择器<a class="anchor" href="#8-CSS选择器">·</a></h3><p>声明组成：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123;</span><br><span class="line">    样式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="各种选择器">各种选择器<a class="anchor" href="#各种选择器">·</a></h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 标签选择器 */</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">font-size</span>:<span class="number">12px</span>;<span class="attribute">line-height</span>:<span class="number">1.6em</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 类选择器 .类名 */</span></span><br><span class="line">.类选器名称 &#123;css样式代码;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ID选择器 #ID */</span></span><br><span class="line">#ID名字 &#123;css样式;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*子选择器 &gt; */</span></span><br><span class="line"><span class="selector-class">.food</span>&gt;<span class="selector-tag">li</span> &#123;<span class="attribute">border</span>:<span class="number">1px</span> solid red;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*后代选择器 空格 */</span></span><br><span class="line"><span class="selector-class">.food</span> <span class="selector-tag">span</span>&#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*通用选择器 匹配html中所有标签元素*/</span></span><br><span class="line">* &#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 伪类选择器 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;<span class="attribute">color</span>:red;&#125; <span class="comment">/*给html中一个标签元素的鼠标滑过的状态来设置字体颜色*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分组选择器 */</span></span><br><span class="line"><span class="selector-tag">h1</span>,<span class="selector-tag">span</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类和ID选择器区别">类和ID选择器区别<a class="anchor" href="#类和ID选择器区别">·</a></h4><ul><li><p><strong>ID选择器只能在文档中使用一次</strong>。与类选择器不同，在一个HTML文档中，ID选择器只能使用一次，而且仅一次。而类选择器可以使用多次。换言之，每个标签ID不能相同</p></li><li><p>**可以使用类选择器词列表方法为一个元素同时设置多个样式。**我们可以为一个元素同时设多个样式，但只可以用类选择器的方法实现，ID选择器是不可以的（<strong>不能使用 ID 词列表</strong>）。如：</p></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.stress</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bigsize</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">25px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;p&gt;到了&lt;span class="stress bigsize"&gt;三年级&lt;/span&gt;下学期时，我们班上了一节公开课...&lt;/p&gt;</span><br></pre></td></tr></table></figure><h3 id="9-CSS继承，优先级和重要性">9.CSS继承，优先级和重要性<a class="anchor" href="#9-CSS继承，优先级和重要性">·</a></h3><h4 id="优先级">优先级<a class="anchor" href="#优先级">·</a></h4><p>内联样式 &gt; id选择器 &gt; 类选择器 &gt; 标签选择器 &gt; 通配符选择器</p><h4 id="权值计算-特殊性">权值计算-特殊性<a class="anchor" href="#权值计算-特殊性">·</a></h4><p>标签的权值为1，类选择符的权值为10，ID选择符的权值最高为100。继承的权值可视为0.1</p><h4 id="选择器最高层级-important">选择器最高层级!important<a class="anchor" href="#选择器最高层级-important">·</a></h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:red<span class="meta">!important</span>;&#125;</span><br></pre></td></tr></table></figure><h3 id="10-CSS字体样式">10.CSS字体样式<a class="anchor" href="#10-CSS字体样式">·</a></h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*使用font-family设置字体*/</span></span><br><span class="line"><span class="selector-tag">body</span>&#123;<span class="attribute">font-family</span>:<span class="string">"宋体"</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用font-size设置字体大小*/</span></span><br><span class="line"><span class="selector-tag">body</span>&#123;<span class="attribute">font-size</span>:<span class="number">12px</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用font-weight设置字体粗细*/</span></span><br><span class="line"><span class="selector-tag">p</span> <span class="selector-tag">span</span>&#123;<span class="attribute">font-weight</span>:bold;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用font-style设置字体样式</span></span><br><span class="line"><span class="comment">正常字体为normal,也是font-style的默认值。</span></span><br><span class="line"><span class="comment">italic为设置字体为斜体，用于字体本身就有倾斜的样式。</span></span><br><span class="line"><span class="comment">oblique为设置倾斜的字体，强制将字体倾斜。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用color设置字体颜色 三种赋值方式*/</span></span><br><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:<span class="built_in">rgb</span>(<span class="number">133</span>,<span class="number">45</span>,<span class="number">200</span>);&#125;</span><br><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:<span class="number">#00ffff</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*font样式的简写方式*/</span></span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">font-style</span>:italic;</span><br><span class="line">    <span class="attribute">font-weight</span>:bold; </span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">12px</span>; </span><br><span class="line">    <span class="attribute">line-height</span>:<span class="number">1.5em</span>; </span><br><span class="line">    <span class="attribute">font-family</span>:<span class="string">"宋体"</span>,sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">---------------</span>&gt;</span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">font</span>:italic  bold  <span class="number">12px</span>/<span class="number">1.5em</span>  <span class="string">"宋体"</span>,sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-装饰文本">11.装饰文本<a class="anchor" href="#11-装饰文本">·</a></h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* text-decoration添加文本修饰</span></span><br><span class="line"><span class="comment">1、text-decoration可以设置添加到文本的修饰。</span></span><br><span class="line"><span class="comment">2、text-decoration默认值为none, 定义标准的文本。</span></span><br><span class="line"><span class="comment">3、text-decoration的值为underline为定义文本下的一条线。</span></span><br><span class="line"><span class="comment">4、text-decoration的值为overline为定义文本上的一条线。</span></span><br><span class="line"><span class="comment">5、text-decoration的值为line-through为定义穿过文本下的一条线，一般用于商品折扣价。 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*text-indent为文本添加首行缩进*/</span></span><br><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">text-indent</span>:<span class="number">2em</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*line-height设置行间距*/</span></span><br><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">line-height</span>:<span class="number">1.5em</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用letter/word-spacing增加或减少字符间的空白*/</span></span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line">    <span class="attribute">letter-spacing</span>:<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用text-align设置文本对齐方式*/</span></span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line">    <span class="attribute">text-align</span>:center; <span class="comment">/*可选left right*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用到<code>px（像素）</code>、<code>em</code>、<code>% 百分比</code> 三种长度单位，这三个都是相对长度单位</p><p>1em和font-size对应</p><p>百分比也是相对于font-size设定值的比</p><h3 id="12-CSS盒模型">12.CSS盒模型<a class="anchor" href="#12-CSS盒模型">·</a></h3><h4 id="元素分类">元素分类<a class="anchor" href="#元素分类">·</a></h4><h5 id="常用的块状元素">常用的块状元素<a class="anchor" href="#常用的块状元素">·</a></h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span>&gt;、&lt;<span class="selector-tag">p</span>&gt;、&lt;<span class="selector-tag">h1</span>&gt;...&lt;<span class="selector-tag">h6</span>&gt;、&lt;<span class="selector-tag">ol</span>&gt;、&lt;<span class="selector-tag">ul</span>&gt;、&lt;<span class="selector-tag">dl</span>&gt;、&lt;<span class="selector-tag">table</span>&gt;、&lt;<span class="selector-tag">address</span>&gt;、&lt;<span class="selector-tag">blockquote</span>&gt; 、&lt;<span class="selector-tag">form</span>&gt;</span><br></pre></td></tr></table></figure><h5 id="常用的内联元素">常用的内联元素<a class="anchor" href="#常用的内联元素">·</a></h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">a</span>&gt;、&lt;<span class="selector-tag">span</span>&gt;、&lt;<span class="selector-tag">br</span>&gt;、&lt;<span class="selector-tag">i</span>&gt;、&lt;<span class="selector-tag">em</span>&gt;、&lt;<span class="selector-tag">strong</span>&gt;、&lt;<span class="selector-tag">label</span>&gt;、&lt;<span class="selector-tag">q</span>&gt;、&lt;<span class="selector-tag">var</span>&gt;、&lt;<span class="selector-tag">cite</span>&gt;、&lt;<span class="selector-tag">code</span>&gt;</span><br></pre></td></tr></table></figure><h5 id="常用的内联块状元素">常用的内联块状元素<a class="anchor" href="#常用的内联块状元素">·</a></h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">img</span>&gt;、&lt;<span class="selector-tag">input</span>&gt;</span><br></pre></td></tr></table></figure><h5 id="几种元素转换">几种元素转换<a class="anchor" href="#几种元素转换">·</a></h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.将<span class="selector-tag">a</span>标签转为块级标签</span><br><span class="line"><span class="selector-tag">a</span>&#123;<span class="attribute">display</span>:block;&#125;</span><br><span class="line">2.将块状元素<span class="selector-tag">div</span>转换为内联元素</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">     <span class="attribute">display</span>:inline;</span><br><span class="line">&#125;</span><br><span class="line">3.设置为内联块状</span><br><span class="line"><span class="selector-tag">display</span><span class="selector-pseudo">:inline-block</span>;</span><br><span class="line">4<span class="selector-class">.none</span>设置不显示</span><br><span class="line"><span class="selector-tag">display</span><span class="selector-pseudo">:none</span>;</span><br></pre></td></tr></table></figure><h4 id="盒子模型">盒子模型<a class="anchor" href="#盒子模型">·</a></h4><p>辅助理解的视频：https://www.imooc.com/video/3225</p><p>内容被<code>padding</code>，<code>border</code>，<code>margin</code>三层包住，每层都有一定的宽度。</p><p>都可以设置<code>top</code>/<code>bottom</code>/<code>left</code>/<code>right</code>四个方向的属性</p><h5 id="基本设置盒子模型">基本设置盒子模型<a class="anchor" href="#基本设置盒子模型">·</a></h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">10px</span>;    </span><br><span class="line">    <span class="attribute">background-color</span>:red; <span class="comment">/*设置背景色*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/CSS3%2BHTML5/1.jpg" style="zoom:80%;"> <img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/CSS3%2BHTML5/2.jpg" style="zoom:80%;"></p><h4 id="设置盒子边框">设置盒子边框<a class="anchor" href="#设置盒子边框">·</a></h4><p>盒子模型的边框就是围绕着内容及补白的线，这条线你可以设置它的粗细、样式和颜色(边框三个属性)。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">2px</span>  solid  red;</span><br><span class="line">&#125;</span><br><span class="line">上面是 <span class="selector-tag">border</span> 代码的缩写形式，可以分开写：</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">border-width</span>:<span class="number">2px</span>; <span class="comment">/*不常用的:thin | medium | thick*/</span></span><br><span class="line">    <span class="attribute">border-style</span>:solid; <span class="comment">/*边框样式: dashed（虚线）| dotted（点线）| solid（实线）。*/</span></span><br><span class="line">    <span class="attribute">border-color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*只加底部边框*/</span></span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">border-bottom</span>:<span class="number">2px</span> solid red; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*元素边框的圆角效果可以使用border-radius属性来设置。圆角可分为左上、右上、右下、左下。*/</span></span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">border-radius</span>: <span class="number">20px</span> <span class="number">10px</span> <span class="number">15px</span> <span class="number">30px</span>;&#125;</span><br></pre></td></tr></table></figure><h4 id="设置内边距">设置内边距<a class="anchor" href="#设置内边距">·</a></h4><p>元素内容与边框之间是可以设置距离的，称之为“内边距（填充）”。填充也可分为上、右、下、左(顺时针)。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">padding</span>:<span class="number">20px</span> <span class="number">10px</span> <span class="number">15px</span> <span class="number">30px</span>;&#125;</span><br><span class="line"></span><br><span class="line">如果上、右、下、左的填充都为10<span class="selector-tag">px</span>;可以这么写</span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">padding</span>:<span class="number">10px</span>;&#125;</span><br><span class="line"></span><br><span class="line">如果上下填充一样为10<span class="selector-tag">px</span>，左右一样为20<span class="selector-tag">px</span>，可以这么写：</span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">padding</span>:<span class="number">10px</span> <span class="number">20px</span>;&#125;</span><br></pre></td></tr></table></figure><h4 id="设置外边距">设置外边距<a class="anchor" href="#设置外边距">·</a></h4><p>元素与其它元素之间的距离可以使用边界（margin）来设置。边界也是可分为上、右、下、左。使用方法和内边距一样。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">margin</span>:<span class="number">20px</span> <span class="number">10px</span> <span class="number">15px</span> <span class="number">30px</span>;&#125;</span><br></pre></td></tr></table></figure><h3 id="13-CSS3布局模型">13.CSS3布局模型<a class="anchor" href="#13-CSS3布局模型">·</a></h3><p>在网页中，元素有三种布局模型：1、流动模型（Flow）2、浮动模型 (Float)3、层模型（Layer）</p><h4 id="流动模型">流动模型<a class="anchor" href="#流动模型">·</a></h4><h5 id="典型特征">典型特征<a class="anchor" href="#典型特征">·</a></h5><p>第一点，<strong>块状元素</strong>都会在所处的<strong>包含元素内</strong>自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为<strong>100%</strong>。实际上，块状元素都会以行的形式占据位置。如右侧代码编辑器中三个块状元素标签(div，h1，p)宽度显示为100%。</p><p>第二点，在流动模型下，<strong>内联元素</strong>都会在所处的包含元素内从左到右水平分布显示。（内联元素可不像块状元素这么霸道独占一行）</p><h4 id="浮动模型">浮动模型<a class="anchor" href="#浮动模型">·</a></h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*让两个块状元素并排显示*/</span></span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">2px</span> red solid;</span><br><span class="line">    <span class="attribute">float</span>:left; <span class="comment">/*左对齐 right即为右对齐*/</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;div id="div1"&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id="div2"&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置div1和div2一个最左一个最右*/</span></span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">2px</span> red solid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#div1</span>&#123;<span class="attribute">float</span>:left;&#125;</span><br><span class="line"><span class="selector-id">#div2</span>&#123;<span class="attribute">float</span>:right;&#125; </span><br><span class="line"></span><br><span class="line">&lt;div id="div1"&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id="div2"&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="层模型">层模型<a class="anchor" href="#层模型">·</a></h4><p>层模型有三种形式：</p><p>1、绝对定位(position: absolute)</p><p>2、相对定位(position: relative)</p><p>3、固定定位(position: fixed)</p><h5 id="绝对定位">绝对定位<a class="anchor" href="#绝对定位">·</a></h5><p>如果想为元素设置层模型中的绝对定位，需要设置position:absolute(表示绝对定位)，这条语句的作用将元素<strong>从文档流中拖出来</strong>，然后使用left、right、top、bottom属性<strong>相对于</strong>其<strong>最接近的一个具有定位属性</strong>的<strong>父包含块</strong>进行绝对定位。如果不存在这样的包含块，则相对于body元素，即相对于<strong>浏览器窗口</strong>。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">实现<span class="selector-tag">div</span>元素相对于浏览器窗口向右移动100<span class="selector-tag">px</span>，向下移动50<span class="selector-tag">px</span>。</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">2px</span> red solid;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50px</span>;                                          </span><br><span class="line">&#125;</span><br><span class="line">&lt;div id="div1"&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h5 id="相对定位">相对定位<a class="anchor" href="#相对定位">·</a></h5><p>如果想为元素设置层模型中的相对定位，需要设置position:relative（表示相对定位），它通过left、right、top、bottom属性确定元素在<strong>正常文档流中</strong>的偏移位置。相对定位完成的过程是首先按static(float)方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于**以前的位置移动，**移动的方向和幅度由left、right、top、bottom属性确定，偏移前的位置保留不动。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">相对于以前位置向下移动50<span class="selector-tag">px</span>，向右移动100<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-id">#div1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">2px</span> red solid;</span><br><span class="line">    <span class="attribute">position</span>:relative;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div id="div1"&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h5 id="固定定位">固定定位<a class="anchor" href="#固定定位">·</a></h5><p>fixed：表示固定定位，与absolute定位类型类似，但它的相对移动的坐标是视图（屏幕内的网页窗口）本身。由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响，这与background-attachment:fixed;属性功能相同。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">实现相对于浏览器视图向右移动100<span class="selector-tag">px</span>，向下移动50<span class="selector-tag">px</span>。并且拖动滚动条时位置固定不变。</span><br><span class="line"><span class="selector-id">#div1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">2px</span> red solid;</span><br><span class="line">    <span class="attribute">position</span>:fixed;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;p&gt;文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本。&lt;/p&gt;</span><br></pre></td></tr></table></figure><h5 id="Relative与Absolute组合使用">Relative与Absolute组合使用<a class="anchor" href="#Relative与Absolute组合使用">·</a></h5><p>使用相对于某个元素的绝对定位</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1、参照定位的元素必须是相对定位元素的前辈元素：</span><br><span class="line">&lt;div id="box1"&gt;&lt;!--参照定位的元素--&gt;</span><br><span class="line">    &lt;div id="box2"&gt;相对参照元素进行定位&lt;/div&gt;&lt;!--相对定位元素--&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">从上面代码可以看出<span class="selector-tag">box1</span>是<span class="selector-tag">box2</span>的父元素（父元素当然也是前辈元素了）。</span><br><span class="line"></span><br><span class="line">2、参照定位的元素必须加入<span class="selector-tag">position</span><span class="selector-pseudo">:relative</span>;</span><br><span class="line"><span class="selector-id">#box1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">position</span>:relative;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3、定位元素加入<span class="selector-tag">position</span><span class="selector-pseudo">:absolute</span>，便可以使用<span class="selector-tag">top</span>、<span class="selector-tag">bottom</span>、<span class="selector-tag">left</span>、<span class="selector-tag">right</span>来进行偏移定位了。</span><br><span class="line"><span class="selector-id">#box2</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">30px</span>;         </span><br><span class="line">&#125;</span><br><span class="line">这样<span class="selector-tag">box2</span>就可以相对于父元素<span class="selector-tag">box1</span>定位了（这里注意参照物就可以不是浏览器了，而可以自由设置了）。</span><br></pre></td></tr></table></figure><h3 id="14-弹性盒模型">14.弹性盒模型<a class="anchor" href="#14-弹性盒模型">·</a></h3><h4 id="设置flex">设置flex<a class="anchor" href="#设置flex">·</a></h4><p>三个块元素设置大小以及背景色，在父容器中添加flex。</p><p>技术点的解释：</p><p>1、设置display: flex属性可以把块级元素在一排显示。</p><p>2、flex需要添加在父元素上，改变子元素的排列顺序。</p><p>3、默认为从左往右依次排列,且和父元素左边没有间隙。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class="box"&gt;</span><br><span class="line">    &lt;div class="box1"&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class="box2"&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class="box3"&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line">    <span class="selector-class">.box</span> &#123;</span><br><span class="line">        <span class="attribute">background</span>: blue;</span><br><span class="line">        <span class="attribute">display</span>: flex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.box</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.box1</span> &#123;</span><br><span class="line">        <span class="attribute">background</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.box2</span> &#123;</span><br><span class="line">        <span class="attribute">background</span>: orange;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.box3</span> &#123;</span><br><span class="line">        <span class="attribute">background</span>: green;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h4 id="使用justify-content属性设置横轴排列方式">使用justify-content属性设置横轴排列方式<a class="anchor" href="#使用justify-content属性设置横轴排列方式">·</a></h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">justify-content: flex-start | flex-end | center | space-between | space-around;</span><br></pre></td></tr></table></figure><p><code>flex-start</code>：交叉轴的起点对齐</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">       <span class="attribute">background</span>: blue;</span><br><span class="line">       <span class="attribute">display</span>: flex;</span><br><span class="line">       <span class="attribute">justify-content</span>: flex-start;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><a href="https://img.mukewang.com/5e959b080001a38d25340322.jpg" target="_blank" rel="noopener"><img src="https://img.mukewang.com/5e959b080001a38d25340322.jpg" alt="img"></a></p><p><code>flex-end</code>：右对齐</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">       <span class="attribute">background</span>: blue;</span><br><span class="line">       <span class="attribute">display</span>: flex;</span><br><span class="line">       <span class="attribute">justify-content</span>: flex-end;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><a href="https://img1.mukewang.com/5e959b8b0001d43b25420308.jpg" target="_blank" rel="noopener"><img src="https://img1.mukewang.com/5e959b8b0001d43b25420308.jpg" alt="img"></a></p><p><code>center</code>： 居中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">       <span class="attribute">background</span>: blue;</span><br><span class="line">       <span class="attribute">display</span>: flex;</span><br><span class="line">       <span class="attribute">justify-content</span>: center;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><a href="https://img2.mukewang.com/5e959bdd0001ad2125300303.jpg" target="_blank" rel="noopener"><img src="https://img2.mukewang.com/5e959bdd0001ad2125300303.jpg" alt="img"></a></p><p><code>space-between</code>：两端对齐，项目之间的间隔都相等。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">       <span class="attribute">background</span>: blue;</span><br><span class="line">       <span class="attribute">display</span>: flex;</span><br><span class="line">       <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><a href="https://img2.mukewang.com/5e959c6400017b1c25530313.jpg" target="_blank" rel="noopener"><img src="https://img2.mukewang.com/5e959c6400017b1c25530313.jpg" alt="img"></a></p><p><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">        <span class="attribute">background</span>: blue;</span><br><span class="line">        <span class="attribute">display</span>: flex;</span><br><span class="line">        <span class="attribute">justify-content</span>: space-around;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><a href="https://img2.mukewang.com/5e959caf000113b125370303.jpg" target="_blank" rel="noopener"><img src="https://img2.mukewang.com/5e959caf000113b125370303.jpg" alt="img"></a></p><h4 id="使用align-items属性设置纵轴排列方式">使用align-items属性设置纵轴排列方式<a class="anchor" href="#使用align-items属性设置纵轴排列方式">·</a></h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-items: flex-start | flex-end | center | baseline | stretch;</span><br></pre></td></tr></table></figure><p><code>flex-start</code>：默认值，左对齐</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">700px</span>;</span><br><span class="line">     <span class="attribute">background</span>: blue;</span><br><span class="line">     <span class="attribute">display</span>: flex;</span><br><span class="line">     <span class="attribute">align-items</span>: flex-start;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><a href="https://img3.mukewang.com/5e95a3720001140325381051.jpg" target="_blank" rel="noopener"><img src="https://img3.mukewang.com/5e95a3720001140325381051.jpg" alt="img"></a></p><p><code>flex-end</code>：交叉轴的终点对齐</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">       <span class="attribute">height</span>: <span class="number">700px</span>;</span><br><span class="line">       <span class="attribute">background</span>: blue;</span><br><span class="line">       <span class="attribute">display</span>: flex;</span><br><span class="line">       <span class="attribute">align-items</span>: flex-end;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><a href="https://img2.mukewang.com/5e95a3ca0001550a25381056.jpg" target="_blank" rel="noopener"><img src="https://img2.mukewang.com/5e95a3ca0001550a25381056.jpg" alt="img"></a></p><p><code>center</code>： 交叉轴的中点对齐</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">700px</span>;</span><br><span class="line">        <span class="attribute">background</span>: blue;</span><br><span class="line">        <span class="attribute">display</span>: flex;</span><br><span class="line">        <span class="attribute">align-items</span>: center;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><a href="https://img3.mukewang.com/5e9667880001796c25371056.jpg" target="_blank" rel="noopener"><img src="https://img3.mukewang.com/5e9667880001796c25371056.jpg" alt="img"></a></p><p><code>baseline</code>：项目的第一行文字的基线对齐。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">700px</span>;</span><br><span class="line">        <span class="attribute">background</span>: blue;</span><br><span class="line">        <span class="attribute">display</span>: flex;</span><br><span class="line">        <span class="attribute">align-items</span>: baseline;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>三个盒子中设置不同的字体大小，可以参考右侧编辑器中的代码进行测试。</p><p>实现效果：</p><p><a href="https://img3.mukewang.com/5e9668ff0001f8f125341053.jpg" target="_blank" rel="noopener"><img src="https://img3.mukewang.com/5e9668ff0001f8f125341053.jpg" alt="img"></a></p><p><code>stretch（默认值）</code>：如果项目未设置高度或设为auto，将占满整个容器的高度。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">       <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">       <span class="attribute">background</span>: blue;</span><br><span class="line">       <span class="attribute">display</span>: flex;</span><br><span class="line">       <span class="attribute">align-items</span>: stretch;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="selector-class">.box</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">       <span class="comment">/*不设置高度，元素在垂直方向上铺满父容器*/</span></span><br><span class="line">       <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><a href="https://img2.mukewang.com/5e9669ef00017e0e25390453.jpg" target="_blank" rel="noopener"><img src="https://img2.mukewang.com/5e9669ef00017e0e25390453.jpg" alt="img"></a></p><h4 id="给子元素设置flex占比">给子元素设置flex占比<a class="anchor" href="#给子元素设置flex占比">·</a></h4><p><a href="https://img3.mukewang.com/5e966c3100011c5b25430450.jpg" target="_blank" rel="noopener"><img src="https://img3.mukewang.com/5e966c3100011c5b25430450.jpg" alt="img"></a></p><p><strong>技术点的解释：</strong></p><p>1、给子元素设置flex属性,可以设置子元素相对于父元素的占比。</p><p>2、flex属性的值只能是正整数,表示占比多少。其实是几个子块的比</p><p>3、给子元素设置了flex之后,其宽度属性会失效。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="selector-tag">DOCTYPE</span> <span class="selector-tag">html</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">html</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">head</span>&gt;</span><br><span class="line">    &lt;meta charset="UTF-8"&gt;</span><br><span class="line">    &lt;title&gt;flex占比&lt;/title&gt;</span><br><span class="line">    &lt;style type="text/css"&gt;</span><br><span class="line">    <span class="selector-class">.box</span> &#123;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">        <span class="attribute">background</span>: blue;</span><br><span class="line">        <span class="attribute">display</span>: flex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.box</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.box1</span> &#123;</span><br><span class="line">        <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">        <span class="attribute">background</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.box2</span> &#123;</span><br><span class="line">        <span class="attribute">flex</span>: <span class="number">3</span>;</span><br><span class="line">        <span class="attribute">background</span>: orange;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.box3</span> &#123;</span><br><span class="line">        <span class="attribute">flex</span>: <span class="number">2</span>;</span><br><span class="line">        <span class="attribute">background</span>: green;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">    &lt;div class="box"&gt;</span><br><span class="line">        &lt;div class="box1"&gt;flex:1&lt;/div&gt;</span><br><span class="line">        &lt;div class="box2"&gt;flex:3&lt;/div&gt;</span><br><span class="line">        &lt;div class="box3"&gt;flex:2&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="15-css样式设置技巧">15.css样式设置技巧<a class="anchor" href="#15-css样式设置技巧">·</a></h3><h4 id="水平居中设置-行内元素">水平居中设置-行内元素<a class="anchor" href="#水平居中设置-行内元素">·</a></h4><p>如果被设置元素为文本、图片等行内元素时，水平居中是通过给父元素设置 <code>text-align:center</code> 来实现的。</p><h4 id="水平居中设置-定宽块状元素">水平居中设置-定宽块状元素<a class="anchor" href="#水平居中设置-定宽块状元素">·</a></h4><p>当被设置元素为 块状元素 时用 <code>text-align：center</code> 就不起作用了，这时也分两种情况：<strong>定宽块状元素</strong>和<strong>不定宽块状元素</strong>。</p><h5 id="定宽块状元素：块状元素的宽度width为固定值。">定宽块状元素：块状元素的宽度width为固定值。<a class="anchor" href="#定宽块状元素：块状元素的宽度width为固定值。">·</a></h5><p>满足定宽和块状两个条件的元素是可以通过设置“左右margin”值为“auto”来实现居中的。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">  &lt;div&gt;我是定宽块状元素，哈哈，我要水平居中显示。&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid red;<span class="comment">/*为了显示居中效果明显为 div 设置了边框*/</span></span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;<span class="comment">/*定宽*/</span></span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">20px</span> auto;<span class="comment">/* margin-left 与 margin-right 设置为 auto */</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h4 id="面试常考题之已知宽高实现盒子水平垂直居中">面试常考题之已知宽高实现盒子水平垂直居中<a class="anchor" href="#面试常考题之已知宽高实现盒子水平垂直居中">·</a></h4><p>这一章节我们来学习已知宽高实现盒子水平垂直居中。通常使用定位完成，例如想要实现以下效果：</p><p><a href="https://img4.mukewang.com/5e967bb40001e35725570475.jpg" target="_blank" rel="noopener"><img src="https://img4.mukewang.com/5e967bb40001e35725570475.jpg" alt="img"></a></p><p>我们有如下两个div元素</p><p><img src="https://img3.mukewang.com/5e967a0500013c9104650162.jpg" alt="img"></p><p>要实现子元素相对于父元素垂直水平居中,我们只需要输入以下代码：</p><p><a href="https://img.mukewang.com/5e967a380001840f11050487.jpg" target="_blank" rel="noopener"><img src="https://img.mukewang.com/5e967a380001840f11050487.jpg" alt="img"></a></p><p><strong>技术点的解释：</strong></p><p>1、利用父元素设置相对定位,子元素设置绝对定位,那么子元素就是相对于父元素定位的特性。</p><p>2、子元素设置上和左偏移的值都为50%，是元素的左上角在父元素中心点的位置。效果：</p><p><a href="https://img2.mukewang.com/5e967c3d0001fbbf25600616.jpg" target="_blank" rel="noopener"><img src="https://img2.mukewang.com/5e967c3d0001fbbf25600616.jpg" alt="img"></a></p><p>3、然后再用margin给上和左都给负的自身宽高的一半,就能达到垂直水平居中的效果。</p><h4 id="面试常考题之宽高不定实现盒子水平垂直居中">面试常考题之宽高不定实现盒子水平垂直居中<a class="anchor" href="#面试常考题之宽高不定实现盒子水平垂直居中">·</a></h4><p>这一章我们来学习未知宽高实现盒子水平垂直居中，通常使用定位以及translate完成。参考下面例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box1"</span>&gt;</span></span><br><span class="line">           慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网</span><br><span class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">       <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#00ee00</span>;</span><br><span class="line">       <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">       <span class="attribute">position</span>: relative;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="selector-class">.box1</span> &#123;</span><br><span class="line">       <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">       <span class="attribute">position</span>: absolute;</span><br><span class="line">       <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">       <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">       <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><a href="https://img4.mukewang.com/5e967f3b000117da25530461.jpg" target="_blank" rel="noopener"><img src="https://img4.mukewang.com/5e967f3b000117da25530461.jpg" alt="img"></a></p><p><strong>技术点的解释：</strong></p><p>1、利用父元素设置相对定位,子元素设置绝对定位,那么子元素就是相对于父元素定位的特性。</p><p>2、子元素设置上和左偏移的值都为50%。</p><p>3、然后再用css3属性translate位移,给上和左都位移-50%距离，就能达到垂直水平居中的效果。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL学习笔记</title>
      <link href="2021/01/29/sql-note/"/>
      <url>2021/01/29/sql-note/</url>
      
        <content type="html"><![CDATA[<p>最近结合廖雪峰教程学习了和sql,mysql相关的一些知识，对重要的部分做了一些梳理。</p><a id="more"></a><h2 id="英文教程">英文教程<a class="anchor" href="#英文教程">·</a></h2><h5 id="How-to-Load-the-Sample-Database-into-MySQL-Server"><a href="https://www.mysqltutorial.org/how-to-load-sample-database-into-mysql-database-server.aspx" target="_blank" rel="noopener">How to Load the Sample Database into MySQL Server</a><a class="anchor" href="#How-to-Load-the-Sample-Database-into-MySQL-Server">·</a></h5><h5 id="https-www-mysqltutorial-org">https://www.mysqltutorial.org/<a class="anchor" href="#https-www-mysqltutorial-org">·</a></h5><h2 id="SQL教程（廖雪峰）笔记">SQL教程（廖雪峰）笔记<a class="anchor" href="#SQL教程（廖雪峰）笔记">·</a></h2><h3 id="关系模型">关系模型<a class="anchor" href="#关系模型">·</a></h3><p>关系数据库是建立在关系模型上的。而关系模型本质上就是若干个存储数据的<strong>二维表</strong>，可以把它们看作很多<strong>Excel表</strong>。</p><h3 id="查询数据">查询数据<a class="anchor" href="#查询数据">·</a></h3><h4 id="脚本生成数据方式">脚本生成数据方式<a class="anchor" href="#脚本生成数据方式">·</a></h4><p>1.打开MYSQL-command line</p><p>2.输入source 将相应的sql文件对应的地址输入（或者直接把文件拖入命令行）</p><p>廖老师的sql文件：<a href="F:%5C%E5%AD%A6%E4%B9%A0%5C%E5%B7%A5%E7%A8%8B%E4%B8%8E%E5%BA%94%E7%94%A8%E7%A7%91%E5%AD%A6%5CCS%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%5CSQL-learn%5Cinit-test-data.sql">init-test-data.sql</a></p><p>3.<code>SHOW DATABASE</code>可以查看已有数据库</p><h4 id="基本查询">基本查询<a class="anchor" href="#基本查询">·</a></h4><p>使用SELECT查询的基本语句<code>SELECT * FROM &lt;表名&gt;</code>可以查询一个表的所有行和所有列的数据。</p><h4 id="条件查询">条件查询<a class="anchor" href="#条件查询">·</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &lt;表名&gt; WHERE &lt;条件表达式&gt;</span><br><span class="line">SELECT * FROM students WHERE score &gt;&#x3D; 80;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">条件</th><th style="text-align:left">表达式举例1</th><th style="text-align:left">表达式举例2</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">使用=判断相等</td><td style="text-align:left">score = 80</td><td style="text-align:left">name = ‘abc’</td><td style="text-align:left">字符串需要用单引号括起来</td></tr><tr><td style="text-align:left">使用&gt;判断大于</td><td style="text-align:left">score &gt; 80</td><td style="text-align:left">name &gt; ‘abc’</td><td style="text-align:left">字符串比较根据ASCII码，中文字符比较根据数据库设置</td></tr><tr><td style="text-align:left">使用&gt;=判断大于或相等</td><td style="text-align:left">score &gt;= 80</td><td style="text-align:left">name &gt;= ‘abc’</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">使用&lt;判断小于</td><td style="text-align:left">score &lt; 80</td><td style="text-align:left">name &lt;= ‘abc’</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">使用&lt;=判断小于或相等</td><td style="text-align:left">score &lt;= 80</td><td style="text-align:left">name &lt;= ‘abc’</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">使用&lt;&gt;判断不相等</td><td style="text-align:left">score &lt;&gt; 80</td><td style="text-align:left">name &lt;&gt; ‘abc’</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">使用LIKE判断相似</td><td style="text-align:left">name LIKE ‘ab%’</td><td style="text-align:left">name LIKE ‘%bc%’</td><td style="text-align:left">%表示任意字符，例如’ab%‘将匹配’ab’，‘abc’，‘abcd’</td></tr><tr><td style="text-align:left">BETWEEN a AND b</td><td style="text-align:left">BETWEEN 60 AND 90</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">IN (a,b)</td><td style="text-align:left">是否等于a或b</td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><h4 id="投影查询">投影查询<a class="anchor" href="#投影查询">·</a></h4><p>基本格式：<code>SELECT 列1, 列2, 列3 FROM students</code></p><p>使用<code>SELECT 列1, 列2, 列3 FROM ...</code>时，还可以给每一列起个别名，这样，结果集的列名就可以与原表的列名不同。它的语法是<code>SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM ...</code>。</p><p>例如，以下<code>SELECT</code>语句将列名<code>score</code>重命名为<code>points</code>，而<code>id</code>和<code>name</code>列名保持不变：</p><p><code>SELECT id, score points, name FROM students;</code></p><h4 id="排序">排序<a class="anchor" href="#排序">·</a></h4><p>查询结果集通常是按照<code>id</code>排序的，也就是根据主键排序。要根据其他条件排序——加上ORDER BY子句</p><p><strong>默认的排序规则</strong>是<code>ASC</code>：“<strong>升序</strong>”，即从小到大。ASC可以省略，即<code>ORDER BY score ASC和ORDER BY score</code>效果一样。</p><p>加上<code>DESC</code>表示“<strong>倒序</strong>”</p><p>如果score列有相同的数据，要进一步排序，可以继续添加列名。例如，使用<code>ORDER BY score DESC, gender</code>表示先按score列倒序，如果有相同分数的，再按gender列排序：</p><p>如果有<code>WHERE</code>子句，那么<code>ORDER BY</code>子句要放到WHERE子句后面。</p><h4 id="分页查询">分页查询<a class="anchor" href="#分页查询">·</a></h4><p>使用<code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code>可以对结果集进行分页，每次查询返回结果集的一部分；</p><p>offset—从第几条记录开始查</p><p>limit—最多显示多少条数据</p><p>分页查询需要先确定每页的数量和当前页数，然后确定LIMIT和OFFSET的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, name, gender, score</span><br><span class="line">FROM students</span><br><span class="line">ORDER BY score DESC</span><br><span class="line">LIMIT 3 OFFSET 0;</span><br></pre></td></tr></table></figure><h4 id="聚合查询">聚合查询<a class="anchor" href="#聚合查询">·</a></h4><p>对于统计总数、平均数这类计算，SQL提供了专门的聚合函数，使用聚合函数进行查询，就是聚合查询，它可以快速获得结果。</p><p><code>SELECT COUNT(*) FROM students;</code></p><p><code>COUNT(*)</code>表示查询所有列的行数，要注意聚合的计算结果虽然是一个数字，但查询的结果仍然是一个二维表，只是这个二维表只有一行一列，并且列名是<code>COUNT(*)</code>。通常，使用聚合查询时，我们应该给列名设置一个别名，便于处理结果：</p><p><code>SELECT COUNT(*) num FROM students;</code></p><p>聚合查询同样可以使用WHERE条件</p><p>除了COUNT()函数外，SQL还提供了如下聚合函数：</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">SUM</td><td style="text-align:left">计算某一列的合计值，该列必须为数值类型</td></tr><tr><td style="text-align:left">AVG</td><td style="text-align:left">计算某一列的平均值，该列必须为数值类型</td></tr><tr><td style="text-align:left">MAX</td><td style="text-align:left">计算某一列的最大值</td></tr><tr><td style="text-align:left">MIN</td><td style="text-align:left">计算某一列的最小值</td></tr></tbody></table><p>要特别注意：如果聚合查询的<code>WHERE</code>条件没有匹配到任何行，<code>COUNT()</code>会返回0，而<code>SUM()</code>、<code>AVG()</code>、<code>MAX()</code>和<code>MIN()</code>会返回<code>NULL</code>：</p><p>每页3条记录，如何通过聚合查询获得总页数？——<code>SELECT CEILING(COUNT(*) / 3) FROM students;</code></p><h5 id="分组">分组<a class="anchor" href="#分组">·</a></h5><p>按class_id分组: <code>SELECT COUNT(*) num FROM students GROUP BY class_id;</code></p><p><code>SELECT class_id, COUNT(*) num FROM students GROUP BY class_id;</code></p><p>请使用一条SELECT查询查出每个班级男生和女生的平均分：<code>SELECT class_id,gender,AVG(score) FROM students GROUP BY class_id,gender;</code></p><h4 id="多表查询">多表查询<a class="anchor" href="#多表查询">·</a></h4><p><code>SELECT * FROM &lt;表1&gt; &lt;表2&gt;</code></p><p>注意，多表查询时，要使用<code>表名.列名</code>这样的方式来引用列和设置别名，这样就避免了结果集的列名重复问题。但是，用<code>表名.列名</code>这种方式列举两个表的所有列实在是很麻烦，所以SQL还允许给表设置一个别名，让我们在投影查询中引用起来稍微简洁一点：</p><p><code>SELECT s.id sid, s.name, s.gender, s.score, c.id cid, c.name cname FROM students s, classes c;</code></p><p>注意到<code>FROM</code>子句给表设置别名的语法是<code>FROM &lt;表名1&gt; &lt;别名1&gt;, &lt;表名2&gt; &lt;别名2&gt;</code>。这样我们用别名<code>s</code>和<code>c</code>分别表示<code>students</code>表和<code>classes</code>表。</p><p>使用多表查询可以获取M x N行记录；</p><p>多表查询的结果集可能非常巨大，要小心使用。</p><h4 id="连接查询">连接查询<a class="anchor" href="#连接查询">·</a></h4><p>注意<strong>INNER JOIN</strong>查询的写法是：</p><ol><li>先确定主表，仍然使用<code>FROM &lt;表1&gt;</code>的语法；</li><li>再确定需要连接的表，使用<code>INNER JOIN &lt;表2&gt;</code>的语法；</li><li>然后确定连接条件，使用<code>ON &lt;条件...&gt;</code>，这里的条件是<code>s.class_id = c.id</code>，表示<code>students</code>表的<code>class_id</code>列与<code>classes</code>表的<code>id</code>列相同的行需要连接；</li><li>可选：加上<code>WHERE</code>子句、<code>ORDER BY</code>等子句。</li></ol><p>有<strong>RIGHT OUTER JOIN，就有LEFT OUTER JOIN，以及FULL OUTER JOIN</strong>。它们的区别是：</p><ul><li><p>INNER JOIN只返回同时存在于两张表的行数据，由于students表的class_id包含1，2，3，classes表的id包含1，2，3，4，所以，INNER JOIN根据条件s.class_id = c.id返回的结果集仅包含1，2，3。</p></li><li><p>RIGHT OUTER JOIN返回右表都存在的行。如果某一行仅在右表存在，那么结果集就会以NULL填充剩下的字段。</p></li><li><p>LEFT OUTER JOIN则返回左表都存在的行。如果我们给students表增加一行，并添加class_id=5，由于classes表并不存在id=5的行，所以，LEFT OUTER JOIN的结果会增加一行，对应的class_name是NULL：</p></li></ul><h4 id="查询数据方式小结">查询数据方式小结<a class="anchor" href="#查询数据方式小结">·</a></h4><p>代码形式总结知识点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT col1_name,col2_name,(COUNT(*),(AVG(col3_name)) average) #基本查询方式 聚合查询——聚合函数 投影查询</span><br><span class="line">FROM excel1_name replace1_name (,excel2_name replace2_name) #多表查询 同表名字替换</span><br><span class="line">INNER(&#x2F;FULL OUTER&#x2F;RIGHT OUTER&#x2F;LEFT OUTER)  JOIN classes c #连接查询</span><br><span class="line">(GROUP BY colx_name) #聚合查询——分组查询</span><br><span class="line">WHERE (EXPRESSION) #条件查询</span><br><span class="line">ORDER BY coly_name (ASC&#x2F;DESC) #排序</span><br><span class="line">LIMIT m OFFSET n; #分页查询</span><br></pre></td></tr></table></figure><h3 id="修改数据">修改数据<a class="anchor" href="#修改数据">·</a></h3><p>关系数据库的基本操作就是增删改查，即CRUD：Create、Retrieve、Update、Delete。</p><p>而对于增、删、改，对应的SQL语句分别是：</p><ul><li>INSERT：插入新记录；</li><li>UPDATE：更新已有记录；</li><li>DELETE：删除已有记录。</li></ul><h4 id="INSERT">INSERT<a class="anchor" href="#INSERT">·</a></h4><p><code>INSERT INTO &lt;表名&gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...);</code></p><p>注意到我们并没有列出<code>id</code>字段，也没有列出<code>id</code>字段对应的值，这是因为<code>id</code>字段是一个自增主键，它的值可以由数据库自己推算出来。此外，如果一个字段有默认值，那么在<code>INSERT</code>语句中也可以不出现。</p><p>还可以一次性添加多条记录，只需要在<code>VALUES</code>子句中指定多个记录值，每个记录是由<code>(...)</code>包含的一组值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO students (class_id, name, gender, score) VALUES</span><br><span class="line">  (1, &#39;大宝&#39;, &#39;M&#39;, 87),</span><br><span class="line">  (2, &#39;二宝&#39;, &#39;M&#39;, 81);</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure><h4 id="UPDATE">UPDATE<a class="anchor" href="#UPDATE">·</a></h4><p><code>UPDATE &lt;表名&gt; SET 字段1=值1, 字段2=值2, ... WHERE ...;</code></p><p>可以一次更新多条记录</p><h4 id="DELETE">DELETE<a class="anchor" href="#DELETE">·</a></h4><p><code>DELETE FROM &lt;表名&gt; WHERE ...;</code></p><p>不带<code>WHERE</code>条件的<code>DELETE</code>语句会删除整个表的数据</p><h3 id="MySQL">MySQL<a class="anchor" href="#MySQL">·</a></h3><p>查找MYSQL安装目录方法：进入mysql命令行输入：<code>show variables like &quot;%char%&quot;;</code></p><p>我的：C:\Program Files\MySQL\MySQL Server 8.0\bin</p><p><strong>加环境变量</strong>：我的计算机——属性——高级系统设置——环境变量——在用户变量和系统变量的path处加地址</p><p>打开命令提示符，输入命令<code>mysql -u root -p</code>，提示输入口令。填入MySQL的<code>root</code>口令，如果正确，就连上了MySQL Server，同时提示符变为<code>mysql&gt;</code>：</p><p>输入<code>exit</code>断开与MySQL Server的连接并返回到命令提示符。</p><p>MySQL Client的可执行程序是mysql，MySQL Server的可执行程序是mysqld。</p><p>MySQL Client和MySQL Server的关系如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──────────────┐  SQL   ┌──────────────┐</span><br><span class="line">│ MySQL Client │───────&gt;│ MySQL Server │</span><br><span class="line">└──────────────┘  TCP   └──────────────┘</span><br></pre></td></tr></table></figure><p>在MySQL Client中输入的SQL语句通过TCP连接发送到MySQL Server。默认端口号是3306，即如果发送到本机MySQL Server，地址就是<code>127.0.0.1:3306</code>。</p><p>也可以只安装MySQL Client，然后连接到远程MySQL Server。假设远程MySQL Server的IP地址是<code>10.0.1.99</code>，那么就使用<code>-h</code>指定IP或域名：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h <span class="number">10</span>.<span class="number">0</span>.<span class="number">1</span>.<span class="number">99</span> -u root -p</span><br></pre></td></tr></table></figure><h5 id="小结">小结<a class="anchor" href="#小结">·</a></h5><p>命令行程序<code>mysql</code>实际上是MySQL客户端，真正的MySQL服务器程序是<code>mysqld</code>，在后台运行。</p><h4 id="管理MySQL">管理MySQL<a class="anchor" href="#管理MySQL">·</a></h4><p>要管理MySQL，可以使用可视化图形界面MySQL Workbench。</p><p>MySQL Workbench可以用可视化的方式查询、创建和修改数据库表，但是，归根到底，MySQL Workbench是一个图形客户端，它对MySQL的操作仍然是发送SQL语句并执行。因此，本质上，MySQL Workbench和MySQL Client命令行都是客户端，和MySQL交互，唯一的接口就是SQL。</p><p>因此，MySQL提供了大量的SQL语句用于管理。虽然可以使用MySQL Workbench图形界面来直接管理MySQL，但是，很多时候，通过SSH远程连接时，只能使用SQL命令，所以，了解并掌握常用的SQL管理操作是必须的。</p><h5 id="1-数据库">1.数据库<a class="anchor" href="#1-数据库">·</a></h5><p>在一个运行MySQL的服务器上，实际上可以创建多个数据库（Database）。要列出所有数据库，使用命令：<code>SHOW DATABASES</code></p><p>其中，<code>information_schema</code>、<code>mysql</code>、<code>performance_schema</code>和<code>sys</code>是系统库，不要去改动它们。其他的是用户创建的数据库。</p><p>要<strong>创建</strong>一个新数据库，使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE test;</span><br></pre></td></tr></table></figure><p>要<strong>删除</strong>一个数据库，使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE test;</span><br></pre></td></tr></table></figure><p>注意：删除一个数据库将导致该数据库的所有表全部被删除。</p><p>对一个数据库进行操作时，要首先将其切换为当前数据库：<code>USE test;</code></p><h5 id="2-表">2.表<a class="anchor" href="#2-表">·</a></h5><p>列出当前数据库的所有表，使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure><p>要查看一个表的结构，使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC students;</span><br></pre></td></tr></table></figure><p>还可以使用以下命令查看创建表的SQL语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE TABLE students;</span><br></pre></td></tr></table></figure><p>创建表使用<code>CREATE TABLE</code>语句，而删除表使用<code>DROP TABLE</code>语句：</p><p>修改表就比较复杂。如果要给<code>students</code>表新增一列<code>birth</code>，使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students ADD COLUMN birth VARCHAR(10) NOT NULL;</span><br></pre></td></tr></table></figure><p>要修改<code>birth</code>列，例如把列名改为<code>birthday</code>，类型改为<code>VARCHAR(20)</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students CHANGE COLUMN birth birthday VARCHAR(20) NOT NULL;</span><br></pre></td></tr></table></figure><p>要删除列，使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students DROP COLUMN birthday;</span><br></pre></td></tr></table></figure><h5 id="3-退出MySQL">3.退出MySQL<a class="anchor" href="#3-退出MySQL">·</a></h5><p>使用<code>EXIT</code>命令退出MySQL</p><h4 id="实用SQL语句">实用SQL语句<a class="anchor" href="#实用SQL语句">·</a></h4><p>在编写SQL时，灵活运用一些技巧，可以大大简化程序逻辑。</p><h5 id="1-插入或替换">1.插入或替换<a class="anchor" href="#1-插入或替换">·</a></h5><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就先删除原记录，再插入新记录。此时，可以使用<code>REPLACE</code>语句，这样就不必先查询，再决定是否先删除再插入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLACE INTO students (id, class_id, name, gender, score) VALUES (1, 1, &#39;小明&#39;, &#39;F&#39;, 99);</span><br></pre></td></tr></table></figure><p>若<code>id=1</code>的记录不存在，<code>REPLACE</code>语句将插入新记录，否则，当前<code>id=1</code>的记录将被删除，然后再插入新记录。</p><h5 id="2-插入或更新">2.插入或更新<a class="anchor" href="#2-插入或更新">·</a></h5><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就更新该记录，此时，可以使用<code>INSERT INTO ... ON DUPLICATE KEY UPDATE ...</code>语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO students (id, class_id, name, gender, score) VALUES (1, 1, &#39;小明&#39;, &#39;F&#39;, 99) ON DUPLICATE KEY UPDATE name&#x3D;&#39;小明&#39;, gender&#x3D;&#39;F&#39;, score&#x3D;99;</span><br></pre></td></tr></table></figure><p>若<code>id=1</code>的记录不存在，<code>INSERT</code>语句将插入新记录，否则，当前<code>id=1</code>的记录将被更新，更新的字段由<code>UPDATE</code>指定。</p><h5 id="3-插入或忽略">3.插入或忽略<a class="anchor" href="#3-插入或忽略">·</a></h5><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就啥事也不干直接忽略，此时，可以使用<code>INSERT IGNORE INTO ...</code>语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT IGNORE INTO students (id, class_id, name, gender, score) VALUES (1, 1, &#39;小明&#39;, &#39;F&#39;, 99);</span><br></pre></td></tr></table></figure><p>若<code>id=1</code>的记录不存在，<code>INSERT</code>语句将插入新记录，否则，不执行任何操作。</p><h5 id="4-快照">4.快照<a class="anchor" href="#4-快照">·</a></h5><p>如果想要对一个表进行快照，即复制一份当前表的数据到一个新表，可以结合<code>CREATE TABLE</code>和<code>SELECT</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 对class_id&#x3D;1的记录进行快照，并存储为新表students_of_class1:</span><br><span class="line">CREATE TABLE students_of_class1 SELECT * FROM students WHERE class_id&#x3D;1;</span><br></pre></td></tr></table></figure><p>新创建的表结构和<code>SELECT</code>使用的表结构完全一致。</p><h5 id="5-写入查询结果集">5.写入查询结果集<a class="anchor" href="#5-写入查询结果集">·</a></h5><p>如果查询结果集需要写入到表中，可以结合<code>INSERT</code>和<code>SELECT</code>，将<code>SELECT</code>语句的结果集直接插入到指定表中。</p><p>例如，创建一个统计成绩的表<code>statistics</code>，记录各班的平均成绩：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE statistics (</span><br><span class="line">    id BIGINT NOT NULL AUTO_INCREMENT,</span><br><span class="line">    class_id BIGINT NOT NULL,</span><br><span class="line">    average DOUBLE NOT NULL,</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>然后，我们就可以用一条语句写入各班的平均成绩：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO statistics (class_id, average) SELECT class_id, AVG(score) FROM students GROUP BY class_id;</span><br></pre></td></tr></table></figure><p>确保<code>INSERT</code>语句的列和<code>SELECT</code>语句的列能一一对应，就可以在<code>statistics</code>表中直接保存查询的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT * FROM statistics;</span><br><span class="line">+----+----------+--------------+</span><br><span class="line">| id | class_id | average      |</span><br><span class="line">+----+----------+--------------+</span><br><span class="line">|  1 |        1 |         86.5 |</span><br><span class="line">|  2 |        2 | 73.666666666 |</span><br><span class="line">|  3 |        3 | 88.333333333 |</span><br><span class="line">+----+----------+--------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h5 id="6-强制使用指定索引">6.强制使用指定索引<a class="anchor" href="#6-强制使用指定索引">·</a></h5><p>在查询的时候，数据库系统会自动分析查询语句，并选择一个最合适的索引。但是很多时候，数据库系统的查询优化器并不一定总是能使用最优索引。如果我们知道如何选择索引，可以使用<code>FORCE INDEX</code>强制查询使用指定的索引。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT * FROM students FORCE INDEX (idx_class_id) WHERE class_id &#x3D; 1 ORDER BY id DESC;</span><br></pre></td></tr></table></figure><p>指定索引的前提是索引<code>idx_class_id</code>必须存在。</p><h2 id="Python3-MySQL-数据库连接-PyMySQL-驱动">Python3 MySQL 数据库连接 - PyMySQL 驱动<a class="anchor" href="#Python3-MySQL-数据库连接-PyMySQL-驱动">·</a></h2><p><code>$ pip3 install PyMySQL   </code></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计组笔记-P0-logisim状态机搭建</title>
      <link href="2021/01/29/CO-P0-logisim%E7%8A%B6%E6%80%81%E6%9C%BA%E6%90%AD%E5%BB%BA/"/>
      <url>2021/01/29/CO-P0-logisim%E7%8A%B6%E6%80%81%E6%9C%BA%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>北航计算机组成原理课程设计的Project0笔记，主要是关于logisim的使用和状态机的搭建。</p><a id="more"></a><h2 id="p0复习（logisim）">p0复习（logisim）<a class="anchor" href="#p0复习（logisim）">·</a></h2><h3 id="注意的点">注意的点<a class="anchor" href="#注意的点">·</a></h3><ul><li>输入信号一般是通过<strong>MUX，多路选择器</strong>来实现对输出结果的控制。</li><li>刚连接好电路时或者连接电路中，可能出现有一些线路<strong>莫名其妙是蓝色</strong>，这时<strong>关闭logisim后再次打开</strong>往往就好了。</li><li><strong>comparator</strong>器件默认是有符号的，要调成<strong>unsigned</strong>来避免出现无符号数比较出现错误。</li><li>一些<strong>Arithmetic</strong>模块器件使用时，由于<strong>上下两侧也有输出端</strong>，如果连在一起可能出现意外。</li><li>组合逻辑部分如果输入、输出的位数较少，可直接用<strong>combinational analysis</strong> 里的 <strong>table</strong> 傻瓜式生成电路。</li><li>出现“xxxx”或者“EEEE”往往是因为电路中有<strong>连错的电路</strong>，比如<strong>把输入当成输出元件连了；某条线没有连接在模块/元件的端口上，而是连在了空白区域</strong>。</li><li>出现“ ”、fewer than output we expected可能是时序问题，比如超出了题目给出的时间。或者期待输出非零值时输出了0。也有可能是<strong>appearance</strong>不对</li><li>DMX最好设置成 <strong>Three-state:Yes</strong>    <strong>Disabled output:Float</strong>  如果Three state勾选为yes，那么DMX输出端<strong>没有被选中的路径</strong>会<strong>保持</strong>原来的值不变</li></ul><h3 id="时序逻辑—状态机">时序逻辑—状态机<a class="anchor" href="#时序逻辑—状态机">·</a></h3><p><strong>参考文章</strong>：<a href="https://www.cnblogs.com/BUAA-YiFei/articles/13855136.html" target="_blank" rel="noopener">lyyf的logisim状态机博客</a></p><h4 id="注意">注意<a class="anchor" href="#注意">·</a></h4><ul><li><strong>状态转移、输出逻辑</strong>用<strong>真值表生成</strong>。</li><li>寄存器的Q端在<strong>时钟信号为0时</strong>的值为<strong>初态</strong>，时钟信号的<strong>上升沿</strong>更新为<strong>次态</strong>。</li><li><strong>Moore输出逻辑</strong>，只和<strong>当前状态</strong>有关。</li><li><strong>Mealy输出逻辑</strong>，除了<strong>当前状态</strong>，还必须和<strong>输入</strong>发生联系。</li><li>（<strong>当前状态值</strong>：时钟上升沿前是寄存器现有的值，上升沿时是状态转移模块的输出值s’）</li></ul><h4 id="Moore型">Moore型<a class="anchor" href="#Moore型">·</a></h4><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/moore.png" alt></p><h4 id="Mealy型">Mealy型<a class="anchor" href="#Mealy型">·</a></h4><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/mealy.png" alt></p><h4 id="同步复位">同步复位<a class="anchor" href="#同步复位">·</a></h4><p>具体来说就是用一个多路选择器，如果复位信号<strong>为0</strong>，则<strong>正常更新状态值</strong>，<strong>如果为1</strong>，就直接赋值给寄存器<strong>常量0</strong>。</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/%E5%90%8C%E6%AD%A5%E5%A4%8D%E4%BD%8D.png" alt></p><h4 id="异步复位">异步复位<a class="anchor" href="#异步复位">·</a></h4><p>直接使用寄存器自带的<strong>clear</strong>端口进行复位即可</p><p>王pb助教的logisim评测帖子：http://cscore.net.cn/courses/course-v1:Internal+B3I062410+2020_T1/discussion/forum/course/threads/5f8ab909cf9bcc0efe0000bd</p><h3 id="logisim命令行调试">logisim命令行调试<a class="anchor" href="#logisim命令行调试">·</a></h3><p>要用 jar 文件</p><p>我的电脑：java -jar logisim-generic-2.7.1.jar fsm.circ -tty table</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-CO-2020 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>廖雪峰git课程笔记</title>
      <link href="2021/01/29/git-liaoxuefeng-note/"/>
      <url>2021/01/29/git-liaoxuefeng-note/</url>
      
        <content type="html"><![CDATA[<p>关于廖雪峰git教程的一点笔记</p><a id="more"></a><h2 id="git教程（廖雪峰）笔记">git教程（廖雪峰）笔记<a class="anchor" href="#git教程（廖雪峰）笔记">·</a></h2><h3 id="1-git简介">1.git简介<a class="anchor" href="#1-git简介">·</a></h3><h4 id="git的诞生">git的诞生<a class="anchor" href="#git的诞生">·</a></h4><p>Git是目前世界上最先进的<strong>分布式版本控制系统</strong>（没有之一）。开发Linux系统时，Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！Git迅速成为最流行的分布式版本控制系统，尤其是2008年，<strong>GitHub</strong>网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。</p><h4 id="分布式vs集中式">分布式vs集中式<a class="anchor" href="#分布式vs集中式">·</a></h4><p>CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统</p><h5 id="集中式版本控制系统">集中式版本控制系统<a class="anchor" href="#集中式版本控制系统">·</a></h5><ul><li><p>版本库是<strong>集中存放在中央服务器的</strong>，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。</p></li><li><p>必须联网才能工作</p></li></ul><h5 id="分布式版本控制系统">分布式版本控制系统<a class="anchor" href="#分布式版本控制系统">·</a></h5><ul><li><p><strong>分布式版本控制系统根本没有“中央服务器”</strong>，<strong>每个人的电脑上都是一个完整的版本库</strong>，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p></li><li><p>不用联网，且分支管理功能强大</p></li></ul><h3 id="2-span-id-anzhuang-git的安装-span">2.<span id="anzhuang">git的安装</span><a class="anchor" href="#2-span-id-anzhuang-git的安装-span">·</a></h3><h4 id="在windows上安装">在windows上安装<a class="anchor" href="#在windows上安装">·</a></h4><p>从Git官网直接<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">下载安装程序</a>，然后按默认选项安装即可。安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p><p>安装完成后，还需要最后一步设置，在命令行输入：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name "Your Name"</span><br><span class="line">$ git config --global user.email "email@example.com"</span><br></pre></td></tr></table></figure><p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：<strong>你的名字和Email地址</strong>。不用担心别人会冒充，如果有也可以查询。</p><p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><h3 id="3-创建版本库">3.创建版本库<a class="anchor" href="#3-创建版本库">·</a></h3><p><strong>版本库</strong>：又名仓库，英文名<strong>repository</strong>，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p><h4 id="创建一个版本库">创建一个版本库<a class="anchor" href="#创建一个版本库">·</a></h4><p>首先，选择一个合适的地方，创建一个空目录：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> learngit</span><br><span class="line">$ <span class="built_in">cd</span> learngit</span><br><span class="line">$ pwd</span><br><span class="line">/Users/michael/learngit</span><br></pre></td></tr></table></figure><ul><li><p><code>pwd</code>命令用于<strong>显示当前目录</strong>。在我的Mac上，这个仓库位于<code>/Users/michael/learngit</code>。</p></li><li><p>如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。</p></li></ul><p>第二步，通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /Users/michael/learngit/.git/</span><br></pre></td></tr></table></figure><ul><li>如果你没有看到<code>.git</code>目录，那是因为这个目录默认是隐藏的，用<code>ls -ah</code>命令就可以看见。</li></ul><h4 id="把文件添加到版本库">把文件添加到版本库<a class="anchor" href="#把文件添加到版本库">·</a></h4><ul><li><p>所有的版本控制系统，其实只能跟踪<strong>文本文件的改动</strong>，比如<strong>TXT文件，网页，所有的程序代码</strong>等等，Git也不例外,图片、视频这些二进制文件，虽然也能由版本控制系统管理，但<strong>没法跟踪文件的变化</strong>,只能知道文件大小的变化。由于word文件是二进制文件，因此无法追踪。</p></li><li><p>建议使用标准的UTF-8编码。建议使用**Notepad++**而不是系统自带记事本</p></li><li><p>执行命令，没有任何显示，就对了，Unix的哲学是“没有消息就是好消息”，说明操作成功。</p></li></ul><h5 id="添加文件到Git仓库，分两步">添加文件到Git仓库，分两步<a class="anchor" href="#添加文件到Git仓库，分两步">·</a></h5><ol><li>使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</li><li>使用命令<code>git commit -m &lt;message&gt;</code>，完成。</li></ol><h3 id="4-版本管理">4.版本管理<a class="anchor" href="#4-版本管理">·</a></h3><ul><li>要随时掌握工作区的状态，使用<code>git status</code>命令。</li><li>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff &lt;file&gt;</code>可以查看修改内容。</li></ul><h4 id="span-id-moveback-版本回退-span"><span id="moveback">版本回退</span><a class="anchor" href="#span-id-moveback-版本回退-span">·</a></h4><ul><li><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</li></ul><p>上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，往上100个版本写成<code>HEAD~100</code>。</p><ul><li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li></ul><p><code>git log</code>命令显示从最近到最远的提交日志，如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数</p><ul><li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li></ul><h4 id="工作区和暂存区">工作区和暂存区<a class="anchor" href="#工作区和暂存区">·</a></h4><p><strong>工作区</strong>（Working Directory）就是你在电脑里能看到的目录</p><p><strong>版本库</strong>（Repository）:工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。Git的版本库里存了很多东西，其中最重要的就是称为<strong>stage（或者叫index）的暂存区</strong>，还有Git为我们<strong>自动创建的第一个分支</strong><code>master</code>，以及指向<code>master</code>的<strong>一个指针</strong>叫<code>HEAD</code>。</p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/1.png" style="zoom:67%;"><p>把文件往Git版本库里添加的时候，是分两步执行的：</p><p><strong>第一步</strong>是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p><p><strong>第二步</strong>是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p><p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p><h4 id="管理修改">管理修改<a class="anchor" href="#管理修改">·</a></h4><p>一个操作过程：第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code></p><p>Git管理的是修改，当你用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p><p>提交后，用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别：</p><h4 id="撤销修改">撤销修改<a class="anchor" href="#撤销修改">·</a></h4><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- &lt;file&gt;</code>。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a href="#moveback">版本回退</a>一节，不过前提是没有推送到远程库。</p><h4 id="删除文件">删除文件<a class="anchor" href="#删除文件">·</a></h4><p>命令<code>git rm &lt;file&gt;</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>。</p><h3 id="5-远程仓库">5.远程仓库<a class="anchor" href="#5-远程仓库">·</a></h3><p>自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置</p><h4 id="设置流程方法">设置流程方法<a class="anchor" href="#设置流程方法">·</a></h4><p>第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C "youremail@example.com"</span><br></pre></td></tr></table></figure><p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><p>第2步：登陆GitHub，鼠标移到右上角头像，点击“Settings”，进入“SSH and GPG keys”页面：</p><p>然后，点“New SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容：点“Add Key”，你就应该看到已经添加的Key。</p><h4 id="添加远程库">添加远程库<a class="anchor" href="#添加远程库">·</a></h4><p>创建一个新的Repository，在Repository name填入名字，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库</p><ul><li><p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</p></li><li><p>关联后，<strong>在需要提交的本地文件夹处的Git Bash</strong>使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p></li><li><p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p></li></ul><h4 id="从远程库克隆">从远程库克隆<a class="anchor" href="#从远程库克隆">·</a></h4><p>要克隆一个仓库，首先必须知道仓库的地址，然后使用</p><p><code>git clone git@github.com:michaelliao/gitskills.git</code> (这个例子是<code>ssh</code>）命令克隆。也可以用<code>https://github.com/michaelliao/gitskills.git</code>  （<code>michaelliao</code>替换成自己的用户名，后者改为自己的项目名字）</p><p>Git支持多种协议，包括<code>https</code>，但<code>ssh</code>协议速度最快。</p><h3 id="6-分支管理">6.分支管理<a class="anchor" href="#6-分支管理">·</a></h3><h4 id="创建与合并分支">创建与合并分支<a class="anchor" href="#创建与合并分支">·</a></h4><p>查看分支：<code>git branch</code></p><p>创建分支：<code>git branch &lt;name&gt;</code></p><p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code></p><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></p><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p><p>删除分支：<code>git branch -d &lt;name&gt;</code></p><h4 id="解决冲突">解决冲突<a class="anchor" href="#解决冲突">·</a></h4><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p><p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p><p>用<code>git log --graph</code>命令可以看到分支合并图。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure><h4 id="分支管理策略">分支管理策略<a class="anchor" href="#分支管理策略">·</a></h4><p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。不能记录下来合并的过程。如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><p><code>--no-ff</code>方式的<code>git merge</code>可以禁用<code>Fast forward</code>合并后，我们用<code>git log</code>看看分支历史：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m "merge with no-ff" dev</span><br><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure><h5 id="分支策略">分支策略<a class="anchor" href="#分支策略">·</a></h5><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p><ul><li><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p></li><li><p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p></li><li><p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p></li></ul><p>所以，团队合作的分支看起来如下图：</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/%E5%9B%A2%E9%98%9F%E5%90%88%E4%BD%9C%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86.png" alt></p><h4 id="Bug分支">Bug分支<a class="anchor" href="#Bug分支">·</a></h4><ul><li><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p></li><li><p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，工作区是干净的，刚才的工作现场存到哪去了？用<code>git stash list</code>命令看看，再<code>git stash pop</code>，回到工作现场；</p></li></ul><p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p><p>一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</p><p>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了：</p><ul><li>在master分支上修复的bug，想要合并到当前dev分支，可以用<code>git cherry-pick &lt;commit&gt;</code>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</li></ul><h4 id="Feature分支">Feature分支<a class="anchor" href="#Feature分支">·</a></h4><p>开发一个新feature，最好新建一个分支；</p><p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p><h4 id="多人协作">多人协作<a class="anchor" href="#多人协作">·</a></h4><ul><li><p>查看远程库信息，使用 <code>git remote</code> (简单信息)  <code>git remote -v</code>（详细信息）；</p></li><li><p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p></li><li><p>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</p><p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p><ul><li><code>master</code>分支是主分支，因此要时刻与远程同步；</li><li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li></ul><ul><li><p>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</p></li><li><p>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p></li></ul></li><li><p>当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的<code>master</code>分支。在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</p></li><li><p>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</p></li><li><p>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</p></li></ul><ul><li>多人协作工作模式</li></ul><ol><li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li></ol><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p><h4 id="Rebase">Rebase<a class="anchor" href="#Rebase">·</a></h4><ul><li>rebase操作可以把本地未push的分叉提交历史整理成直线；</li><li>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</li></ul><h3 id="7-标签管理">7.标签管理<a class="anchor" href="#7-标签管理">·</a></h3><h4 id="创建标签">创建标签<a class="anchor" href="#创建标签">·</a></h4><ul><li>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id；</li><li>命令<code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；<code>-m</code>后面是说明文字</li><li>命令<code>git tag</code>可以查看所有标签。</li></ul><ul><li>用命令<code>git show &lt;tagname&gt;</code>可以看到说明文字：</li></ul><h4 id="操作标签">操作标签<a class="anchor" href="#操作标签">·</a></h4><ul><li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</li><li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li><li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</li><li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</li></ul><h3 id="8-使用GitHub">8.使用GitHub<a class="anchor" href="#8-使用GitHub">·</a></h3><p>我们一直用GitHub作为免费的远程仓库，如果是个人的开源项目，放到GitHub上是完全没有问题的。其实GitHub还是一个开源协作社区，通过GitHub，既可以让别人参与你的开源项目，也可以参与别人的开源项目。</p><p>如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:michaelliao/bootstrap.git</span><br></pre></td></tr></table></figure><p>一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址<code>git@github.com:twbs/bootstrap.git</code>克隆，因为没有权限，你将不能推送修改。</p><p>Bootstrap的官方仓库<code>twbs/bootstrap</code>、你在GitHub上克隆的仓库<code>my/bootstrap</code>，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌─ GitHub ────────────────────────────────────┐</span><br><span class="line">│                                             │</span><br><span class="line">│ ┌─────────────────┐     ┌─────────────────┐ │</span><br><span class="line">│ │ twbs&#x2F;bootstrap  │────&gt;│  my&#x2F;bootstrap   │ │</span><br><span class="line">│ └─────────────────┘     └─────────────────┘ │</span><br><span class="line">│                                  ▲          │</span><br><span class="line">└──────────────────────────────────┼──────────┘</span><br><span class="line">                                   ▼</span><br><span class="line">                          ┌─────────────────┐</span><br><span class="line">                          │ local&#x2F;bootstrap │</span><br><span class="line">                          └─────────────────┘</span><br></pre></td></tr></table></figure><p>如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。</p><p>如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。</p><h5 id="小结-2">小结<a class="anchor" href="#小结-2">·</a></h5><ul><li>在GitHub上，可以任意Fork开源仓库；</li><li>自己拥有Fork后的仓库的读写权限；</li><li>可以推送pull request给官方仓库来贡献代码。</li></ul><h3 id="9-使用Gitee">9.使用Gitee<a class="anchor" href="#9-使用Gitee">·</a></h3><p>使用GitHub时，国内的用户经常遇到的问题是访问速度太慢，有时候还会出现无法连接的情况（原因你懂的）。</p><p>如果我们希望体验Git飞一般的速度，可以使用国内的Git托管服务——<a href="https://gitee.com/?utm_source=blog_lxf" target="_blank" rel="noopener">Gitee</a>（<a href="https://gitee.com/?utm_source=blog_lxf" target="_blank" rel="noopener">gitee.com</a>）。</p><p>和GitHub相比，Gitee也提供免费的Git仓库。此外，还集成了代码质量检测、项目演示等功能。对于团队协作开发，Gitee还提供了项目管理、代码托管、文档管理的服务，5人以下小团队免费。</p><p>Gitee的免费版本也提供私有库功能，只是有5人的成员上限。</p><p>使用Gitee和使用GitHub类似，我们在Gitee上注册账号并登录后，需要先上传自己的SSH公钥。选择右上角用户头像 -&gt; 菜单“修改资料”，然后选择“SSH公钥”，填写一个便于识别的标题，然后把用户主目录下的<code>.ssh/id_rsa.pub</code>文件的内容粘贴进去：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1163452910422880/l" alt="gitee-add-ssh-key"></p><p>点击“确定”即可完成并看到刚才添加的Key：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1163453163108928/l" alt="gitee-key"></p><p>如果我们已经有了一个本地的git仓库（例如，一个名为learngit的本地库），如何把它关联到Gitee的远程库上呢？</p><p>首先，我们在Gitee上创建一个新的项目，选择右上角用户头像 -&gt; 菜单“控制面板”，然后点击“创建项目”：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1163453517527296/l" alt="gitee-new-repo"></p><p>项目名称最好与本地库保持一致：</p><p>然后，我们在本地库上使用命令<code>git remote add</code>把它和Gitee的远程库关联：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@gitee.com:liaoxuefeng/learngit.git</span><br></pre></td></tr></table></figure><p>之后，就可以正常地用<code>git push</code>和<code>git pull</code>推送了！</p><p>如果在使用命令<code>git remote add</code>时报错：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@gitee.com:liaoxuefeng/learngit.git</span><br><span class="line"><span class="function">fatal: <span class="title">remote</span> <span class="title">origin</span> <span class="title">already</span> <span class="title">exists</span>.</span></span><br></pre></td></tr></table></figure><p>这说明本地库已经关联了一个名叫<code>origin</code>的远程库，此时，可以先用<code>git remote -v</code>查看远程库信息：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">origingit@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origingit@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure><p>可以看到，本地库已经关联了<code>origin</code>的远程库，并且，该远程库指向GitHub。</p><p>我们可以删除已有的GitHub远程库：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure><p>再关联Gitee的远程库（注意路径中需要填写正确的用户名）：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@gitee.com:liaoxuefeng/learngit.git</span><br></pre></td></tr></table></figure><p>此时，我们再查看远程库信息：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">origingit@gitee.com:liaoxuefeng/learngit.git (fetch)</span><br><span class="line">origingit@gitee.com:liaoxuefeng/learngit.git (push)</span><br></pre></td></tr></table></figure><p>现在可以看到，origin已经被关联到Gitee的远程库了。通过<code>git push</code>命令就可以把本地库推送到Gitee上。</p><p>有的小伙伴又要问了，一个本地库能不能既关联GitHub，又关联Gitee呢？</p><p>答案是肯定的，因为git本身是分布式版本控制系统，可以同步到另外一个远程库，当然也可以同步到另外两个远程库。</p><p>使用多个远程库时，我们要注意，git给远程库起的默认名称是<code>origin</code>，如果有多个远程库，我们需要用不同的名称来标识不同的远程库。</p><p>仍然以<code>learngit</code>本地库为例，我们先删除已关联的名为<code>origin</code>的远程库：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure><p>然后，先关联GitHub的远程库：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add github git@github.com:michaelliao/learngit.git</span><br></pre></td></tr></table></figure><p>注意，远程库的名称叫<code>github</code>，不叫<code>origin</code>了。</p><p>接着，再关联Gitee的远程库：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add gitee git@gitee.com:liaoxuefeng/learngit.git</span><br></pre></td></tr></table></figure><p>同样注意，远程库的名称叫<code>gitee</code>，不叫<code>origin</code>。</p><p>现在，我们用<code>git remote -v</code>查看远程库信息，可以看到两个远程库：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">giteegit@gitee.com:liaoxuefeng/learngit.git (fetch)</span><br><span class="line">giteegit@gitee.com:liaoxuefeng/learngit.git (push)</span><br><span class="line">githubgit@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">githubgit@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure><p>如果要推送到GitHub，使用命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push github master</span><br></pre></td></tr></table></figure><p>如果要推送到Gitee，使用命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push gitee master</span><br></pre></td></tr></table></figure><p>这样一来，我们的本地库就可以同时与多个远程库互相同步：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌─────────┐ ┌─────────┐</span><br><span class="line">│ GitHub  │ │  Gitee  │</span><br><span class="line">└─────────┘ └─────────┘</span><br><span class="line">     ▲           ▲</span><br><span class="line">     └─────┬─────┘</span><br><span class="line">           │</span><br><span class="line">    ┌─────────────┐</span><br><span class="line">    │ Local Repo  │</span><br><span class="line">    └─────────────┘</span><br></pre></td></tr></table></figure><p>Gitee也同样提供了Pull request功能，可以让其他小伙伴参与到开源项目中来。你可以通过Fork我的仓库：<a href="https://gitee.com/liaoxuefeng/learngit?utm_source=blog_lxf" target="_blank" rel="noopener">https://gitee.com/liaoxuefeng/learngit</a>，创建一个<code>your-gitee-id.txt</code>的文本文件， 写点自己学习Git的心得，然后推送一个pull request给我，这个仓库会在Gitee和GitHub做双向同步。</p><h3 id="10-自定义Git">10.自定义Git<a class="anchor" href="#10-自定义Git">·</a></h3><p>在<a href="#anzhuang">安装Git</a>一节中，我们已经配置了<code>user.name</code>和<code>user.email</code>，实际上，Git还有很多可配置项。</p><p>比如，让Git显示颜色，会让命令输出看起来更醒目：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global <span class="built_in">color</span>.ui true</span><br></pre></td></tr></table></figure><h4 id="忽略特殊文件">忽略特殊文件<a class="anchor" href="#忽略特殊文件">·</a></h4><p>有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次<code>git status</code>都会显示<code>Untracked files ...</code>，有强迫症的童鞋心里肯定不爽。</p><p>好在Git考虑到了大家的感受，这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的<code>.gitignore</code>文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p><p>不需要从头写<code>.gitignore</code>文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：https://github.com/github/gitignore</p><p>忽略文件的原则是：</p><ol><li>忽略操作系统自动生成的文件，比如缩略图等；</li><li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的<code>.class</code>文件；</li><li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li></ol><p>举个例子：</p><p>假设你在Windows下进行Python开发，Windows会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有<code>Desktop.ini</code>文件，因此你需要忽略Windows自动生成的垃圾文件：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Windows:</span><br><span class="line">Thumbs.db</span><br><span class="line">ehthumbs.db</span><br><span class="line">Desktop.ini</span><br></pre></td></tr></table></figure><p>然后，继续忽略Python编译产生的<code>.pyc</code>、<code>.pyo</code>、<code>dist</code>等文件或目录：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Python:</span><br><span class="line">*.py[cod]</span><br><span class="line">*.so</span><br><span class="line">*.egg</span><br><span class="line">*.egg-info</span><br><span class="line">dist</span><br><span class="line">build</span><br></pre></td></tr></table></figure><p>加上你自己定义的文件，最终得到一个完整的<code>.gitignore</code>文件，内容如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Windows:</span><br><span class="line">Thumbs.db</span><br><span class="line">ehthumbs.db</span><br><span class="line">Desktop.ini</span><br><span class="line"></span><br><span class="line"># Python:</span><br><span class="line">*.py[cod]</span><br><span class="line">*.so</span><br><span class="line">*.egg</span><br><span class="line">*.egg-info</span><br><span class="line">dist</span><br><span class="line">build</span><br><span class="line"></span><br><span class="line"># My configurations:</span><br><span class="line">db.ini</span><br><span class="line">deploy_key_rsa</span><br></pre></td></tr></table></figure><p>最后一步就是把<code>.gitignore</code>也提交到Git，就完成了！当然检验<code>.gitignore</code>的标准是<code>git status</code>命令是不是说<code>working directory clean</code>。</p><p>使用Windows的童鞋注意了，如果你在资源管理器里新建一个<code>.gitignore</code>文件，它会非常弱智地提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为<code>.gitignore</code>了。</p><p>有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被<code>.gitignore</code>忽略了：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add App.class</span><br><span class="line">The following paths are ignored by one of your .gitignore files:</span><br><span class="line">App.class</span><br><span class="line">Use -f <span class="keyword">if</span> you really want to add them.</span><br></pre></td></tr></table></figure><p>如果你确实想添加该文件，可以用<code>-f</code>强制添加到Git：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add -f App.class</span><br></pre></td></tr></table></figure><p>或者你发现，可能是<code>.gitignore</code>写得有问题，需要找出来到底哪个规则写错了，可以用<code>git check-ignore</code>命令检查：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git check-ignore -v App.class</span><br><span class="line"><span class="function">.gitignore:3:*.<span class="title">class</span><span class="title">App.class</span></span></span><br></pre></td></tr></table></figure><p>Git会告诉我们，<code>.gitignore</code>的第3行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。</p><h5 id="小结-3">小结<a class="anchor" href="#小结-3">·</a></h5><ul><li>忽略某些文件时，需要编写<code>.gitignore</code>；</li><li><code>.gitignore</code>文件本身要放到版本库里，并且可以对<code>.gitignore</code>做版本管理！</li></ul><h4 id="配置别名">配置别名<a class="anchor" href="#配置别名">·</a></h4><p>阅读: 8189585</p><hr><p>有没有经常敲错命令？比如<code>git status</code>？<code>status</code>这个单词真心不好记。</p><p>如果敲<code>git st</code>就表示<code>git status</code>那就简单多了，当然这种偷懒的办法我们是极力赞成的。</p><p>我们只需要敲一行命令，告诉Git，以后<code>st</code>就表示<code>status</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.st status</span><br></pre></td></tr></table></figure><p>好了，现在敲<code>git st</code>看看效果。</p><p>当然还有别的命令可以简写，很多人都用<code>co</code>表示<code>checkout</code>，<code>ci</code>表示<code>commit</code>，<code>br</code>表示<code>branch</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.co checkout</span><br><span class="line">$ git config --global alias.ci commit</span><br><span class="line">$ git config --global alias.br branch</span><br></pre></td></tr></table></figure><p>以后提交就可以简写成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git ci -m &quot;bala bala bala...&quot;</span><br></pre></td></tr></table></figure><p><code>--global</code>参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。</p><p>在<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897889638509536" target="_blank" rel="noopener">撤销修改</a>一节中，我们知道，命令<code>git reset HEAD file</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个<code>unstage</code>别名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.unstage &#39;reset HEAD&#39;</span><br></pre></td></tr></table></figure><p>当你敲入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git unstage test.py</span><br></pre></td></tr></table></figure><p>实际上Git执行的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD test.py</span><br></pre></td></tr></table></figure><p>配置一个<code>git last</code>，让其显示最后一次提交信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.last &#39;log -1&#39;</span><br></pre></td></tr></table></figure><p>这样，用<code>git last</code>就能显示最近一次的提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git last</span><br><span class="line">commit adca45d317e6d8a4b23f9811c3d7b7f0f180bfe2</span><br><span class="line">Merge: bd6ae48 291bea8</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Thu Aug 22 22:49:22 2013 +0800</span><br><span class="line"></span><br><span class="line">    merge &amp; fix hello.py</span><br></pre></td></tr></table></figure><p>甚至还有人丧心病狂地把<code>lg</code>配置成了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.lg &quot;log --color --graph --pretty&#x3D;format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;</span><br></pre></td></tr></table></figure><p>来看看<code>git lg</code>的效果：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919059728302912/0" alt="git-lg"></p><p>为什么不早点告诉我？别激动，咱不是为了多记几个英文单词嘛！</p><h5 id="配置文件">配置文件<a class="anchor" href="#配置文件">·</a></h5><p>配置Git的时候，加上<code>--global</code>是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。</p><p>配置文件放哪了？每个仓库的Git配置文件都放在<code>.git/config</code>文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git&#x2F;config </span><br><span class="line">[core]</span><br><span class="line">    repositoryformatversion &#x3D; 0</span><br><span class="line">    filemode &#x3D; true</span><br><span class="line">    bare &#x3D; false</span><br><span class="line">    logallrefupdates &#x3D; true</span><br><span class="line">    ignorecase &#x3D; true</span><br><span class="line">    precomposeunicode &#x3D; true</span><br><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">    url &#x3D; git@github.com:michaelliao&#x2F;learngit.git</span><br><span class="line">    fetch &#x3D; +refs&#x2F;heads&#x2F;*:refs&#x2F;remotes&#x2F;origin&#x2F;*</span><br><span class="line">[branch &quot;master&quot;]</span><br><span class="line">    remote &#x3D; origin</span><br><span class="line">    merge &#x3D; refs&#x2F;heads&#x2F;master</span><br><span class="line">[alias]</span><br><span class="line">    last &#x3D; log -1</span><br></pre></td></tr></table></figure><p>别名就在<code>[alias]</code>后面，要删除别名，直接把对应的行删掉即可。</p><p>而当前用户的Git配置文件放在用户主目录下的一个隐藏文件<code>.gitconfig</code>中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat .gitconfig</span><br><span class="line">[alias]</span><br><span class="line">    co &#x3D; checkout</span><br><span class="line">    ci &#x3D; commit</span><br><span class="line">    br &#x3D; branch</span><br><span class="line">    st &#x3D; status</span><br><span class="line">[user]</span><br><span class="line">    name &#x3D; Your Name</span><br><span class="line">    email &#x3D; your@email.com</span><br></pre></td></tr></table></figure><p>配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。</p><h5 id="小结-4">小结<a class="anchor" href="#小结-4">·</a></h5><p>给Git配置好别名，就可以输入命令时偷个懒。我们鼓励偷懒。</p><h4 id="搭建Git服务器">搭建Git服务器<a class="anchor" href="#搭建Git服务器">·</a></h4><p>阅读: 45444012</p><hr><p>在<a href="https://www.liaoxuefeng.com/wiki/896043488029600/896954117292416" target="_blank" rel="noopener">远程仓库</a>一节中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了7x24小时开机并交换大家的修改。</p><p>GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。</p><p>搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的<code>apt</code>命令就可以完成安装。</p><p>假设你已经有<code>sudo</code>权限的用户账号，下面，正式开始安装。</p><p>第一步，安装<code>git</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install git</span><br></pre></td></tr></table></figure><p>第二步，创建一个<code>git</code>用户，用来运行<code>git</code>服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo adduser git</span><br></pre></td></tr></table></figure><p>第三步，创建证书登录：</p><p>收集所有需要登录的用户的公钥，就是他们自己的<code>id_rsa.pub</code>文件，把所有公钥导入到<code>/home/git/.ssh/authorized_keys</code>文件里，一行一个。</p><p>第四步，初始化Git仓库：</p><p>先选定一个目录作为Git仓库，假定是<code>/srv/sample.git</code>，在<code>/srv</code>目录下输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo git init --bare sample.git</span><br></pre></td></tr></table></figure><p>Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以<code>.git</code>结尾。然后，把owner改为<code>git</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown -R git:git sample.git</span><br></pre></td></tr></table></figure><p>第五步，禁用shell登录：</p><p>出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑<code>/etc/passwd</code>文件完成。找到类似下面的一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:x:1001:1001:,,,:&#x2F;home&#x2F;git:&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:x:1001:1001:,,,:&#x2F;home&#x2F;git:&#x2F;usr&#x2F;bin&#x2F;git-shell</span><br></pre></td></tr></table></figure><p>这样，<code>git</code>用户可以正常通过ssh使用git，但无法登录shell，因为我们为<code>git</code>用户指定的<code>git-shell</code>每次一登录就自动退出。</p><p>第六步，克隆远程仓库：</p><p>现在，可以通过<code>git clone</code>命令克隆远程仓库了，在各自的电脑上运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@server:&#x2F;srv&#x2F;sample.git</span><br><span class="line">Cloning into &#39;sample&#39;...</span><br><span class="line">warning: You appear to have cloned an empty repository.</span><br></pre></td></tr></table></figure><p>剩下的推送就简单了。</p><h5 id="管理公钥">管理公钥<a class="anchor" href="#管理公钥">·</a></h5><p>如果团队很小，把每个人的公钥收集起来放到服务器的<code>/home/git/.ssh/authorized_keys</code>文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用<a href="https://github.com/res0nat0r/gitosis" target="_blank" rel="noopener">Gitosis</a>来管理公钥。</p><p>这里我们不介绍怎么玩<a href="https://github.com/res0nat0r/gitosis" target="_blank" rel="noopener">Gitosis</a>了，几百号人的团队基本都在500强了，相信找个高水平的Linux管理员问题不大。</p><h5 id="管理权限">管理权限<a class="anchor" href="#管理权限">·</a></h5><p>有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。<a href="https://github.com/sitaramc/gitolite" target="_blank" rel="noopener">Gitolite</a>就是这个工具。</p><p>这里我们也不介绍<a href="https://github.com/sitaramc/gitolite" target="_blank" rel="noopener">Gitolite</a>了，不要把有限的生命浪费到权限斗争中。</p><h5 id="小结-5">小结<a class="anchor" href="#小结-5">·</a></h5><ul><li>搭建Git服务器非常简单，通常10分钟即可完成；</li><li>要方便管理公钥，用<a href="https://github.com/res0nat0r/gitosis" target="_blank" rel="noopener">Gitosis</a>；</li><li>要像SVN那样变态地控制权限，用<a href="https://github.com/sitaramc/gitolite" target="_blank" rel="noopener">Gitolite</a>。</li></ul><h3 id="使用SourceTree">使用SourceTree<a class="anchor" href="#使用SourceTree">·</a></h3><p>当我们对Git的提交、分支已经非常熟悉，可以熟练使用命令操作Git后，再使用GUI工具，就可以更高效。</p><p>Git有很多图形界面工具，这里我们推荐<a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">SourceTree</a>，它是由<a href="https://www.atlassian.com/" target="_blank" rel="noopener">Atlassian</a>开发的免费Git图形界面工具，可以操作任何Git库。</p><p>首先从<a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">官网</a>下载SourceTree并安装，然后直接运行SourceTree。</p><p>第一次运行SourceTree时，SourceTree并不知道我们的Git库在哪。如果本地已经有了Git库，直接从资源管理器把文件夹拖拽到SourceTree上，就添加了一个本地Git库：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1317162822139970/l" alt="add-local-repo"></p><p>也可以选择“New”-“Clone from URL”直接从远程克隆到本地。</p><h4 id="提交">提交<a class="anchor" href="#提交">·</a></h4><p>我们双击<code>learngit</code>这个本地库，SourceTree会打开另一个窗口，展示这个Git库的当前所有分支以及文件状态。选择左侧面板的“WORKSPACE”-“File status”，右侧会列出当前已修改的文件（Unstaged files）：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1317163279319106/l" alt="unstaged"></p><p>选中某个文件，该文件就自动添加到“Staged files”，实际上是执行了<code>git add README.md</code>命令：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1317163629543489/l" alt="add"></p><p>然后，我们在下方输入Commit描述，点击“Commit”，就完成了一个本地提交：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1317163717623874/l" alt="commit"></p><p>实际上是执行了<code>git commit -m &quot;update README.md&quot;</code>命令。</p><p>使用SourceTree进行提交就是这么简单，它的优势在于可以可视化地观察文件的修改，并以红色和绿色高亮显示。</p><h4 id="分支">分支<a class="anchor" href="#分支">·</a></h4><p>在左侧面板的“BRANCHES”下，列出了当前本地库的所有分支。当前分支会加粗并用○标记。要切换分支，我们只需要选择该分支，例如<code>master</code>，然后点击右键，在弹出菜单中选择“Checkout master”，实际上是执行命令<code>git checkout master</code>：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1317164906709058/l" alt="checkout"></p><p>要合并分支，同样选择待合并分支，例如<code>dev</code>，然后点击右键，在弹出菜单中选择“Merge dev into master”，实际上是执行命令<code>git merge dev</code>：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1317165154172993/l" alt="merge-dev-into-master"></p><h4 id="推送">推送<a class="anchor" href="#推送">·</a></h4><p>在SourceTree的工具栏上，分别有<code>Pull</code>和<code>Push</code>，分别对应命令<code>git pull</code>和<code>git push</code>，只需注意本地和远程分支的名称要对应起来，使用时十分简单。</p><p>注意到使用SourceTree时，我们只是省下了敲命令的麻烦，SourceTree本身还是通过Git命令来执行任何操作。如果操作失败，SourceTree会自动显示执行的Git命令以及错误信息，我们可以通过Git返回的错误信息知道出错的原因：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1317166563459138/l" alt="push-error"></p><h3 id="小结-6">小结<a class="anchor" href="#小结-6">·</a></h3><p>使用SourceTree可以以图形界面操作Git，省去了敲命令的过程，对于常用的提交、分支、推送等操作来说非常方便。</p><p>SourceTree使用Git命令执行操作，出错时，仍然需要阅读Git命令返回的错误信息。</p><p>终于到了期末总结的时刻了！</p><p>经过几天的学习，相信你对Git已经初步掌握。一开始，可能觉得Git上手比较困难，尤其是已经熟悉SVN的童鞋，没关系，多操练几次，就会越用越顺手。</p><p>Git虽然极其强大，命令繁多，但常用的就那么十来个，掌握好这十几个常用命令，你已经可以得心应手地使用Git了。</p><p>友情附赠国外网友制作的Git Cheat Sheet，建议打印出来备用：</p><p><a href="https://gitee.com/liaoxuefeng/learn-java/raw/master/teach/git-cheatsheet.pdf" target="_blank" rel="noopener">Git Cheat Sheet</a></p><p>现在告诉你Git的官方网站：<a href="http://git-scm.com/" target="_blank" rel="noopener">http://git-scm.com</a>，英文自我感觉不错的童鞋，可以经常去官网看看。什么，打不开网站？相信我，我给出的绝对是官网地址，而且，Git官网决没有那么容易宕机，可能是你的人品问题，赶紧面壁思过，好好想想原因。</p><p>如果你学了Git后，工作效率大增，有更多的空闲时间健身看电影，那我的教学目标就达到了。</p><p>谢谢观看！</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git家族 </tag>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello,My personal Blog!个人博客搭建总结</title>
      <link href="2021/01/29/hello-myblog/"/>
      <url>2021/01/29/hello-myblog/</url>
      
        <content type="html"><![CDATA[<p>经过了好几天的摸索，终于大概部署好了个人博客，之后会把所学的一些CS知识技术整理成笔记记录在这里，欢迎大家时不时来踩一踩！</p><p>这篇博客主要是关于个人博客搭建和更新方法的笔记，怕之后忘了所以赶紧记一下。目前博客仅仅是实现了基本功能，之后可能会视情况设置一下评论区，点赞，社交等功能。</p><a id="more"></a><h3 id="个人博客搭建总结">个人博客搭建总结<a class="anchor" href="#个人博客搭建总结">·</a></h3><h4 id="Jekyll">Jekyll<a class="anchor" href="#Jekyll">·</a></h4><p>这段时间为了搭建一下自己的博客尝试了两种方式，一种是基于<code>Jekyll</code>的，这种方式比较简单，但是有时过于简单了，之前试过用一个cayman的主题，但由于本人太菜，这个模板需要配置太多，只好放弃了，改用hexo搭建。如果想用<code>Jekyll</code>的可以参考这个网站：http://jekyllcn.com/ ，此站目标是<strong>成为 Jekyll 的全面指南</strong>，内容详细，值得看一看。</p><h4 id="hexo搭建大致流程">hexo搭建大致流程<a class="anchor" href="#hexo搭建大致流程">·</a></h4><p>大致参考了以下几篇博客</p><p>https://blog.csdn.net/jinxiaonian11/article/details/82900119（这个作者有两篇这方面的博客，讲的挺详细的）</p><p>https://blog.csdn.net/qq_37210523/article/details/80909983</p><ol><li><p>选好一个空文件夹，最好不要有中文路径，之后用bash cd到这个路径下，继续下面的操作。</p></li><li><p>安装配置好node.js（node.js下载地址：https://nodejs.org/en/download/），hexo (<code>npm install hexo -g</code>)。</p><p>npm安装hexo时可能会出问题，更换一下镜像就好了。（如：<code>npm config set registry http://registry.npm.taobao.org</code></p></li><li><p>安装必要的组件：<code>npm install</code>，之后输入处理命令 <code>hexo g</code>   并开启服务器<code>hexo s</code> 出现了能够打开本地网页的提示（这个打开和那个线上的是一样的效果）就说明已经成功了，之后<code>ctrl+C</code>退出继续下面步骤</p></li><li><p>在github上新增仓库，命名为: username.github.io，并在本地的根目录下的 _config.yml 文件中的<strong>Deployment</strong>设置处，添加以下代码，<strong>repo</strong>和<strong>branch</strong>根据自己情况修改</p></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:BUAADreamer/BUAADreamer.github.io.git</span> </span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><ol start="5"><li><p>之后选好主题，并利用作者提供的方式git clone到本地theme文件夹下即可，并在根目录下的)_config.yml改一下theme设置，很多人推荐next，我的这个用的是ocean，也看到有同学用的黄玄大神的https://huangxuan.me/</p><p>然后创建博客：<code>hexo new blog-name</code>，之后一行代码部署到github上即可：<code>hexo d -g</code>，再打开自己的网站：username.github.io即可看到了！</p></li><li><p>后续配置，这个每个主题都有区别，去github上看作者的文档就行。可以添加很多功能。下面记录一下常用的几个tips和资源</p><ul><li><p>修改文章：直接修改之后用hexo d- g就可以完成push的操作。</p></li><li><p>设置摘要：使用<code>&lt;!--more--&gt;</code>标签设置摘要。这样在index页只会展示这行代码之前的文字</p></li><li><p>hexo官方中文文档：https://hexo.io/zh-cn/docs/</p></li></ul></li></ol><h4 id="问题和个人用法总结">问题和个人用法总结<a class="anchor" href="#问题和个人用法总结">·</a></h4><ol><li>图片用的腾讯云对象存储</li><li>md文件配置时一定是类似<code>tags: 123</code>这样的格式。<code>tags</code>和<code>123</code>之间<strong>一定要有空格</strong>！！！</li></ol><h4 id="评论功能">评论功能<a class="anchor" href="#评论功能">·</a></h4><p>我的博客使用的<code>Utterances</code>，配置非常简单，并且也比较安全简洁。</p><p>可以参考这篇文章：https://roife.github.io/2021/02/12/use-utterances-for-comment/</p><p>其他的还有<code>Gitalk</code>,<code>Valine</code>，也可以用，但是<code>Gitalk</code>配置麻烦且很容易挂，后者貌似需要花钱。</p><h4 id="更换代理">更换代理<a class="anchor" href="#更换代理">·</a></h4><p>同时参考下面这<strong>两篇</strong>文章，因为都有些不全面。记得要实名认证+获取证书+域名解析</p><p>https://blog.csdn.net/obsession753/article/details/84110360</p><p>https://blog.csdn.net/i042416/article/details/89926005</p><h4 id="2021-4-24">2021.4.24<a class="anchor" href="#2021-4-24">·</a></h4><p>更换了主题，换成了感觉更美观的huxblog主题</p><p>更换过程很简单，只需要到https://github.com/Kaijun/hexo-theme-huxblog 这个网站下载代码，之后将themes里的huxblog文件夹copy到你自己的themes目录下，然后在根目录下的_config.xml修改themes名字为huxblog即可。</p><h4 id="2021-4-25">2021.4.25<a class="anchor" href="#2021-4-25">·</a></h4><p>调换过程很简单，但是由于hexo版的黄玄主题作者已经不维护了，出现了各式各样的问题，于是决定换成长得差不多的snail主题，这个主题作者给了详细的说明文档。https://github.com/dusign/hexo-theme-snail</p><h4 id="2021-6-3-图片配置">2021.6.3 图片配置<a class="anchor" href="#2021-6-3-图片配置">·</a></h4><p>以下内容搬运自：https://blog.csdn.net/qq_36408085/article/details/104117319</p><p>修改 hexo 目录下的 .config.yml 文件，将 post_asset_folder: false 修改为 post_asset_folder: true。</p><p>安装一个图片路径转换的插件。在hexo文件夹下打开 Git bush。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/7ym0n/hexo-asset-image --save  <span class="comment">#注意，不是官方的那个！！！</span></span><br></pre></td></tr></table></figure><p>这样就可以让本地和远程显示一样了！就正常使用绝对或相对路径插入图片代码即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](文章名/1.png)</span><br></pre></td></tr></table></figure><p><strong>注意</strong>： 这是经过修改的插件代码，网上流传的另一份代码 npm install https://github.com/CodeFalling/hexo-asset-image --save 并不能使用。</p><p>如果你之前安装了这个错误的插件，请将 /node_modules/hexo-asset-image/index.js这个文件替换成下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="built_in">String</span>(hexo.version).split(<span class="string">'.'</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">'after_post_render'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> config = hexo.config;</span><br><span class="line"><span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">    <span class="keyword">var</span> link = data.permalink;</span><br><span class="line"><span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">'/'</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">'/'</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html".</span></span><br><span class="line"><span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>;</span><br><span class="line">link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> toprocess = [<span class="string">'excerpt'</span>, <span class="string">'more'</span>, <span class="string">'content'</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">    ignoreWhitespace: <span class="literal">false</span>,</span><br><span class="line">    xmlMode: <span class="literal">false</span>,</span><br><span class="line">    lowerCaseTags: <span class="literal">false</span>,</span><br><span class="line">    decodeEntities: <span class="literal">false</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    $(<span class="string">'img'</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ($(<span class="keyword">this</span>).attr(<span class="string">'src'</span>))&#123;</span><br><span class="line">        <span class="comment">// For windows style path, we replace '\' to '/'.</span></span><br><span class="line">        <span class="keyword">var</span> src = $(<span class="keyword">this</span>).attr(<span class="string">'src'</span>).replace(<span class="string">'\\'</span>, <span class="string">'/'</span>);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;</span><br><span class="line">            !<span class="regexp">/^\s*\//</span>.test(src)) &#123;</span><br><span class="line">            <span class="comment">// For "about" page, the first part of "src" can't be removed.</span></span><br><span class="line">            <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">            <span class="keyword">var</span> linkArray = link.split(<span class="string">'/'</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> elem != <span class="string">''</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">var</span> srcArray = src.split(<span class="string">'/'</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> elem != <span class="string">''</span> &amp;&amp; elem != <span class="string">'.'</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">            srcArray.shift();</span><br><span class="line">            src = srcArray.join(<span class="string">'/'</span>);</span><br><span class="line">            $(<span class="keyword">this</span>).attr(<span class="string">'src'</span>, config.root + link + src);</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">"update link as:--&gt;"</span>+config.root + link + src);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">"no src attr, skipped..."</span>);</span><br><span class="line">        <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    data[key] = $.html();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="2022-4-24-增加一些渲染-包括todo清单">2022.4.24 增加一些渲染 包括todo清单<a class="anchor" href="#2022-4-24-增加一些渲染-包括todo清单">·</a></h4><p>使用这个仓库：https://github.com/hexojs/hexo-renderer-marked</p><p>发现图片居然和todo不能同时渲染</p><p>换用：https://blog.bugimg.com/works/hexo-renderer-markdown-it_and_plugins_config.html</p><h4 id="2024-1-14-修复目录跳转问题">2024.1.14 修复目录跳转问题<a class="anchor" href="#2024-1-14-修复目录跳转问题">·</a></h4><p>原因：toc插件与hexo自带的toc函数有冲突，不能同时使用。</p><p>解决方法：如果使用已经支持目录的主题，卸载掉toc插件即可。执行以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm remove hexo-toc --save</span><br><span class="line">hexo cl #清除缓存</span><br></pre></td></tr></table></figure><h4 id="2024-1-15-修复公式渲染问题（Nunjucks-Error-expected-variable-end）">2024.1.15 修复公式渲染问题（Nunjucks Error expected variable end）<a class="anchor" href="#2024-1-15-修复公式渲染问题（Nunjucks-Error-expected-variable-end）">·</a></h4><p>官网说明是如下问题：即对有两个大括号包起来的内容会产生渲染问题，需要特殊处理。latex可以直接改成其他表达形式</p><img src="/2021/01/29/hello-myblog/2020070122580072.png" alt="2020070122580072" style="zoom:50%;">]]></content>
      
      
      
        <tags>
            
            <tag> hello my blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
