<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OO-Unit3-总结</title>
      <link href="2021/05/31/OO-Unit3-%E5%B0%8F%E7%BB%93/"/>
      <url>2021/05/31/OO-Unit3-%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>OO第三单元JML规格设计学习总结与分析</p><h1 id="OO-Unit3-总结"><a href="#OO-Unit3-总结" class="headerlink" title="OO-Unit3-总结"></a>OO-Unit3-总结</h1><h2 id="1-JML规格设计策略"><a href="#1-JML规格设计策略" class="headerlink" title="1.JML规格设计策略"></a>1.JML规格设计策略</h2><p>由于JML的规格描述较复杂，本单元的JML规格设计我往往采用<strong>由简入难</strong>的<strong>迭代开发</strong>策略。</p><p>即一开始不着急开发出最为复杂，性能最好的代码，先<strong>严格按照JML</strong>描述写一遍代码，<strong>实现基本功能</strong>。比如类似<code>public instance model non_null Person[] acquaintance;</code>这样的规格，第9次作业开始时先直接按照<code>ArrayList</code>处理，这样各个函数中实际的代码和JML描述近乎一致，<strong>方便检查</strong>。之后在完成了基本功能后，在已经理解了基本功能描述后，对各个容器和方法算法性能进行<strong>优化设计迭代</strong>。</p><p>同时，一般简单的方法和容器设计虽然性能较差，但正确性一般较好，因此个人认为也可以作为之后的迭代优化版本的<strong>正确性测试参考的标程</strong>（不过实际开发过程中也不可能先开发一版低性能保证正确性，所以还是直接全盘考虑好再写高效一点）。</p><p>对于每个方法而言。先确定<code>normal_behavior</code>和<code>exceptional_behavior</code>。确定进入函数后不同参数对应的<strong>分支条件</strong>。并把<strong>条件判断语句</strong>写好，搭好基本框架。之后再看<code>assignable</code>会涉及到的变量。再根据<code>ensures</code>确定<strong>结果返回值</strong>和应该如何<strong>改动变量</strong>。对于异常处理里的分支逻辑也是类似的编写方式。此外，每个方法编写时也可以通过函数名字推敲涵义，从而提高正确性。</p><p>同时对于迭代增量开发，每次都要重新阅读<strong>之前实现过的方法内的JML规格</strong>，因为可能会发生变化，比如第二次到第三次作业中的<code>sendMessage</code>方法。此外要特别注意<strong>JML没写出</strong>，但是你<strong>需要实现</strong>的代码，比如<code>MyGroup内的delPerson方法</code>，如果输入的<code>person</code>是个<code>null</code>需要直接返回；<code>MyPerson</code>类内需要加一个<code>addAcquaitance</code>方法以及<code>getAcquaitance</code>方法等。</p><h2 id="2-JML测试方法和策略"><a href="#2-JML测试方法和策略" class="headerlink" title="2.JML测试方法和策略"></a>2.JML测试方法和策略</h2><p>本单元的JML规格设计由于JML细节较多，很难保证某一份代码是完全正确的，因此测试上最方便最简单的当然就是<strong>多人对拍找少数派</strong>（即<del>多人运动</del>）的方式了。这个方法在<strong>第一单元</strong>中也用到过，总结来说，对于这种<strong>输入一样</strong>，<strong>输出结果</strong>就应该一样的代码，这种方式测试效率还是很高的。此外，还有Junit单元测试，以及openJML等其他JML工具。</p><h3 id="Junit单元测试"><a href="#Junit单元测试" class="headerlink" title="Junit单元测试"></a>Junit单元测试</h3><p>Junit测试简单，可以进行对类内每个方法编写自己的测试逻辑。IDEA里最简单的使用方式就是<code>右键点击代码里的类名--&gt;点击Go to--&gt;点击Test</code>，选择<strong>需要测试的函数</strong>和<strong>选项</strong>，就生成了<strong>测试文件</strong>。</p><p>本单元中主要针对一些比较容易出现错误的方法比如<code>isCircle</code>和<code>queryBlockSum</code>进行了测试，以这两个函数为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.oocourse.spec3.exceptions.PersonIdNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.assertEquals;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.assertFalse;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.assertTrue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNetworkTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyPerson pa = <span class="keyword">new</span> MyPerson(<span class="number">1</span>, <span class="string">"a"</span>, <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyPerson pb = <span class="keyword">new</span> MyPerson(<span class="number">2</span>, <span class="string">"b"</span>, <span class="number">13</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyPerson pc = <span class="keyword">new</span> MyPerson(<span class="number">3</span>, <span class="string">"c"</span>, <span class="number">14</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyPerson pd = <span class="keyword">new</span> MyPerson(<span class="number">4</span>, <span class="string">"d"</span>, <span class="number">15</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyPerson pe = <span class="keyword">new</span> MyPerson(<span class="number">5</span>, <span class="string">"e"</span>, <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MyPerson pf = <span class="keyword">new</span> MyPerson(<span class="number">6</span>, <span class="string">"f"</span>, <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">private</span> MyNetwork net = <span class="keyword">new</span> MyNetwork();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        net.addPerson(pa);</span><br><span class="line">        net.addPerson(pb);</span><br><span class="line">        net.addPerson(pc);</span><br><span class="line">        net.addPerson(pd);</span><br><span class="line">        net.addPerson(pe);</span><br><span class="line">        net.addPerson(pf);</span><br><span class="line">        net.addRelation(<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">        net.addRelation(<span class="number">1</span>, <span class="number">3</span>, <span class="number">20</span>);</span><br><span class="line">        net.addRelation(<span class="number">3</span>, <span class="number">4</span>, <span class="number">10</span>);</span><br><span class="line">        net.addRelation(<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">        net.addRelation(<span class="number">3</span>, <span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">isCircle</span><span class="params">()</span> <span class="keyword">throws</span> PersonIdNotFoundException </span>&#123;</span><br><span class="line">        assertTrue(net.isCircle(<span class="number">1</span>, <span class="number">4</span>));</span><br><span class="line">        assertFalse(net.isCircle(<span class="number">1</span>, <span class="number">6</span>));</span><br><span class="line">        assertTrue(net.isCircle(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">queryBlockSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(<span class="number">2</span>, net.queryBlockSum());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后就会出现<strong>令人舒适</strong>的评测信息，这样的单元测试，怎能不爱😍。</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit3/8.png" style="zoom:80%;"></p><p>一般来说就在<code>BeforeEach</code>和<code>AfterEach</code>里分别编写数据构造和初始化以及其他的评测信息。但是注意到这样的测试方式是对于每个<code>@Test</code>处的函数都分别调用了一次测试，即每个这样的函数对应一个点。这样有时体现不出一个类整体连续性，比如某几个方法之间的联系。参考官网写出了连续的测试方式，相当于所有方法在一次程序执行内跑完。</p><p>同时，Junit实在太强大，几乎可以测试所有的情况，比如空指针，异常抛出等，用以下代码举例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nested</span></span><br><span class="line">  <span class="meta">@DisplayName</span>(<span class="string">"when new"</span>)</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">WhenNew</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> MyPerson pa = <span class="keyword">new</span> MyPerson(<span class="number">1</span>, <span class="string">"a"</span>, <span class="number">12</span>);</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> MyPerson pb = <span class="keyword">new</span> MyPerson(<span class="number">2</span>, <span class="string">"b"</span>, <span class="number">13</span>);</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> MyPerson pc = <span class="keyword">new</span> MyPerson(<span class="number">3</span>, <span class="string">"c"</span>, <span class="number">14</span>);</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> MyPerson pd = <span class="keyword">new</span> MyPerson(<span class="number">4</span>, <span class="string">"d"</span>, <span class="number">15</span>);</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> MyPerson pe = <span class="keyword">new</span> MyPerson(<span class="number">5</span>, <span class="string">"e"</span>, <span class="number">16</span>);</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> MyPerson pf = <span class="keyword">new</span> MyPerson(<span class="number">6</span>, <span class="string">"f"</span>, <span class="number">16</span>);</span><br><span class="line">      <span class="keyword">private</span> MyNetwork net = <span class="keyword">new</span> MyNetwork();</span><br><span class="line"></span><br><span class="line">      <span class="meta">@BeforeEach</span></span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">createNewNetwork</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">          net = <span class="keyword">new</span> MyNetwork();</span><br><span class="line">          net.addPerson(pa);</span><br><span class="line">          net.addPerson(pb);</span><br><span class="line">          net.addPerson(pc);</span><br><span class="line">          net.addPerson(pd);</span><br><span class="line">          net.addPerson(pe);</span><br><span class="line">          net.addPerson(pf);</span><br><span class="line">          net.addRelation(<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">          net.addRelation(<span class="number">1</span>, <span class="number">3</span>, <span class="number">20</span>);</span><br><span class="line">          net.addRelation(<span class="number">3</span>, <span class="number">4</span>, <span class="number">10</span>);</span><br><span class="line">          net.addRelation(<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">          net.addRelation(<span class="number">3</span>, <span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Test</span></span><br><span class="line">      <span class="meta">@DisplayName</span>(<span class="string">"throws MyPersonIdNotFoundException when query a unexist id"</span>)</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">throwsMyPersonIdNotFoundException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          assertThrows(MyPersonIdNotFoundException<span class="class">.<span class="keyword">class</span>, () -&gt; <span class="title">net</span>.<span class="title">addRelation</span>(1, 7, 10))</span>; <span class="comment">//这里的()-&gt;是个啥实在没理解，但是加上就可以这么测试了</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Nested</span></span><br><span class="line">      <span class="meta">@DisplayName</span>(<span class="string">"after init"</span>)</span><br><span class="line">      <span class="class"><span class="keyword">class</span> <span class="title">AfterInit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Test</span></span><br><span class="line">          <span class="meta">@DisplayName</span>(<span class="string">"contains"</span>)</span><br><span class="line">          <span class="function"><span class="keyword">void</span> <span class="title">containsTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              assertTrue(net.contains(<span class="number">4</span>));</span><br><span class="line">              assertFalse(net.contains(<span class="number">10</span>));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Test</span></span><br><span class="line">          <span class="meta">@DisplayName</span>(<span class="string">"qps test"</span>)</span><br><span class="line">          <span class="function"><span class="keyword">void</span> <span class="title">queryPeopleSumTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              assertEquals(<span class="number">6</span>, net.queryPeopleSum());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="Python对拍评测"><a href="#Python对拍评测" class="headerlink" title="Python对拍评测"></a>Python对拍评测</h3><p>与第一单元类似，主要分为<strong>双人对拍</strong>和<strong>多人运动</strong>。本次作业单独写了两个文件。<code>relation_testdata</code>产生测试数据。<code>relationTest</code>进行对拍测试。</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit3/2.png" alt></p><p>测试数据产生主要分为<strong>随机生成用例</strong>和生成复杂的<strong>卡时间的用例</strong>。具体的生成的方式都封装在<code>getOneTestPoint()</code>方法中。根据<strong>作业次数</strong>和<strong>数据特点变量</strong>生成相应用例。其中随机生成用例要保证一定的强度，比如每个测试点都是5000条指令，保证每个测试点覆盖了所有的指令（对每个指令的个数进行计数）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">datas_src = <span class="string">"test_data/"</span></span><br><span class="line">n = <span class="number">100</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        src = datas_src + <span class="string">"%d.txt"</span> % (i + <span class="number">1</span>)</span><br><span class="line">        writeToFile(getOneTestPoint(), src)</span><br></pre></td></tr></table></figure><p>对拍测试中先进行<strong>多人团建</strong>。挨个检查所有每个文件对测试点的CPU使用时间测试性能。之后再通过比对所有人的答案检验正确性。如果大家答案均一样且没有人超时，则认为所有人正确。这里使用的是<code>test</code>函数，对输入的一个<code>jar</code>文件名字列表进行处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    nameList = [<span class="string">'Archer.jar'</span>, <span class="string">'Saber.jar'</span>, <span class="string">'Rider.jar'</span>, <span class="string">'Caster.jar'</span>, <span class="string">'Berserker.jar'</span>, <span class="string">'Assassin.jar'</span>]</span><br><span class="line">    test(nameList)</span><br></pre></td></tr></table></figure><p>效果如下</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit3/3.png" style="zoom:80%;"></p><p>在一波多人运动后，一般会发现团队中有个别成员（比如自己的代码）存在一定的问题，这时就可以选择<code>1-2</code>个优秀的成员作为<strong>标程</strong>和其他代码进行对拍。使用<code>beatTest</code>函数进行<strong>重点爆破</strong>，提高寻找<code>bug</code>的效率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beatTest(<span class="string">'homework11.jar'</span>, <span class="string">'Berserker.jar'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit3/6.png" style="zoom:80%;"></p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit3/7.png" style="zoom:80%;"></p><p>总的来说，1、3单元对多人的代码进行测试的方式比较可取的就是每个人单独跑数据看时间，使用多人对拍评价正确性。</p><h3 id="openJML工具使用"><a href="#openJML工具使用" class="headerlink" title="openJML工具使用"></a>openJML工具使用</h3><p>代码静态检查命令如下，感觉输出好奇怪，调了半天也没调好，只好放弃了。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java <span class="literal">-jar</span> .\openjml.jar <span class="literal">-exec</span> (SMT Solvers的路径) .\Solvers<span class="literal">-windows</span>\z3<span class="literal">-4</span>.<span class="number">7.1</span>.exe <span class="literal">-esc</span> <span class="literal">-dir</span> (项目目录)</span><br><span class="line">java <span class="literal">-jar</span> .\openjml.jar <span class="literal">-exec</span> .\Solvers<span class="literal">-windows</span>\z3<span class="literal">-4</span>.<span class="number">7.1</span>.exe <span class="literal">-esc</span> <span class="literal">-dir</span> ..\test_src\Archer\src\</span><br><span class="line">java <span class="literal">-jar</span> openjml.jar <span class="literal">-esc</span> <span class="literal">-progress</span> MyPerson.java</span><br></pre></td></tr></table></figure><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit3/9.png" alt></p><h3 id="JMLUnitNG"><a href="#JMLUnitNG" class="headerlink" title="JMLUnitNG"></a>JMLUnitNG</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -jar jmlunitng.jar test/MyGroup.java</span><br><span class="line">javac -cp jmlunitng.jar test/MyGroup.java</span><br><span class="line">java -cp jmlunitng.jar test.MyGroup_JML_Test</span><br></pre></td></tr></table></figure><p>这种方式只检查了边界数据，因此只是简单了解了一下，没有怎么使用。</p><h2 id="3-容器选择与使用"><a href="#3-容器选择与使用" class="headerlink" title="3.容器选择与使用"></a>3.容器选择与使用</h2><p>由于本单元作业需要对容器内元素进行高频率增删改查的操作，选用普通数组实现JML效率非常低下，因此大部分容器都采用<code>HashMap</code>进行设计。</p><h3 id="homework9"><a href="#homework9" class="headerlink" title="homework9"></a>homework9</h3><p>本次作业由于性能要求较低，除了为了<code>isCircle</code>函数的广度优先搜索算法编写的<code>visit</code>数组使用了<code>HashMap&lt;MyPerson,Boolean&gt;</code>外其余的容器均使用<code>ArrayList</code>，即<code>acquaintance/value/people</code>。使用时基本和<code>JML</code>描述写法一致。</p><h3 id="homework10-homework11"><a href="#homework10-homework11" class="headerlink" title="homework10/homework11"></a>homework10/homework11</h3><p>在这两次作业中由于指令数量增多，性能要求提升，将第9次作业中所有的<code>ArrayList</code>全部替换成了<code>HashMap</code>。包括<code>MyNetwork</code>类中的<code>people/id2group/id2message/id2bossid</code>以及<code>MyPerson</code>中的<code>acquaintance</code>。同时新增的方法和变量也尽量使用了<code>HashMap</code>保证性能要求。</p><h2 id="4-bug分析"><a href="#4-bug分析" class="headerlink" title="4.bug分析"></a>4.bug分析</h2><p>本单元的bug主要集中在两方面，即：</p><ul><li>因为JML阅读不细致导致的程序<strong>正确性</strong>问题。</li><li>因为算法/容器设计不合理导致的<strong>CPU时间</strong>问题。</li></ul><h3 id="homework9-1"><a href="#homework9-1" class="headerlink" title="homework9"></a>homework9</h3><h4 id="自己的bug"><a href="#自己的bug" class="headerlink" title="自己的bug"></a>自己的bug</h4><p>这一次作业性能要求不高，但由于没有仔细思考，采用了<code>dfs</code>算法进行<code>isCircle</code>函数设计，同时在<code>qbs</code>函数中直接采用二层循环进行遍历查找，导致非常慢，出现了性能问题。强测被hack一个点，互测被hack7个点，全部是<code>CTLE</code>。修复<code>bug</code>时将<code>isCircle</code>采用<code>bfs</code>实现<code>qbs</code>和<code>isCircle</code>函数。</p><h4 id="他人的bug"><a href="#他人的bug" class="headerlink" title="他人的bug"></a>他人的bug</h4><p>测试时由于这一单元正确性较简单，主要针对多人的复杂网络进行了数据构造，至少增加200人以及200条关系之后在最后的几百条指令全部用<code>qbs</code>和<code>qci</code>进行轰炸。效果还可，很快就刀到了两个同样使用<code>dfs</code>的难兄难弟，之后基本就收手了，看了房间里被hack的代码都是这两个的性能问题导致。</p><h3 id="homework10"><a href="#homework10" class="headerlink" title="homework10"></a>homework10</h3><p>本次作业个人测试时主要注重性能，没有很关注正确性，导致代码里有大量正确性问题，导致第一次没进互测，心态崩溃的同时，也对各个写错的地方认真进行了审视。</p><h4 id="自己的bug-1"><a href="#自己的bug-1" class="headerlink" title="自己的bug"></a>自己的bug</h4><ul><li><code>MyGroup</code>类内删除人的时候没有把总年龄和减去删除的人的年龄导致错误。</li><li><code>MyNetwork</code>类<code>addToGroup</code>方法内不存在新加的人且<code>group</code>内人数大于等于1111时没有直接返回而是进入了异常。异常里存在这个人时。<code>addMessage</code>内当加入的邮件里两个人id相同时抛出异常使用的id是<code>messageId</code>。</li><li><code>sendMeesage</code>方法内当类型为0时没有把<code>person1</code>加入<code>person2</code>的关系数组里。</li><li><code>getReceivedMessages</code>方法内误以为只返回一个小于等于3的<code>Message</code>数组，实际上是返回一个小于等于4的<code>Message</code>数组。</li></ul><p>这次作业的bug主要都是因为在阅读JML代码时过于草率，很多地方都是漏看了一句话导致了问题的出现，且测试不够充分。这启发我在以后的JML规格编写时要认真细致地阅读每一行说明，编写后要进行充分细致的单元测试和黑箱测试。此外，本次作业在自己构造数据时往往关注时间，构造了和第一次差不多的数据，对第二次作业涉及的指令覆盖很有限，这也导致了问题的出现。同时之后也发现自己的测试脚本中也是有问题的，很多时候可能测试数据里只有第一次的指令，因此问题也很难找出来。所以以后对自己的测试数据生成脚本不能过于自信，要仔细审查。</p><p>正确性虽然被<code>hack</code>惨了，但是时间性能上由于使用了<strong>并查集</strong>进行搜索，没有出现问题。并查集对每个新进入的人先设置他的<code>bossid</code>为他自己的<code>id</code>，之后新增的关系中，如果他们的bossid不一样，则把一个人的最高级的<code>bossid</code>（<code>p.bossid==p.id</code>)设置为另一个人的最高级<code>bossid</code>即可。</p><h3 id="homework11"><a href="#homework11" class="headerlink" title="homework11"></a>homework11</h3><h4 id="自己的bug-2"><a href="#自己的bug-2" class="headerlink" title="自己的bug"></a>自己的bug</h4><p>本次强测互测均未被hack。</p><p>有了上一次的惨痛教训，本次在测试时非常细致，结合了ch大佬的数据和自己的数据进行了多轮校验。这次自测时仍然找出来了与上次作业中类似的正确性的错误，对于各个类中的方法进行了多次修改，值得一提的是很多错误都是由于想当然以为上次的方法这次不变导致的，这一点以后也需要注意。同时重点设计了最短路径查找算法，使用了堆优化的<code>Dijistra</code>算法，新增一个Node节点类保存了距离和id，使用优先队列模拟堆，避免了每一轮循环都进行全部的遍历查找，保证了时间性能。此外在<code>MyGroup</code>类中加入了<code>valueSum</code>变量，每次有人员变动时就修改<code>valueSum</code>。从而保证了<code>qgvs</code>指令的性能。</p><h4 id="他人的bug-1"><a href="#他人的bug-1" class="headerlink" title="他人的bug"></a>他人的bug</h4><p>本次由于限制了5000条指令，且上限为6s，从时间上hack是极难，尝试构造了很多复杂的数据都未成功。最后通过大量随机生成用例hack了一人。阅读代码发现是经典的问题：<code>isCircle</code>函数输入相同的<code>id</code>时没有返回<code>true</code></p><h2 id="5-作业架构设计"><a href="#5-作业架构设计" class="headerlink" title="5.作业架构设计"></a>5.作业架构设计</h2><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit3/Top-Level Package.png" style="zoom:80%;"></p><p>本单元作业架构相对固定且是官方给出的，每个基本类相对固定，活动空间主要是对于图模型的管理维护。由于代码量并不大，本单元我直接将全部的图相关算法和主要数据、方法都写在了<code>MyNetwork</code>类内，同时将具体算法函数与功能函数分开。在<code>isCircle</code>内调用不同的<code>find</code>方法从而方便优化性能，有过<code>dfsFind(id1,id2)  bfsFind(id1,id2)  unionFind(id1,id2)</code>共三个查找的算法函数。同时在<code>sendIndirectMessage</code>函数中也是调用<code>Dijistra</code>函数进行操作，且调动了一个外部类<code>Node</code>进行堆优化操作。同时，使用一个<code>HashMap</code>保存每个PersonId对应的<code>bossId</code>进行并查集数据管理。</p><p>同时，各个类内最终都基本使用了<code>HashMap</code>作为数组的实现容器，且这些都采用<code>id</code>作为<code>key</code>值进行查找。</p><p>本次的异常类采用<code>static</code>类<code>count</code>对异常数据进行管理，确定了统一接口进行查询和存储异常次数。每次新增时只需要新增新的<code>HashMap</code>的<code>key</code>值即可。</p><h2 id="6-感想与体会"><a href="#6-感想与体会" class="headerlink" title="6.感想与体会"></a>6.感想与体会</h2><ul><li>本单元是圣杯战争最后一战了，回想参加的8次互测，整体来说体验还是很好的，在这个过程中学到了不少和测试相关的知识，也加深了对java和python这两门语言的理解。非常感谢课程组给我们设置的这种课程体制，让我们对测试这门艺术有所理解和掌握</li><li>JML对代码的限制还是很强的，之后在开发之前不妨先写上JML再进行后续的开发，这样正确性能够有大幅提升。同时，JML也确实太复杂了，感谢为我们的作业献出那么多力量的助教和老师们，真的辛苦你们了！</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-OO-2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS理论课笔记-系统引导/内存管理/进程与并发程序设计</title>
      <link href="2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/"/>
      <url>2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/</url>
      
        <content type="html"><![CDATA[<h2 id="第1章-引论"><a href="#第1章-引论" class="headerlink" title="第1章 引论"></a>第1章 引论</h2><p>操作系统是一个程序，是一组管理计算机硬件资源的软件集合，向计算机程序提供共性服务。</p><ol><li>控制计算机资源；</li><li>给用户提供<strong>接口</strong>或<strong>虚拟机</strong>。</li></ol><p><img src="/2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/1-1.png" style="zoom:67%;"></p><h3 id="OS的历史沿革"><a href="#OS的历史沿革" class="headerlink" title="OS的历史沿革"></a>OS的历史沿革</h3><p><img src="/2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/1-2.png" style="zoom: 50%;"></p><p><strong>批处理</strong>：用户提交作业成批送入计算机，由作业调度程序自动选择作业运行。涉及到<strong>Mainframe基本功能，排队论、统筹学</strong>。</p><p><strong>批处理系统</strong>，分为<strong>联机批处理系统</strong>（作业的输入/输出由CPU来处理）和<strong>脱机批处理系统</strong>（输入/输出脱离主机控制）。 两者均有CPU空闲，均为<strong>单道程序系统</strong></p><p><strong>多道程序系统</strong>：多个程序同时进入内存，交替使用I/O设备和CPU。</p><p>多道程序系统的出现，标志着操作系统<strong>渐趋成熟</strong>的阶段，先后出现了<strong>作业调度管理</strong>、<strong>处理机管理</strong>、<strong>存储器管理</strong>、<strong>外部设备管理</strong>、<strong>文件系统管理</strong>等功能。</p><p><strong>分时系统</strong>：多个用户分享使用同一台计算机。多个程序分时共享硬件和软件资源</p><p>两种典型分时系统：</p><ol><li><p>Multics/Unix (1968/1970)</p></li><li><p>IBM VM 360/370 (1966/1972)</p></li></ol><p>Unix、DOS、Windows、Linux（使用GNU）</p><p><strong>分布式网络化</strong></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><img src="/2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/1-3.png" style="zoom: 60%;"></p><h3 id="操作系统基本实现机制"><a href="#操作系统基本实现机制" class="headerlink" title="操作系统基本实现机制"></a>操作系统基本实现机制</h3><h4 id="异常-exception-陷阱-trap-和中断-interrupt"><a href="#异常-exception-陷阱-trap-和中断-interrupt" class="headerlink" title="异常(exception): 陷阱(trap)和中断(interrupt)"></a>异常(exception): 陷阱(trap)和中断(interrupt)</h4><p><img src="/2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/1-4.png" style="zoom:50%;"></p><h3 id="操作系统的基本类型"><a href="#操作系统的基本类型" class="headerlink" title="操作系统的基本类型"></a>操作系统的基本类型</h3><ul><li>批处理系统</li><li>分时系统</li><li>实时系统</li><li>混合型</li></ul><h3 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h3><h4 id="处理机管理"><a href="#处理机管理" class="headerlink" title="处理机管理"></a>处理机管理</h4><p>核心任务：分配CPU时间 ——进程、线程管理——公平分配、保证非阻塞、按优先级分配</p><p>进程管理：程序是静态实体，进程是执行中的程序。进程的调度：创建、挂起、激活。进程间通信：同步，互斥，死锁。</p><h4 id="存储器-内存-管理"><a href="#存储器-内存-管理" class="headerlink" title="存储器(内存)管理"></a>存储器(内存)管理</h4><p>管理缓存、主存、磁盘等所形成的多级存储架构，为多道程序的并发提供良好的环境。</p><p>– 内存分配和存储无关性：方便用户<br>– 内存保护：互不干扰<br>– 内存扩充：虚拟存储器</p><h4 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h4><p>管理输入/输出设备，屏蔽差异性，提供并发访问</p><p>– 设备无关性：逻辑设备-&gt;物理设备<br>– 设备分配：独享、共享和虚拟<br>– 设备的传输控制：中断、通道</p><h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p>将磁盘变成一个很容易使用的存储媒介提供给用户使用。<br>– 文件存储空间的管理<br>– 目录管理<br>– 文件读、写管理<br>– 文件保护<br>– 向用户提供接口</p><h4 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h4><ul><li>作业调度</li><li>作业控制。<ul><li>批量型作业</li><li>终端型作业</li></ul></li></ul><h2 id="第2章-系统引导"><a href="#第2章-系统引导" class="headerlink" title="第2章 系统引导"></a>第2章 系统引导</h2><h3 id="BootLoader"><a href="#BootLoader" class="headerlink" title="BootLoader"></a>BootLoader</h3><p>引导加载程序，是系统<strong>加电后</strong>运行的第一段软件代码，是操作系统<strong>内核运行之前</strong>运行的一段小程序</p><p><strong>BootLoader</strong>是<strong>Booter</strong>和<strong>Loader</strong>的合写，前者要<strong>初始化系统硬件</strong>使之运行起来，至少是<strong>部分运行</strong>起来；后者将<strong>操作系统映像加载到内存</strong>中，并跳转到操作系统的代码运行。</p><ul><li><strong>MIPS</strong>处理器大多用于<strong>嵌入式系统</strong>，嵌入式系统常用<strong>U-boot</strong>作为OS启动装载程序，U-Boot，全称 Universal Boot Loader；</li><li><strong>X86</strong>处理器通常采用<strong>LILO</strong>和<strong>GRUB</strong>。</li></ul><h3 id="U-Boot启动流程"><a href="#U-Boot启动流程" class="headerlink" title="U-Boot启动流程"></a>U-Boot启动流程</h3><p>大多数BootLoader都分为<strong>stage1</strong>和<strong>stage2</strong>两大部分，U-boot也不例外。</p><ul><li>依赖于cpu体系结构的代码（如设备初始化代码等）通常都放在stage1且可以用<strong>汇编语言</strong>来实现；</li><li>stage2则通常用<strong>C语言</strong>来实现，这样可以实现复杂的功能，而且有更好的可读性和移植性。</li></ul><h3 id="启动及OS引导"><a href="#启动及OS引导" class="headerlink" title="启动及OS引导"></a>启动及OS引导</h3><p><img src="/2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/2-1.png" alt></p><h5 id="启动第一步——加载BIOS"><a href="#启动第一步——加载BIOS" class="headerlink" title="启动第一步——加载BIOS"></a>启动第一步——加载BIOS</h5><p>BIOS进行硬件自检以及读取启动顺序</p><h5 id="启动第二步——读取MBR，装载MBR到内存特定地址"><a href="#启动第二步——读取MBR，装载MBR到内存特定地址" class="headerlink" title="启动第二步——读取MBR，装载MBR到内存特定地址"></a>启动第二步——读取MBR，装载MBR到内存特定地址</h5><h5 id="启动第三步——Boot-Loader，运行主引导程序"><a href="#启动第三步——Boot-Loader，运行主引导程序" class="headerlink" title="启动第三步——Boot Loader，运行主引导程序"></a>启动第三步——Boot Loader，运行主引导程序</h5><h2 id="第3章-内存管理"><a href="#第3章-内存管理" class="headerlink" title="第3章 内存管理"></a>第3章 内存管理</h2><h3 id="3-1-多道程序的存储管理"><a href="#3-1-多道程序的存储管理" class="headerlink" title="3.1 多道程序的存储管理"></a>3.1 多道程序的存储管理</h3><p>固定（静态）式分区分配，程序适应分区。系统初始化时将存储空间分为若干个区域，之后再将这些区域分配给用户作业。</p><p>可变（动态）式分区分配，分区适应程序。动态确定分区边界。</p><p>内外碎片造成巨大空间浪费</p><p><strong>跟踪</strong>内存使用情况？<strong>位图表示法（分区表）</strong>和<strong>链表表示法（分区链表）</strong>。</p><p><img src="/2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/2-2.png" style="zoom:40%;"><img src="/2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/2-3.png" alt="2-3" style="zoom:40%;"></p><p>位图表示法空间成本固定，时间成本低，容错能力差（不知道被占用的原因）。</p><p>链表表示法时间成本高，容错能力较好。</p><h4 id="可变分区管理"><a href="#可变分区管理" class="headerlink" title="可变分区管理"></a>可变分区管理</h4><p>内存分配采用两张表：<strong>已分配分区表</strong>和<strong>未分配分区表</strong>。操作为分配、回收内存。</p><h4 id="基于顺序搜索的分配算法"><a href="#基于顺序搜索的分配算法" class="headerlink" title="基于顺序搜索的分配算法"></a>基于顺序搜索的分配算法</h4><p><img src="/2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-1.png" style="zoom: 50%;"></p><h4 id="基于索引搜索的动态分区分配算法"><a href="#基于索引搜索的动态分区分配算法" class="headerlink" title="基于索引搜索的动态分区分配算法"></a>基于索引搜索的动态分区分配算法</h4><p>大中型系统采用</p><h5 id="快速适应算法（分类搜索法）"><a href="#快速适应算法（分类搜索法）" class="headerlink" title="快速适应算法（分类搜索法）"></a>快速适应算法（分类搜索法）</h5><p>把空闲分区<strong>按容量大小</strong>进行分类，经常用到长度的空闲区设立单独的<strong>空闲区链表</strong>。为多个空闲链表设立一张<strong>管理索引表</strong>。</p><h4 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h4><p>介于固定分区与可变分区之间的动态分区技术</p><p>在分配存储块时将一个<strong>大的存储块</strong>分裂成<strong>两个大小相等的小块</strong>。</p><p>已分配和空闲分区大小均为2的整数次幂。每次有一个新的大小请求先看有无最靠近这个大小的幂次的分区，没有就向上查找并分裂。</p><p><img src="/2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-2.png" style="zoom:45%;"><img src="/2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-3.png" style="zoom:45%;"></p><h3 id="3-2-程序从存储到执行"><a href="#3-2-程序从存储到执行" class="headerlink" title="3.2 程序从存储到执行"></a>3.2 程序从存储到执行</h3><h4 id="存储分配三种方式"><a href="#存储分配三种方式" class="headerlink" title="存储分配三种方式"></a>存储分配三种方式</h4><ul><li>直接指定。直接使用实际地址</li><li>静态分配</li><li>动态分配</li></ul><h5 id="可重定位分区分配"><a href="#可重定位分区分配" class="headerlink" title="可重定位分区分配"></a>可重定位分区分配</h5><p>定时的或在内存紧张时，移动某些已分配区中的信息，把存储空间中<strong>所有的空白区</strong>合<strong>并为</strong>一个<strong>大的连续区</strong>。</p><h4 id="程序的链接和装入"><a href="#程序的链接和装入" class="headerlink" title="程序的链接和装入"></a>程序的链接和装入</h4><ul><li><strong>编译</strong>(compile)：由编译程序将用户源程序<strong>编译</strong>成<strong>若干个目标模块</strong>。</li><li><strong>链接</strong>(linking)：由链接程序将<strong>目标模块</strong>和相应的<strong>库函数</strong>链接成<strong>可装载模块</strong>（<strong>可执行文件</strong>）。</li><li><strong>装入</strong>(loading)：由装载程序将可装载模块<strong>装入内存</strong>。一般采用动态运行时装入方式</li></ul><h5 id="链接方式"><a href="#链接方式" class="headerlink" title="链接方式"></a>链接方式</h5><ul><li><p>静态链接 直接将共享库中代码链接如程序代码中</p></li><li><p>动态链接 需要时才链接特定的模块</p></li></ul><h5 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h5><p>在装入时对目标程序中的指令和数据地址的修改，或映射过程。</p><h5 id="多重分区分配"><a href="#多重分区分配" class="headerlink" title="多重分区分配"></a>多重分区分配</h5><p>一个作业往往由相对独立的程序段和数据段组成，将这些片段分别装入到存储空间中不同的区域内的分配方式。</p><h4 id="程序段"><a href="#程序段" class="headerlink" title="程序段"></a>程序段</h4><p>一个程序本质上都是由 bss段、data段、text段三个组成的。</p><p><strong>bss段</strong>：（bss segment）用来存放程序中<strong>未初始化的全局变量</strong>的一块内存区域。bss是英文Block Started by Symbol的简称。bss段属于<strong>静态内存分配</strong>。</p><p><strong>data段</strong>：数据段（data segment）用来存放程序中<strong>已初始化的全局变量</strong>的一块内存区域。数据段属于<strong>静态内存分配</strong>。</p><p><strong>text段</strong>：代码段（code segment/text segment）用来存放<strong>程序执行代码</strong>的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于<strong>只读</strong>(某些架构也允许代码段为可写，即允许修改程序)。在代码段中，也有可能包含一些只读的常数变量，例如<strong>字符串常量</strong>等。</p><p><strong>栈(stack)</strong>：存放、交换<strong>临时数据</strong>的内存区</p><ul><li><p>用户存放<strong>程序局部变量</strong>的内存区域，（但不包括static声明的变量，<strong>static</strong>意味着在<strong>数据段中存放变量</strong>）。</p></li><li><p><strong>保存/恢复调用现场</strong>。在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。</p></li></ul><p><strong>堆（heap）</strong>：存放进程运行中<strong>动态分配</strong>的内存段</p><ul><li>它的大小并不固定，可动态扩张或缩减。当进程调用<strong>malloc等函数分配内存</strong>时，新分配的内存就被动态添加到堆上（<strong>堆被扩张</strong>）；当利用<strong>free</strong>等函数释放内存时，被释放的内存从堆中被剔除（<strong>堆被缩减</strong>）。</li></ul><p><img src="/2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-4.png" alt></p><p>C语言各个段地址解析：</p><p><a href="https://blog.csdn.net/zhengshifeng123/article/details/79756830" target="_blank" rel="noopener">https://blog.csdn.net/zhengshifeng123/article/details/79756830</a></p><h4 id="gcc编译与链接"><a href="#gcc编译与链接" class="headerlink" title="gcc编译与链接"></a>gcc编译与链接</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gcc -o main main.c extra.c #-o 编译+链接</span><br><span class="line">./main #运行main</span><br><span class="line"></span><br><span class="line">gcc -c main.c</span><br><span class="line">gcc -c extra.c #只编译</span><br><span class="line"></span><br><span class="line">gcc main.o extra.o -o main</span><br><span class="line">./main #只链接</span><br></pre></td></tr></table></figure><p><strong>gcc调用</strong>包含的几个<strong>工具</strong>：</p><ul><li>cc1：预处理器和编译器</li><li>as：汇编器</li><li>collect2：链接器</li></ul><h4 id="Linux下可执行文件的格式"><a href="#Linux下可执行文件的格式" class="headerlink" title="Linux下可执行文件的格式"></a>Linux下可执行文件的格式</h4><p>ELF（Executable and Linkable Format）文件</p><ol><li><strong>可重定位（relocatable）文件</strong>，保存着代码和适当的数据，用来和其他的object文件一起来创建一个可执行文件或者是一个共享文件。</li><li><strong>可执行（executable）文件</strong>，保存着一个用来执行的程序，该文件指出了exec（BA_OS）如何来创建程序进程映像</li><li><strong>共享object文件</strong>，保存着代码和合适的数据，用来被下面的两个链接器链接。第一个是链接编辑器（静态链接），可以和其他的可重定位和共享object文件一起来创建object文件；第二个是动态链接器，联合一个可执行文件和其他的共享object文件来创建一个进程映象。</li></ol><p><strong>编译，链接，重定位，装载，运行</strong>。五个步骤完成程序的执行全流程。</p><h3 id="3-3-页式内存管理"><a href="#3-3-页式内存管理" class="headerlink" title="3.3 页式内存管理"></a>3.3 页式内存管理</h3><h4 id="程序、进程和作业"><a href="#程序、进程和作业" class="headerlink" title="程序、进程和作业"></a>程序、进程和作业</h4><p><strong>程序</strong>—<strong>静止</strong>的，是存放在磁盘上的可执行文件</p><p><strong>进程</strong>—<strong>动态</strong>的，包括程序和程序处理对象，是分配资源的基本单位。</p><ul><li><p>完成操作系统功能的进程是<strong>系统进程</strong>。</p></li><li><p>完成用户功能的进程称为<strong>用户进程</strong>。</p></li></ul><p><strong>作业</strong>—是用户需要计算机完成的<strong>某项任务</strong>，是要求计算机<strong>所做工作的集合</strong>。</p><p>一个<strong>作业</strong>划分为<strong>多个进程</strong>来完成，一个进程又由其<strong>实体</strong>—<strong>程序和数据集合</strong>来组成。</p><h4 id="分页式存储管理"><a href="#分页式存储管理" class="headerlink" title="分页式存储管理"></a>分页式存储管理</h4><p><strong>纯分页系统</strong>：没有页面置换功能。所有页<strong>一次性全部装入主存</strong>。</p><p><strong>页</strong>：每个作业的<strong>地址空间</strong>分成一些<strong>大小相等的片</strong>，称之为<strong>页面</strong>或<strong>页</strong>。</p><p><strong>存储块</strong>：主存的<strong>存储空间</strong>也分成和<strong>页面相同大小的片</strong>，称为<strong>存储块</strong>，或<strong>页框</strong>。</p><p><strong>分页地址结构</strong>：</p><h5 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a>逻辑地址</h5><div class="table-container"><table><thead><tr><th style="text-align:center">31-12</th><th style="text-align:center">11-0</th></tr></thead><tbody><tr><td style="text-align:center">页号p</td><td style="text-align:center">页内偏移w</td></tr></tbody></table></div><h5 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h5><div class="table-container"><table><thead><tr><th style="text-align:center">21-12</th><th style="text-align:center">11-0</th></tr></thead><tbody><tr><td style="text-align:center">块号</td><td style="text-align:center">块内偏移d</td></tr></tbody></table></div><p>现代操作系统中最常用的页面大小为4KB</p><h5 id="内存分配基本思想"><a href="#内存分配基本思想" class="headerlink" title="内存分配基本思想"></a>内存分配基本思想</h5><ul><li>以<strong>页</strong>为单位进行分配，并按程序（作业）的<strong>长度（页数）</strong>进行分配；</li><li><strong>逻辑上相邻</strong>的页，<strong>物理上不一定相邻</strong>。</li></ul><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><p>每个进程有一个<strong>进程页表</strong>，描述该进程<strong>占用的物理页面</strong>及<strong>逻辑排列顺序</strong>。</p><p>整个系统有一个<strong>物理页面表</strong>，描述物理内存空间<strong>分配使用</strong>情况。</p><p>整个系统有一个<strong>请求表</strong>，描述系统内各个<strong>进程页表的位置</strong>和<strong>大小</strong>，用于<strong>地址转换</strong>，也可以结合到各进程的PCB里。</p><h5 id="地址变换—页表查找"><a href="#地址变换—页表查找" class="headerlink" title="地址变换—页表查找"></a>地址变换—页表查找</h5><p><img src="/2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-5.png" style="zoom: 80%;"></p><h5 id="关于页表"><a href="#关于页表" class="headerlink" title="关于页表"></a>关于页表</h5><ul><li>页表<strong>放置在内存中</strong>，记录了进程的<strong>现场信息</strong>。记录进程的<strong>内存分配情况</strong>以及实现进程运行时的<strong>动态重定位</strong>。</li><li>访问一个数据需要访问内存<strong>两次</strong>（页表一次，内存一次）。</li><li>页表的<strong>基址</strong>及<strong>长度</strong>由<strong>页表寄存器</strong>给出。</li></ul><h5 id="地址转换机构"><a href="#地址转换机构" class="headerlink" title="地址转换机构"></a>地址转换机构</h5><p><img src="/2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-6.png" style="zoom:80%;"></p><p>逻辑地址分为页号和页内地址两部分。先进行越界保护。之后进行页表定位：页表始址+页号*页表项长度</p><p>查询页表，读出块号。物理地址=块号+块内地址（块内地址=页内地址）</p><h4 id="提高分页效率"><a href="#提高分页效率" class="headerlink" title="提高分页效率"></a>提高分页效率</h4><ul><li>减少页表大小</li><li>提高地址映射速度</li></ul><h5 id="解决问题方法"><a href="#解决问题方法" class="headerlink" title="解决问题方法"></a>解决问题方法</h5><ul><li>动态调入页表：只将需用的部分页表项调入内存</li><li>多级页表</li></ul><p><strong>二级页表</strong>：</p><ul><li>一级目录：页目录表</li><li>二级目录：页表</li></ul><p>参考博客：<a href="https://www.jianshu.com/p/51c2286a6268" target="_blank" rel="noopener">https://www.jianshu.com/p/51c2286a6268</a></p><p><img src="/2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-7.jpg" style="zoom: 67%;"></p><p><img src="/2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-8.png" style="zoom:67%;"></p><blockquote><p>如果是64位操作系统，内存也是4G，每个页面大小也为4KB，采用三级页表，需要字对齐，则虚拟地址应该为多少位？</p></blockquote><p>首先每一级页表的所占空间大小应该都是一个页面的大小。即4KB（因为自映射机制）</p><p>又由于64位操作系统需要字对齐，所以实际上每一级目录只占用12-3=9位。</p><p>因此三级目录就需要9*3+12=39位</p><p>多级页表带来访存效率低下问题</p><h4 id="页表快速访问机制——MMU"><a href="#页表快速访问机制——MMU" class="headerlink" title="页表快速访问机制——MMU"></a>页表快速访问机制——MMU</h4><p>CPU内部增加了一个硬件单元，称为<strong>存储管理单元MMU</strong>（Memory Management Unit）</p><ul><li><strong>页表Cache</strong>：又称为<strong>TLB</strong>，用于存放<strong>虚拟地址</strong>与<strong>相应</strong>的<strong>物理地址</strong>；</li><li><strong>TLB控制单元</strong>：TLB内容<strong>填充、刷新、覆盖，以及越界检查</strong>。</li><li><strong>页表（遍历）查找单元</strong>：若TLB未命中，自动查找多级页表，将找到的物理地址<strong>送与TLB控制单元</strong>。（可用软件实现）</li></ul><p><img src="/2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-21.png" alt></p><h4 id="反向页表、哈希页表"><a href="#反向页表、哈希页表" class="headerlink" title="反向页表、哈希页表"></a>反向页表、哈希页表</h4><h4 id="页的保护"><a href="#页的保护" class="headerlink" title="页的保护"></a>页的保护</h4><ul><li>地址<strong>越界</strong>保护</li><li>页表中设置<strong>保护位</strong>（只读，读写，执行）</li></ul><h4 id="页面大小习题"><a href="#页面大小习题" class="headerlink" title="页面大小习题"></a>页面大小习题</h4><p>假设进程的平均大小是1MB，每个页表项需要8个字节。页面大小设置为多少字节比较好？</p><p>答：$f(p)=se/p+p/2，求minf(p)$ $为4kB$</p><h4 id="多级页表再理解"><a href="#多级页表再理解" class="headerlink" title="多级页表再理解"></a>多级页表再理解</h4><p>指令给出的地址除<strong>偏移地址之外</strong>的<strong>各部分</strong>全是各级页表的<strong>页表号</strong>或<strong>页号</strong>，且都是<strong>物理页号</strong></p><p><img src="/2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-9.png" style="zoom: 67%;"></p><h3 id="3-4-分段存储管理"><a href="#3-4-分段存储管理" class="headerlink" title="3.4 分段存储管理"></a>3.4 分段存储管理</h3><p>逻辑地址结构为：<strong>段号S+位移量W</strong></p><p><strong>段表</strong>记录了段与内存位置对应关系，保存在内存中。</p><p>段表<strong>基地址</strong>和<strong>长度</strong>由段表寄存器给出。访问一个字节数据/指令需要<strong>访问内存两次</strong>（段表1次，内存1次）。</p><p><img src="/2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-10.png" style="zoom:80%;"></p><p>先比较段号S和段表长度TL，不越界则检查段内地址d是否超过段长。</p><p><img src="/2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-11.png" style="zoom:80%;"></p><p><strong>信息共享</strong>——<strong>可重入代码</strong>（<strong>纯代码Pure Code</strong>），允许多个进程<strong>同时访问</strong>，但<strong>不允许</strong>任何进程对其进行<strong>修改</strong>。</p><p>可采用<strong>分段共享</strong>，</p><h4 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h4><p><strong>分段方法</strong>——分配和管理<strong>虚拟存储器</strong></p><p><strong>分页方法</strong>——分配和管理<strong>实存储器</strong></p><p><img src="/2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-12.png" style="zoom:80%;"></p><h3 id="3-5-虚拟存储管理（※）"><a href="#3-5-虚拟存储管理（※）" class="headerlink" title="3.5 虚拟存储管理（※）"></a>3.5 虚拟存储管理（※）</h3><p><strong>虚拟地址空间</strong>：并不真实存在，格式按<strong>字节从0开始编址</strong>所形成的空间</p><p><img src="/2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-13.png" style="zoom: 67%;"></p><h3 id="3-6-页面置换"><a href="#3-6-页面置换" class="headerlink" title="3.6 页面置换"></a>3.6 页面置换</h3><h4 id="1-最优置换-OPT"><a href="#1-最优置换-OPT" class="headerlink" title="1.最优置换 OPT"></a>1.最优置换 OPT</h4><ul><li><p>需要用<strong>先验知识</strong>，无法实现，作为<strong>基准</strong>衡量其他算法效果。</p></li><li><p>置换掉<strong>未来最久不被使用</strong>的页</p></li></ul><h4 id="2-FIFO类算法"><a href="#2-FIFO类算法" class="headerlink" title="2.FIFO类算法"></a>2.FIFO类算法</h4><h5 id="先进先出-FIFO"><a href="#先进先出-FIFO" class="headerlink" title="先进先出 FIFO"></a>先进先出 FIFO</h5><p>用一个<strong>队列</strong>维护</p><p><strong>性能较差</strong>，因为<strong>较早调入</strong>的页往往<strong>访问频率高</strong></p><h6 id="Belady-现象"><a href="#Belady-现象" class="headerlink" title="Belady 现象"></a>Belady 现象</h6><p>FIFO容易出现</p><p>分配页面增多，<strong>缺页率</strong>反而<strong>增高</strong></p><h5 id="改进FIFO—Second-Chance"><a href="#改进FIFO—Second-Chance" class="headerlink" title="改进FIFO—Second Chance"></a>改进FIFO—Second Chance</h5><p>每个页面增加一个<strong>访问标志位</strong>，标识进入<strong>缓存队列</strong>后是否再次被访问过</p><p>如果一个页面进入后被访问，则将A移动到<strong>队列头</strong></p><p><img src="/2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-15.png" style="zoom: 80%;"></p><h5 id="改进FIFO—Clock"><a href="#改进FIFO—Clock" class="headerlink" title="改进FIFO—Clock"></a>改进FIFO—Clock</h5><p>Second Chance的改进版，也叫最近未使用算法</p><p>使用<strong>环形队列</strong>，缺页时当前指针指向的P如果访问标记为1，则清零并移动指针到P的下一个</p><p><img src="/2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-14.png" style="zoom:67%;"></p><p>FIFO类算法命中率较低，<strong>实际应用</strong>较少。</p><h5 id="FIFO算法性能比较"><a href="#FIFO算法性能比较" class="headerlink" title="FIFO算法性能比较"></a>FIFO算法性能比较</h5><p><img src="/2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-16.png" style="zoom: 50%;"></p><h4 id="3-最近最少使用-LRU算法"><a href="#3-最近最少使用-LRU算法" class="headerlink" title="3.最近最少使用 LRU算法"></a>3.最近最少使用 LRU算法</h4><p><strong>核心思想</strong>：最近被访问过，将来被访问概率增高</p><p>淘汰掉<strong>最先进入队列</strong>里且被<strong>访问次数最少</strong>的页面，可采用链表实现</p><p><img src="/2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-17.png" style="zoom: 50%;"></p><h4 id="4-其他替换算法"><a href="#4-其他替换算法" class="headerlink" title="4.其他替换算法"></a>4.其他替换算法</h4><ul><li><p>LRU类：LRU2， Two queues（2Q）， Multi Queue（MQ）</p></li><li><p>LFU类： LFU（Least Frequently Used）， LFU-Aging， LFU*-Aging， Window-LFU； </p></li><li>其它： Most Recently Used（MRU），Adaptive Replacement Cache（ARC），Working Set（WS），Working Set Clock（WSclock）</li></ul><h4 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h4><ul><li><strong>两个进程共享</strong>同一块物理内存，每个页面都被标志成了<strong>写时复制</strong>。共享的物理内存中每个页面都是只读的。</li><li>如果某个进程想改变某个页面时，就会与<strong>只读标记</strong>冲突，而系统在检测出页面是<strong>写时复制</strong>的，则会在内存中复制一个页面，然后进行写操作。</li><li>新复制的页面对执行写操作的进程是私有的，对其他共享写时复制页面的进程是不可见的。</li></ul><h3 id="3-7-页目录自映射"><a href="#3-7-页目录自映射" class="headerlink" title="3.7 页目录自映射"></a>3.7 页目录自映射</h3><p><img src="/2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-18.png" style="zoom: 40%;"><img src="/2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-19.png" style="zoom:40%;"><img src="/2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/3-20.png" style="zoom:40%;"></p><h2 id="第4章-进程与并发程序设计"><a href="#第4章-进程与并发程序设计" class="headerlink" title="第4章 进程与并发程序设计"></a>第4章 进程与并发程序设计</h2><h3 id="4-1-进程与线程"><a href="#4-1-进程与线程" class="headerlink" title="4.1 进程与线程"></a>4.1 进程与线程</h3><h4 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h4><p>并发：两个活动都处在各自的<strong>起点到终点间的某一处</strong>。</p><p>并行：<strong>同一时间度量</strong>下<strong>同时运行</strong>在<strong>不同的处理机</strong>上</p><p>并发不一定是并行</p><h5 id="并行性的确定—Bernstein条件"><a href="#并行性的确定—Bernstein条件" class="headerlink" title="并行性的确定—Bernstein条件"></a>并行性的确定—Bernstein条件</h5><p>程序并发执行出现<strong>竞争</strong></p><p><img src="/2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/4-1.png" style="zoom:50%;"></p><p>归结为：<strong>不存在一个数据集</strong>两个进程<strong>同时需要写</strong></p><h4 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h4><p><strong>结构特征</strong>：包含<strong>程序段，数据段，进程控制块（PCB）</strong></p><p>一个进程应该包括：</p><ul><li>程序的代码；</li><li>程序的数据；</li><li>PC中的值，用来指示下一条将运行的指令；</li><li>一组通用的寄存器的当前值，堆、栈；</li><li>一组系统资源（如打开的文件）</li></ul><h4 id="进程状态与控制"><a href="#进程状态与控制" class="headerlink" title="进程状态与控制"></a>进程状态与控制</h4><p>进程控制实现：<strong>原语</strong>——常驻内存，只在内核态下执行，指令序列连续不可分割</p><p>创建原语(fork exec)</p><p>撤销原语(kill)</p><h5 id="进程三种基本状态"><a href="#进程三种基本状态" class="headerlink" title="进程三种基本状态"></a>进程三种基本状态</h5><p>就绪(Ready)：已获得处理机外所需资源，等待CPU的分配</p><p>执行(Running)：<strong>占用处理机</strong>资源。无进程可执行时，自动执行系统idle进程（相当于空操作）</p><p>阻塞(Blocked)：正在执行的进程，因等待某事件，<strong>暂时无法</strong>继续执行，放弃处理机处于<strong>暂停</strong>状态</p><p><img src="/2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/4-2.png" style="zoom: 67%;"></p><p><img src="/2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/4-3.png" style="zoom: 80%;"></p><h5 id="挂起进程模型"><a href="#挂起进程模型" class="headerlink" title="挂起进程模型"></a>挂起进程模型</h5><p><img src="/2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/4-4.png" style="zoom: 67%;"></p><h5 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h5><ul><li><strong>进程标识符</strong> （进程ID）</li><li><strong>程序、数据地址</strong></li><li><strong>当前状态</strong> 系统会把相同状态的进程组成队列</li><li><strong>现场保护区</strong> 需要等待时保存CPU各种状态信息</li><li><strong>同步与同步机制</strong> 实现进程间互斥同步、通信所需的信号量</li><li><strong>优先级</strong> </li><li><strong>资源清单</strong> 拥有的除CPU外的资源记录</li><li><strong>链接字</strong> 该进程所在队列中下一个进程PCB首地址</li></ul><h4 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h4><p>进程 (process task) 包含了两个概念：<strong>资源拥有者</strong>和<strong>可执行单元</strong></p><p>可执行单元——线程(thread)  将<strong>资源与计算</strong>分离，提高并发效率</p><p><strong>进程</strong>是<strong>资源分配</strong>的基本单位，<strong>线程</strong>是<strong>处理机调度</strong>的基本单位</p><p><img src="/2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/4-5.png" style="zoom:50%;"></p><h4 id="线程的实现方式-※※"><a href="#线程的实现方式-※※" class="headerlink" title="线程的实现方式 ※※"></a>线程的实现方式 ※※</h4><h5 id="用户级线程：User-level-threads-ULT"><a href="#用户级线程：User-level-threads-ULT" class="headerlink" title="用户级线程：User level threads(ULT)"></a>用户级线程：User level threads(ULT)</h5><p>线程在用户空间,通过library模拟的thread</p><h5 id="内核级线程：Kernel-level-threads-KLT"><a href="#内核级线程：Kernel-level-threads-KLT" class="headerlink" title="内核级线程：Kernel level threads (KLT)"></a>内核级线程：Kernel level threads (KLT)</h5><p>kernel有好几个分身 多线程内核</p><h5 id="混合实现方式"><a href="#混合实现方式" class="headerlink" title="混合实现方式"></a>混合实现方式</h5><p>使用内核级线程，将<strong>用户级线程</strong>与<strong>某些</strong>或者<strong>全部</strong>内核线程<strong>多路复用</strong>起来，形成混合的线程实现方式。</p><h5 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h5><ul><li><strong>Many-to-One Model</strong> 多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。<ul><li>优点：线程管理在用户空间进行，<strong>效率高</strong></li><li>缺点：一个线程被阻塞，整个进程被阻塞；<strong>多个线程不能并行</strong>运行在多处理机上</li></ul></li><li><strong>One-to-one Model</strong>  将每个用户级线程映射到一个内核级线程<ul><li>优点：一个进程阻塞可以让另一线程继续，<strong>并发能力强</strong></li><li>缺点：每创1个用户级线程都需要创1个内核级线程，<strong>开销大</strong></li></ul></li><li><strong>Many-to-Many Model</strong>  将 n 个用户级线程映射到m 个内核级线程上，要求m &lt;= n。<ul><li>特点：集前2者之长</li></ul></li></ul><h3 id="4-2-同步与互斥"><a href="#4-2-同步与互斥" class="headerlink" title="4.2 同步与互斥"></a>4.2 同步与互斥</h3><p>互斥-间接制约：多个进程不能同时进入<strong>同一组共享变量临界区域</strong></p><p>同步-直接制约：有效地共享资源、相互合作</p><h4 id="基于忙等的方式"><a href="#基于忙等的方式" class="headerlink" title="基于忙等的方式"></a>基于忙等的方式</h4><p>软硬件方法都不可取 </p><p>Lamport面包店算法、Eisenberg算法</p><h4 id="基于信号量的方法"><a href="#基于信号量的方法" class="headerlink" title="基于信号量的方法"></a>基于信号量的方法</h4><h5 id="经典信号量机制"><a href="#经典信号量机制" class="headerlink" title="经典信号量机制"></a>经典信号量机制</h5><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单表述</span></span><br><span class="line">P(S): <span class="keyword">while</span> S&lt;=<span class="number">0</span> <span class="keyword">do</span> skip</span><br><span class="line">  S:=S-<span class="number">1</span>;</span><br><span class="line">V(S): S:=S+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//详细表述</span></span><br><span class="line"><span class="keyword">Type</span> semaphore = <span class="keyword">record</span></span><br><span class="line">    value : integer;</span><br><span class="line">    L : list <span class="keyword">of</span> process;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">Procedure</span> <span class="title">P</span><span class="params">(S)</span></span></span><br><span class="line"><span class="function">    <span class="title">var</span> <span class="title">S</span> :</span> semaphore;</span><br><span class="line">    <span class="keyword">begin</span> </span><br><span class="line">        S.value := S.value -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> S.value&lt;<span class="number">0</span> <span class="keyword">then</span> block(S.L);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">V</span><span class="params">(S)</span></span></span><br><span class="line"><span class="function">    <span class="title">var</span> <span class="title">S</span> :</span> semaphore;</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        S.value := S.value + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> S.value&lt;=<span class="number">0</span> <span class="keyword">then</span> wakeup(S.L);</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>信号量必须且只能置一次初值，且只能由P/V操作来改变</p><h5 id="物理意义"><a href="#物理意义" class="headerlink" title="物理意义"></a>物理意义</h5><ul><li>S.value为正时表示<strong>资源的个数</strong></li><li>S.value为负时表示<strong>等待进程</strong>的<strong>个数</strong></li><li>P操作<strong>分配</strong>资源</li><li>V操作<strong>释放</strong>资源</li></ul><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#互斥 初始化S=1</span></span><br><span class="line"><span class="comment">#有限n并发可以把S初始值设为n</span></span><br><span class="line">P(S)   P(S)</span><br><span class="line">临界区  临界区</span><br><span class="line">V(S)   V(S)</span><br><span class="line"></span><br><span class="line"><span class="comment">#同步 初始化S=0 先运行code1 再运行code2</span></span><br><span class="line">P(S)   code1</span><br><span class="line">code2  V(S)</span><br></pre></td></tr></table></figure><h4 id="基于管程的同步与互斥"><a href="#基于管程的同步与互斥" class="headerlink" title="基于管程的同步与互斥"></a>基于管程的同步与互斥</h4><p>管程：高级同步原语</p><p>把<strong>分散的临界区集中</strong>起来，为每个可共享资源设计一个<strong>专门机构</strong>来<strong>统一管理</strong>各进程对该资源的访问，这个<strong>专门机构</strong>称为管程。</p><p>管程互斥进入，由编译器进行实现、</p><h4 id="进程间通信-Inter-Process-Comm"><a href="#进程间通信-Inter-Process-Comm" class="headerlink" title="进程间通信(Inter-Process-Comm)"></a>进程间通信(Inter-Process-Comm)</h4><ul><li>管道（Pipe）及命名管道（Named pipe或FIFO） </li><li>消息队列（Message） 两个通信原语<ul><li>send(destination, &amp;message)</li><li>receive(source, &amp;message)</li></ul></li><li>共享内存（Shared memory） <ul><li>最有用,最快</li><li>同一块物理内存被映射到进程A、B各自的进程地址空间</li><li>共享内存可以同时读但不能同时写，则需要<strong>同步机制</strong>约束</li></ul></li><li>信号量（Semaphore） </li><li>套接字（Socket） </li><li>信号（Signal）</li></ul><h3 id="4-3-经典进程同步问题"><a href="#4-3-经典进程同步问题" class="headerlink" title="4.3 经典进程同步问题"></a>4.3 经典进程同步问题</h3><h4 id="生产者－消费者问题-the-producer-consumer-problem"><a href="#生产者－消费者问题-the-producer-consumer-problem" class="headerlink" title="生产者－消费者问题(the producer consumer problem)"></a>生产者－消费者问题(the producer consumer problem)</h4><blockquote><p>若干进程通过有限的共享缓冲区交换数据。其中，“生产者”进程不断写入，而 “消费者”进程不断读出；共享缓冲区共有 N个；任何时刻只能有一个进程可对共享缓冲区进行操作。</p></blockquote><h5 id="信号量写法"><a href="#信号量写法" class="headerlink" title="信号量写法"></a>信号量写法</h5><p><img src="/2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/4-6.png" style="zoom:50%;"></p><h5 id="管程写法"><a href="#管程写法" class="headerlink" title="管程写法"></a>管程写法</h5><p><img src="/2021/05/05/OS%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0-1/4-7.png" style="zoom: 67%;"></p><h4 id="读者－写者问题-the-readers-writers-problem"><a href="#读者－写者问题-the-readers-writers-problem" class="headerlink" title="读者－写者问题(the readers-writers problem)"></a>读者－写者问题(the readers-writers problem)</h4><blockquote><p>问题描述：对共享资源的读写操作，任一时刻 “写者”最多只允许一个，而 “读者”则允许多个，即 “读－写”互斥，“写－写”互斥，“读－读”允许</p></blockquote><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.读者占优势算法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//wmutex表示“允许写”，初值是1。 </span></span><br><span class="line"><span class="comment">//公共变量readcount表示“正在读”的进程数，初值是0； </span></span><br><span class="line"><span class="comment">//mutex表示对readcount的互斥操作，初值是1。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Writer</span></span><br><span class="line">P(wmutex);</span><br><span class="line"><span class="keyword">write</span></span><br><span class="line">V(wmutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Reader</span></span><br><span class="line">P(mutex);</span><br><span class="line">    <span class="keyword">if</span> readcount=<span class="number">0</span> <span class="keyword">then</span> P(wmutex);</span><br><span class="line">    readcount := readcount +<span class="number">1</span>;</span><br><span class="line">V(mutex);</span><br><span class="line"><span class="keyword">read</span></span><br><span class="line">P(mutex);</span><br><span class="line">    readcount := readcount -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> readcount=<span class="number">0</span> <span class="keyword">then</span> V(wmutex);</span><br><span class="line">V(mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.读写公平算法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//新增读写互斥变量rwmutex=1</span></span><br><span class="line"><span class="comment">//相当于读完1个之后不能继续下一个人读</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Writer</span></span><br><span class="line">P(rwmutex);</span><br><span class="line">P(wmutex);</span><br><span class="line"><span class="keyword">write</span></span><br><span class="line">V(wmutex);</span><br><span class="line">V(rwmutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Reader</span></span><br><span class="line">P(rwmutex);</span><br><span class="line">P(mutex);</span><br><span class="line">    <span class="keyword">if</span> readcount=<span class="number">0</span> <span class="keyword">then</span> P(wmutex);</span><br><span class="line">    readcount := readcount +<span class="number">1</span>;</span><br><span class="line">V(mutex);</span><br><span class="line">V(rwmutex);  <span class="comment">//释放rwmutex从而让写者先写</span></span><br><span class="line"><span class="keyword">read</span></span><br><span class="line">P(mutex);</span><br><span class="line">    readcount := readcount -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> readcount=<span class="number">0</span> <span class="keyword">then</span> V(wmutex);</span><br><span class="line">V(mutex);</span><br></pre></td></tr></table></figure><h4 id="哲学家进餐问题-the-dining-philosophers-problem"><a href="#哲学家进餐问题-the-dining-philosophers-problem" class="headerlink" title="哲学家进餐问题(the dining philosophers problem)"></a>哲学家进餐问题(the dining philosophers problem)</h4><blockquote><p>问题描述：（由Dijkstra首先提出并解决）5个哲学家围绕一张圆桌而坐，桌子上放着5支筷子，每两个哲学家之间放一支；</p><p>哲学家的动作包括思考和进餐，进餐时需要同时拿起他左边和右边的两支筷子，思考时则同时将两支筷子放回原处。</p><p>如何保证哲学家们的动作有序进行？如：不出现相邻者同时进餐；不出现有人永远拿不到筷子。</p></blockquote><h4 id="理发师问题"><a href="#理发师问题" class="headerlink" title="理发师问题"></a>理发师问题</h4><blockquote><p>理发店里有一位理发师、一把理发椅和n把供等候理发的顾客坐的椅子；</p><p>如果没有顾客，理发师便在理发椅上睡觉，当一个顾客到来时，叫醒理发师；</p><p>如果理发师正在理发时，又有顾客来到，则如果有空椅子可坐，就坐下来等待，否则就离开。</p></blockquote><h4 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h4><blockquote><p>三个吸烟者在一间房间内，还有一个香烟供应者。为了制造并抽掉香烟，每个吸烟者需要三样东西：烟草、纸和火柴。供应者有丰富的货物提供。</p><p>三个吸烟者中，第一个有自己的烟草，第二个有自己的纸，第三个有自己的火柴。</p><p>供应者将两样东西放在桌子上，允许一个吸烟者吸烟。当吸烟者完成吸烟后唤醒供应者，供应者再放两样东西（随机地）在桌面上，然后唤醒另一个吸烟者。</p><p>试为吸烟者和供应者编写程序解决问题。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-OS-2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OO-Unit2-总结</title>
      <link href="2021/04/24/OO-Unit2-%E5%B0%8F%E7%BB%93/"/>
      <url>2021/04/24/OO-Unit2-%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>OO第二单元电梯调度总结与分析。</p><h1 id="OO-Unit2-总结"><a href="#OO-Unit2-总结" class="headerlink" title="OO-Unit2-总结"></a>OO-Unit2-总结</h1><h2 id="一、程序结构分析"><a href="#一、程序结构分析" class="headerlink" title="一、程序结构分析"></a>一、程序结构分析</h2><h3 id="第五次作业"><a href="#第五次作业" class="headerlink" title="第五次作业"></a>第五次作业</h3><h4 id="代码可视化与数据统计"><a href="#代码可视化与数据统计" class="headerlink" title="代码可视化与数据统计"></a>代码可视化与数据统计</h4><h5 id="程序类图"><a href="#程序类图" class="headerlink" title="程序类图"></a>程序类图</h5><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit2/hw5.png" style="zoom:80%;" /></p><p>由于本次只有一台电梯，因此没有使用调度器，而是只设计了一个策略类<code>Scheduler</code>类来实现每到一个楼层根据当前等待的乘客和电梯中的乘客请求来确定目标楼层的功能。而电梯类和输入线程类则是本次作业的两个线程类，分别对应消费者和生产者。</p><h5 id="程序复杂度分析"><a href="#程序复杂度分析" class="headerlink" title="程序复杂度分析"></a>程序复杂度分析</h5><ul><li>类复杂度</li></ul><div class="table-container"><table><thead><tr><th>Class</th><th>OCavg</th><th>OCmax</th><th>WMC</th></tr></thead><tbody><tr><td>Elevator</td><td>4.5</td><td>7</td><td>18</td></tr><tr><td>InitQueue</td><td>1</td><td>1</td><td>7</td></tr><tr><td>InputThread</td><td>2</td><td>3</td><td>4</td></tr><tr><td>Main</td><td>2</td><td>2</td><td>2</td></tr><tr><td>Scheduler</td><td>8</td><td>16</td><td>40</td></tr><tr><td>WaitQueue</td><td>1</td><td>1</td><td>7</td></tr></tbody></table></div><p>可以看出，在<code>Elevator</code>类和<code>Scheduler</code>类中代码复杂度较高。两者构成了电梯的核心逻辑，包含较多分支。</p><ul><li>方法复杂度</li></ul><div class="table-container"><table><thead><tr><th>Method</th><th>CogC</th><th>ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>Elevator.Elevator(WaitQueue,InitQueue,String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.move(int)</td><td>6</td><td>3</td><td>3</td><td>5</td></tr><tr><td>Elevator.personFlow()</td><td>11</td><td>1</td><td>8</td><td>8</td></tr><tr><td>Elevator.run()</td><td>25</td><td>4</td><td>11</td><td>11</td></tr><tr><td>InitQueue.InitQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.addRequest(PersonRequest)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.clearQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.close()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.getRequests()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.isEnd()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.noWaiting()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InputThread.InputThread(WaitQueue,ElevatorInput)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InputThread.run()</td><td>7</td><td>3</td><td>4</td><td>4</td></tr><tr><td>Main.main(String[])</td><td>5</td><td>1</td><td>5</td><td>5</td></tr><tr><td>Scheduler.Scheduler(WaitQueue,InitQueue,String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Scheduler.getDesFloor(int)</td><td>49</td><td>13</td><td>15</td><td>21</td></tr><tr><td>Scheduler.getFloor(int,int)</td><td>26</td><td>7</td><td>3</td><td>15</td></tr><tr><td>Scheduler.getMorningFloor(int,int)</td><td>13</td><td>4</td><td>2</td><td>8</td></tr><tr><td>Scheduler.getNightFloor(int,int)</td><td>13</td><td>4</td><td>2</td><td>8</td></tr><tr><td>WaitQueue.WaitQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.addRequest(PersonRequest)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.clearQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.close()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.getRequests()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.isEnd()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.noWaiting()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr></tbody></table></div><p>可以看到，<code>getDesFloor、getFloor</code>方法和电梯类中的<code>run</code>方法由于需要处理电梯的运行，调用了很多其他方法和变量，复杂度较高。</p><h5 id="程序行数统计"><a href="#程序行数统计" class="headerlink" title="程序行数统计"></a>程序行数统计</h5><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit2/hw5line.png" alt=""></p><p>与之前代码复杂度分析保持一致，仍然是<code>Elevator</code>类和<code>Scheduler</code>类的行数最多。总有效代码函数为423行。</p><h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><h5 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h5><p>本次作业定义了一个<code>waitqueue</code>作为生产者消费者之间的托盘，在各个类之间进行共享。当<code>Main</code>类开始后，先读入这份数据的到达模式，之后启动输入线程和电梯线程，输入线程不断读入新的请求，将请求加入到等待队列中，同时<code>Elevator</code>类不断处理等待队列中的请求，处理时每到一个新的楼层就会询问<code>Scheduler</code>类获得新的目标楼层。当输入到EOF时，输入线程结束。电梯内外的全部请求都处理结束时，电梯线程也结束，之后<code>Main</code>类主线程就会结束。</p><p>具体对于三种到达模式。<code>Random</code>直接使用了<code>ALS</code>进行调度。而<code>Morning</code>模式下则是先等待2s再开始接送乘客，且当电梯内没有乘客时自动返回1楼。<code>Night</code>模式下则是对当前的等待队列进行从大到小的排序，先接高楼层的乘客，接满后直接返回1层，反复如此进行下去。</p><h5 id="同步块的设置和锁的选择"><a href="#同步块的设置和锁的选择" class="headerlink" title="同步块的设置和锁的选择"></a>同步块的设置和锁的选择</h5><p>本次的共享变量主要有<code>waitqueue</code>和<code>initqueue</code>。前者被电梯类，策略类和输入类三者共享，后者只被电梯类和策略类两者共享（此处忽略了同样共享的主类）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Elevator.run</span></span><br><span class="line"><span class="keyword">if</span> (initQueue.noWaiting() &amp;&amp; waitQueue.noWaiting()) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (waitQueue) &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            waitQueue.wait(); <span class="comment">//等待队列为空，需要先等输入线程接受新的输入</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pattern.equals(<span class="string">"Night"</span>)) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (waitQueue.getRequests()) &#123; <span class="comment">//Night模式下需要排序，给waitQueue类里的请求列表加锁</span></span><br><span class="line">        waitQueue.getRequests()</span><br><span class="line">            .sort(Comparator.comparingInt(PersonRequest::getFromFloor)); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//InputThread.run</span></span><br><span class="line"><span class="keyword">synchronized</span> (waitQueue) &#123; <span class="comment">//给waitQueue加锁保证线程安全</span></span><br><span class="line">    <span class="keyword">if</span> (request == <span class="keyword">null</span>) &#123;</span><br><span class="line">        waitQueue.close();</span><br><span class="line">        waitQueue.notifyAll(); <span class="comment">//输入结束时唤醒等待队列，让Elevator类继续处理请求</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            elevatorInput.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        waitQueue.addRequest(request);</span><br><span class="line">        waitQueue.notifyAll(); <span class="comment">//有新的输入时唤醒等待队列，让Elevator类继续处理请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Main.main </span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    inputThread.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    elevator.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="comment">//等两个线程均结束，主线程才结束</span></span><br></pre></td></tr></table></figure><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>架构较为清晰，每个类的功能都比较独立，且将策略类和电梯类分开，易于更换策略。对一个电梯的建模比较完整，便于第六次作业中增加电梯。</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p><code>Random</code>模式下只采用了标准的ALS调度方式，导致性能较差。</p><h3 id="第六次作业"><a href="#第六次作业" class="headerlink" title="第六次作业"></a>第六次作业</h3><h4 id="代码可视化与数据统计-1"><a href="#代码可视化与数据统计-1" class="headerlink" title="代码可视化与数据统计"></a>代码可视化与数据统计</h4><h5 id="程序类图-1"><a href="#程序类图-1" class="headerlink" title="程序类图"></a>程序类图</h5><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit2/hw6.png" alt=""></p><p>本次作业和上次作业相比改动幅度不大，只增加了一个调度器类。</p><h5 id="程序复杂度分析-1"><a href="#程序复杂度分析-1" class="headerlink" title="程序复杂度分析"></a>程序复杂度分析</h5><ul><li>类复杂度</li></ul><div class="table-container"><table><thead><tr><th>Class</th><th>OCavg</th><th>OCmax</th><th>WMC</th></tr></thead><tbody><tr><td>Dispatcher</td><td>3.5</td><td>10</td><td>21</td></tr><tr><td>Elevator</td><td>2.5</td><td>8</td><td>25</td></tr><tr><td>InitQueue</td><td>1</td><td>1</td><td>7</td></tr><tr><td>InputThread</td><td>3</td><td>5</td><td>6</td></tr><tr><td>Main</td><td>4</td><td>4</td><td>4</td></tr><tr><td>Scheduler</td><td>8</td><td>16</td><td>40</td></tr><tr><td>WaitQueue</td><td>1</td><td>1</td><td>7</td></tr></tbody></table></div><p>可以看出<code>Dispatcher</code>和<code>Elevator、Scheduler</code>类的复杂度较高。这三个类也是本次作业的核心类。</p><ul><li>方法复杂度</li></ul><div class="table-container"><table><thead><tr><th>Method</th><th>CogC</th><th>ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>Dispatcher.Dispatcher(WaitQueue,ArrayList<Elevator>,String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Dispatcher.dispatch()</td><td>39</td><td>3</td><td>12</td><td>12</td></tr><tr><td>Dispatcher.getMinElevatori()</td><td>3</td><td>1</td><td>2</td><td>3</td></tr><tr><td>Dispatcher.getMorningMinElevatori()</td><td>3</td><td>1</td><td>2</td><td>3</td></tr><tr><td>Dispatcher.getNightMinElevatori()</td><td>3</td><td>1</td><td>2</td><td>3</td></tr><tr><td>Dispatcher.run()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.Elevator(WaitQueue,InitQueue,String,String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.addRequest(PersonRequest)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.close()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.getInitReqNum()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.getReqNum()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.getWaitQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.getWaitReqNum()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.move(int)</td><td>6</td><td>3</td><td>3</td><td>5</td></tr><tr><td>Elevator.personFlow()</td><td>11</td><td>1</td><td>8</td><td>8</td></tr><tr><td>Elevator.run()</td><td>26</td><td>4</td><td>12</td><td>12</td></tr><tr><td>InitQueue.InitQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.addRequest(PersonRequest)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.clearQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.close()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.getRequests()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.isEnd()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.noWaiting()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InputThread.InputThread(WaitQueue,ElevatorInput,ArrayList<Elevator>,String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InputThread.run()</td><td>11</td><td>3</td><td>6</td><td>6</td></tr><tr><td>Main.main(String[])</td><td>6</td><td>1</td><td>6</td><td>6</td></tr><tr><td>Scheduler.Scheduler(WaitQueue,InitQueue,String)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Scheduler.getDesFloor(int)</td><td>49</td><td>13</td><td>16</td><td>22</td></tr><tr><td>Scheduler.getFloor(int,int)</td><td>26</td><td>7</td><td>3</td><td>15</td></tr><tr><td>Scheduler.getMorningFloor(int,int)</td><td>13</td><td>4</td><td>2</td><td>8</td></tr><tr><td>Scheduler.getNightFloor(int,int)</td><td>13</td><td>4</td><td>2</td><td>8</td></tr><tr><td>WaitQueue.WaitQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.addRequest(PersonRequest)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.clearQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.close()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.getRequests()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.isEnd()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.noWaiting()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr></tbody></table></div><p>本次复杂度较高的是调度器的<code>dispatch</code>方法，以及获得目标楼层的<code>`getDesFloor</code>方法和电梯运行的<code>run</code>方法。</p><h5 id="程序行数统计-1"><a href="#程序行数统计-1" class="headerlink" title="程序行数统计"></a>程序行数统计</h5><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit2/hw6line.png" alt=""></p><p>本次作业代码量较大，总有效行数是571行。</p><h4 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h4><h5 id="原理分析-1"><a href="#原理分析-1" class="headerlink" title="原理分析"></a>原理分析</h5><p>本次作业在上一次作业基础上主要增加了调度器类，用来实现各个电梯的负载均衡调度，采用了分布式调度，即将一个大的请求队列分配给各个电梯自己的请求队列，由各个电梯对自己的请求队列进行处理。相当于采用了两对消费者-生产者，一对是输入线程和调度器线程，一对是调度器线程和各个电梯。输入线程终止条件与上次作业相同，而调度器线程终止条件则是没有新的输入且总的请求队列为空。各个电梯自己的终止条件是自身的请求等待队列为空。具体策略上，本次作业采用了和上次作业一致的策略。</p><h5 id="同步块的设置和锁的选择-1"><a href="#同步块的设置和锁的选择-1" class="headerlink" title="同步块的设置和锁的选择"></a>同步块的设置和锁的选择</h5><p>本次作业共享的变量为总请求等待队列，各个电梯自身的请求等待队列和电梯内请求队列。<code>Elevator</code>和<code>Scheduler</code>类的同步与上次一致，不再赘述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dispatcher.dispatch</span></span><br><span class="line"><span class="keyword">if</span> (waitQueue.isEnd() &amp;&amp; waitQueue.noWaiting()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Elevator elevator : elevators) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (elevator.getWaitQueue()) &#123; <span class="comment">//遍历时给每个电梯的等待队列类加上锁保证安全</span></span><br><span class="line">            elevator.getWaitQueue().close();</span><br><span class="line">            elevator.getWaitQueue().notifyAll(); </span><br><span class="line">            <span class="comment">//输入线程结束且总等待队列为空将所有电梯的等待队列关闭，同时唤醒所有电梯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (waitQueue.noWaiting()) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (waitQueue) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                waitQueue.wait(); <span class="comment">//总等待队列为空但输入线程并未结束时，先等待</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//InputThread.run</span></span><br><span class="line"><span class="keyword">synchronized</span> (waitQueue) &#123; <span class="comment">//给总等待队列加锁，防止与调度器线程冲突</span></span><br><span class="line">    <span class="keyword">if</span> (request == <span class="keyword">null</span>) &#123;</span><br><span class="line">        waitQueue.close(); <span class="comment">//关闭总请求队列</span></span><br><span class="line">        waitQueue.notifyAll(); <span class="comment">//输入结束时唤醒调度器内的总等待队列</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            elevatorInput.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (request <span class="keyword">instanceof</span> PersonRequest) &#123;</span><br><span class="line">            waitQueue.addRequest((PersonRequest) request);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request <span class="keyword">instanceof</span> ElevatorRequest) &#123;</span><br><span class="line">            Elevator elevator = <span class="keyword">new</span> Elevator(<span class="keyword">new</span> WaitQueue(), <span class="keyword">new</span> InitQueue(),</span><br><span class="line">                                             pattern, ((ElevatorRequest) request).getElevatorId());</span><br><span class="line">            <span class="keyword">synchronized</span> (elevators) &#123; <span class="comment">//给电梯数组加锁，保证线程安全</span></span><br><span class="line">                elevators.add(elevator);</span><br><span class="line">                elevator.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        waitQueue.notifyAll(); <span class="comment">//在新的请求进入等待队列中或者加入了新电梯后唤醒所有的等待队列。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><p>在没有非必要的对第五次作业的修改基础上，只通过新增一个调度器线程类对请求进行处理，复用了电梯类和策略类，层次架构较清晰，是一次比较好的增量开发。同时，调度器每次分配请求时对现有的每个电梯内的请求人数进行比较，较好的考虑了负载均衡。</p><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><p>因为写代码不谨慎，出现了一处潜在的死循环发生区。</p><h3 id="第七次作业"><a href="#第七次作业" class="headerlink" title="第七次作业"></a>第七次作业</h3><h4 id="代码可视化与数据统计-2"><a href="#代码可视化与数据统计-2" class="headerlink" title="代码可视化与数据统计"></a>代码可视化与数据统计</h4><h5 id="程序类图-2"><a href="#程序类图-2" class="headerlink" title="程序类图"></a>程序类图</h5><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit2/hw7.png" alt=""></p><p>本次作业的架构与上次一致。</p><h5 id="程序复杂度分析-2"><a href="#程序复杂度分析-2" class="headerlink" title="程序复杂度分析"></a>程序复杂度分析</h5><ul><li>类复杂度</li></ul><div class="table-container"><table><thead><tr><th>Class</th><th>OCavg</th><th>OCmax</th><th>WMC</th></tr></thead><tbody><tr><td>Dispatcher</td><td>3.75</td><td>9</td><td>15</td></tr><tr><td>Elevator</td><td>2.93</td><td>8</td><td>41</td></tr><tr><td>InitQueue</td><td>1</td><td>1</td><td>7</td></tr><tr><td>InputThread</td><td>3</td><td>5</td><td>6</td></tr><tr><td>Main</td><td>3</td><td>3</td><td>3</td></tr><tr><td>Scheduler</td><td>6.6</td><td>14</td><td>33</td></tr><tr><td>WaitQueue</td><td>1</td><td>1</td><td>7</td></tr></tbody></table></div><ul><li>方法复杂度</li></ul><div class="table-container"><table><thead><tr><th>Method</th><th>CogC</th><th>ev(G)</th><th>iv(G)</th><th>v(G)</th></tr></thead><tbody><tr><td>Dispatcher.Dispatcher(WaitQueue,ArrayList<Elevator>,HashSet<Integer>)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Dispatcher.dispatch()</td><td>34</td><td>4</td><td>11</td><td>12</td></tr><tr><td>Dispatcher.getMinElevatori(PersonRequest)</td><td>6</td><td>1</td><td>2</td><td>4</td></tr><tr><td>Dispatcher.run()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.Elevator(WaitQueue,InitQueue,String,String,String,WaitQueue,HashSet<Integer>)</td><td>3</td><td>1</td><td>2</td><td>3</td></tr><tr><td>Elevator.addRequest(PersonRequest)</td><td>5</td><td>1</td><td>5</td><td>6</td></tr><tr><td>Elevator.canArrive(PersonRequest)</td><td>10</td><td>3</td><td>1</td><td>12</td></tr><tr><td>Elevator.canBOut(PersonRequest)</td><td>4</td><td>1</td><td>1</td><td>5</td></tr><tr><td>Elevator.canCOut(PersonRequest)</td><td>7</td><td>2</td><td>1</td><td>8</td></tr><tr><td>Elevator.close()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.getInitReqNum()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.getReqNum()</td><td>3</td><td>1</td><td>2</td><td>3</td></tr><tr><td>Elevator.getType()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.getWaitQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.getWaitReqNum()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Elevator.move(int)</td><td>8</td><td>3</td><td>3</td><td>6</td></tr><tr><td>Elevator.personFlow()</td><td>17</td><td>4</td><td>11</td><td>12</td></tr><tr><td>Elevator.run()</td><td>25</td><td>4</td><td>11</td><td>11</td></tr><tr><td>InitQueue.InitQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.addRequest(PersonRequest)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.clearQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.close()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.getRequests()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.isEnd()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InitQueue.noWaiting()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InputThread.InputThread(WaitQueue,ElevatorInput,ArrayList<Elevator>,String,HashSet<Integer>)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>InputThread.run()</td><td>11</td><td>3</td><td>6</td><td>6</td></tr><tr><td>Main.main(String[])</td><td>5</td><td>1</td><td>5</td><td>5</td></tr><tr><td>Scheduler.Scheduler(WaitQueue,InitQueue,String,int)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Scheduler.getBFloor(int,int)</td><td>4</td><td>2</td><td>1</td><td>3</td></tr><tr><td>Scheduler.getCFloor(int,int)</td><td>7</td><td>2</td><td>1</td><td>6</td></tr><tr><td>Scheduler.getDesFloor(int)</td><td>38</td><td>10</td><td>14</td><td>17</td></tr><tr><td>Scheduler.getTakeFloor(int,int)</td><td>28</td><td>7</td><td>4</td><td>16</td></tr><tr><td>WaitQueue.WaitQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.addRequest(PersonRequest)</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.clearQueue()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.close()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.getRequests()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.isEnd()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WaitQueue.noWaiting()</td><td>0</td><td>1</td><td>1</td><td>1</td></tr></tbody></table></div><h5 id="程序行数统计-2"><a href="#程序行数统计-2" class="headerlink" title="程序行数统计"></a>程序行数统计</h5><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit2/hw7line.png" alt=""></p><p>本次代码量较上次增加了60行，主要增加了与电梯性质和换乘相关的代码。</p><h4 id="代码分析-2"><a href="#代码分析-2" class="headerlink" title="代码分析"></a>代码分析</h4><h5 id="原理分析-2"><a href="#原理分析-2" class="headerlink" title="原理分析"></a>原理分析</h5><p>本次作业架构与上次一致。对调度器内部的负载均衡判定方法除了考虑电梯现有请求队列人数，加入了判断是否能停留的逻辑和优先级的逻辑（速度快的优先级高）,加入了换乘的处理逻辑。同时，改变了调度器线程的终止条件，当且仅当输入线程终止且所有换乘乘客均已到达目的地，才结束。而调度器线程的结束也才会导致若干个电梯线程的结束。具体电梯的策略类和前两次作业保持一致。</p><h5 id="同步块的设置和锁的选择-2"><a href="#同步块的设置和锁的选择-2" class="headerlink" title="同步块的设置和锁的选择"></a>同步块的设置和锁的选择</h5><p>本次作业与前两次作业比起来，由于要处理换乘的情况，加入了一个记录换乘乘客id的集合<code>checkidset</code>用来判断调度器线程的终止条件。核心的线程安全问题也主要集中在对这个集合的处理上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Elevator.run</span></span><br><span class="line"><span class="keyword">if</span> (d == <span class="number">0</span>) &#123; <span class="comment">//乘客到达目的地时</span></span><br><span class="line">    ...</span><br><span class="line">    TimableOutput.println(</span><br><span class="line">        String.format(<span class="string">"OUT-%d-%d-%s"</span>, request.getPersonId(), floor, id));</span><br><span class="line">    <span class="keyword">synchronized</span> (checkidset) &#123;</span><br><span class="line">        checkidset.remove(request.getPersonId()); <span class="comment">//将这个id从换乘id集合中移除</span></span><br><span class="line">        checkidset.notifyAll(); <span class="comment">//唤醒换乘人集合，让调度器继续作业</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((type.equals(<span class="string">"B"</span>) &amp;&amp; canBOut(request))) &#123; <span class="comment">//到达中转站</span></span><br><span class="line">  ...</span><br><span class="line">    TimableOutput.println(String.format(<span class="string">"OUT-%d-%d-%s"</span>,</span><br><span class="line">                                        request.getPersonId(), floor, id));</span><br><span class="line">    <span class="keyword">synchronized</span> (allWaitQueue) &#123;</span><br><span class="line">        PersonRequest newrequest = <span class="keyword">new</span> PersonRequest(floor,</span><br><span class="line">                                                    request.getToFloor(), request.getPersonId());</span><br><span class="line">        allWaitQueue.addRequest(newrequest); <span class="comment">//总请求等待队列新增请求</span></span><br><span class="line">        allWaitQueue.notifyAll(); <span class="comment">//唤醒总请求等待对列，让调度器继续分配请求</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (checkidset) &#123; checkidset.notifyAll(); &#125; <span class="comment">//唤醒换乘人集合，让调度器继续作业</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dispatcher.dispatch</span></span><br><span class="line"><span class="keyword">if</span> (waitQueue.isEnd() &amp;&amp; waitQueue.noWaiting()) &#123; <span class="comment">//当输入线程已经终止时</span></span><br><span class="line">    <span class="keyword">synchronized</span> (checkidset) &#123; <span class="comment">//给换乘人集合加锁</span></span><br><span class="line">        <span class="keyword">if</span> (checkidset.size() &gt; <span class="number">0</span>) &#123; <span class="comment">//当前还有换乘的乘客没有到达目的地</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                checkidset.wait(); <span class="comment">//等待乘客到达目的地或者新的换乘请求加入</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (waitQueue) &#123; <span class="comment">//处理现在的请求</span></span><br><span class="line">                ArrayList&lt;PersonRequest&gt; requests = waitQueue.getRequests();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; requests.size(); i++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> mini = getMinElevatori(requests.get(i));</span><br><span class="line">                    elevators.get(mini).addRequest(requests.get(i));</span><br><span class="line">                    <span class="keyword">synchronized</span> (elevators.get(mini).getWaitQueue()) &#123;</span><br><span class="line">                        elevators.get(mini).getWaitQueue().notifyAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                    requests.remove(i);</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (checkidset.size() &gt; <span class="number">0</span>) &#123; <span class="comment">//如果还有没到达的换乘乘客，继续下一轮循环</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Elevator elevator : elevators) &#123; <span class="comment">//所有换乘乘客均已到达，可以关闭各个线程的等待队列了</span></span><br><span class="line">        <span class="keyword">synchronized</span> (elevator.getWaitQueue()) &#123;</span><br><span class="line">            elevator.getWaitQueue().close(); </span><br><span class="line">            elevator.getWaitQueue().notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;...&#125; <span class="comment">//输入线程未终止，正常分配请求</span></span><br></pre></td></tr></table></figure><h5 id="UML时序图"><a href="#UML时序图" class="headerlink" title="UML时序图"></a>UML时序图</h5><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit2/hw7-0.png" alt=""></p><p>时序图说明：只保留了几个线程类，主要展示了整个时序流程而省略了实现细节。图中Elevator类是所有elevator的代表</p><h5 id="可扩展性分析"><a href="#可扩展性分析" class="headerlink" title="可扩展性分析"></a>可扩展性分析</h5><ol><li><strong>功能设计</strong>上。由于上次作业架构较为合理，本次作业整体改动不大，同时，在完善了对电梯类型和电梯属性的扩展后，现在的电梯的可扩展性较强，之后改动时只需要针对不同的电梯种类在电梯类做出相应的改变和扩展即可。其他地方不用改变。</li><li><strong>性能设计</strong>上。本次作业实现了换乘，但是由于各种原因没有实现对所有电梯状态的整体把握和换乘考虑，因此性能表现一般。</li></ol><h2 id="二、bug分析"><a href="#二、bug分析" class="headerlink" title="二、bug分析"></a>二、bug分析</h2><h3 id="第五次作业-1"><a href="#第五次作业-1" class="headerlink" title="第五次作业"></a>第五次作业</h3><h4 id="自己的bug"><a href="#自己的bug" class="headerlink" title="自己的bug"></a>自己的bug</h4><h5 id="bug描述"><a href="#bug描述" class="headerlink" title="bug描述"></a>bug描述</h5><p>本次作业在强测中AK，在互测中被找出一个bug</p><p>原因是线程安全没考虑周全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"Thread-1"</span> java.util.ConcurrentModificationException</span><br><span class="line">at java.util.ArrayList.sort(ArrayList.java:<span class="number">1464</span>)</span><br><span class="line">at Elevator.run(Elevator.java:<span class="number">68</span>)</span><br></pre></td></tr></table></figure><p>问题原因其实就是源于以下的代码。即是因为<code>Elevator</code>类在<code>Night</code>模式下对等待请求队列排序的处理有误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pattern.equals(<span class="string">"Night"</span>)) &#123;</span><br><span class="line">        waitQueue.getRequests()</span><br><span class="line">            .sort(Comparator.comparingInt(PersonRequest::getFromFloor));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="bug修复总结"><a href="#bug修复总结" class="headerlink" title="bug修复总结"></a>bug修复总结</h5><p>是非常明显的线程安全问题，只要给<code>waitQueue.getRequests()</code>加锁就没问题了。出现原因本质上还是自己对多线程的理解不深刻，没有养成勤加锁的好习惯。</p><h4 id="他人的bug"><a href="#他人的bug" class="headerlink" title="他人的bug"></a>他人的bug</h4><h5 id="bug描述-1"><a href="#bug描述-1" class="headerlink" title="bug描述"></a>bug描述</h5><p>本次共分别找到三个人的共计三个bug，都是由于线程安全所致，均导致了RTLE。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1 Random hack了3个同学 </span></span><br><span class="line">[1.0]Random</span><br><span class="line">[1.0]1-FROM-19-TO-1</span><br><span class="line">[1.0]2-FROM-19-TO-1</span><br><span class="line">[1.0]3-FROM-19-TO-1</span><br><span class="line">[1.0]4-FROM-19-TO-1</span><br><span class="line">[1.0]5-FROM-19-TO-1</span><br><span class="line">[1.0]133-FROM-19-TO-1</span><br><span class="line">[1.0]134-FROM-19-TO-1</span><br><span class="line">[1.0]135-FROM-19-TO-1</span><br><span class="line">[1.0]136-FROM-19-TO-1</span><br><span class="line">[1.0]137-FROM-19-TO-1</span><br><span class="line">[1.0]138-FROM-19-TO-1</span><br><span class="line">[1.0]139-FROM-19-TO-1</span><br><span class="line">[1.0]130-FROM-19-TO-1</span><br><span class="line">[1.0]6-FROM-19-TO-1</span><br><span class="line">[1.0]131-FROM-19-TO-1</span><br><span class="line">[1.0]132-FROM-19-TO-1</span><br><span class="line">[2.0]7-FROM-19-TO-1</span><br><span class="line">[2.0]8-FROM-19-TO-1</span><br><span class="line">[2.0]9-FROM-19-TO-1</span><br><span class="line">[2.0]10-FROM-19-TO-1</span><br><span class="line">[2.0]11-FROM-19-TO-1</span><br><span class="line">[2.0]12-FROM-19-TO-1</span><br><span class="line">[2.0]13-FROM-19-TO-1</span><br><span class="line">[10.0]14-FROM-19-TO-17</span><br><span class="line">[10.0]15-FROM-15-TO-19</span><br><span class="line">[10.0]16-FROM-18-TO-1</span><br><span class="line">[10.0]17-FROM-2-TO-20</span><br><span class="line">[10.0]18-FROM-20-TO-4</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">2 Night hack了1个同学</span></span><br><span class="line">[1.0]Night</span><br><span class="line">[1.0]1-FROM-19-TO-1</span><br><span class="line">[1.0]2-FROM-19-TO-1</span><br><span class="line">[1.0]3-FROM-19-TO-1</span><br><span class="line">[1.0]4-FROM-19-TO-1</span><br><span class="line">[1.0]5-FROM-19-TO-1</span><br><span class="line">[1.0]133-FROM-19-TO-1</span><br><span class="line">[1.0]134-FROM-19-TO-1</span><br><span class="line">[1.0]135-FROM-19-TO-1</span><br><span class="line">[1.0]136-FROM-19-TO-1</span><br><span class="line">[1.0]137-FROM-19-TO-1</span><br><span class="line">[1.0]138-FROM-19-TO-1</span><br><span class="line">[1.0]139-FROM-19-TO-1</span><br><span class="line">[1.0]130-FROM-19-TO-1</span><br><span class="line">[1.0]6-FROM-19-TO-1</span><br><span class="line">[1.0]131-FROM-19-TO-1</span><br><span class="line">[1.0]132-FROM-19-TO-1</span><br><span class="line">[1.0]7-FROM-19-TO-1</span><br><span class="line">[1.0]8-FROM-19-TO-1</span><br><span class="line">[1.0]9-FROM-19-TO-1</span><br><span class="line">[1.0]10-FROM-19-TO-1</span><br><span class="line">[1.0]11-FROM-19-TO-1</span><br><span class="line">[1.0]12-FROM-19-TO-1</span><br><span class="line">[1.0]13-FROM-19-TO-1</span><br><span class="line">[1.0]14-FROM-19-TO-1</span><br><span class="line">[1.0]15-FROM-19-TO-1</span><br><span class="line">[1.0]16-FROM-19-TO-1</span><br><span class="line">[1.0]17-FROM-19-TO-1</span><br><span class="line">[1.0]18-FROM-19-TO-1</span><br><span class="line">[1.0]19-FROM-19-TO-1</span><br></pre></td></tr></table></figure><h5 id="测试方式"><a href="#测试方式" class="headerlink" title="测试方式"></a>测试方式</h5><p>本单元由于与很多事情相撞，没完成评测机，所以只能一直采用阅读代码加上手动构造复杂的测试用例的方式来进行互测。基本原则就是构造请求数量和最大限制一样，且出现很多楼层跨度很大的电梯请求的测试数据。</p><h3 id="第六次作业-1"><a href="#第六次作业-1" class="headerlink" title="第六次作业"></a>第六次作业</h3><h4 id="自己的bug-1"><a href="#自己的bug-1" class="headerlink" title="自己的bug"></a>自己的bug</h4><p>本次强测中被hack1个点，互测中未被hack。</p><h5 id="bug描述-2"><a href="#bug描述-2" class="headerlink" title="bug描述"></a>bug描述</h5><p>RTLE，运行时间超过了210s</p><h5 id="bug修复总结-1"><a href="#bug修复总结-1" class="headerlink" title="bug修复总结"></a>bug修复总结</h5><p>原因如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (floor != desFloor1) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sleep(<span class="number">400</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    floor += step;</span><br><span class="line">    TimableOutput.println(</span><br><span class="line">        String.format(<span class="string">"ARRIVE-%d-%s"</span>, floor, id));</span><br><span class="line">    desFloor1 = scheduler.getDesFloor(floor);</span><br><span class="line">    <span class="comment">//缺少这行:step=floor&lt;desFloor1?:1:-1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即我每到一个楼层都会更新下一个目标楼层，而与此同时却没有更新方向。因此出现了问题。当出现新的请求与当前请求方向不一致时，会一直死循环，导致电梯通向天堂或者地狱。</p><h4 id="他人的bug-1"><a href="#他人的bug-1" class="headerlink" title="他人的bug"></a>他人的bug</h4><p>本次未发现他人bug。</p><p>尝试用上次的强测用例修改后进行hack，没有成功。</p><h3 id="第七次作业-1"><a href="#第七次作业-1" class="headerlink" title="第七次作业"></a>第七次作业</h3><h4 id="自己的bug-2"><a href="#自己的bug-2" class="headerlink" title="自己的bug"></a>自己的bug</h4><p>本次强测被hack四个点，互测被hack四个点。主要原因是因为换乘导致的唤醒遗漏问题以及两处代码逻辑问题。</p><p><strong>唤醒遗漏</strong>主要发生在B电梯的换乘处理上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">TimableOutput.println(String.format(<span class="string">"OUT-%d-%d-%s"</span>,request.getPersonId(), floor, id));</span><br><span class="line"><span class="keyword">synchronized</span> (allWaitQueue) &#123;</span><br><span class="line">    PersonRequest newrequest = <span class="keyword">new</span> PersonRequest(floor,request.getToFloor(), request.getPersonId());</span><br><span class="line">    allWaitQueue.addRequest(newrequest);</span><br><span class="line">    allWaitQueue.notifyAll();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>代码中，显然只对总的等待请求队列做了唤醒处理，却没有对checkidset也就是换乘乘客id的集合做唤醒处理，导致了在Dispatcher类中一直卡死，无法结束线程。</p><p><strong>处理逻辑</strong>主要是对B电梯的处理上有问题。一处是当B电梯中有偶数层目的地的乘客时，在到达偶数层会一直循环卡死在这一层。通过设置B电梯且为偶数层跳过的逻辑就解决了。即：<code>if (type.equals(&quot;B&quot;) &amp;&amp; floor % 2 == 0) { continue; }</code>。另一处如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lenInit == maxnum || (!initReqs.contains(mainRequest) &amp;&amp; lenInit == maxnum - <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> mainDesFloor;</span><br><span class="line">&#125;</span><br><span class="line">mainDesFloor = maxnum == <span class="number">6</span> ? getBFloor(floor, mainDesFloor) : mainDesFloor;</span><br></pre></td></tr></table></figure><p>当B电梯进行换乘时，我的代码逻辑在某些情况直接返回了主请求的目的地，而不是经过<code>getBFloor</code>函数转换后再做将进一步处理。于是导致了问题。只需要将转换的代码放在前面即可</p><p>如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mainDesFloor &#x3D; maxnum &#x3D;&#x3D; 6 ? getBFloor(floor, mainDesFloor) : mainDesFloor;</span><br><span class="line">if (lenInit &#x3D;&#x3D; maxnum || (!initReqs.contains(mainRequest) &amp;&amp; lenInit &#x3D;&#x3D; maxnum - 1)) &#123;</span><br><span class="line">    return mainDesFloor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="他人的bug-2"><a href="#他人的bug-2" class="headerlink" title="他人的bug"></a>他人的bug</h4><p>本次未发现他人bug。</p><h2 id="三、心得体会"><a href="#三、心得体会" class="headerlink" title="三、心得体会"></a>三、心得体会</h2><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><ul><li>一定要勤给变量加锁，同时也要注意锁的先后顺序避免出现死锁。</li><li>加锁后如果进行了<code>wait</code>操作一定要注意在合适的地方进行唤醒，否则就会一直卡死。这个时候最好枚举出所有需要唤醒的情况。</li><li>共享变量的维护很重要，尽量减少共享变量，同时对于共享变量一定要加锁进行操作。</li><li>一定要注意每个线程的终止条件，要考虑到尽可能全面的情况，比如第七次作业的输入结束后又产生新的换乘请求的情况。一般需要加一个新的变量来处理。</li></ul><h4 id="层次化设计"><a href="#层次化设计" class="headerlink" title="层次化设计"></a>层次化设计</h4><ul><li>在进行系统设计时，往往需要多线程模式。而这就往往需要对一些对象进行精细的不依赖于上层的建模，比如本次的单台电梯。只要写好一个电梯线程，就可以加无数个电梯，便于之后的扩展。建模过程中要注意不同模块之间的解耦，比如本单元作业就可以将电梯类和策略类分开，便于之后更换策略。</li><li>写之前要理清不同线程、不同类之间的交互关系和共享变量，并尽可能使得关系更加简洁，共享变量尽可能少。关系清晰了，才不容易出线程安全错误。</li></ul><h4 id="经验教训"><a href="#经验教训" class="headerlink" title="经验教训"></a>经验教训</h4><ul><li><p>对一个版本底气不足时不如老老实实交把握大的版本。第7次作业最后一次交的时候自知换乘的版本有很多问题，但是时间原因没法进一步debug了，就交上去了。但其实选择更稳妥的没换乘的方式至少正确性可能会好很多。</p></li><li><p>评测机很重要！！上一单元因为有较完善的评测机互测自测都很顺利。本单元没有实现评测机导致很多时候比较被动。</p></li><li>修复bug的时候最重要的是通过，所以修改的时候可以不考虑性能，纯考虑正确性来进行修改。另外<del>修复bug的时候不要按<code>Alt+Ctrl+L</code></del>，原因懂得都懂。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-OO-2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++面向对象</title>
      <link href="2021/04/22/C_C++/"/>
      <url>2021/04/22/C_C++/</url>
      
        <content type="html"><![CDATA[<p>C++的部分知识复习，为了准备考试</p><a id="more"></a><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="C-面向对象"><a href="#C-面向对象" class="headerlink" title="C++面向对象"></a>C++面向对象</h2><h3 id="1-类-amp-对象"><a href="#1-类-amp-对象" class="headerlink" title="1.类&amp;对象"></a>1.类&amp;对象</h3><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">#类定义</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> &#123;</span></span><br><span class="line">    <span class="comment">//范围修饰符: 开头定义变量与函数</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//变量定义</span></span><br><span class="line">    <span class="keyword">double</span> weight;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//函数定义</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getWeight</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age2set)</span></span>;</span><br><span class="line">    People(); <span class="comment">//构造函数</span></span><br><span class="line">    People(<span class="keyword">int</span> age2set,weight2set);</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在类定义外定义函数 在返回值类型和函数名之间加上 类名+范围解析运算符 :: </span></span><br><span class="line">People::People()&#123;</span><br><span class="line">    weight=<span class="number">70</span>;</span><br><span class="line">    age=<span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">People::People(<span class="keyword">int</span> age2set,<span class="keyword">double</span> weight2set)&#123;</span><br><span class="line">age=age2set;</span><br><span class="line">    weight=weight2set;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造函数另一种写法:初始化列表来初始化字段 与上一种写法等价</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">People::People( double age2set, double weight2set): age(age2set),weight(weight2set)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  ...</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">People::getWeight</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">People::set</span><span class="params">(<span class="keyword">int</span> age2set)</span></span>&#123;</span><br><span class="line">    age=age2set;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建People类变量</span></span><br><span class="line">People jack;</span><br><span class="line"><span class="function">People <span class="title">xiaoming</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>; <span class="comment">//创建时自动调用了构造函数</span></span><br></pre></td></tr></table></figure><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><p>在每次<strong>删除</strong>创建的对象时执行。<strong>类似构造</strong>函数，函数名与类名相同。只是函数名前要加一个<code>~</code>。</p><p>这个函数<strong>不能有返回值和参数</strong>。有助于在跳出程序前<strong>释放资源</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ~Obj();</span><br><span class="line">&#125;;</span><br><span class="line">Obj::~Obj()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Obj is being deleted"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h4><p><strong>特殊</strong>的构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形式</span></span><br><span class="line">classname (<span class="keyword">const</span> classname &amp;obj) &#123;</span><br><span class="line">   <span class="comment">// 构造函数的主体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Obj(<span class="keyword">int</span> len);</span><br><span class="line">   Obj(<span class="keyword">const</span> Obj &amp;obj);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line">Obj::Obj(<span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    p=<span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    *p=len; <span class="comment">//构造函数</span></span><br><span class="line">&#125;</span><br><span class="line">Obj::Obj(<span class="keyword">const</span> Obj &amp;obj)</span><br><span class="line">&#123;</span><br><span class="line">    p=<span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    *p=*obj.p; <span class="comment">//拷贝</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Obj <span class="title">obja</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">Obj objb = obja; <span class="comment">//调用了拷贝构造函数</span></span><br></pre></td></tr></table></figure><h4 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h4><p><code>friend</code> 关键字对函数进行声明即可，友元函数可以访问这个类的所有成员。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">printa</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassB</span>;</span> <span class="comment">//ClassB中所有函数都成为了Obj对象的友元函数</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><p>加上<code>inline</code> 关键字即可。一种用<strong>空间换时间</strong>的方式，在编译时会在每个调用这个函数的位置放置这个函数副本，所以<strong>空间开销大</strong>。</p><p>一般要使用最好行数较短，<strong>1-5行</strong>为宜，不要出现分支。</p><p>比如<code>Max</code>,<code>Min</code>等。</p><h4 id="对象指针"><a href="#对象指针" class="headerlink" title="对象指针"></a>对象指针</h4><h5 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h5><p>是一个指向自身的指针，用<code>this-&gt;变量/方法名</code>来使用。</p><p><strong>普通对象指针</strong>用法与this一样。</p><h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><p><code>static</code> 关键词来定义。</p><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><p>创建第一个类对象时若<strong>无其他初始化语句</strong>，所有的静态数据会<strong>清0</strong>。之后所有<strong>新创建的同类</strong>都<strong>共享</strong>这个数据。</p><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><p>不能使用<strong>this</strong>指针。必须使用<code>classname::fun()</code>的形式来调用。</p><h3 id="2-C-继承"><a href="#2-C-继承" class="headerlink" title="2.C++继承"></a>2.C++继承</h3><p><strong>基本形式</strong>是<code>class A:access-specifier B;</code></p><p>同时，也可以<strong>多继承</strong>。如下代码所示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;派生类名&gt;:</span>&lt;继承方式<span class="number">1</span>&gt;&lt;基类名<span class="number">1</span>&gt;,&lt;继承方式<span class="number">2</span>&gt;&lt;基类名<span class="number">2</span>&gt;,…</span><br><span class="line">&#123;</span><br><span class="line">&lt;派生类类体&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>修饰符</strong>是<code>public/protected/private</code>，一般用<code>public</code>，即父类的<code>public/protected</code>成员都作为相同的权限被定义在子类中。其他两种则是将父类的<code>public/protected</code>成员作为相应的权限被定义。同时，三种定义皆不能访问到父类的<code>private</code>成员。</p><p>C++<strong>继承函数</strong>比较麻烦。</p><p>以下三种是不会继承的。其他符合权限限制的都可以访问。</p><ul><li>基类的<strong>构造函数</strong>、<strong>析构函数</strong>和<strong>拷贝构造函数</strong>。</li><li>基类的<strong>重载运算符</strong>。</li><li>基类的<strong>友元函数</strong>。</li></ul><p>这里实在太复杂，先简单罗列一下最常用的<strong>构造函数的继承使用说明</strong>。</p><p>构造原则如下（这里参考了这篇博客 <a href="https://blog.csdn.net/lzbzclz/article/details/105062566" target="_blank" rel="noopener">https://blog.csdn.net/lzbzclz/article/details/105062566</a>)：</p><ol><li>在类的继承的过程中，如果子类<strong>没有定义构造函数</strong>，程序就会<strong>自动调用父类</strong>的<strong>构造函数</strong>。</li><li>如果子类<strong>定义了构造函数</strong>且父类是<strong>无参</strong>的构造函数，那么创建类的时候会自动<strong>先调用父类的构造函数</strong>，再调用子类的构造函数。</li><li>如果子类<strong>定义了构造函数</strong>且没有显示调用父类中<strong>唯一的带参构造函数</strong>，程序会报错。</li><li>调用父类构造函数的时候得用<strong>初始化父类成员对象</strong>的方式。</li></ol><p>举例如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//报错的代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> a);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line">A::A(<span class="keyword">int</span> a)&#123;</span><br><span class="line">    <span class="keyword">this</span>.a=a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    B(<span class="keyword">int</span> b);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line">B::B(<span class="keyword">int</span> b)&#123;</span><br><span class="line">    <span class="keyword">this</span>.b=b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">B <span class="title">b</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> a);</span><br><span class="line">    <span class="comment">//在这里加一个不带参数的构造函数也可</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line">A::A(<span class="keyword">int</span> a)&#123;</span><br><span class="line">    <span class="keyword">this</span>.a=a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    B(<span class="keyword">int</span> b);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line">B::B(<span class="keyword">int</span> b):A(<span class="number">10</span>)&#123;</span><br><span class="line">    <span class="keyword">this</span>.b=b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">B <span class="title">b</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="3-重载运算符和重载函数"><a href="#3-重载运算符和重载函数" class="headerlink" title="3.重载运算符和重载函数"></a>3.重载运算符和重载函数</h3><p><strong>函数</strong>和<strong>运算符</strong>都可以进行重载</p><p>调用时编译器通过<strong>使用的参数类型</strong>与<strong>定义</strong>中的进行比较，选择合适的，称为<strong>重载决策</strong>。</p><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"No Parameter!"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">string</span> a)</span> </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt; <span class="string">"p1:"</span> &lt;&lt; a;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">A a;</span><br><span class="line">A.<span class="built_in">print</span>();</span><br><span class="line">A.print1(<span class="string">"a"</span>);</span><br></pre></td></tr></table></figure><h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><p>关键字 <code>operator</code> 和其后要<strong>重载的运算符符号</strong>构成的，可以视为一个函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//如果在类内只需要传入一个Box参数</span></span><br><span class="line">        Box <span class="keyword">operator</span>+(<span class="keyword">const</span> Box&amp; b) &#123;</span><br><span class="line">            Box box;</span><br><span class="line">            box.a = <span class="keyword">this</span>-&gt;a+b-&gt;a;</span><br><span class="line">            box.b = <span class="keyword">this</span>-&gt;b+b-&gt;b;</span><br><span class="line">            <span class="keyword">return</span> box;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果在类外传入两个Box参数</span></span><br><span class="line">Box <span class="keyword">operator</span>+(<span class="keyword">const</span> Box&amp; b1,<span class="keyword">const</span> Box&amp; b2) &#123;</span><br><span class="line">    Box box;</span><br><span class="line">    box.a = b1-&gt;a+b2-&gt;a;</span><br><span class="line">    box.b = b1-&gt;b+b2-&gt;b;</span><br><span class="line">    <span class="keyword">return</span> box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-C-多态"><a href="#4-C-多态" class="headerlink" title="4.C++多态"></a>4.C++多态</h3><p><strong>继承关联</strong>时会用到<strong>多态</strong></p><p><strong>调用成员函数</strong>时<strong>根据对象类型</strong>执行不同函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> <span class="built_in">width</span>, <span class="built_in">height</span>;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      Shape( <span class="keyword">int</span> a=<span class="number">0</span>, <span class="keyword">int</span> b=<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">width</span> = a;</span><br><span class="line">         <span class="built_in">height</span> = b;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">"Parent class area :"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      Rectangle( <span class="keyword">int</span> a=<span class="number">0</span>, <span class="keyword">int</span> b=<span class="number">0</span>):Shape(a, b) &#123; &#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">area</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">"Rectangle class area :"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">         <span class="keyword">return</span> (<span class="built_in">width</span> * <span class="built_in">height</span>); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span>:</span> <span class="keyword">public</span> Shape&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      Triangle( <span class="keyword">int</span> a=<span class="number">0</span>, <span class="keyword">int</span> b=<span class="number">0</span>):Shape(a, b) &#123; &#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">area</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">"Triangle class area :"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">         <span class="keyword">return</span> (<span class="built_in">width</span> * <span class="built_in">height</span> / <span class="number">2</span>); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Shape *shape;</span><br><span class="line">   <span class="function">Rectangle <span class="title">rec</span><span class="params">(<span class="number">10</span>,<span class="number">7</span>)</span></span>;</span><br><span class="line">   <span class="function">Triangle  <span class="title">tri</span><span class="params">(<span class="number">10</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 存储矩形的地址</span></span><br><span class="line">   shape = &amp;rec;</span><br><span class="line">   <span class="comment">// 调用矩形的求面积函数 area</span></span><br><span class="line">   shape-&gt;area();</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 存储三角形的地址</span></span><br><span class="line">   shape = &amp;tri;</span><br><span class="line">   <span class="comment">// 调用三角形的求面积函数 area</span></span><br><span class="line">   shape-&gt;area(); </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，由于基类中实定义了函数，后面两处都输出 <code>Parent class area:</code>  </p><ul><li>这里也被称为 <strong>静态多态/静态链接</strong>，在程序执行前就已经将<code>area</code>函数定死了。</li></ul><p>只需要在基类的函数定义前加关键字<code>virtual</code>，进行<strong>虚定义</strong>，后面输出的就是正常的各自的输出。</p><p>这时就是根据不同的指针地址的位置的 <code>area</code> 函数来执行了。</p><h5 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带实现的虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">area</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//纯虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">area</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="5-C-数据抽象与封装"><a href="#5-C-数据抽象与封装" class="headerlink" title="5.C++数据抽象与封装"></a>5.C++数据抽象与封装</h3><ul><li>数据抽象：仅向用户<strong>暴露接口</strong>而<strong>隐藏具体实现细节</strong>的机制。</li><li><p>数据封装：把数据和操作数据的函数捆绑在一起的机制。</p></li><li><p>数据成员和外界不需要的类内方法函数用<code>private</code>，外部接口方法用<code>public</code></p></li></ul><h3 id="6-C-接口（抽象类）"><a href="#6-C-接口（抽象类）" class="headerlink" title="6.C++ 接口（抽象类）"></a>6.C++ 接口（抽象类）</h3><p>接口：类中<strong>至少有一个函数</strong>被声明为<strong>纯虚函数</strong>，则这个类就是<strong>抽象类</strong></p><p>这个和<code>Java</code>中的<strong>接口</strong>是一样的，直接用接口去定义一个实例会报错，需要具体实现</p><p>比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="comment">// 纯虚函数</span></span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getVolume</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setLength</span><span class="params">(<span class="keyword">double</span> length)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>-&gt;length = length;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> length;      <span class="comment">// 长度</span></span><br><span class="line">      <span class="keyword">double</span> breadth;     <span class="comment">// 宽度</span></span><br><span class="line">      <span class="keyword">double</span> <span class="built_in">height</span>;      <span class="comment">// 高度</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoxChild</span>:</span><span class="keyword">public</span> Box</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getVolume</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;length;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="课程思维导图"><a href="#课程思维导图" class="headerlink" title="课程思维导图"></a>课程思维导图</h3><p><img src="/.top//微信图片_20210527063529.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    
    
    <entry>
      <title>OS-C语言基础</title>
      <link href="2021/03/30/OS-C-Basic/"/>
      <url>2021/03/30/OS-C-Basic/</url>
      
        <content type="html"><![CDATA[<p>近期操作系统课上测试因为C语言的薄弱基础接连受到暴击，笔者痛下决心一定要开始一篇C语言基础总结的博客，时间有限，本次先将OS两次课上的坑总结一下，以后再补充其他的。</p><a id="more"></a><h2 id="数据类型与移位运算"><a href="#数据类型与移位运算" class="headerlink" title="数据类型与移位运算"></a>数据类型与移位运算</h2><p><code>unsigned int</code> 是无符号整数</p><p><code>int</code>有符号整数</p><p>对上述两者赋值时，都是将右边的数字的补码存入相应地址中。</p><p>比如：<code>int a = -1;unsigned a = -1;</code>其实这两个<code>a</code>存的变量内容一样，都是<code>FFFFFFFF</code>（负数的首位为1不变，其他位取反然后整体+1.）</p><p>上述两者如果用<code>%d</code>输出，都会输出一个<code>-1</code>，但是如果输出一个<code>%u</code>则会输出32位无符号整数。另外,<code>%o</code>是8进制，<code>%x</code>是输出十六进制</p><p>同理对于其他的<code>char/unsigned char</code> <code>long/unsigned long</code>等。</p><p>同时，在C语言中默认为十进制数字，可以直接用0x开头表示十六进制，0开头表示8进制，0b开头表示二进制数字。如：<code>0x1af 0176 0b101</code></p><p>同时建立起一个意识就是OS课中C语言中的最小单位可以认为是char，即一个字节</p><h2 id="大小端转换"><a href="#大小端转换" class="headerlink" title="大小端转换"></a>大小端转换</h2><p>那么再有了移位的运算符知识我们就可以实现lab1-1课上的Extra的大小端转换问题了。</p><p>大小端是针对字节来说的，对于一个数字0x12345678来说下图是一个<strong>小端存储</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">           -------------------------------------</span><br><span class="line">首地址0x4000|00010010|00110100|01010110|01111000|末尾地址0x4004</span><br><span class="line">           -------------------------------------</span><br></pre></td></tr></table></figure><p>而这张是一个<strong>大端存储</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">           -------------------------------------</span><br><span class="line">首地址0x4000|01111000|01010110|00110100|00010010|末尾地址0x4004</span><br><span class="line">           -------------------------------------</span><br></pre></td></tr></table></figure><p>即每个字节内其实都是按照所谓的”小端存储”，而大端存储相当于是把小端存储的字节序列倒序排列了。</p><p>一般的x86/ARM架构其实都是小端存储为主，但是也时常有解析大端存储数据的需求。</p><p>有了这些就可以进行转换了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1 = <span class="number">0xff</span>&lt;&lt;<span class="number">24</span>;</span><br><span class="line"><span class="keyword">int</span> a2 = <span class="number">0xff</span>&lt;&lt;<span class="number">16</span>;</span><br><span class="line"><span class="keyword">int</span> a3 = <span class="number">0xff</span>&lt;&lt;<span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> a4 = <span class="number">0xff</span>; <span class="comment">//本来以为必须要定义成unsigned，结果其实不用也可以</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0x12345678</span>;</span><br><span class="line"><span class="comment">//注意优先级，可以输出一下这个看看 a = (a &lt;&lt; 24) &amp; a1 + (a &lt;&lt; 8) &amp; a2 + (a &gt;&gt; 8) &amp; a3 + (a &gt;&gt; 24) &amp; a4; 结果为0</span></span><br><span class="line">a = ((a&lt;&lt;<span class="number">24</span>)&amp;a1) + ((a&lt;&lt;<span class="number">8</span>)&amp;a2) + ((a&gt;&gt;<span class="number">8</span>)&amp;a3) + ((a&gt;&gt;<span class="number">24</span>)&amp;a4); </span><br><span class="line"><span class="comment">// a = 0x78563412</span></span><br></pre></td></tr></table></figure><p>一旦遇到移位运算符，逻辑运算符，多加括号是个好习惯。</p><h2 id="指针与结构体"><a href="#指针与结构体" class="headerlink" title="指针与结构体"></a>指针与结构体</h2><p><code>sizeof(type)</code> 返回该变量所占字节数</p><p>指针本质上可以理解为一个<code>int</code>型变量，存着一个32位的地址数据，因为有内存里其他数据的辅助，可以解析相应地址的变量。</p><p>而数组和指针没有本质区别，即如下面所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *b=a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,a[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,b[<span class="number">1</span>]);<span class="comment">//b[1]和*(b+1)一样</span></span><br></pre></td></tr></table></figure><p>结构体的基本使用方式回顾</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s1</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s1</span> <span class="title">t1</span>;</span></span><br><span class="line">t1.a=<span class="number">12</span>;t1.b=<span class="string">'a'</span>;t1.c=<span class="string">'b'</span>;t1.d=<span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s1</span> * <span class="title">t1p</span> = <span class="title">t1</span>;</span></span><br><span class="line">t1-&gt;a=<span class="number">13</span>; <span class="comment">//指针需要使用箭头的引用方式</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s1</span> * <span class="title">tp</span> = (<span class="title">struct</span> <span class="title">s1</span> *) <span class="title">addr</span>;</span><span class="comment">//将一个地址转换成结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s1</span> <span class="title">t</span> = *((<span class="title">struct</span> <span class="title">s1</span> *) <span class="title">addr</span>);</span><span class="comment">//将一个地址转换成结构体变量</span></span><br></pre></td></tr></table></figure><p>值得注意的是结构体内会很<strong>贴心</strong>的（一个哥们直接被这个坑了，挂了一次课上）将第二个b/c这两个char变量放在a变量后的连续两个字节里,然后空两个字节之后继续存d变量。即是下图这样的（一个*代表一个字节）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aaaabc  dddd</span><br><span class="line">************</span><br></pre></td></tr></table></figure><p>所以第二次课上如果想直接使用寻找四个变量的地址的方式，就应该先加一个<code>sizeof(int)</code>得到b，再加一个<code>sizeof(char)</code>得到c，再加两个<code>sizeof(char)</code>得到d</p><p>而笔者则是采用了直接将得到的变量利用结构体指针强制转换成结构体变量再进行使用的方式，但是课上测试时，在输出结构体变量内的数字时没有对符号进行清零导致了错误。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-OS-2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OO-Unit1-总结</title>
      <link href="2021/03/25/OO-Unit1-%E5%B0%8F%E7%BB%93/"/>
      <url>2021/03/25/OO-Unit1-%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>2021年北航OO课程的第一单元—表达式求导作业项目总结。</p><p>本单元中，有过因为疏忽大意出现重大错误导致被hack惨的痛苦经历，也有未被hack成功的喜悦体验，下面就来对这一单元的内容做一下梳理和回顾。</p><a id="more"></a><h1 id="OO-Unit1-总结"><a href="#OO-Unit1-总结" class="headerlink" title="OO-Unit1-总结"></a>OO-Unit1-总结</h1><h2 id="一、程序结构分析"><a href="#一、程序结构分析" class="headerlink" title="一、程序结构分析"></a>一、程序结构分析</h2><h3 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h3><h4 id="代码可视化与数据统计"><a href="#代码可视化与数据统计" class="headerlink" title="代码可视化与数据统计"></a>代码可视化与数据统计</h4><h5 id="程序类图"><a href="#程序类图" class="headerlink" title="程序类图"></a>程序类图</h5><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit1/hw1.png" style="zoom:80%;" /></p><p>可以看出，本次作业<code>Item</code>类中含有两个多余的方法，而整体架构上并没有严格遵循高内聚低耦合的原则，需要对各个类进行化简。</p><h5 id="程序复杂度分析"><a href="#程序复杂度分析" class="headerlink" title="程序复杂度分析"></a>程序复杂度分析</h5><div class="table-container"><table><thead><tr><th>Class</th><th>OCavg</th><th>OCmax</th><th>WMC</th></tr></thead><tbody><tr><td>Item</td><td>3.33</td><td>12</td><td>20</td></tr><tr><td>Main</td><td>2</td><td>2</td><td>4</td></tr><tr><td>Poly</td><td>4</td><td>12</td><td>20</td></tr></tbody></table></div><p>可以看出，在<code>Item</code>类和<code>Poly</code>类中代码复杂度较高，含有过多的判断语句。</p><h5 id="程序行数统计"><a href="#程序行数统计" class="headerlink" title="程序行数统计"></a>程序行数统计</h5><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit1/hw1_sta.png" style="zoom:80%;" /></p><p>本次的<code>Main</code>类中的有效行数达到了31行，过多。</p><h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><h5 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h5><p><code>Main</code>类中含有对字符串的预处理<code>process</code>方法，包含去除空白字符和对加减号的替换。</p><p><code>Item</code>类中记录了一个项的系数和幂指数。</p><p><code>Poly</code>类中记录了一个多项式的系数和幂指数的幂指数到系数的<code>HashMap</code>，以及相应的求导化简方法。</p><p>具体运行时，先对输入的字符串做好预处理，同时产生一个<code>Item</code>类的列表，之后将这个列表存入<code>Poly</code>类中利用<code>initMap</code>方法转换成<code>HashMap</code>，转换同时进行了化简，之后再完成求导方法。</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>针对本次任务，字符串处理后根据符号分割的速度快，操作简便。之后将表达式每一项先进行化简再进行求导操作，类之间耦合程度较低，同时化简效果较好。</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>可扩展性较弱，字符串处理的方法仅仅适用于本次作业，之后两次作业均不适用。</p><h3 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h3><h4 id="代码可视化与数据统计-1"><a href="#代码可视化与数据统计-1" class="headerlink" title="代码可视化与数据统计"></a>代码可视化与数据统计</h4><h5 id="程序类图-1"><a href="#程序类图-1" class="headerlink" title="程序类图"></a>程序类图</h5><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit1/hw2.png" style="zoom: 50%;" /></p><p>本次作业基本达到了高内聚低耦合的目的，每个类的功能相对独立，除了<code>Expression</code>类外没有特别臃肿的类。</p><h5 id="程序复杂度分析-1"><a href="#程序复杂度分析-1" class="headerlink" title="程序复杂度分析"></a>程序复杂度分析</h5><div class="table-container"><table><thead><tr><th>Class</th><th>OCavg</th><th>OCmax</th><th>WMC</th></tr></thead><tbody><tr><td>Constant</td><td>1</td><td>1</td><td>5</td></tr><tr><td>ExprFactor</td><td>1</td><td>1</td><td>6</td></tr><tr><td>ExprNode</td><td>2.62</td><td>7</td><td>21</td></tr><tr><td>Expression</td><td>3.33</td><td>8</td><td>40</td></tr><tr><td>FactorFather</td><td>1</td><td>1</td><td>9</td></tr><tr><td>Item</td><td>5.5</td><td>14</td><td>55</td></tr><tr><td>Main</td><td>1</td><td>1</td><td>1</td></tr><tr><td>PowerFun</td><td>3.43</td><td>13</td><td>24</td></tr><tr><td>TriFun</td><td>4.33</td><td>20</td><td>39</td></tr></tbody></table></div><p>可以看出<code>Expression</code>和<code>Item</code>类的复杂度较高。</p><h5 id="程序行数统计-1"><a href="#程序行数统计-1" class="headerlink" title="程序行数统计"></a>程序行数统计</h5><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit1/hw2_sta.png" style="zoom:80%;" /></p><p>本次作业代码量较大，总有效行数是751行，其中代码行数最长地就是<code>Expression</code>类</p><h4 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h4><h5 id="原理分析-1"><a href="#原理分析-1" class="headerlink" title="原理分析"></a>原理分析</h5><p>本次作业使用了多叉树作为数据结构建立表达式树。采用了递归下降的方式对输入的表达式进行解析。</p><p>表达式树分为三个层次，如下图所示。</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit1/pic.png" style="zoom:80%;" /></p><p>其中表达式层可以看成是若干个项的对象组成的列表，项层可以看成是若干个因子对象组成的列表，而因子里的表达式因子里的表达式也符合这里的表达式定义。</p><p>对最小层次因子，本次作业我建立了<code>Factor</code>抽象类，同时使用一个父类<code>FactorFather</code>类对<code>Factor</code>类的各个方法进行实现，并让各个具体的因子类继承这个父类，达到了使用<code>Factor</code>对象就可以对所有的因子类进行无差别调用和管理的目的。<code>Factor</code>类主要的重写方法有<code>toString</code>输出原因子方法，<code>diff</code>求导方法，返回值都是字符串。</p><p><code>Item</code>类中主要有<code>diff</code>、<code>simplify</code>方法。分别对应求导，化简。求导具体是用递归的方式计算第一个因子的导数乘以后面所有因子的乘积加第一个因子乘以后面所有因子的乘积的导数。化简方法将项转换成$a<em>x^k</em>sin(x)^m<em>cos(x)^n</em>若干个表达式因子相乘$的形方便合并同类项。</p><p><code>ExprNode</code>类定义了表达式树的根节点。里面也含有<code>diff</code>、<code>simplify</code>方法。求导方法拼接每个项的求导输出，化简方法则是将相同的项进行合并。</p><p><code>Expression</code>类包含了一个<code>ExprNode</code>对象，具体的求导输出也是调用了相关接口。同时<code>Expression</code>类也包含了对输入字符串的递归下降的解析过程和相关方法。包含了<code>getExpression、getItem、getFactor、getExprFactor、getTriFun、getPowFun、getNumber、getConstant</code>等方法。最后调用<code>getExpression</code>方法对输入进行解析并将结果存入<code>exprNode</code>对象中。</p><p>求导之后，将导数的字符串重新进行解析化简，得到较为简单的结果。</p><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><p>利用递归下降和表达式树对输入字符串进行了快速准确的解析，同时对同类项进行了一定程度的合并，可以达到较好的化简效果。</p><p>求导方法自下而上，各层之间关系清晰，且可以简便的使用同一种方式遍历所有的项和因子进行操作。</p><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><p>对于表达式的深合并和化简没有完成，同时没有定义清晰的复合求导，嵌套求导接口，对于比第三次作业更复杂的合并方式（比如增加各种嵌套）本次作业代码可扩展性一般。</p><h3 id="第三次作业"><a href="#第三次作业" class="headerlink" title="第三次作业"></a>第三次作业</h3><h4 id="代码可视化与数据统计-2"><a href="#代码可视化与数据统计-2" class="headerlink" title="代码可视化与数据统计"></a>代码可视化与数据统计</h4><h5 id="程序类图-2"><a href="#程序类图-2" class="headerlink" title="程序类图"></a>程序类图</h5><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit1/hw3.png" style="zoom: 33%;" /></p><h5 id="程序复杂度分析-2"><a href="#程序复杂度分析-2" class="headerlink" title="程序复杂度分析"></a>程序复杂度分析</h5><div class="table-container"><table><thead><tr><th>Class</th><th>OCavg</th><th>OCmax</th><th>WMC</th></tr></thead><tbody><tr><td>Constant</td><td>1</td><td>1</td><td>5</td></tr><tr><td>ExprFactor</td><td>1</td><td>1</td><td>6</td></tr><tr><td>ExprNode</td><td>2.62</td><td>7</td><td>21</td></tr><tr><td>Expression</td><td>5.31</td><td>11</td><td>69</td></tr><tr><td>FactorFather</td><td>1</td><td>1</td><td>9</td></tr><tr><td>Item</td><td>4.7</td><td>13</td><td>47</td></tr><tr><td>Main</td><td>2</td><td>2</td><td>2</td></tr><tr><td>PowerFun</td><td>3.43</td><td>13</td><td>24</td></tr><tr><td>TriFun</td><td>3.73</td><td>12</td><td>41</td></tr><tr><td>WFexception</td><td>1</td><td>1</td><td>1</td></tr><tr><td>WFjudge</td><td>1.67</td><td>3</td><td>5</td></tr></tbody></table></div><h5 id="程序行数统计-2"><a href="#程序行数统计-2" class="headerlink" title="程序行数统计"></a>程序行数统计</h5><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/OO-Unit1/hw3_sta.png" style="zoom:80%;" /></p><p>本次代码量较上次增加了150行，主要是增加了格式正确性判断的逻辑以及修改了部分解析表达式的代码。</p><h4 id="代码分析-2"><a href="#代码分析-2" class="headerlink" title="代码分析"></a>代码分析</h4><h5 id="原理分析-2"><a href="#原理分析-2" class="headerlink" title="原理分析"></a>原理分析</h5><p>本次代码在上次的代码基础上修改了对三角函数的解析函数以及增加了嵌套求导、正确格式检查（包含了对空白字符，非法字符的解析），改动量较小。具体原理与上次作业类似。</p><p>具体方法上，增加了<code>getWhite</code>方法读入空白字符而没有做预处理，同时如果代码中遇到了不符合格式规范的输入序列，直接抛出异常，在<code>Main</code>类中进行接受和处理。</p><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><p>格式检查正确性较好，检查的比较完整。较上次作业改动不大，可以认为是比较符合设计模式中的开放-封闭原则。</p><h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><p>为了求稳，化简效果较差，仅完成了和上次程度一样的化简。</p><h2 id="二、bug分析"><a href="#二、bug分析" class="headerlink" title="二、bug分析"></a>二、bug分析</h2><h3 id="第一次作业-1"><a href="#第一次作业-1" class="headerlink" title="第一次作业"></a>第一次作业</h3><h4 id="自己的bug"><a href="#自己的bug" class="headerlink" title="自己的bug"></a>自己的bug</h4><h5 id="bug描述"><a href="#bug描述" class="headerlink" title="bug描述"></a>bug描述</h5><p>本次作业在强测中AK，在互测中被找出一个bug</p><p>被一些比较长且负号很多的用例测的时候有可能会产生下述bug：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.IllegalArgumentException: Comparison method violates its general contract!</span><br><span class="line">at java.util.TimSort.mergeLo(TimSort.java:<span class="number">777</span>)</span><br><span class="line">at java.util.TimSort.mergeAt(TimSort.java:<span class="number">514</span>)</span><br><span class="line">at java.util.TimSort.mergeCollapse(TimSort.java:<span class="number">441</span>)</span><br><span class="line">at java.util.TimSort.sort(TimSort.java:<span class="number">245</span>)</span><br><span class="line">at java.util.Arrays.sort(Arrays.java:<span class="number">1512</span>)</span><br><span class="line">at java.util.ArrayList.sort(ArrayList.java:<span class="number">1462</span>)</span><br><span class="line">at java.util.Collections.sort(Collections.java:<span class="number">175</span>)</span><br><span class="line">at Poly.getOutput(Poly.java:<span class="number">51</span>)</span><br><span class="line">at Poly.diff(Poly.java:<span class="number">42</span>)</span><br><span class="line">at Main.main(Main.java:<span class="number">17</span>)</span><br></pre></td></tr></table></figure><p>问题原因其实就是源于以下的代码。以下代码位于<code>Poly.java</code>的输出函数中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(ls, (Comparator) (o1, o2) -&gt; &#123;</span><br><span class="line">    BigInteger i1 = (BigInteger) o1;</span><br><span class="line">    BigInteger i2 = (BigInteger) o2;</span><br><span class="line">    <span class="keyword">if</span> (miXiMap.get(i1).compareTo(BigInteger.valueOf(<span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (miXiMap.get(i2).compareTo(BigInteger.valueOf(<span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i2.compareTo(i1);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>简单来说就是对一个容器进行排序时（首先本次作业排序就没必要，但笔者非常脑残地进行了降幂排序），比较函数里不能出现两个相互矛盾返回值逻辑，或者至少不要调用除了这个对象外部的变量。比如我的上述代码例子里，其实就是想降幂排序的同时将负号的移到后面去以此来简化长度，这个过程调用了外部的<code>HashMap</code>中对应幂指数的系数，这就会和JDK的底层实现相矛盾，于是造成了错误。</p><h5 id="bug修复总结"><a href="#bug修复总结" class="headerlink" title="bug修复总结"></a>bug修复总结</h5><p>和找出我这个bug的同学交流了一下，其实该大佬根本没看出我这个代码有啥问题，单纯用大规模的随机数据把我刀了，所以建议大家如果遇到没有必要的需求千万不要一时兴起随意加入，即使要加入也要好好翻翻文档看看能不能这么用。</p><p>那么我是怎么修改的呢，其实非常简单，我只需要查找整个序列找到一个系数为负的把他和第一个交换一下就好了。</p><p>这次bug修复也让我意识到了，简单的功能用更少的代码不一定能实现更好的效果，有时候偷懒其实会害了自己。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (miXiMap.get(ls.get(<span class="number">0</span>)).compareTo(BigInteger.ZERO) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> j = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ls.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (miXiMap.get(ls.get(i)).compareTo(BigInteger.ZERO) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            j = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j != -<span class="number">1</span>) &#123;</span><br><span class="line">        BigInteger x = ls.get(j);</span><br><span class="line">        ls.remove(j);</span><br><span class="line">        ls.add(<span class="number">0</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="他人的bug"><a href="#他人的bug" class="headerlink" title="他人的bug"></a>他人的bug</h4><h5 id="bug描述-1"><a href="#bug描述-1" class="headerlink" title="bug描述"></a>bug描述</h5><p>本次共分别找到两个人的共计三个bug，由于不太了解OO玩法，第一次多交了一些错误类型差不多的数据（第二次作业我交的少多了），这里向两位同学抱歉了，以后我保证不交那么多同质用例了，纯属浪费时间。</p><p>具体hack用例和结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1 符号parse有问题 hack 2人</span></span><br><span class="line">input:+++8*x*x**+78+x**6504-+-3313147-++69209*x**-7375*x+--837214</span><br><span class="line">output:510347166*x**-7375-6504*x**-6505+632*x**78</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">2 对于没有指数的数字parse有误 抛出了异常 hack 1人</span></span><br><span class="line">input:-+-2048*52*x++9-++6*-6*x**+138-x*x+x*+406*x**36+1-+-7320*+01+x**266*-530*4---458-+-622+x*5872*+51+-1343+x**13*x**0*x**465+x*x*579713++x**-8029*x*353*9463-+79*x**+239*x-+-681--x*-8200+++9223*x+x**867*851*1*-5--x**0*-4</span><br><span class="line">output:</span><br><span class="line">Exception in thread "main" java.lang.NumberFormatException: Zero length BigInteger</span><br><span class="line">at java.math.BigInteger.&lt;init&gt;(BigInteger.java:420)</span><br><span class="line">at java.math.BigInteger.&lt;init&gt;(BigInteger.java:606)</span><br><span class="line">at Term.&lt;init&gt;(Term.java:53)</span><br><span class="line">at Box.&lt;init&gt;(Box.java:26)</span><br><span class="line">at Main.main(Main.java:14)</span><br></pre></td></tr></table></figure><p>第一个bug主要是这两位同学都采用了字符串预处理的方式，但是并没有涵盖所有的情况，比如<code>---</code>、<code>-+-</code>这样的三符号情况导致出错。</p><p>第二个bug因为一位同学在解析数字时将空串传给了<code>BigInteger</code>对象。</p><h5 id="测试方式"><a href="#测试方式" class="headerlink" title="测试方式"></a>测试方式</h5><p>本次采用了<strong>大规模随机数据生成和评测</strong>寻找不同类型bug，遇到有错误的再<strong>查看代码进行定点爆破</strong>的方式。</p><p>由于第一次的表达式较简单，直接采用了<code>sympy</code>库的<code>sympify</code>方法转换每个<code>jar</code>文件的输出和<code>sympy</code>库的输出进行比对进行测试。</p><p>同时由于这种方式有时候会parse错误，我还采用了比对房内7个人地结果找少数派的方式，加大了找到bug的概率。</p><p>笔者对生成输入数据的正则表达式加以控制，让每个可以重复的地方次数不超过4次以此控制复杂度。共生成了6组数据，每组有1000个表达式。这样的测试方式就找到了上述的bug。</p><h3 id="第二次作业-1"><a href="#第二次作业-1" class="headerlink" title="第二次作业"></a>第二次作业</h3><h4 id="自己的bug-1"><a href="#自己的bug-1" class="headerlink" title="自己的bug"></a>自己的bug</h4><h5 id="bug描述-2"><a href="#bug描述-2" class="headerlink" title="bug描述"></a>bug描述</h5><p>本次作业在强测中<code>WA</code>了五个点，互测被刀了12下，全是一个同质bug。</p><p>在遇到以下用例时会出现问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(x)</span><br><span class="line">错误输出:(<span class="number">1</span>)</span><br><span class="line">-(-(x))</span><br><span class="line">错误输出:((<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>简单来说就是一个负号与一个表达式因子相连时，求导会无视负号的存在。</p><h5 id="bug修复总结-1"><a href="#bug修复总结-1" class="headerlink" title="bug修复总结"></a>bug修复总结</h5><p>这个bug根植于设计的不够合理。我的设计是先parse输入获得一个简单的表达式树，再对每一项进行化简，而化简时将项内的每个因子的符号进行连乘（代码中是符号因子的异或运算）得到项的符号，而最后将项的符号设置到这一项的系数因子上。而实际写代码时对于表达式因子的符号，不小心写出了如下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fact.setNeg(flag != fact.getNeg());</span><br></pre></td></tr></table></figure><p><code>flag</code>即是项的符号，这里本应将<code>flag</code>的值更新，然后将<code>fact</code>的<code>neg</code>符号设置为<code>false</code>，但是却手残写成了这样。</p><p>只要改为以下代码即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flag &#x3D; flag !&#x3D; fact.getNeg();</span><br><span class="line">fact.setNeg(false);</span><br></pre></td></tr></table></figure><p>同时，我的这种方法必须要化简后才能对表达式因子做出正确输出，而表达式因子类中并没有调用化简方法，导致了表达式因子中的表达式因子输出有误。</p><p>只需要在<code>ExprFactor</code>类中增加两行代码即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exprNode.simplify();</span><br><span class="line">exprNode.mergeItems();</span><br></pre></td></tr></table></figure><h4 id="他人的bug-1"><a href="#他人的bug-1" class="headerlink" title="他人的bug"></a>他人的bug</h4><h5 id="bug描述-3"><a href="#bug描述-3" class="headerlink" title="bug描述"></a>bug描述</h5><p>本次一共找出两个人共3个bug</p><p>用例和结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1 对常数求导处理有误 hack了1人</span></span><br><span class="line">in:--1837*-4816</span><br><span class="line">out:</span><br><span class="line"></span><br><span class="line">in:-6489+--595*x**8245*7592*-7893</span><br><span class="line">out:595*(+8245*x**8244*(7592*-7893)+x**8245*())</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">2 对表达式因子符号处理有误 hack了1人</span></span><br><span class="line">in:-(-x**-2-(-x**-2-(-x-(-x-(-x-sin(x))))))</span><br><span class="line">out:((0*(x)+1*(-1))+(0+((0*(x)+1*(-1))+(0+((0*(x)+1*(-1))+(0*(sin(x))+cos(x)*(-1)))))))</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">3 表达式因子求导错误 hack了1人</span></span><br><span class="line">in:--(+cos(x)**+4219*+7970+3497*-8451*x**8072*x)-+(+6179)</span><br><span class="line">out:(0+0)</span><br></pre></td></tr></table></figure><p>本次作业较上次作业主要增加的难度就在于表达式因子。需要格外注意表达式因子的<code>parse</code>和求导的符号输出。</p><h5 id="测试方式-1"><a href="#测试方式-1" class="headerlink" title="测试方式"></a>测试方式</h5><p>本次代码量太大且复杂，仍然采用了一定规模数据集测试+有针对性阅读代码的方式进行测试，仍然使用<code>python</code>评测机。</p><p>测试时将用例进行了分类，分为了多层表达式因子嵌套类，三角函数类，常数类，杂类。测试数据构造也采用递归下降的方式，简单来说也是<code>get a Expression--&gt;get many Items--&gt;get many Factors</code>这样的形式，对于每个因子采用正则表达式生成字母加上<code>python</code>随机数生成指数的方式。同时使用全局变量来记录调用<code>getExprFactor</code>方法的次数，以及在<code>getExpression</code>方法内通过判断当前字符串长度来决定是否直接返回当前字符串还是继续获得随机生成的项，同时生成数据时如果大于了长度限制就继续生成，直到长度小于等于50。用这两个方法就可以构造出符合第二次作业互测数据要求的数据点了。</p><p>对拍数据采用了官方给出的评测方式即在$[-10,10]$上随机生成$1000$个点将这些结果和<code>sympy</code>求导结果进行比对的方式，必须要全对才算这个点通过。</p><p>同时由于本次作业表达式较复杂，求导时间长，采用了多个点复用一组1000个点的数据的方式加快评测进度。同时每一组表达式的用例个数从之前的1000个降到了100个。</p><h3 id="第三次作业-1"><a href="#第三次作业-1" class="headerlink" title="第三次作业"></a>第三次作业</h3><h4 id="自己的bug-2"><a href="#自己的bug-2" class="headerlink" title="自己的bug"></a>自己的bug</h4><p>本次作业强测和互测中均未发现bug</p><h4 id="他人的bug-2"><a href="#他人的bug-2" class="headerlink" title="他人的bug"></a>他人的bug</h4><h5 id="bug描述-4"><a href="#bug描述-4" class="headerlink" title="bug描述"></a>bug描述</h5><p>找出了一个同学的一个bug</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1 输出的字符串中右括号未输出导致错误</span></span><br><span class="line">in:-((-cos((-sin(x)))*x+cos(85)**48*x*-25))</span><br><span class="line">out:(-x*sin((-sin(x)))*cos(x)-cos((-sin(x)))-25*cos(85)**48</span><br></pre></td></tr></table></figure><h5 id="测试方式-2"><a href="#测试方式-2" class="headerlink" title="测试方式"></a>测试方式</h5><p>本次测试方式与上次类似，只是修改了测试数据生成的程序，加入了对空白字符的生成以及三角嵌套的生成，同时针对这次作业与上次作业的主要不同点三角嵌套进行了重点生成，获得了三角多层嵌套数据，然而有些数据因为长度过长，实在无法缩减，最后没有成功hack到人。</p><h2 id="三、重构经历总结"><a href="#三、重构经历总结" class="headerlink" title="三、重构经历总结"></a>三、重构经历总结</h2><h3 id="第二次作业重构"><a href="#第二次作业重构" class="headerlink" title="第二次作业重构"></a>第二次作业重构</h3><h4 id="重构过程"><a href="#重构过程" class="headerlink" title="重构过程"></a>重构过程</h4><p>本单元主要在第二次作业开发时被迫重构了<strong>输入的解析方式</strong>和整个<strong>求导的数据结构和方法</strong>。</p><p>第一次作业时，由于表达式结构简单，笔者并没有考虑递归下降，表达式树这些方法，而是直接采用了字符串预处理和简单的项求导合并的方式。然而到了第二次作业，引入了表达式因子和三角函数，简单的正负号替换等预处理方式已经解决不了问题，而且对于表达式因子这样的嵌套求导规则并不能用简单的每项直接求导这样简单的方式了。</p><p>于是进行了重构，基本是整个项目<strong>推倒重来</strong>。</p><p>定义了因子的抽象类，以及各个具体的因子类。同时在<code>Expression</code>类中用递归下降的方式对表达式的输入进行了解析。</p><p>重构时曾经纠结过表达式树的结构问题，曾经在一个晚上想了很久二叉树应该如何建立，最终也没有想的很完善，考虑到二叉树建树和<strong>化简求导操作比较麻烦</strong>，在时间紧急的情况下，抛弃了二叉树，转而采用了<strong>多叉树</strong>的方式。而多叉树开始建立时已经到了周六上午，时间所剩无几，决定边做边思考，最终参考助教在讨论区的帖子，解析出了表达式，并利用多叉树进行了求导，效果还可以，1个上午就通过了中测。</p><h4 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h4><ul><li>一开始就要将之后的几次作业内容大概了解，知道最终需要做成什么样子，不要在一开始就随心所欲地设计一个简单的只符合该次要求的结构。</li><li>如果一开始并不明确之后会做成什么样子，那么应该对程序的各个部分进行解耦，比如本单元作业的字符串解析，求导，化简其实可以分属为三个部分，如果将每一部分都解开，之后重构或者增量开发时思路也会更清晰，效率也会更高。</li><li>对于一个需求，尽可能不要钻这个需求的空子寻求捷径去完成，而要寻求本质的一般性解决办法，比如本单元作业中的表达式解析，指导书中明确给出了符号形式化表达，目的就是在于提示我们使用一般化的方法对输入进行处理。</li><li>同时，重构时也不能要求过高，如果时间紧迫时，拿出一种现阶段最可行最好实现的方式进行实现就好。同时，最好边实践边思考，不要空想，有时候，做出来比做完美更重要，一定要把思路落实到纸上或者电脑上。</li></ul><h2 id="四、心得体会"><a href="#四、心得体会" class="headerlink" title="四、心得体会"></a>四、心得体会</h2><ul><li><p>本单元的作业着眼于表达式求导这个基本问题，从第一次的简单的幂函数求导延申到最后的幂函数和三角嵌套的求导，增量开发的过程中，涉及了一个软件从开发到测试到交付的各个环节，体验了重构，测试代码，bug修复等多个以后会经常遇到的环节，对于软件设计开发的流程有了一定的认识。</p></li><li><p>巩固了面向对象的基本知识，了解了常用的工厂模式，接口实现，层次化设计的方法，进一步加深了对于<code>java</code>语言的了解和掌握。同时，代码风格也由于<code>checkstyle</code>的介入越来越好。</p></li><li>增强了测试程序的编写能力，掌握了<code>multiprocessing/sympy/xeger/os</code>等常用库的使用方法和<code>java</code>文件的打包方式，了解了如何修改终端输出的颜色改善评测体验，已经可以熟练的使用<code>Python</code>搭建功能优良完善，架构清晰的评测机。</li><li>加深了对正则表达式的理解，学习到了如何使用递归下降来解析和生成输入数据。</li><li>增强了心理抗压能力，在面对ddl的压力时正确应对并解决困难后，心理更强大了。</li><li>磨炼了意志力，知道了不到最后一刻不放弃，多次OO互测在要放弃的时候用一个新的用例hack成功，只有不放弃，多尝试才有可能不断进步，不断收获新的惊喜和成果。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-OO-2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS-Lab0笔记</title>
      <link href="2021/03/10/OS-Lab0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/03/10/OS-Lab0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>OS课程Lab0学习笔记</p><a id="more"></a><h1 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h1><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><p>命令格式：<code>命令名 [选项] [参数]</code></p><p>Linux命令在系统中有两种类型：<code>内置Shell（外壳）命令</code>和<code>Linux命令</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf #删除所有文件</span><br></pre></td></tr></table></figure><h3 id="OS常用命令"><a href="#OS常用命令" class="headerlink" title="OS常用命令"></a>OS常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find ./ test.md #查找文件</span><br><span class="line">grep -r printf ./ #查找函数变量。。</span><br></pre></td></tr></table></figure><h3 id="vim常用命令"><a href="#vim常用命令" class="headerlink" title="vim常用命令"></a>vim常用命令</h3><p><img src="2021-03-10-OS-Lab0笔记/vim常用操作.jpg" style="zoom: 80%;" /></p><p>撤销重做：<code>u</code> <code>Ctrl+r</code></p><p>复制粘贴：<code>y</code> <code>p</code></p><p>剪切：<code>d</code></p><p>查找某个单词：<code>/word</code> 有多个则按n/N移到上一个或者下一个</p><p>查看某一行代码：<code>:n</code></p><p><strong>永久配置</strong>vim：在<code>~/.vimrc</code>文件中进行配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set nu</span><br><span class="line">set mouse=a</span><br><span class="line">set tabstop=2</span><br><span class="line">set tags=~/19373573-lab/tags</span><br></pre></td></tr></table></figure><h4 id="Ctags使用"><a href="#Ctags使用" class="headerlink" title="Ctags使用"></a>Ctags使用</h4><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><ol><li>首先，在项目根目录（例如 <code>19373573-lab</code>）下面建立索引，即在根目录下敲：<code>ctags -R *</code></li><li>在 vim 配置文件 <code>.vimrc</code> 里面加上这句话，告诉 vim 我们 tags 文件的位置：<code>set tags=~/19373573-lab/tags</code></li></ol><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><ul><li><p>光标放在某函数/变量上，<code>Ctrl+N</code>或者<code>Ctrl+P</code>进行代码补全。<code>Ctrl+]</code>进入代码的定义位置，<code>Ctrl+T</code>返回。</p></li><li><p>同时，<code>Ctrl+W+]</code>可以在新窗口打开其他代码。<code>Ctrl+W K</code>/<code>Ctrl+W J</code>在窗口间移动 <code>:q</code>退出窗口</p></li></ul><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">回退版本时常用</span></span><br><span class="line">git reset hashid --hard</span><br><span class="line">git checkout .</span><br><span class="line">git add . &amp;&amp; git commit -m "1" &amp;&amp; git push --force</span><br></pre></td></tr></table></figure><h2 id="运行小操作系统"><a href="#运行小操作系统" class="headerlink" title="运行小操作系统"></a>运行小操作系统</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/OSLAB/gxemul -E testmips -C R3000 -M 64 gxemul/vmlinux #直接运行</span><br><span class="line">/OSLAB/gxemul -E testmips -C R3000 -M 64 -V gxemul/vmlinux #调试</span><br></pre></td></tr></table></figure><p>由于OS实验经常需要使用<code>gexmul</code>模拟器，所以我直接写了一个<code>test</code>脚本封装这个指令，如下所示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash </span></span><br><span class="line">if [$1 = ''];then</span><br><span class="line">/OSLAB/gxemul -E testmips -C R3000 -M 64 gxemul/vmlinux</span><br><span class="line">else</span><br><span class="line">/OSLAB/gxemul -E testmips -C R3000 -M 64 -V gxemul/vmlinux</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span><span class="bash">breakpoint add addr (addr--&gt;usually <span class="keyword">function</span> name)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">continue</span> (<span class="built_in">continue</span> execute to next breakpoint)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">step n   (execute n steps asm code)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">lookup name|addr</span></span><br><span class="line"><span class="meta">#</span><span class="bash">dump addr</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">help</span> (get cmd <span class="built_in">help</span>)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">quit</span></span><br></pre></td></tr></table></figure><p>再给它加上权限<code>chmod +x test</code></p><p>就可以使用<code>./test</code> 直接运行操作系统</p><p>加一个任意的参数比如<code>./test 1</code>则进入调试模式</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-OS-2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OO-评测机搭建学习</title>
      <link href="2021/03/09/OO-%E8%AF%84%E6%B5%8B%E6%9C%BA%E6%90%AD%E5%BB%BA%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/03/09/OO-%E8%AF%84%E6%B5%8B%E6%9C%BA%E6%90%AD%E5%BB%BA%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>关于OO作业评测机搭建的探索</p><a id="more"></a><h3 id="将java项目打包成jar文件并运行"><a href="#将java项目打包成jar文件并运行" class="headerlink" title="将java项目打包成jar文件并运行"></a>将java项目打包成jar文件并运行</h3><h4 id="在IDEA中打包"><a href="#在IDEA中打包" class="headerlink" title="在IDEA中打包"></a>在IDEA中打包</h4><p><code>File-&gt;project structure</code></p><p>在弹窗最左侧选中 <code>Artifacts-&gt;&quot;+&quot;</code> ,选 <code>jar</code>，选择 <code>from modules with dependencies</code></p><p>此处需要注意两点：</p><ul><li>需要选择jar包默认运行的入口类</li><li>需要设置MANIFEST.MF的位置</li></ul><p>之后点<code>Build-&gt;Build Artifacts-&gt;在选项中点击build即可</code></p><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p><code>java -jar hello.jar</code></p><h3 id="生成数据—xeger"><a href="#生成数据—xeger" class="headerlink" title="生成数据—xeger"></a>生成数据—xeger</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xeger <span class="keyword">import</span> Xeger</span><br><span class="line">str=<span class="string">"你的正则表达式"</span></span><br><span class="line">x=Xeger(limit=<span class="number">10</span>) <span class="comment">#初始化，设置最大长度</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">x.xeger(str) <span class="comment">#循环生成字符串</span></span><br></pre></td></tr></table></figure><h3 id="驱动文件获得输出—subprocess"><a href="#驱动文件获得输出—subprocess" class="headerlink" title="驱动文件获得输出—subprocess"></a>驱动文件获得输出—subprocess</h3><p>最简单的就用<code>os.system(&quot;java 1.jar &lt;&lt; 1.txt &gt;&gt; out.txt&quot;)</code>的方式即可</p><h3 id="正确性判定—sympy"><a href="#正确性判定—sympy" class="headerlink" title="正确性判定—sympy"></a>正确性判定—sympy</h3><p>用到的<code>sympy</code>库函数有 <code>Symbol、diff、sympify</code></p><p>此外可能需要<code>eval</code>来去掉字符串的外围双引号</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-OO-2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OO-Pre-学习笔记</title>
      <link href="2021/03/08/OO-PRE-%E7%AC%94%E8%AE%B0/"/>
      <url>2021/03/08/OO-PRE-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>2021年OO的Pre部分学习笔记</p><a id="more"></a><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="gitlab维护代码"><a href="#gitlab维护代码" class="headerlink" title="gitlab维护代码"></a>gitlab维护代码</h3><h4 id="Command-line-instructions"><a href="#Command-line-instructions" class="headerlink" title="Command line instructions"></a>Command line instructions</h4><h5 id="Git-global-setup"><a href="#Git-global-setup" class="headerlink" title="Git global setup"></a>Git global setup</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name "冯张驰"</span><br><span class="line">git config --global user.email "19373573@buaa.edu.cn"</span><br></pre></td></tr></table></figure><h5 id="Create-a-new-repository"><a href="#Create-a-new-repository" class="headerlink" title="Create a new repository"></a>Create a new repository</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitlab.buaaoo.top/oo_homeworks_2021/仓库名.git</span><br><span class="line">cd oo_2021_pre2_19373573_pre2_task2</span><br><span class="line">touch README.md</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m "add README"</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h5 id="Existing-folder"><a href="#Existing-folder" class="headerlink" title="Existing folder"></a>Existing folder</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd existing_folder</span><br><span class="line">git init</span><br><span class="line">git remote add origin https://gitlab.buaaoo.top/oo_homeworks_2021/仓库名.git</span><br><span class="line">git add .</span><br><span class="line">git commit -m "Initial commit"</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h5 id="Existing-Git-repository"><a href="#Existing-Git-repository" class="headerlink" title="Existing Git repository"></a>Existing Git repository</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd existing_repo</span><br><span class="line">git remote rename origin old-origin</span><br><span class="line">git remote add origin https://gitlab.buaaoo.top/oo_homeworks_2021/仓库名.git</span><br><span class="line">git push -u origin --all</span><br><span class="line">git push -u origin --tags</span><br></pre></td></tr></table></figure><h4 id="补充-实验1git学习"><a href="#补充-实验1git学习" class="headerlink" title="补充-实验1git学习"></a>补充-实验1git学习</h4><h5 id="step-1-新建仓库"><a href="#step-1-新建仓库" class="headerlink" title="step 1 新建仓库"></a>step 1 新建仓库</h5><p>在本地新建一个空文件夹，在此目录下打开终端（bash/git bash/power shell/…）</p><p>输入</p><blockquote><p>git init</p></blockquote><p>从而得到一个新的<code>git</code>仓库</p><h5 id="step-2-关联远程仓库"><a href="#step-2-关联远程仓库" class="headerlink" title="step 2 关联远程仓库"></a>step 2 关联远程仓库</h5><p>目前为止，<code>step 1</code>建立的文件夹还是一个空文件夹，需要关联两个远程仓库，首先考虑第一个远程仓库</p><p>第一个远程仓库是课程组提供的远程公共仓库<code>share</code></p><blockquote><p>git remote add share git@gitlab.buaaoo.top:oo_2021_public/experiment/exp1_public.git</p></blockquote><h5 id="step-3-从远程仓库拉取文件"><a href="#step-3-从远程仓库拉取文件" class="headerlink" title="step 3 从远程仓库拉取文件"></a>step 3 从远程仓库拉取文件</h5><p>关联后可以从远程仓库拉取文件</p><p>执行命令</p><blockquote><p>git pull share master</p></blockquote><p>从<code>share</code>仓库的<code>master</code>分支下得到两个文件夹</p><h5 id="step-4-忽略不必要的文件"><a href="#step-4-忽略不必要的文件" class="headerlink" title="step 4 忽略不必要的文件"></a>step 4 忽略不必要的文件</h5><p>文件夹<code>share</code>中的内容是实现了<code>Comparable</code>接口并按序输出的例程，可以尝试跑通</p><p>文件夹<code>poly</code>中的内容是任务二中需要完善的程序，是需要提交的，而且实验要求，提交时<strong>忽略</strong><code>share</code>文件夹下的所有内容，故需要使用<code>.gitignore</code></p><p>在当前工作的<strong>根目录</strong>下新建文件<code>.gitignore</code></p><p>在其中写入</p><blockquote><p>share/*</p></blockquote><p>表示<code>push</code>时忽略子目录<code>share</code>下的所有文件</p><h5 id="step-5-删除暂存区文件"><a href="#step-5-删除暂存区文件" class="headerlink" title="step 5 删除暂存区文件"></a>step 5 删除暂存区文件</h5><p>为了保证<code>.gitignore</code>正常工作，需要删除暂存区的文件</p><blockquote><p>git rm —cached . -r</p></blockquote><h5 id="step-6-删除与远程仓库的关联"><a href="#step-6-删除与远程仓库的关联" class="headerlink" title="step 6 删除与远程仓库的关联"></a>step 6 删除与远程仓库的关联</h5><p>为了避免不必要的干扰，需要删除与远程仓库<code>share</code>的关联</p><blockquote><p>git remote remove share</p></blockquote><h5 id="step-7-关联个人实验1仓库，并尝试一次提交"><a href="#step-7-关联个人实验1仓库，并尝试一次提交" class="headerlink" title="step 7 关联个人实验1仓库，并尝试一次提交"></a>step 7 关联个人实验1仓库，并尝试一次提交</h5><blockquote><p>git remote add origin 你的个人实验1的远程仓库链接</p><p>git add .</p><p>git commit -m “anything you want to write”</p><p>git push -u origin master</p></blockquote><p>关联到远程仓库<code>origin</code>，并尝试提交</p><p>至此，任务一的内容已全部介绍完毕，如果按照上述步骤操作后得到预期结果（例如可以正常<code>pull</code>和<code>push</code> ，且<code>.gitignore</code>文件生效等），即可开始进行任务二，课程组会对你的<code>git</code>操作进行评判</p><h4 id="平时常用操作"><a href="#平时常用操作" class="headerlink" title="平时常用操作"></a>平时常用操作</h4><h5 id="在IDEA里使用git"><a href="#在IDEA里使用git" class="headerlink" title="在IDEA里使用git"></a>在IDEA里使用git</h5><p>点击工具栏的<code>VCS</code>，选择 <code>Import into Vision Control</code> 里的 <code>Create Git Repository</code></p><p>之后就可以在IDEA里完成 <code>commit</code> <code>push</code> 的操作了（右上角的对钩和绿色箭头），第一次 <code>push</code> 时可以设置远程仓库关联。还有<code>rollback</code>等操作</p><h5 id="一行shell代码完成更新提交"><a href="#一行shell代码完成更新提交" class="headerlink" title="一行shell代码完成更新提交"></a>一行shell代码完成更新提交</h5><h6 id="初次提交"><a href="#初次提交" class="headerlink" title="初次提交"></a>初次提交</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add . &amp;&amp; git commit -m "Initial commit" &amp;&amp; git push -u origin master</span><br></pre></td></tr></table></figure><h6 id="之后提交"><a href="#之后提交" class="headerlink" title="之后提交"></a>之后提交</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add . &amp;&amp; git commit -m &quot;Initial commit&quot; &amp;&amp; git push</span><br></pre></td></tr></table></figure><h5 id="代码回退"><a href="#代码回退" class="headerlink" title="代码回退"></a>代码回退</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git log #查看历史版本</span><br><span class="line">git reset --hard xxx #xxx为对应版本的hashcode </span><br><span class="line">git push origin HEAD --force #远程也更新为当前版本</span><br></pre></td></tr></table></figure><h5 id="一个项目配置多个远程源"><a href="#一个项目配置多个远程源" class="headerlink" title="一个项目配置多个远程源"></a>一个项目配置多个远程源</h5><p>更改源的名字</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rename origin task1</span><br></pre></td></tr></table></figure><p>一次性添加好所有 task 的 remote：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">projectName=<span class="string">"pre3"</span></span><br><span class="line">ID=19XXXXXX</span><br><span class="line">taskNum=6</span><br><span class="line"><span class="keyword">for</span> ((i=1;i&lt;=<span class="variable">$taskNum</span>;++i))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    git remote add task<span class="variable">$&#123;i&#125;</span> git@gitlab.buaaoo.top:oo_homeworks_2021/oo_2021_<span class="variable">$&#123;projectName&#125;</span>_<span class="variable">$&#123;ID&#125;</span>_<span class="variable">$&#123;projectName&#125;</span>_task<span class="variable">$&#123;i&#125;</span>.git</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>然后 push 的时候 specify 一下 push 到哪个 remote，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push task3 master</span><br></pre></td></tr></table></figure><p>如果某个 task 反复 push，可以将其设置为当前 branch 的 upstream：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u task3 master</span><br></pre></td></tr></table></figure><p>之后直接使用 <code>git push</code> 即可。</p><p>也可以在 IDEA 内直接进行 push 操作。选择 Git &gt; Push…，出现操作框。左侧显示你的 branch 和 commit，上面显示你要 push 的 remote 和 branch，点击可以选择具体要 push 的内容 / 具体要 push 到哪个 remote。</p><h3 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h3><h4 id="使用checkstyle"><a href="#使用checkstyle" class="headerlink" title="使用checkstyle"></a>使用checkstyle</h4><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>最简单的配置方式是直接在<code>Settings -&gt; Plugins</code> 里安装好</p><p>然后在 <code>New Projects Settings -&gt; Settings for New Projects</code>里导入<code>config.xml</code>文件或者选择自带的两种代码风格检查方式。（这个default的设置仅适用于2020版，<strong>IDEA 2018</strong> :  <code>File -&gt; Other Settings -&gt; Default Settings</code>  <strong>IDEA 2019</strong> :  <code>File -&gt; Other Settings -&gt; Settings for New Projects</code> ）</p><h5 id="平时使用"><a href="#平时使用" class="headerlink" title="平时使用"></a>平时使用</h5><p><code>鼠标右键 -&gt; Check Current File</code></p><p>或者点击左下角窗口里的<code>checkstyle</code>的按钮也可</p><h4 id="配置符合课程要求"><a href="#配置符合课程要求" class="headerlink" title="配置符合课程要求"></a>配置符合课程要求</h4><h5 id="设置不自动-import-xx"><a href="#设置不自动-import-xx" class="headerlink" title="设置不自动 import xx.*"></a>设置不自动 <code>import xx.*</code></h5><p><code>File -&gt; setting -&gt; Editor -&gt; Code Style -&gt; Java -&gt; Imports</code>设置两个count为大于100的数字</p><h3 id="评论区规范"><a href="#评论区规范" class="headerlink" title="评论区规范"></a>评论区规范</h3><h4 id="提问方式"><a href="#提问方式" class="headerlink" title="提问方式"></a>提问方式</h4><p>针对作业内容答疑区</p><ul><li>作业内容，请使用“【作业内容】”</li><li>评测要求，请使用“【评测要求】”</li></ul><p>针对公共讨论区</p><ul><li>课程规则，请使用“【课程规则】“</li><li>系统使用，请使用”【系统使用】“</li><li>技术交流，请使用”【技术交流】“</li></ul><h2 id="Pre2"><a href="#Pre2" class="headerlink" title="Pre2"></a>Pre2</h2><h3 id="task1"><a href="#task1" class="headerlink" title="task1"></a>task1</h3><p><strong>封装</strong>：是指隐藏对象的属性和实现细节（属性变量和内部方法用<code>private</code>修饰），仅对外提供公共访问⽅法 （访问方法使用<code>public</code>）。</p><h3 id="task2"><a href="#task2" class="headerlink" title="task2"></a>task2</h3><p>java<strong>常用容器</strong>：HashSet，HashMap，ArrayList</p><p>容器<strong>常用方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建</span></span><br><span class="line">ArrayList&lt;Bookset&gt; booksArrayList = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">Bookset book = <span class="keyword">new</span> Bookset(name, price, num);</span><br><span class="line"><span class="comment">// 添加新元素</span></span><br><span class="line">booksArrayList.add(book);</span><br><span class="line"><span class="comment">// 判断是否存在</span></span><br><span class="line"><span class="keyword">if</span> (booksArrayList.contains(book)) &#123;</span><br><span class="line">    System.out.println(<span class="string">"We have it!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历所有元素</span></span><br><span class="line"><span class="keyword">for</span> (Bookset item : booksArrayList) &#123;</span><br><span class="line">    System.out.println(item.getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出容器规模</span></span><br><span class="line">System.out.println(booksArrayList.size());</span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">booksArrayList.remove(book);</span><br></pre></td></tr></table></figure><p>主要的坑在 <code>BigDecimal</code> <code>BigInteger</code> 类的使用上</p><p>需要用 <code>BigDecimal ans = BigDecimal.valueOf(price);</code> 这样的方式来维持精度，如果直接用 <code>BigDecimal(price)</code> 会丢失精度</p><h3 id="task3"><a href="#task3" class="headerlink" title="task3"></a>task3</h3><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>参考菜鸟教程<a href="https://www.runoob.com/design-pattern/factory-pattern.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/factory-pattern.html</a></p><p>步骤如下</p><h5 id="1-创建一个接口"><a href="#1-创建一个接口" class="headerlink" title="1.创建一个接口"></a>1.创建一个接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-创建实体类"><a href="#2-创建实体类" class="headerlink" title="2.创建实体类"></a>2.创建实体类</h5><p>注意实体类是可以使用接口的方法去<strong>调用类内的属性值</strong>的</p><p>同时可以认为这些实体类都是<strong>Shape</strong>类型的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(a);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookFace</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getType</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getNum</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getOutput</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bookset</span> <span class="keyword">implements</span> <span class="title">BookFace</span> </span>&#123;</span><br><span class="line"><span class="comment">//定义各个变量</span></span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> num;   </span><br><span class="line">    <span class="keyword">private</span> String output; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bookset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        init(); <span class="comment">//调用init函数进行初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重写各个方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookShape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bookset <span class="title">getShape</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"Other"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Bookset();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"OtherA"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> OtherA();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"Novel"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Novel();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"Poetry"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Poetry();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"OtherS"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> OtherS();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"Math"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Math1();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"Computer"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Computer();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BookFace book = BookShape.getShape(type);</span><br></pre></td></tr></table></figure><p>同时也可以对一个实体类进行继承，子类也是实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">child</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(a);</span><br><span class="line">      System.out.println(b);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-创建工厂，生成指定类型对象"><a href="#3-创建工厂，生成指定类型对象" class="headerlink" title="3.创建工厂，生成指定类型对象"></a>3.创建工厂，生成指定类型对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">   <span class="comment">//使用 getShape 方法获取形状类型的对象</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(shapeType == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;        </span><br><span class="line">      <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"RECTANGLE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"child"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> child();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-使用该工厂，通过传递类型信息来获取实体类的对象。"><a href="#4-使用该工厂，通过传递类型信息来获取实体类的对象。" class="headerlink" title="4.使用该工厂，通过传递类型信息来获取实体类的对象。"></a>4.使用该工厂，通过传递类型信息来获取实体类的对象。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ShapeFactory factory = <span class="keyword">new</span> ShapeFactory();</span><br><span class="line">Shape a = factory.getShape(<span class="string">"RECTANGLE"</span>);</span><br><span class="line">a.draw();</span><br></pre></td></tr></table></figure><h3 id="task4"><a href="#task4" class="headerlink" title="task4"></a>task4</h3><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>我写这里的时候用了比较拉跨的<code>if else</code>写法，不展示了，参考Roife的博客，记录一下怎么写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> exceptions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BooksetExistedException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BooksetExistedException</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"Oh, no! The "</span> + name + <span class="string">" exist."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> exceptions.BooksetExistedException;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    bookshelves.get(i).addNewBookset(bookset);</span><br><span class="line">&#125; <span class="keyword">catch</span> (BooksetExistedException e) &#123;</span><br><span class="line">    System.out.println(e.getMessage());</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123; <span class="comment">// 想想为啥要放在 finally 里面</span></span><br><span class="line">    scanner.nextLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="task5"><a href="#task5" class="headerlink" title="task5"></a>task5</h3><h4 id="clone和equals方法"><a href="#clone和equals方法" class="headerlink" title="clone和equals方法"></a>clone和equals方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getClass() != obj.getClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        BookFace other = (BookFace) obj;</span><br><span class="line">        <span class="comment">//其他比较逻辑</span></span><br><span class="line">        <span class="keyword">if</span>(other.a==<span class="keyword">this</span>.a) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>() &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于基本类型可以直接继承主类方法即可，String是不可变类型</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BookFace <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pre3"><a href="#Pre3" class="headerlink" title="Pre3"></a>Pre3</h2><p>正则表达式菜鸟教程：<a href="https://www.runoob.com/regexp/regexp-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/regexp/regexp-tutorial.html</a></p><p>java正则表达式用法：<a href="https://www.runoob.com/java/java-regular-expressions.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-regular-expressions.html</a></p><p>一篇补充的博客：<a href="https://blog.csdn.net/baidu_28289725/article/details/80414445" target="_blank" rel="noopener">https://blog.csdn.net/baidu_28289725/article/details/80414445</a></p><h2 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h2><p><a href="https://blog.csdn.net/asdx1020/article/details/104956074" target="_blank" rel="noopener">https://blog.csdn.net/asdx1020/article/details/104956074</a></p><p><a href="https://blog.csdn.net/asdx1020/article/details/104870918" target="_blank" rel="noopener">https://blog.csdn.net/asdx1020/article/details/104870918</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> BUAA-OO-2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端-jquery学习笔记</title>
      <link href="2021/03/03/%E5%89%8D%E7%AB%AF-jquery%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/03/03/%E5%89%8D%E7%AB%AF-jquery%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>javascript学习笔记</title>
      <link href="2021/03/02/%E5%89%8D%E7%AB%AF-javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/03/02/%E5%89%8D%E7%AB%AF-javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>前端的javascript资源整理和学习笔记</p><a id="more"></a><h2 id="资源整理"><a href="#资源整理" class="headerlink" title="资源整理"></a>资源整理</h2><h3 id="菜鸟教程"><a href="#菜鸟教程" class="headerlink" title="菜鸟教程"></a>菜鸟教程</h3><p><a href="https://www.runoob.com/js/js-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/js/js-tutorial.html</a></p><h3 id="w3school"><a href="#w3school" class="headerlink" title="w3school"></a>w3school</h3><p><a href="https://www.w3school.com.cn/js/index.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/js/index.asp</a></p><h2 id="慕课网教程笔记"><a href="#慕课网教程笔记" class="headerlink" title="慕课网教程笔记"></a>慕课网教程笔记</h2><p>教程网站：</p><p><a href="https://www.imooc.com/learn/36" target="_blank" rel="noopener">https://www.imooc.com/learn/36</a>  入门篇—对应本部分1-3</p><p><a href="https://www.imooc.com/learn/10" target="_blank" rel="noopener">https://www.imooc.com/learn/10</a>  进阶篇—对应本部分4-8</p><h3 id="1-入门"><a href="#1-入门" class="headerlink" title="1.入门"></a>1.入门</h3><h4 id="引入JS"><a href="#引入JS" class="headerlink" title="引入JS"></a>引入JS</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.插入<span class="selector-tag">JS</span></span><br><span class="line">&lt;script type="text/javascript"&gt;表示:</span><br><span class="line">在&lt;script&gt;&lt;/script&gt;之间的是文本类型(text)</span><br><span class="line"><span class="selector-tag">javascript</span>是为了告诉浏览器里面的文本是属于<span class="selector-tag">JavaScript</span>语言</span><br><span class="line"></span><br><span class="line">&lt;script type="text/javascript"&gt;</span><br><span class="line"><span class="selector-tag">document</span><span class="selector-class">.write</span>("开启<span class="selector-tag">JS</span>之旅!"); </span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">2.外部引用 使用<span class="selector-tag">src</span></span><br><span class="line">&lt;script src="script.js"&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">3.页面中位置</span><br><span class="line">一般放在<span class="selector-tag">head</span>或<span class="selector-tag">body</span>部分</span><br><span class="line">放在&lt;<span class="selector-tag">head</span>&gt;部分:</span><br><span class="line">最常用的方式是在页面中<span class="selector-tag">head</span>部分放置&lt;<span class="selector-tag">script</span>&gt;元素，浏览器解析<span class="selector-tag">head</span>部分就会执行这个代码，然后才解析页面的其余部分。</span><br><span class="line">放在&lt;<span class="selector-tag">body</span>&gt;部分:</span><br><span class="line"><span class="selector-tag">JavaScript</span>代码在网页读取到该语句的时候就会执行。</span><br></pre></td></tr></table></figure><p>注意: javascript作为一种脚本语言<strong>可以放在html页面中任何位置</strong>，但是浏览器<strong>解释html</strong>时是<strong>按先后顺序</strong>的，所以前面的script就先被执行。比如进行<strong>页面显示初始化的js必须放在head里面</strong>，因为初始化都要求提前进行（如给页面body设置css等）；而如果是通过<strong>事件调用</strong>执行的function那么<strong>对位置没什么要求</strong>的。</p><h4 id="语句和符号"><a href="#语句和符号" class="headerlink" title="语句和符号"></a>语句和符号</h4><p>基本格式：<code>语句;</code> 分号也可不加</p><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行</span></span><br><span class="line"><span class="comment">/* 多行 */</span></span><br></pre></td></tr></table></figure><h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> b,c;</span><br><span class="line">a=<span class="number">1</span>;</span><br><span class="line">b=<span class="string">"abs"</span></span><br><span class="line">c=<span class="literal">true</span>;</span><br><span class="line">c=<span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h4 id="基本语句-和java、C一样"><a href="#基本语句-和java、C一样" class="headerlink" title="基本语句 和java、C一样"></a>基本语句 和java、C一样</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件)</span><br><span class="line">&#123; 条件成立时执行的代码 &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>()</span><br><span class="line">&#123; 条件不成立时执行的代码 &#125;</span><br><span class="line"><span class="keyword">else</span>&#123; &#125;</span><br><span class="line">还有<span class="keyword">do</span>...while/<span class="keyword">while</span>/<span class="keyword">for</span>/<span class="keyword">switch</span>-<span class="keyword">case</span></span><br></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     函数代码;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以有返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add2</span>(<span class="params">x,y</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   sum = x + y;</span><br><span class="line">   <span class="keyword">return</span> sum; <span class="comment">//返回函数值,return后面的值叫做返回值。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-常用互动方法"><a href="#2-常用互动方法" class="headerlink" title="2.常用互动方法"></a>2.常用互动方法</h3><h4 id="输出内容（document-write）"><a href="#输出内容（document-write）" class="headerlink" title="输出内容（document.write）"></a>输出内容（document.write）</h4><h5 id="第一种-输出内容用””括起，直接输出””号内的内容。"><a href="#第一种-输出内容用””括起，直接输出””号内的内容。" class="headerlink" title="第一种:输出内容用””括起，直接输出””号内的内容。"></a>第一种:输出内容用””括起，直接输出””号内的内容。</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type="text/javascript"&gt;</span><br><span class="line">  document.write("I love JavaScript！"); //内容用""括起来，""里的内容直接输出。</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h5 id="第二种-通过变量，输出内容"><a href="#第二种-通过变量，输出内容" class="headerlink" title="第二种:通过变量，输出内容"></a>第二种:通过变量，输出内容</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type="text/javascript"&gt;</span><br><span class="line">  var mystr="hello world!";</span><br><span class="line">  document.write(mystr);  //直接写变量名，输出变量存储的内容。</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h5 id="第三种-输出多项内容，内容之间用-号连接。"><a href="#第三种-输出多项内容，内容之间用-号连接。" class="headerlink" title="第三种:输出多项内容，内容之间用+号连接。"></a>第三种:输出多项内容，内容之间用+号连接。</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type="text/javascript"&gt;</span><br><span class="line">  var mystr="hello";</span><br><span class="line">  document.write(mystr+"I love JavaScript"); //多项内容之间用+号连接</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h5 id="第四种-输出HTML标签，并起作用，标签使用””括起来。"><a href="#第四种-输出HTML标签，并起作用，标签使用””括起来。" class="headerlink" title="第四种:输出HTML标签，并起作用，标签使用””括起来。"></a>第四种:输出HTML标签，并起作用，标签使用””括起来。</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type="text/javascript"&gt;</span><br><span class="line">  var mystr="hello";</span><br><span class="line">document.write(mystr+"&lt;br&gt;");//输出hello后，输出一个换行符</span><br><span class="line">  <span class="selector-tag">document</span><span class="selector-class">.write</span>("<span class="selector-tag">JavaScript</span>");</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>关于JS输出空格问题，请查看wiki中” <a href="http://www.imooc.com/wiki/view?pid=167" target="_blank" rel="noopener">JS如何输出空格</a> “</p><h4 id="警告（alert-消息对话框）"><a href="#警告（alert-消息对话框）" class="headerlink" title="警告（alert 消息对话框）"></a>警告（alert 消息对话框）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(字符串或变量);</span><br></pre></td></tr></table></figure><p><strong>注意</strong>:</p><ol><li>在点击对话框”确定”按钮前，不能进行任何其它操作。</li><li>消息对话框通常可以用于调试程序。</li><li>alert输出内容，可以是字符串或变量，与document.write 相似。</li></ol><h4 id="确认（confirm-消息对话框）"><a href="#确认（confirm-消息对话框）" class="headerlink" title="确认（confirm 消息对话框）"></a>确认（confirm 消息对话框）</h4><h5 id="语法"><a href="#语法" class="headerlink" title="语法:"></a>语法:</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">confirm(str);</span><br></pre></td></tr></table></figure><h5 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明:"></a>参数说明:</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str：在消息对话框中要显示的文本</span><br><span class="line">返回值: <span class="built_in">Boolean</span>值</span><br></pre></td></tr></table></figure><h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值:"></a>返回值:</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当用户点击<span class="string">"确定"</span>按钮时，返回<span class="literal">true</span></span><br><span class="line">当用户点击<span class="string">"取消"</span>按钮时，返回<span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>注1:</strong> 通过返回值可以判断用户点击了什么按钮</p><p><strong>注2</strong>: 消息对话框是排它的，即用户在点击对话框按钮前，不能进行任何其它操作。</p><h4 id="提问（prompt-消息对话框）"><a href="#提问（prompt-消息对话框）" class="headerlink" title="提问（prompt 消息对话框）"></a>提问（prompt 消息对话框）</h4><p>弹出消息对话框（包含一个<strong>确定按钮</strong>、<strong>取消按钮</strong>与一个<strong>文本输入框</strong>）。</p><h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法:"></a>语法:</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prompt(str1, str2);</span><br></pre></td></tr></table></figure><h5 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1: 要显示在消息对话框中的文本，不可修改</span><br><span class="line">str2：文本框中的内容，可以修改</span><br></pre></td></tr></table></figure><h5 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值:"></a>返回值:</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 点击确定按钮，文本框中的内容将作为函数返回值</span><br><span class="line"><span class="number">2.</span> 点击取消按钮，将返回<span class="literal">null</span></span><br></pre></td></tr></table></figure><h4 id="打开新窗口（window-open）"><a href="#打开新窗口（window-open）" class="headerlink" title="打开新窗口（window.open）"></a>打开新窗口（window.open）</h4><p>open() 方法可以查找一个已经存在或者新建的浏览器窗口。</p><p><strong>语法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.open([URL], [窗口名称], [参数字符串])</span><br></pre></td></tr></table></figure><p><strong>参数说明:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">URL：可选参数，在窗口中要显示网页的网址或路径。如果省略这个参数，或者它的值是空字符串，那么窗口就不显示任何文档。</span><br><span class="line">窗口名称：可选参数，被打开窗口的名称。</span><br><span class="line">    <span class="number">1.</span>该名称由字母、数字和下划线字符组成。</span><br><span class="line">    <span class="number">2.</span><span class="string">"_top"</span>、<span class="string">"_blank"</span>、<span class="string">"_self"</span>具有特殊意义的名称。</span><br><span class="line">       _blank：在新窗口显示目标网页</span><br><span class="line">       _self：在当前窗口显示目标网页</span><br><span class="line">       _top：框架网页中在上部窗口中显示目标网页</span><br><span class="line">    <span class="number">3.</span>相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。</span><br><span class="line">    <span class="number">4.n</span>ame 不能包含有空格。</span><br><span class="line">参数字符串：可选参数，设置窗口参数，各参数用逗号隔开。</span><br></pre></td></tr></table></figure><p><strong>参数表:</strong></p><p><strong><a href="http://img.mukewang.com/52e3677900013d6a05020261.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/52e3677900013d6a05020261.jpg" alt="img"></a></strong></p><p>例如:打开<a href="http://www.imooc.com网站，大小为300px" target="_blank" rel="noopener">http://www.imooc.com网站，大小为300px</a> * 200px，无菜单，无工具栏，无状态栏，有滚动条窗口：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type="text/javascript"&gt; window.open('http://www.imooc.com','_blank','width=300,height=200,menubar=no,toolbar=no, status=no,scrollbars=yes')</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type="text/javascript"&gt;</span><br><span class="line">  <span class="selector-tag">function</span> <span class="selector-tag">Wopen</span>()&#123;</span><br><span class="line">    window.open("http://www.imooc.com","_blank"); </span><br><span class="line">  &#125; </span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;input name="button" type="button" onClick="Wopen()" value="点击我，打开新窗口!" /&gt;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>运行结果考虑浏览器兼容问题。</p><h4 id="关闭窗口（window-close）"><a href="#关闭窗口（window-close）" class="headerlink" title="关闭窗口（window.close）"></a>关闭窗口（window.close）</h4><p><strong>用法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.close();   <span class="comment">//关闭本窗口</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;窗口对象&gt;.close();   <span class="comment">//关闭指定的窗口</span></span><br></pre></td></tr></table></figure><h3 id="3-DOM操作"><a href="#3-DOM操作" class="headerlink" title="3.DOM操作"></a>3.DOM操作</h3><h4 id="DOM介绍"><a href="#DOM介绍" class="headerlink" title="DOM介绍"></a>DOM介绍</h4><p>文档对象模型<strong>DOM</strong>（Document Object Model）定义访问和处理HTML文档的标准方法。</p><p>DOM 将HTML文档呈现为<strong>带有元素、属性和文本</strong>的<strong>树结构</strong>（<strong>节点树</strong>）。</p><h4 id="通过ID获取元素"><a href="#通过ID获取元素" class="headerlink" title="通过ID获取元素"></a>通过ID获取元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mychar= <span class="built_in">document</span>.getElementById(<span class="string">"con"</span>);</span><br></pre></td></tr></table></figure><p>注:获取的元素是一个对象，如想对元素进行操作，我们要通过它的属性或方法。</p><h4 id="innerHTML-属性"><a href="#innerHTML-属性" class="headerlink" title="innerHTML 属性"></a>innerHTML 属性</h4><p>用于获取或替换 HTML 元素的内容</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type="text/javascript"&gt;</span><br><span class="line">  var mychar=document.getElementById("con");</span><br><span class="line">  mychar.innerHTML="hello world!"; //利用innerHTML属性修改标签内容</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="改变-HTML-样式"><a href="#改变-HTML-样式" class="headerlink" title="改变 HTML 样式"></a>改变 HTML 样式</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.style.property=new style;</span><br><span class="line">var mychar = document.getElementById("pcon");</span><br><span class="line">mychar.style.color="red";</span><br><span class="line">mychar.style.fontSize="20";</span><br></pre></td></tr></table></figure><p><strong>注意:</strong>Object是获取的元素对象，如通过document.getElementById(“id”)获取的元素。</p><p><strong>基本属性表（property）:</strong></p><p><strong><a href="http://img.mukewang.com/52e4d4240001dd6c04850229.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/52e4d4240001dd6c04850229.jpg" alt="img"></a></strong></p><p><strong>注意:</strong>该表只是一小部分CSS样式属性，其它样式也可以通过该方法设置和修改。</p><h4 id="显示和隐藏（display属性）"><a href="#显示和隐藏（display属性）" class="headerlink" title="显示和隐藏（display属性）"></a>显示和隐藏（display属性）</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.style.display = value</span><br></pre></td></tr></table></figure><h5 id="value取值"><a href="#value取值" class="headerlink" title="value取值:"></a>value取值:</h5><p><strong><a href="http://img.mukewang.com/52e4dba5000179da04110095.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/52e4dba5000179da04110095.jpg" alt="img"></a></strong></p><h4 id="控制类名（className-属性）"><a href="#控制类名（className-属性）" class="headerlink" title="控制类名（className 属性）"></a>控制类名（className 属性）</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object.className = classname</span><br></pre></td></tr></table></figure><h4 id="本章思路小结"><a href="#本章思路小结" class="headerlink" title="本章思路小结"></a>本章思路小结</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">a[document.getElementById方法通过ID获取元素-即DOM对象]--&gt;b[修改对象的属性]</span><br><span class="line">b--&gt;c[Object.innerHTML改变代码]</span><br><span class="line">b--&gt;d[Object.style.property改变样式]</span><br><span class="line">b--&gt;e[Object.display改变隐藏与否]</span><br><span class="line">b--&gt;f[Object.classname改变类名]</span><br></pre></td></tr></table></figure><h3 id="4-数组"><a href="#4-数组" class="headerlink" title="4.数组"></a>4.数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myarray=<span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">//创建 括号内可以设置个数</span></span><br><span class="line"><span class="keyword">var</span> myarray = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">66</span>,<span class="number">80</span>,<span class="number">90</span>,<span class="number">77</span>,<span class="number">59</span>);<span class="comment">//创建数组同时赋值</span></span><br><span class="line"><span class="keyword">var</span> myarray = [<span class="number">66</span>,<span class="number">80</span>,<span class="number">90</span>,<span class="number">77</span>,<span class="number">59</span>];<span class="comment">//直接输入一个数组（称 “字面量数组”）</span></span><br><span class="line"><span class="comment">//数组存储的数据可以是任何类型（数字、字符、布尔值等）</span></span><br><span class="line">myarray[<span class="number">5</span>]=<span class="number">88</span>; <span class="comment">//使用一个新索引，为数组增加一个新元素</span></span><br><span class="line">myarray.length; <span class="comment">//获得数组myarray的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二维数组的定义方法一</span></span><br><span class="line"><span class="keyword">var</span> myarr=<span class="keyword">new</span> <span class="built_in">Array</span>();  <span class="comment">//先声明一维 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;   <span class="comment">//一维长度为2</span></span><br><span class="line">   myarr[i]=<span class="keyword">new</span> <span class="built_in">Array</span>();  <span class="comment">//再声明二维 </span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;   <span class="comment">//二维长度为3</span></span><br><span class="line">   myarr[i][j]=i+j;   <span class="comment">// 赋值，每个数组元素的值为i+j</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//二维数组的定义方法二</span></span><br><span class="line"><span class="keyword">var</span> Myarr = [[<span class="number">0</span> , <span class="number">1</span> , <span class="number">2</span> ],[<span class="number">1</span> , <span class="number">2</span> , <span class="number">3</span>]]</span><br></pre></td></tr></table></figure><h3 id="5-事件响应"><a href="#5-事件响应" class="headerlink" title="5.事件响应"></a>5.事件响应</h3><p>事件是<strong>可以被 JavaScript 侦测到的行为</strong>。 网页中的每个元素都可以产生某些可以触发 JavaScript 函数或程序的事件。</p><h5 id="主要事件表"><a href="#主要事件表" class="headerlink" title="主要事件表"></a>主要事件表</h5><p><a href="http://img.mukewang.com/53e198540001b66404860353.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/53e198540001b66404860353.jpg" alt="img"></a></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">form</span>&gt;</span><br><span class="line">&lt;input name="button" type="button" value="点击提交" onclick="add2()" /&gt;</span><br><span class="line">&lt;input name="确定" type="button" value="确定" onmouseover="add()"/&gt; </span><br><span class="line">&lt;a href="http://www.imooc.com" onmouseout="message()"&gt;点击我&lt;/a&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>onfocus和onblur是相对于一个区域的焦点说的</p><h5 id="加载事件（onload）"><a href="#加载事件（onload）" class="headerlink" title="加载事件（onload）"></a>加载事件（onload）</h5><p>事件会在页面加载完成后，立即发生，同时执行被调用的程序。</p><p>注意：加载页面时，触发onload事件，事件写在<code>&lt;body&gt;</code>标签内。</p><h5 id="卸载事件（onunload）"><a href="#卸载事件（onunload）" class="headerlink" title="卸载事件（onunload）"></a>卸载事件（onunload）</h5><p>当用户退出页面时（页面关闭、页面刷新等），触发onUnload事件，同时执行被调用的程序。</p><p>注意：不同浏览器对onunload事件支持不同。</p><h3 id="6-JS内置对象"><a href="#6-JS内置对象" class="headerlink" title="6.JS内置对象"></a>6.JS内置对象</h3><h4 id="Date日期对象"><a href="#Date日期对象" class="headerlink" title="Date日期对象"></a>Date日期对象</h4><p>定义一个时间对象 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Udate=<span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">/*使 Udate 成为日期对象，并且已有初始值：当前时间(当前电脑系统时间)。*/</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>:使用关键字new，Date()的首字母必须大写。 </p><p>如果要自定义初始值，可以用以下方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2012</span>, <span class="number">10</span>, <span class="number">1</span>);  <span class="comment">//2012年10月1日</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'Oct 1, 2012'</span>); <span class="comment">//2012年10月1日</span></span><br></pre></td></tr></table></figure><p>我们最好使用下面介绍的<strong>方法</strong>来严格定义时间。</p><p><strong>访问方法语法：</strong>“&lt;日期对象&gt;.&lt;方法&gt;”</p><p>Date对象中处理时间和日期的常用方法：</p><p><a href="http://img.mukewang.com/555c650d0001ae7b04180297.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/555c650d0001ae7b04180297.jpg" alt="img"></a></p><h4 id="String-字符串对象"><a href="#String-字符串对象" class="headerlink" title="String 字符串对象"></a>String 字符串对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"I Love Beijing"</span>;</span><br><span class="line">str=str.toUpperCase(); <span class="comment">//转换为大写字母 还有toLowerCase()</span></span><br><span class="line"><span class="keyword">var</span> len=str.length; <span class="comment">//获取长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取指定位置字符</span></span><br><span class="line">stringObject.charAt(index)</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回指定的字符串首次出现的位置</span></span><br><span class="line">stringObject.indexOf(substring, startpos)</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串分割split()</span></span><br><span class="line">stringObject.split(separator,limit) <span class="comment">//limit--&gt;分割的最大次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提取字符串substring()</span></span><br><span class="line">stringObject.substring(startPos,stopPos) </span><br><span class="line"></span><br><span class="line"><span class="comment">//提取指定数目的字符substr()</span></span><br><span class="line">stringObject.substr(startPos,length) <span class="comment">//提取从 startPos位置开始的指定数目的字符串。</span></span><br></pre></td></tr></table></figure><h4 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h4><p>Math 对象是一个<strong>固有的对象</strong>，<strong>无需创建它</strong>，<strong>直接</strong>把 Math <strong>作为对象使用</strong>就<strong>可以调用</strong>其所有属性和方法。这是它与Date,String对象的<strong>区别</strong>。</p><h5 id="常用的属性、方法"><a href="#常用的属性、方法" class="headerlink" title="常用的属性、方法"></a>常用的属性、方法</h5><p>属性：<code>Math.PI</code></p><p>方法：<code>Math.ceil()</code> (向上取整)  <code>Math.floor()</code> (向下取整) <code>Math.round()</code> (四舍五入)  <code>Math.random()</code> (随机数，返回一个$[0,1]$区间内的随机数)</p><h5 id="Math-对象属性"><a href="#Math-对象属性" class="headerlink" title="Math 对象属性"></a>Math 对象属性</h5><p><a href="http://img.mukewang.com/532fe7cf0001e7b505170269.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/532fe7cf0001e7b505170269.jpg" alt="img"></a></p><h5 id="Math-对象方法"><a href="#Math-对象方法" class="headerlink" title="Math 对象方法"></a>Math 对象方法</h5><p><a href="http://img.mukewang.com/532fe841000174db05160622.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/532fe841000174db05160622.jpg" alt="img"></a></p><h4 id="Array-数组对象"><a href="#Array-数组对象" class="headerlink" title="Array 数组对象"></a>Array 数组对象</h4><h5 id="数组定义的方法"><a href="#数组定义的方法" class="headerlink" title="数组定义的方法"></a>数组定义的方法</h5><p>1.定义了一个空数组:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组名= <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br></pre></td></tr></table></figure><p>2.定义时指定有n个空元素的数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组名 =<span class="keyword">new</span> <span class="built_in">Array</span>(n);</span><br></pre></td></tr></table></figure><p>3.定义数组的时候，直接初始化数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 数组名 = [&lt;元素<span class="number">1</span>&gt;, &lt;元素<span class="number">2</span>&gt;, &lt;元素<span class="number">3</span>&gt;...];</span><br></pre></td></tr></table></figure><p>我们定义myArray数组，并赋值，<strong>代码如下：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myArray = [<span class="number">2</span>, <span class="number">8</span>, <span class="number">6</span>];</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>定义了一个数组 myArray，里边的元素是：<code>myArray[0] = 2; myArray[1] = 8; myArray[2] = 6。</code></p><h5 id="数组元素使用"><a href="#数组元素使用" class="headerlink" title="数组元素使用"></a>数组元素使用</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名[下标] = 值;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>: 数组的下标用方括号括起来，从0开始。</p><h5 id="数组属性"><a href="#数组属性" class="headerlink" title="数组属性"></a>数组属性</h5><p>length 用法：&lt;数组对象&gt;.length；返回：数组的长度，即数组里有多少个元素。它等于数组里最后一个元素的下标加一。</p><h5 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h5><p><a href="http://img.mukewang.com/533295ab0001dead05190599.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/533295ab0001dead05190599.jpg" alt="img"></a></p><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><p><code>arrayObject.concat(array1,array2,...,arrayN)</code>  返回一个新数组，原数组不改变</p><p><code>arrayObject.join(分隔符)</code>  把数组中的<strong>所有元素放入一个字符串</strong>。元素是通过<strong>指定的分隔符</strong>进行<strong>分隔</strong>的。</p><p><code>arrayObject.reverse()</code>  颠倒数组中元素的顺序。原数组改变</p><p><code>arrayObject.slice(start,end)</code>  返回一个新的数组，包含从 start 到 end （<strong>不包括该元素</strong>）的 arrayObject 中的元素。类似<code>python</code>的切片</p><p><code>arrayObject.sort(方法函数)</code>  </p><p><strong>注意</strong>: 该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下： </p><p>  若返回值<strong>&lt;=-1</strong>，则表示 <strong>A</strong> 在排序后的序列中<strong>出现在 B 之前</strong>。<br>  若返回值<strong>&gt;-1 &amp;&amp; &lt;1</strong>，则表示 <strong>A 和 B</strong> 具有<strong>相同</strong>的排序顺序。<br>  若返回值<strong>&gt;=1</strong>，则表示 <strong>A</strong> 在排序后的序列中<strong>出现在 B 之后</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortNum</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line"> <span class="comment">//升序，如降序，把“a - b”改成“b - a”</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myarr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"80"</span>,<span class="string">"16"</span>,<span class="string">"50"</span>,<span class="string">"6"</span>,<span class="string">"100"</span>,<span class="string">"1"</span>);</span><br><span class="line"><span class="built_in">document</span>.write(myarr + <span class="string">"&lt;br&gt;"</span>);</span><br><span class="line"><span class="built_in">document</span>.write(myarr.sort(sortNum));</span><br></pre></td></tr></table></figure><h3 id="7-window对象"><a href="#7-window对象" class="headerlink" title="7.window对象"></a>7.window对象</h3><p>window对象是BOM的核心，window对象指<strong>当前的浏览器窗口</strong>。</p><h4 id="window对象方法"><a href="#window对象方法" class="headerlink" title="window对象方法"></a>window对象方法</h4><p><strong><a href="http://img.mukewang.com/535483720001a54506670563.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/535483720001a54506670563.jpg" alt="img"></a></strong></p><h3 id="8-认识DOM"><a href="#8-认识DOM" class="headerlink" title="8.认识DOM"></a>8.认识DOM</h3><p>HTML文档可以说由节点构成的集合，DOM节点有:</p><p><strong>1.</strong> <strong>元素节点：</strong><code>&lt;html&gt;、&lt;body&gt;、&lt;p&gt;</code>等都是元素节点，即标签。</p><p><strong>2.</strong> <strong>文本节点:</strong>向用户展示的内容，如<code>&lt;li&gt;...&lt;/li&gt;</code>中的文本。</p><p><strong>3.</strong> <strong>属性节点:</strong>元素属性，如<code>&lt;a&gt;</code>标签的链接属性href=”<a href="http://www.imooc.com&quot;。" target="_blank" rel="noopener">http://www.imooc.com&quot;。</a></p><h5 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h5><p><a href="http://img.mukewang.com/5375c953000117ee05240129.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/5375c953000117ee05240129.jpg" alt="img"></a></p><h5 id="遍历节点树"><a href="#遍历节点树" class="headerlink" title="遍历节点树"></a>遍历节点树</h5><p><a href="http://img.mukewang.com/53f17a6400017d2905230219.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/53f17a6400017d2905230219.jpg" alt="img"></a></p><h5 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h5><p><a href="http://img.mukewang.com/538d29da000152db05360278.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/538d29da000152db05360278.jpg" alt="img"></a></p><p><strong>注意:</strong>前两个是document方法。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>薛兆丰经济学讲义笔记</title>
      <link href="2021/02/28/%E8%96%9B%E5%85%86%E4%B8%B0%E7%BB%8F%E6%B5%8E%E5%AD%A6%E8%AE%B2%E4%B9%89%E7%AC%94%E8%AE%B0/"/>
      <url>2021/02/28/%E8%96%9B%E5%85%86%E4%B8%B0%E7%BB%8F%E6%B5%8E%E5%AD%A6%E8%AE%B2%E4%B9%89%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>阅读薛兆丰的《经济学讲义》的读书笔记</p><a id="more"></a><h1 id="前言-人类的四大约束"><a href="#前言-人类的四大约束" class="headerlink" title="前言 人类的四大约束"></a>前言 人类的四大约束</h1><p>人类的四大约束：东西不够，生命有限，互相依赖，需要协调</p><h1 id="第1章-稀缺—为何商业是最大的慈善"><a href="#第1章-稀缺—为何商业是最大的慈善" class="headerlink" title="第1章 稀缺—为何商业是最大的慈善"></a>第1章 稀缺—为何商业是最大的慈善</h1><h2 id="真实世界-经济学的视角"><a href="#真实世界-经济学的视角" class="headerlink" title="真实世界|经济学的视角"></a>真实世界|经济学的视角</h2><h3 id="1-战俘营里的经济组织"><a href="#1-战俘营里的经济组织" class="headerlink" title="1.战俘营里的经济组织"></a>1.战俘营里的经济组织</h3><p>二战德国战俘营里也产生了经济组织，有交易，有货币（香烟），有价格波动，有通胀紧缩</p><h3 id="2-马粪争夺案"><a href="#2-马粪争夺案" class="headerlink" title="2.马粪争夺案"></a>2.马粪争夺案</h3><p>鼓励人们创造财富，社会才会越变越好</p><p>本案中法官将公路上的马粪所有权最终判给了搬马粪的原告，从而鼓励了该地区的人民劳动积极性</p><p><strong>公正和公平</strong>的背后是<strong>效率</strong>考量，是对整体社会<strong>长远发展的效率</strong>的考量</p><h3 id="3-看得见的和看不见的"><a href="#3-看得见的和看不见的" class="headerlink" title="3.看得见的和看不见的"></a>3.看得见的和看不见的</h3><p><strong>破窗理论</strong>——有破坏才有进步</p><p>变种1：国家发展需要大的灾难</p><p>变种2：工人就业（机器取代工人，工人没有工作做）（机器取代工人，工人也不一定能找到新工作）</p><p>变种3：少用塑料袋</p><p>做决策时不仅要考虑到看的见的损失，也要考虑隐形的净损失（另一种方案或者情况也许有更大收益）</p><h3 id="4-区分愿望和结果"><a href="#4-区分愿望和结果" class="headerlink" title="4.区分愿望和结果"></a>4.区分愿望和结果</h3><p>现代经济学研究的是<strong>事与愿违</strong>的现象。</p><p>美好愿望不一定带来理想结果，坏人干坏事的影响也相对有限，好人好心不一定干好事。</p><p>比如：</p><ul><li><strong>最低工资制度</strong>本想保护穷人，但穷人仍然穷</li><li><strong>同工同酬制度</strong>本想保护弱势群体最后却伤害了他们</li><li><strong>福利制度</strong>让没有依靠的人更惨</li><li><strong>保护动物的法律</strong>让动物减少</li><li><strong>政府立法不是问题的终点</strong>，上有法律，下有对策。</li></ul><h2 id="人性观-人是理性和自私的吗"><a href="#人性观-人是理性和自私的吗" class="headerlink" title="人性观|人是理性和自私的吗"></a>人性观|人是理性和自私的吗</h2><h3 id="5-不确定性、进化与经济理论"><a href="#5-不确定性、进化与经济理论" class="headerlink" title="5.不确定性、进化与经济理论"></a>5.不确定性、进化与经济理论</h3><p><strong>阿曼阿尔钦</strong>的论文<strong>《不确定性、进化与经济理论》</strong>认为万物存活看条件，与理性与否无关。</p><p>经济学基础不是人是理性的，而是人应该如何存活。经济学关心的是<strong>存活的条件</strong>。</p><p>随着时代和条件变化，存活条件始终在变化，物竞天择，适者生存（进化论）。</p><h3 id="6-亚当斯密的人性观"><a href="#6-亚当斯密的人性观" class="headerlink" title="6.亚当斯密的人性观"></a>6.亚当斯密的人性观</h3><p>亚当斯密的《国富论》主张人是自私的，认为人在只追求自己福利同时，也会隐形地推动社会进步。他的《道德情操论》讲的是人应该有道德。</p><p>亚当斯密的观点如下：</p><ul><li>人性自私完全不自私甚至对自己自暴自弃的人得不到他人尊重</li><li>人不仅是自私的，也具有同情心和爱心</li><li><p>人的爱心有限，随着距离拉远而减弱</p></li><li><p>仅靠爱心不够，陌生人互助需要市场协调。我们让他人帮助自己往往需要说出唤起他们的利己心话。</p></li><li>人际互动二分法：小圈子靠爱心，大世界靠市场</li></ul><h3 id="7-铅笔的故事"><a href="#7-铅笔的故事" class="headerlink" title="7.铅笔的故事"></a>7.铅笔的故事</h3><p>《我，铅笔的故事》——伦纳德.里德</p><p>市场让很多互不认识不一样的人一起参与制作了铅笔</p><h3 id="8-商业是最大的慈善"><a href="#8-商业是最大的慈善" class="headerlink" title="8.商业是最大的慈善"></a>8.商业是最大的慈善</h3><p>世界银行扶贫失败；哈利波特商业奇迹，2005年7月16日英美两国将900万册哈6送到了读者手里。</p><p>两者透露出行善和商业这两个模式存在本质区别。</p><p>行善扶贫难见成效四大原因：</p><ul><li><strong>缺乏反馈机制</strong>。行善者不能确定自己的行善行为是否是正确有效的。</li><li><strong>委托代理问题</strong>。负责行善的人花的不是自己的钱，不认真。</li><li><strong>所托非人问题</strong>。将钱交给贫困根源的地方政府。</li><li><strong>养懒汉效应</strong>。持续扶贫造成人们的依赖和懒惰，人们甚至考虑如何保住贫困的帽子。</li></ul><p>商业行为由于市场协调机制和鼓励人们分工合作，大幅持续高效的改进了人们的福利。商业是大量陌生人给予的慈善，商业是最大的慈善。</p><h2 id="区别对待-选择的标准"><a href="#区别对待-选择的标准" class="headerlink" title="区别对待|选择的标准"></a>区别对待|选择的标准</h2><h3 id="9-稀缺"><a href="#9-稀缺" class="headerlink" title="9.稀缺"></a>9.稀缺</h3><p>经济学大厦应当建立在<strong>稀缺</strong>这个基础上。</p><p>稀缺的原因</p><ol><li>我们想要的东西别人也想要</li><li>人的需求在不断变化和升级，即人的欲望是无限的。</li></ol><h3 id="10-选择和歧视"><a href="#10-选择和歧视" class="headerlink" title="10.选择和歧视"></a>10.选择和歧视</h3><p><strong>稀缺</strong>，<strong>选择</strong>，<strong>区别对待</strong>，<strong>歧视</strong>四个概念融为一体，有了一个也有了其他三个。因此歧视不可避免</p><p>因为想消除歧视，而导致了<strong>逆向歧视</strong>。美国的白人在有些方面却因为不是黑人而得不到一些福利。</p><p>真正重要的是<strong>如何歧视</strong>。</p><h3 id="11-凡歧视必得付代价"><a href="#11-凡歧视必得付代价" class="headerlink" title="11.凡歧视必得付代价"></a>11.凡歧视必得付代价</h3><p>因为歧视（以偏概全）的认识成本最低，所以人很容易先入为主。</p><p>对人歧视越多，付出代价也越大。因为市场往往需要让人放下偏见，通力合作。</p><p><strong>市场竞争</strong>让人心胸宽广。偏远小镇的歧视比繁华的大都市严重很多。</p><h3 id="12-歧视的作用和限制歧视的恶果"><a href="#12-歧视的作用和限制歧视的恶果" class="headerlink" title="12.歧视的作用和限制歧视的恶果"></a>12.歧视的作用和限制歧视的恶果</h3><p>东南亚华人把当地人按照姓氏，方言，国籍分成7等，不同距离关系的人做生意条款不一样，这样反而使人生地不熟的他们得到了很好的发展。</p><p>20世纪初美国针对买房借贷的平权运动，最终导致政府强制银行多借贷，导致次贷危机。反歧视运动导致恶果。</p><p>说明某些歧视未必有害，可能是有效率的。</p><h1 id="第2章-成本—不要只盯着钱"><a href="#第2章-成本—不要只盯着钱" class="headerlink" title="第2章 成本—不要只盯着钱"></a>第2章 成本—不要只盯着钱</h1><h2 id="选择偏好-一句话给成本下定义"><a href="#选择偏好-一句话给成本下定义" class="headerlink" title="选择偏好|一句话给成本下定义"></a>选择偏好|一句话给成本下定义</h2><h3 id="13-一句话给成本下定义"><a href="#13-一句话给成本下定义" class="headerlink" title="13.一句话给成本下定义"></a>13.一句话给成本下定义</h3><p>采石场旁边买一块空地，防止有开发商开发房地产影响采石场。实际是采石场的消费者买下了这块地。</p><p>成本是放弃了的最大代价。即被选中的选项是所有放弃的选项中价值最高的。</p><p>沉没成本：已经发生不可收回的支出。——其实不是成本，因为已经没办法收回或放弃，成本是向前看的。</p><h3 id="14-你的成本由被人来决定"><a href="#14-你的成本由被人来决定" class="headerlink" title="14.你的成本由被人来决定"></a>14.你的成本由被人来决定</h3><p>负面的感受不是成本</p><p>你的成本由他人决定</p><p>你的职业范围由社会决定</p><h3 id="15-别只盯着钱"><a href="#15-别只盯着钱" class="headerlink" title="15.别只盯着钱"></a>15.别只盯着钱</h3><p>货币成本不等于全部成本，比如假货货币成本低，但是有维权成本。</p><p>志愿兵制优于义务征兵制（义务征兵看似成本低但是使得一些科学家等也变成了士兵）</p><p>中间商赚差价，让价格更便宜。因为中间商也要竞争，同时可以免去消费者的一些麻烦。</p><h2 id="资源的价值-重新理解盈利和亏损"><a href="#资源的价值-重新理解盈利和亏损" class="headerlink" title="资源的价值|重新理解盈利和亏损"></a>资源的价值|重新理解盈利和亏损</h2><h3 id="16-从成本角度理解盈利和亏损"><a href="#16-从成本角度理解盈利和亏损" class="headerlink" title="16.从成本角度理解盈利和亏损"></a>16.从成本角度理解盈利和亏损</h3><p>盈利是意外的，提升了资源使用的成本</p><p>亏损降低了资源使用成本</p><h3 id="17-最终产品的供需决定原材料的成本"><a href="#17-最终产品的供需决定原材料的成本" class="headerlink" title="17.最终产品的供需决定原材料的成本"></a>17.最终产品的供需决定原材料的成本</h3><p>关于产品价格的形成过程，有成本决定论和供需决定论。</p><p>成本决定价格肯定是错误的</p><p>供需关系决定商品价格，商品价格决定资源成本</p><h3 id="18-“租”是对资产的付费"><a href="#18-“租”是对资产的付费" class="headerlink" title="18.“租”是对资产的付费"></a>18.“租”是对资产的付费</h3><p>租，是对资产的付费</p><p>资产—能够带来收入的资源，含义很广，包括土地，矿山，人的才能，发明创造……</p><p>猫王成为歌星前当司机的收入为10万/年，成为歌星后收入为1000万，多出的990万即为租。因为即使他的收入降低100万，900万，他还是会当歌星。</p><p>政府安排的出租车牌有价—垄断带来的收入，也是租—垄断租</p><p>租是旱涝保收的收入</p><p>租看似是白赚的，但是如果本身不努力打理，租也会下降很多。</p><h3 id="19-寻租—乞丐没有白拿施舍"><a href="#19-寻租—乞丐没有白拿施舍" class="headerlink" title="19.寻租—乞丐没有白拿施舍"></a>19.寻租—乞丐没有白拿施舍</h3><p>寻租概念起源：贼没有减少社会总财富，但是增加了人们造锁的成本，消耗了资源。</p><p>政府管制下资源消耗：企业之间为了争夺政策福利付出代价，竞争成本造成的内耗超过了政策本身的价值。</p><p>乞丐之间也是通过竞争才可以拿到施舍，没有白拿。</p><p>寻找能够带来收入的资产，分为两类：一类是努力工作提升自我，增加了社会财富。另一类是内卷竞争，消耗社会财富，即寻租。</p><p>贫穷国家制度不合理，寻租行为非常普遍，所以相对贫穷。</p><h2 id="科斯定律-从社会成本看问题"><a href="#科斯定律-从社会成本看问题" class="headerlink" title="科斯定律|从社会成本看问题"></a>科斯定律|从社会成本看问题</h2><h3 id="20-社会成本问题"><a href="#20-社会成本问题" class="headerlink" title="20.社会成本问题"></a>20.社会成本问题</h3>]]></content>
      
      
      <categories>
          
          <category> Life Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经济管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows问题和解决方案、相应网站工具</title>
      <link href="2021/02/21/windows%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3/"/>
      <url>2021/02/21/windows%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>windows遇到的系统问题和对应解决方法积累。最近遇到了Powershell异常的问题，找了微软工程师没解决，最后自己在一个论坛上找到了类似的解决了，记录一下这次排坑经历，顺便以后积累一下其他常见问题。</p><a id="more"></a><h2 id="问题1-Powershell找不到驱动器"><a href="#问题1-Powershell找不到驱动器" class="headerlink" title="问题1 Powershell找不到驱动器"></a>问题1 Powershell找不到驱动器</h2><h3 id="问题起因和描述"><a href="#问题起因和描述" class="headerlink" title="问题起因和描述"></a>问题起因和描述</h3><p>最近装了很多编辑器，配置了很多环境变量，也删除更新了很多文件，于是再打开Powershell时便遇到了以下问题。</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/windows%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98//2.png" alt=""></p><p>导致Vscode也用不了</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/windows%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98//1.png" alt=""></p><p>于是去找了微软官网找相关人员咨询，还接受了上海的工程师的电话帮助。但是都没有解决。顺便提一下，有问题的确可以和微软官方联系，不管你的windows版本，都会给你完整的咨询服务。不仅有机器自动服务，还有客服人员，技术人员的咨询支持。</p><p>工程师说这个没有通用解决办法，于是给我提供了四条基本没用看着很可怕的方法：使用系统修复命令，更新系统，重装系统，尝试卸载一些最近装的软件。</p><p>之后又找到一篇博客是关于vscode遇到这个问题的<a href="https://blog.csdn.net/yys190418/article/details/103767720" target="_blank" rel="noopener">https://blog.csdn.net/yys190418/article/details/103767720</a></p><p>然而这个只是解决vscode中powershell用不了的小问题，对我的问题并不适用。</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>最后，终于在下面这个网站上找到了问题。<a href="https://superuser.com/questions/1021310/powershell-a-drive-c-does-not-exist" target="_blank" rel="noopener">https://superuser.com/questions/1021310/powershell-a-drive-c-does-not-exist</a></p><p>原来就是环境变量的锅，只要将Path中每个变量前面的 <code>.</code> 去掉即可！根据我的实践是每个都要删，不光是开头的 <code>.</code> 以后配置环境真的要小心谨慎了，这次真的吓人</p><p>即如下图所示</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/windows%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98//3.png" style="zoom:50%;" /></p><h2 id="网站工具"><a href="#网站工具" class="headerlink" title="网站工具"></a>网站工具</h2><h3 id="社区"><a href="#社区" class="headerlink" title="社区"></a>社区</h3><p><a href="https://superuser.com/" target="_blank" rel="noopener">https://superuser.com/</a>     貌似是在stackoverflow下属的一个机构的网站</p><p><a href="https://stackoverflow.com/" target="_blank" rel="noopener">https://stackoverflow.com/</a></p><h3 id="微软网站"><a href="#微软网站" class="headerlink" title="微软网站"></a>微软网站</h3><h4 id="联系微软"><a href="#联系微软" class="headerlink" title="联系微软"></a>联系微软</h4><p><a href="https://support.microsoft.com/zh-cn/contactus" target="_blank" rel="noopener">https://support.microsoft.com/zh-cn/contactus</a> </p><p><a href="https://support.microsoft.com/zh-cn/contact/virtual-agent/?flowId=smc-contactus-entitlement&amp;partnerId=smc&amp;referrer=www.microsoft.com" target="_blank" rel="noopener">https://support.microsoft.com/zh-cn/contact/virtual-agent/?flowId=smc-contactus-entitlement&amp;partnerId=smc&amp;referrer=www.microsoft.com</a> </p><h4 id="社区-1"><a href="#社区-1" class="headerlink" title="社区"></a>社区</h4><p><a href="https://answers.microsoft.com/zh-hans" target="_blank" rel="noopener">https://answers.microsoft.com/zh-hans</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模比赛总结</title>
      <link href="2021/02/12/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AC%94%E8%AE%B0/"/>
      <url>2021/02/12/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>关于已经参加的几次数学建模比赛的参赛总结。</p><a id="more"></a><h1 id="数学建模比赛总结与回顾"><a href="#数学建模比赛总结与回顾" class="headerlink" title="数学建模比赛总结与回顾"></a>数学建模比赛总结与回顾</h1><h2 id="比赛流程梳理"><a href="#比赛流程梳理" class="headerlink" title="比赛流程梳理"></a>比赛流程梳理</h2><h3 id="美赛"><a href="#美赛" class="headerlink" title="美赛"></a>美赛</h3><h4 id="第一天-数据处理分析与模型建立"><a href="#第一天-数据处理分析与模型建立" class="headerlink" title="第一天 数据处理分析与模型建立"></a>第一天 数据处理分析与模型建立</h4><ul><li><p>6-8点。拿到题目，全队<strong>自行读题审题</strong>，按照我们队的重点读A/C/D题（数据相关），对每道题用md写一点自己的分析总结并在<strong>至少1.5小时</strong>后讨论</p></li><li><p>8-10点。基本确定题目。</p><p>每个人迅速<strong>查阅相关资料</strong>，<strong>收集文献</strong>。</p><p>如果是C/D题则全队先各自思考对数据集理解，再一起讨论确定完整的数据处理模型。如果是A题，则先找好数据再讨论。需要确定的数据处理内容有以下几个：</p><ul><li><strong>数据清洗与预处理方式</strong>（如何处理异常值，残缺值，重复值，标准化方法等）。</li><li>对于<strong>每道题</strong>都先定义<strong>单独的数据集</strong>，包含这个题需要用到的所有数据。</li><li>确立整体数据集，即<strong>体现出各题之间联系</strong>的或者<strong>多题需要用到</strong>的多用数据集。常用于开头的引入和数据处理部分以及结尾的写信部分的写作。</li></ul></li><li><p>10-12点。<strong>查文献</strong>和<strong>数据处理</strong>以及做探索性数据分析（EDA）。</p></li><li>14-15点。数据处理基本结束，全队先自行思考建模同学的思路并做出自己的补充，之后全队交流。</li><li>15-16点。和指导老师交流，明确思路和方向。</li><li>16点-晚上。<ul><li>完成数据处理和初步可视化，写作论文的问题重述、背景介绍、数据处理部分。</li><li>根据建模同学的数学原理跑出至少前两个问的模型。</li><li>建模同学至少给出<strong>前三题</strong>的<strong>大致解法</strong>。</li></ul></li></ul><h4 id="第二天-模型完善与模型计算"><a href="#第二天-模型完善与模型计算" class="headerlink" title="第二天 模型完善与模型计算"></a>第二天 模型完善与模型计算</h4><ul><li>上午：跑完至少1题并顺便做相应可视化。</li><li>下午：跑完至少1题并顺便做相应可视化。建模同学大概把所有问题的模型建立完全，并对每道题的思路用中文表述，且确立符号表。</li><li>晚上：跑完至少1题并顺便做相应可视化。</li></ul><h4 id="第三天-模型跑完与可视化"><a href="#第三天-模型跑完与可视化" class="headerlink" title="第三天 模型跑完与可视化"></a>第三天 模型跑完与可视化</h4><ul><li>所有模型的代码全部跑完，并做相应的可视化整理。</li><li>论文的中文版完善以及前几部分的英文版敲定。</li><li>模型优化与调参，模型和结果最后完善。</li></ul><h4 id="第四天-可视化与论文写作"><a href="#第四天-可视化与论文写作" class="headerlink" title="第四天 可视化与论文写作"></a>第四天 可视化与论文写作</h4><ul><li>每人分工翻译几个部分，并直接打到overleaf上（包括图片、表格、公式），同时完成对应部分时进行补充的可视化。</li><li>晚上20点前尽量完成论文的撰写，并给老师看。</li><li>20点一直到第二天8点根据老师意见进行修改，需要可视化的继续作图，并不断打磨文字。</li><li>第五天早上8点前完成论文提交。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据科学 </tag>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>missingCourseForCsers_note_stanford</title>
      <link href="2021/02/12/missingCourseForCsers-note-stanford/"/>
      <url>2021/02/12/missingCourseForCsers-note-stanford/</url>
      
        <content type="html"><![CDATA[<p>关于一些CS必备工具使用的笔记，根据斯坦福的缺失的一课课程以及一些其他网络教程整理得来。</p><a id="more"></a><p><a href="https://missing-semester-cn.github.io/" target="_blank" rel="noopener">https://missing-semester-cn.github.io/</a></p><h2 id="一、shell脚本"><a href="#一、shell脚本" class="headerlink" title="一、shell脚本"></a>一、shell脚本</h2><p><code>Bourne Again SHell</code>——Bash</p><p>终端，文字接口，Shell</p><h3 id="使用shell执行程序"><a href="#使用shell执行程序" class="headerlink" title="使用shell执行程序"></a>使用shell执行程序</h3><p>如果执行的程序不是shell编程关键字，则咨询环境变量</p><p>shell使用空格分割命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">打开后看到的:</span></span><br><span class="line">muller:~$ #$表示不是root用户 muller--&gt;用户名下面的代码略去了用户名，只保留$后的</span><br><span class="line"><span class="meta">$</span><span class="bash"> date <span class="comment">#执行程序，打印当前时间</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> hello <span class="comment">#echo--&gt;打印函数 hello为参数 特殊字符(比如空格)可以用""、''将后面的参数括起来，也可以用转义字符</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$path</span> <span class="comment">#打印环境变量所在路径</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">which</span> <span class="built_in">echo</span> <span class="comment">#打印echo的环境变量路径</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /bin/<span class="built_in">echo</span> <span class="variable">$path</span> <span class="comment">#直接使用路径名执行echo程序</span></span></span><br></pre></td></tr></table></figure><h3 id="在shell中导航"><a href="#在shell中导航" class="headerlink" title="在shell中导航"></a>在shell中导航</h3><p><code>linux</code>系统中<code>/</code>开头的都是<strong>绝对路径</strong>。</p><p>命令后带<code>-</code>接受标记和选项</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">pwd</span> <span class="comment">#获取当前目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ../a <span class="comment">#cd 切换到上级目录中的a文件夹 .表示当前目录 ..表示上一级目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls <span class="comment">#查看目录下包含的文件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -<span class="built_in">help</span> <span class="comment">#或ls -h</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mv 1.txt a.txt <span class="comment">#重命名或移动文件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp 1.txt <span class="comment">#拷贝文件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir <span class="comment">#新建文件目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> man ls <span class="comment">#man获取ls的手册 使用q退出</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> touch 1.txt <span class="comment">#创建空文件</span></span></span><br></pre></td></tr></table></figure><h3 id="在程序间创建连接"><a href="#在程序间创建连接" class="headerlink" title="在程序间创建连接"></a>在程序间创建连接</h3><p>shell中有输入输出流</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> hello &gt; hello.txt <span class="comment">#最简单的重定向输出，如果不存在hello.txt文件则生成出来一个</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat hello txt <span class="comment">#获取文件内容</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat &lt; hello.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat &lt; hello.txt &gt; hello2.txt</span></span><br></pre></td></tr></table></figure><p>使用&gt;&gt;可以进行追加输出</p><p>根用户：<code>sudo</code> 命令开头，变为<code>root</code>用户</p><h3 id="变量，控制语句"><a href="#变量，控制语句" class="headerlink" title="变量，控制语句"></a>变量，控制语句</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> a=1 <span class="comment">#变量赋值</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'$a'</span> <span class="comment">#打印出 $a</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"<span class="variable">$a</span>"</span> <span class="comment">#打印出a变量的值，即1</span></span></span><br></pre></td></tr></table></figure><p>以<strong><code>&#39;</code>定义</strong>的字符串为<strong>原义字符串</strong>，其中的变量不会被转义，而 <strong><code>&quot;</code>定义</strong>的字符串会<strong>将变量值进行替换</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mcd () &#123;</span><br><span class="line">    mkdir -p "$1"</span><br><span class="line">    cd "$1"</span><br><span class="line">&#125;  #函数定义</span><br></pre></td></tr></table></figure><ul><li><code>$0</code> - 脚本名</li><li><code>$1</code> 到 <code>$9</code> - 脚本的参数。 <code>$1</code> 是第一个参数，依此类推。</li><li><code>$@</code> - 所有参数</li><li><code>$#</code> - 参数个数</li><li><code>$?</code> - 前一个命令的返回值</li><li>$$$$ - 当前脚本的进程识别码</li><li><code>!!</code> - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 <code>sudo !!</code>再尝试一次。</li><li><code>$_</code> - 上一条命令的最后一个参数。如果你正在使用的是交互式shell，你可以通过按下 <code>Esc</code> 之后键入 . 来获取这个值。</li></ul><p>命令通常使用 <code>STDOUT</code>来返回输出值，使用<code>STDERR</code> 来返回错误及错误码</p><p><strong>返回值0</strong>表示<strong>正常执行</strong>，其他所有<strong>非0的返回值</strong>都表示<strong>有错误发生</strong>。</p><p>可以使用<code>false</code>和<code>true</code>以及<code>&amp;&amp;</code> <code>||</code>等逻辑表达式来作为条件，例如：<code>false || echo &quot;1234&quot;</code></p><h3 id="Shell工具"><a href="#Shell工具" class="headerlink" title="Shell工具"></a>Shell工具</h3><h4 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查找所有名称为src的文件夹</span></span><br><span class="line">find . -name src -type d</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找所有文件夹路径中包含<span class="built_in">test</span>的python文件</span></span><br><span class="line">find . -path '**/test/**/*.py' -type f</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找前一天修改的所有文件</span></span><br><span class="line">find . -mtime -1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找所有大小在500k至10M的tar.gz文件</span></span><br><span class="line">find . -size +500k -size -10M -name '*.tar.gz'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">对找到文件进行操作</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Delete all files with .tmp extension</span></span><br><span class="line">find . -name '*.tmp' -exec rm &#123;&#125; \;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Find all PNG files and convert them to JPG</span></span><br><span class="line">find . -name '*.png' -exec convert &#123;&#125; &#123;&#125;.jpg \;</span><br></pre></td></tr></table></figure><p><code>fd</code> <code>locate</code> 是另外两个查找工具</p><h4 id="查找代码"><a href="#查找代码" class="headerlink" title="查找代码"></a>查找代码</h4><p><code>grep</code> <code>ack</code> <code>ag</code> <code>rg</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查找所有使用了 requests 库的文件</span></span><br><span class="line">rg -t py 'import requests'</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找所有没有写 shebang 的文件（包含隐藏文件）</span></span><br><span class="line">rg -u --files-without-match "^#!"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找所有的foo字符串，并打印其之后的5行</span></span><br><span class="line">rg foo -A 5</span><br><span class="line"><span class="meta">#</span><span class="bash"> 打印匹配的统计信息（匹配的行和文件的数量）</span></span><br><span class="line">rg --stats PATTERN</span><br></pre></td></tr></table></figure><h4 id="查找shell命令"><a href="#查找shell命令" class="headerlink" title="查找shell命令"></a>查找shell命令</h4><p><code>history</code> 命令允许您以程序员的方式来访问shell中输入的历史命令</p><p>使用 <code>Ctrl+R</code> 对命令历史记录进行回溯搜索。可以配合 <a href="https://github.com/junegunn/fzf/wiki/Configuring-shell-key-bindings#ctrl-r" target="_blank" rel="noopener"><code>fzf</code></a> 使用</p><h4 id="文件夹导航"><a href="#文件夹导航" class="headerlink" title="文件夹导航"></a>文件夹导航</h4><p>Fasd 基于 <a href="https://developer.mozilla.org/en/The_Places_frecency_algorithm" target="_blank" rel="noopener"><code>frecency</code></a> 对文件和文件排序，也就是说它会同时针对频率（frequency ）和时效（ recency）进行排序。</p><p>对于常用的目录，目录名子串前加入一个命令 <code>z</code> 就可以快速切换命令到该目录</p><p>还有一些更复杂的工具可以用来概览目录结构，例如 <a href="https://linux.die.net/man/1/tree" target="_blank" rel="noopener"><code>tree</code></a>, <a href="https://github.com/Canop/broot" target="_blank" rel="noopener"><code>broot</code></a> 或更加完整的文件管理器，例如 <a href="https://github.com/jarun/nnn" target="_blank" rel="noopener"><code>nnn</code></a> 或 <a href="https://github.com/ranger/ranger" target="_blank" rel="noopener"><code>ranger</code></a>。</p><h2 id="二、Vim编辑器"><a href="#二、Vim编辑器" class="headerlink" title="二、Vim编辑器"></a>二、Vim编辑器</h2><h3 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h3><ul><li>正常模式：在文件中四处移动光标进行修改（默认的模式）</li><li>插入模式：插入文本 </li><li>替换模式：替换文本</li><li>可视化（一般，行，块）模式：选中文本块</li><li>命令模式：用于执行命令</li></ul><p>按下 <code>&lt;ESC&gt;</code> （退出键） 从任何其他模式返回正常模式。 正常模式和插入模式是最常用的两个模式</p><h4 id="正常模式与各个模式切换"><a href="#正常模式与各个模式切换" class="headerlink" title="正常模式与各个模式切换"></a>正常模式与各个模式切换</h4><p>键入 <code>i</code> 进入插入 模式， <code>R</code> 进入替换模式</p><p> <code>v</code> 进入可视（一般）模式， <code>V</code> 进入可视（行）模式， <code>&lt;C-v&gt;</code> （Ctrl-V, 有时也写作 <code>^V</code>）进入可视（块）模式，</p><p> <code>:</code> 进入命令模式。</p><ul><li><code>:q</code> 退出 （关闭窗口）</li><li><code>:w</code> 保存 （写）</li><li><code>:wq</code> 保存然后退出</li><li><code>:e {文件名}</code> 打开要编辑的文件</li><li><code>:ls</code> 显示打开的缓存</li><li><code>:help {标题}</code>打开帮助文档<ul><li><code>:help :w</code> 打开 <code>:w</code> 命令的帮助文档</li><li><code>:help w</code> 打开 <code>w</code> 移动的帮助文档</li></ul></li></ul><h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><ul><li>基本移动: <code>hjkl</code> （左， 下， 上， 右）</li><li>词： <code>w</code> （下一个词）， <code>b</code> （词初）， <code>e</code> （词尾）</li><li>行： <code>0</code> （行初）， <code>^</code> （第一个非空格字符）， <code>$</code> （行尾）</li><li>屏幕： <code>H</code> （屏幕首行）， <code>M</code> （屏幕中间）， <code>L</code> （屏幕底部）</li><li>翻页： <code>Ctrl-u</code> （上翻）， <code>Ctrl-d</code> （下翻）</li><li>文件： <code>gg</code> （文件头）， <code>G</code> （文件尾）</li><li>行数： <code>:{行数}&lt;CR&gt;</code> 或者 <code>{行数}G</code> ({行数}为行数)</li><li>杂项： <code>%</code> （找到配对，比如括号或者 /<em> </em>/ 之类的注释对）</li><li>查找：<code>f{字符}</code> <code>t{字符}</code> <code>F{字符}</code> <code>T{字符}</code><ul><li>查找/到 向前/向后 在本行的{字符}</li><li><code>,</code> / <code>;</code> 用于导航匹配</li></ul></li><li>搜索: <code>/{正则表达式}</code>, <code>n</code> / <code>N</code> 用于导航匹配</li></ul><h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><ul><li><code>i</code>进入插入模式<ul><li>但是对于操纵/编辑文本，不单想用退格键完成</li></ul></li><li><code>O</code> / <code>o</code> 在之上/之下插入行</li><li><code>d{移动命令}</code> 删除 {移动命令}<ul><li>例如， <code>dw</code> 删除词, <code>d$</code> 删除到行尾, <code>d0</code> 删除到行头。</li></ul></li><li><code>c{移动命令}</code>改变 {移动命令}<ul><li>例如， <code>cw</code> 改变词</li><li>比如 <code>d{移动命令}</code> 再 <code>i</code></li></ul></li><li><code>x</code> 删除字符 （等同于 <code>dl</code>）</li><li><code>s</code> 替换字符 （等同于 <code>xi</code>）</li><li>可视化模式 + 操作<ul><li>选中文字, <code>d</code> 删除 或者 <code>c</code> 改变</li></ul></li><li><code>u</code> 撤销, <code>&lt;C-r&gt;</code> 重做</li><li><code>y</code> 复制 / “yank” （其他一些命令比如 <code>d</code> 也会复制）</li><li><code>p</code> 粘贴</li><li>更多值得学习的: 比如 <code>~</code> 改变字符的大小写</li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习</title>
      <link href="2021/02/10/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/02/10/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>算法学习笔记，本篇主要是一些基本的知识整理</p><a id="more"></a><h1 id="《labuladong算法小抄》笔记"><a href="#《labuladong算法小抄》笔记" class="headerlink" title="《labuladong算法小抄》笔记"></a>《labuladong算法小抄》笔记</h1><h2 id="一、语言基础"><a href="#一、语言基础" class="headerlink" title="一、语言基础"></a>一、语言基础</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><p>传参用<code>&amp;</code>表示引用</p><h4 id="1-动态数组vector"><a href="#1-动态数组vector" class="headerlink" title="1.动态数组vector"></a>1.动态数组vector</h4><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n=<span class="number">7</span>,m=<span class="number">8</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>; <span class="comment">//数组中全部为0</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;; <span class="comment">//初始化为1,3,5</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(n,<span class="number">2</span>)</span></span>; <span class="comment">//初始化一个长度为n且全为2的数组</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp; <span class="comment">//初始一个二维数组</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(m,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n,<span class="literal">true</span>))</span></span>; <span class="comment">//初始一个m*n的二维布尔数组 且值全为true</span></span><br></pre></td></tr></table></figure><h5 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="comment">//返回是否为空</span></span></span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span></span>; <span class="comment">//返回大小</span></span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span></span>; <span class="comment">//返回最后一个值的引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>; <span class="comment">//尾部插入一个元素val</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>; <span class="comment">//删除尾部元素</span></span><br></pre></td></tr></table></figure><h4 id="2-字符串string"><a href="#2-字符串string" class="headerlink" title="2.字符串string"></a>2.字符串string</h4><h5 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s; <span class="comment">//s--&gt;""</span></span><br><span class="line"><span class="built_in">string</span> s=<span class="string">"abc"</span>;</span><br></pre></td></tr></table></figure><h5 id="成员函数-1"><a href="#成员函数-1" class="headerlink" title="成员函数"></a>成员函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">char</span> c)</span></span>; <span class="comment">//尾部插入一个字符c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>; <span class="comment">//删除尾部字符</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">substr</span><span class="params">(<span class="keyword">size_t</span> pos,<span class="keyword">size_t</span> len)</span></span>; <span class="comment">//获得pos开始的长度为len的子串</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s1==s2; <span class="comment">//看两字符串是否相等</span></span><br></pre></td></tr></table></figure><h4 id="3-哈希表unordered-map"><a href="#3-哈希表unordered-map" class="headerlink" title="3.哈希表unordered_map"></a>3.哈希表unordered_map</h4><h5 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mapping; <span class="comment">//key and value both int</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; mapping; <span class="comment">//key is string,value is int</span></span><br></pre></td></tr></table></figure><h5 id="成员函数-2"><a href="#成员函数-2" class="headerlink" title="成员函数"></a>成员函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span></span>; <span class="comment">//返回键值对个数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>;<span class="comment">//是否为空</span></span><br><span class="line"><span class="function">size_type <span class="title">count</span> <span class="params">(<span class="keyword">const</span> key_type&amp; key)</span></span>; <span class="comment">//返回key在map中出现次数,由于哈希表，这个值只能是0/1，因此本函数用于判断key是否在哈希表中</span></span><br><span class="line"><span class="function">size_type <span class="title">erase</span><span class="params">(<span class="keyword">const</span> key_type&amp; key)</span></span>; <span class="comment">//清除一个键值对</span></span><br></pre></td></tr></table></figure><h5 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; counter;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">    counter[num]++; <span class="comment">//如果键值num本来不存在，则相当于是初始化为0后再+1:counter[num]=0;counter[num]++;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; it:counter)&#123;</span><br><span class="line">    <span class="keyword">int</span> key=it.first;</span><br><span class="line">    <span class="keyword">int</span> value=it.second;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;key&lt;&lt;<span class="string">":"</span>&lt;&lt;value&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-哈希集合unordered-set"><a href="#4-哈希集合unordered-set" class="headerlink" title="4.哈希集合unordered_set"></a>4.哈希集合unordered_set</h4><h5 id="初始化-3"><a href="#初始化-3" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; visited;</span><br></pre></td></tr></table></figure><h5 id="成员函数-3"><a href="#成员函数-3" class="headerlink" title="成员函数"></a>成员函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span></span>; <span class="comment">//返回元素的个数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>;<span class="comment">//是否为空</span></span><br><span class="line"><span class="function">size_type <span class="title">count</span> <span class="params">(<span class="keyword">const</span> key_type&amp; key)</span></span>; <span class="comment">//类似哈希表</span></span><br><span class="line">pair&lt;iterator,bool&gt; insert(const key_type&amp; key);//插入元素</span><br><span class="line"><span class="function">size_type <span class="title">erase</span><span class="params">(<span class="keyword">const</span> key_type&amp; key)</span></span>;<span class="comment">//删除元素</span></span><br></pre></td></tr></table></figure><h4 id="5-队列queue"><a href="#5-队列queue" class="headerlink" title="5.队列queue"></a>5.队列queue</h4><h5 id="初始化-4"><a href="#初始化-4" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;</span><br></pre></td></tr></table></figure><h5 id="成员函数-4"><a href="#成员函数-4" class="headerlink" title="成员函数"></a>成员函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span></span>; <span class="comment">//返回队列元素的个数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>;<span class="comment">//队列是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp;val)</span></span>; <span class="comment">//加入元素到队尾</span></span><br><span class="line"><span class="function">value_type&amp; <span class="title">front</span><span class="params">()</span></span>; <span class="comment">//获得队头元素引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">//删除队头元素</span></span><br><span class="line"><span class="keyword">int</span> e=q.front();q.pop(); <span class="comment">//获得队头元素并出队,注意,pop()是直接删除,不会返回队头元素</span></span><br></pre></td></tr></table></figure><h4 id="6-堆栈stack"><a href="#6-堆栈stack" class="headerlink" title="6.堆栈stack"></a>6.堆栈stack</h4><h5 id="初始化-5"><a href="#初始化-5" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; stk;</span><br></pre></td></tr></table></figure><h5 id="成员函数-5"><a href="#成员函数-5" class="headerlink" title="成员函数"></a>成员函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span></span>; <span class="comment">//返回堆栈元素的个数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>;<span class="comment">//堆栈是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp;val)</span></span>; <span class="comment">//加入元素到栈顶</span></span><br><span class="line"><span class="function">value_type&amp; <span class="title">top</span><span class="params">()</span></span>; <span class="comment">//获得栈顶元素引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">//删除队头元素</span></span><br><span class="line"><span class="keyword">int</span> e=q.front();q.pop(); <span class="comment">//获得队头元素并出队,注意,pop()是直接删除,不会返回队头元素</span></span><br></pre></td></tr></table></figure><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><h4 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m=<span class="number">5</span>,n=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>[] nums=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">boolean</span>[][] visited=<span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">nums.length --&gt;获得数组长度</span><br></pre></td></tr></table></figure><h4 id="2-字符串String"><a href="#2-字符串String" class="headerlink" title="2.字符串String"></a>2.字符串String</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="string">"Hello,world"</span>;</span><br><span class="line"><span class="keyword">char</span> c=s1.charAt(<span class="number">2</span>); <span class="comment">//返回字符串中第2个字符</span></span><br><span class="line"><span class="keyword">char</span>[] chars=s1.toCharArray();  <span class="comment">//字符串转字符数组</span></span><br><span class="line">chars[<span class="number">1</span>]=<span class="string">'a'</span>;</span><br><span class="line">String s2=<span class="keyword">new</span> String(chars); <span class="comment">//字符数组转字符串</span></span><br><span class="line">System.out.println(s2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(s1.equals(s2))&#123;</span><br><span class="line">    <span class="comment">//s1==s2</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//s1!=s2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String s3=s1+<span class="string">"!"</span>; <span class="comment">//+的效率比较低</span></span><br><span class="line">StringBuilder sb=<span class="keyword">new</span> StringBuilder(); <span class="comment">//一般用StringBuilder append方法好一点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">char</span> c=<span class="string">'a'</span>;c&lt;<span class="string">'f'</span>;c++)&#123;  </span><br><span class="line">    sb.append(c);</span><br><span class="line">&#125;</span><br><span class="line">sb.append(<span class="string">'a'</span>).append(<span class="string">"avx"</span>).append(<span class="number">1234</span>) <span class="comment">//支持拼接字符串，字符，数字</span></span><br><span class="line">    </span><br><span class="line">String s=sb.toString();<span class="comment">//转为字符串类型</span></span><br><span class="line"><span class="comment">//注:字符串比较尽量用s.equals(s1),否则可能出意想不到的问题</span></span><br></pre></td></tr></table></figure><h4 id="3-动态数组ArrayList"><a href="#3-动态数组ArrayList" class="headerlink" title="3.动态数组ArrayList"></a>3.动态数组ArrayList</h4><p>类似<code>C++</code>的<code>vector</code></p><p><code>E</code>代表元素,下同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; nums=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">ArrayList&lt;Integer&gt; strings=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>; <span class="comment">//获得数组大小</span></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>; <span class="comment">//获得index处元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>; <span class="comment">//尾部添加元素</span></span><br></pre></td></tr></table></figure><h4 id="4-双链表LinkedList"><a href="#4-双链表LinkedList" class="headerlink" title="4.双链表LinkedList"></a>4.双链表LinkedList</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;String&gt; strings=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>; <span class="comment">//获得数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>; <span class="comment">//时间复杂度为O(n),比较慢</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addFirst</span><span class="params">(E e)</span></span>; <span class="comment">//头部添加元素</span></span><br><span class="line"><span class="function">E <span class="title">removeFirst</span><span class="params">()</span></span>;<span class="comment">//delete first element</span></span><br><span class="line"><span class="function">E <span class="title">removeLast</span><span class="params">()</span></span>;<span class="comment">//delete last element</span></span><br></pre></td></tr></table></figure><h4 id="5-哈希表HashMap"><a href="#5-哈希表HashMap" class="headerlink" title="5.哈希表HashMap"></a>5.哈希表HashMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer,String&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">HashMap&lt;String,<span class="keyword">int</span>[]&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">//字符串到数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常用方法</span></span><br><span class="line"><span class="comment">//K代表键值，V代表类型</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span></span>; <span class="comment">//判断是否存在键key</span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(Object key)</span></span>;<span class="comment">//获得key对应value值</span></span><br><span class="line"><span class="function">V <span class="title">put</span><span class="params">(K key,V value)</span></span>; <span class="comment">//存入哈希表</span></span><br><span class="line"><span class="function">V <span class="title">remove</span><span class="params">(Object key)</span></span>; <span class="comment">//删除key并返回对应值</span></span><br><span class="line"><span class="function">V <span class="title">getOrDefault</span><span class="params">(Object key,defaultValue)</span> <span class="comment">//返回key对应value值，不存在则返回default值</span></span></span><br><span class="line"><span class="function">Set&lt;k&gt; <span class="title">keySet</span><span class="params">()</span> <span class="comment">//获得Hash表中所有key</span></span></span><br><span class="line"><span class="function">V <span class="title">putIfAbsent</span><span class="params">(K key,V value)</span></span>;<span class="comment">//存在则不做事,不存在就插入</span></span><br></pre></td></tr></table></figure><h4 id="6-哈希集合HashSet"><a href="#6-哈希集合HashSet" class="headerlink" title="6.哈希集合HashSet"></a>6.哈希集合HashSet</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">//init</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>; <span class="comment">//add an element</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>; <span class="comment">//集合是否存在元素o</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>; <span class="comment">//若o存在则删除</span></span><br></pre></td></tr></table></figure><h4 id="7-队列Queue"><a href="#7-队列Queue" class="headerlink" title="7.队列Queue"></a>7.队列Queue</h4><p><code>Queue</code>是一个接口,初始化方式相对特别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;String&gt; q=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span></span>; <span class="comment">//返回队头元素</span></span><br><span class="line"><span class="function">E <span class="title">poll</span><span class="params">()</span></span>; <span class="comment">//删除并返回队尾元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>; <span class="comment">//将元素e插入队尾</span></span><br></pre></td></tr></table></figure><h4 id="8-堆栈Stack"><a href="#8-堆栈Stack" class="headerlink" title="8.堆栈Stack"></a>8.堆栈Stack</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;integer&gt; s=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">push</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span></span>; <span class="comment">//返回栈顶元素</span></span><br><span class="line"><span class="function">E <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">//删除并返回栈顶元素</span></span><br></pre></td></tr></table></figure><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list</span><br><span class="line">tuple</span><br><span class="line">set</span><br><span class="line">dict</span><br></pre></td></tr></table></figure><h2 id="二、核心套路"><a href="#二、核心套路" class="headerlink" title="二、核心套路"></a>二、核心套路</h2>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据科学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据分析可视化笔记</title>
      <link href="2021/02/04/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AC%94%E8%AE%B0/"/>
      <url>2021/02/04/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>关于python数据科学相关的知识笔记</p><a id="more"></a><h1 id="Python数据分析可视化笔记"><a href="#Python数据分析可视化笔记" class="headerlink" title="Python数据分析可视化笔记"></a>Python数据分析可视化笔记</h1><h4 id="jupyter-lab好东西集合"><a href="#jupyter-lab好东西集合" class="headerlink" title="jupyter lab好东西集合"></a>jupyter lab好东西集合</h4><p><a href="https://www.cnblogs.com/feffery/p/13364668.html" target="_blank" rel="noopener">https://www.cnblogs.com/feffery/p/13364668.html</a></p><h2 id="pandas基本操作和概念"><a href="#pandas基本操作和概念" class="headerlink" title="pandas基本操作和概念"></a>pandas基本操作和概念</h2><p><code>DataFrame</code>对象单独取出一行即：<code>df.loc[0]</code>和一列<code>df[&quot;a&quot;]</code>都是<code>Series</code>对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> nunpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df.columns <span class="comment">#DataFrame对象所有表头值组成的列表</span></span><br><span class="line">df.index <span class="comment">#DataFrame对象所有索引组成的列表</span></span><br></pre></td></tr></table></figure><h3 id="创建DataFrame对象"><a href="#创建DataFrame对象" class="headerlink" title="创建DataFrame对象"></a>创建DataFrame对象</h3><p>最简单也最好用：根据两个列表创建</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">index=[i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>)]</span><br><span class="line">columns=[<span class="string">"a"</span>,<span class="string">"b"</span>]</span><br><span class="line">df=pd.DataFrame(index=index,columns=columns)</span><br><span class="line">l1=[i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>)]</span><br><span class="line">l2=[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">df[<span class="string">"a"</span>]=l1 <span class="comment">#直接用列表给df一列赋值</span></span><br><span class="line">df.loc[<span class="number">0</span>]=l2 <span class="comment">##直接用列表给df一行赋值</span></span><br></pre></td></tr></table></figure><h2 id="数据分析6步"><a href="#数据分析6步" class="headerlink" title="数据分析6步"></a>数据分析6步</h2><h3 id="一、读取数据"><a href="#一、读取数据" class="headerlink" title="一、读取数据"></a>一、读取数据</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">pd.read_excel(<span class="string">"1.xlsx"</span>,)</span><br><span class="line">pd.read_csv(<span class="string">"1.csv"</span>)</span><br><span class="line"><span class="comment">#查询用法</span></span><br><span class="line">pd.read_excel?</span><br><span class="line">pd.*read*?</span><br></pre></td></tr></table></figure><h3 id="二、清洗数据"><a href="#二、清洗数据" class="headerlink" title="二、清洗数据"></a>二、清洗数据</h3><h4 id="查找异常"><a href="#查找异常" class="headerlink" title="查找异常"></a>查找异常</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置最多显示十行</span></span><br><span class="line">pd.set_option(<span class="string">'max_rows'</span>, <span class="number">10</span>) </span><br><span class="line"><span class="comment">#查找异常</span></span><br><span class="line">df[df[<span class="string">"a"</span>].isnull()]</span><br><span class="line"><span class="comment">#查找完全重复的行</span></span><br><span class="line">df[df.duplicated()]</span><br><span class="line"><span class="comment"># 查找某⼀列重复的⾏</span></span><br><span class="line">df[df.编号.duplicated()]</span><br><span class="line"><span class="comment"># 查找a属性的所有唯⼀值</span></span><br><span class="line">df.a.unique()</span><br><span class="line"><span class="comment"># 查找a包含 30 的异常值</span></span><br><span class="line">df[df.a.isin([<span class="string">'30'</span>])]</span><br><span class="line"><span class="comment">#字符换匹配</span></span><br><span class="line">df[df.a.str.contains(<span class="string">"abc"</span>,na=<span class="literal">False</span>)]</span><br><span class="line"><span class="comment"># 查找a列值在1到5之间的⾏</span></span><br><span class="line">df[df.a.between(<span class="number">1</span>, <span class="number">5</span>)]</span><br><span class="line"><span class="comment">#逻辑运算</span></span><br><span class="line">df[(df.a &gt;= <span class="number">1</span>) &amp; (df.b &lt;= <span class="number">5</span>)]</span><br></pre></td></tr></table></figure><h4 id="排除重复"><a href="#排除重复" class="headerlink" title="排除重复"></a>排除重复</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df.drop_duplicates()</span><br><span class="line">df.drop_duplicates(inplace=<span class="literal">True</span>) <span class="comment">#直接改变原数据</span></span><br><span class="line">df.drop_duplicates([<span class="string">'a'</span>]) <span class="comment"># 按某⼀列排除重复，默认保留第⼀⾏ keep='last'--&gt;删除最后一行</span></span><br></pre></td></tr></table></figure><h4 id="删除缺失值"><a href="#删除缺失值" class="headerlink" title="删除缺失值"></a>删除缺失值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">color.dropna()</span><br><span class="line">color.dropna(how=<span class="string">'all'</span>) <span class="comment"># 删除全部为空的⾏</span></span><br><span class="line">color.dropna(axis=<span class="number">1</span>) <span class="comment"># 删除包含缺失值的列</span></span><br></pre></td></tr></table></figure><h4 id="补全缺失值"><a href="#补全缺失值" class="headerlink" title="补全缺失值"></a>补全缺失值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df.fillna(<span class="string">'a'</span>) <span class="comment">#所有缺失处补上"a" 实际工作时常补上0</span></span><br><span class="line">df.fillna(method=<span class="string">'bfill'</span>) <span class="comment">#⽤后⾯的值填充</span></span><br><span class="line">df.fillna( &#123;<span class="string">'花⾊'</span>: <span class="number">0</span>, <span class="string">'牌⾯'</span>: <span class="number">1</span>&#125; ) <span class="comment">#按照字典填充</span></span><br></pre></td></tr></table></figure><h4 id="完整例子"><a href="#完整例子" class="headerlink" title="完整例子"></a>完整例子</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 设置最多显示 10 ⾏</span></span><br><span class="line">pd.set_option(<span class="string">'max_rows'</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 从 Excel ⽂件中读取原始数据</span></span><br><span class="line">df = pd.read_excel(<span class="string">'待清洗的扑克牌数据集.xlsx'</span>,sheet_name=<span class="string">"name"</span>)</span><br><span class="line"><span class="comment"># 补全缺失值</span></span><br><span class="line">df = df.fillna(<span class="string">'Joker'</span>)</span><br><span class="line"><span class="comment"># 排除重复值</span></span><br><span class="line">df = df.drop_duplicates()</span><br><span class="line"><span class="comment"># 修改异常值</span></span><br><span class="line">df.loc[<span class="number">4</span>, <span class="string">'牌⾯'</span>] = <span class="number">3</span></span><br><span class="line"><span class="comment"># 增加⼀张缺少的牌</span></span><br><span class="line">df = df.append(&#123;<span class="string">'编号'</span>: <span class="number">4</span>,<span class="string">'花⾊'</span>: <span class="string">'⿊桃♠'</span>,<span class="string">'牌⾯'</span>: <span class="number">2</span>&#125;,ignore_index=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 按编号排序</span></span><br><span class="line">df = df.sort_values(<span class="string">'编号'</span>)</span><br><span class="line"><span class="comment"># 重置索引</span></span><br><span class="line">df = df.reset_index()</span><br><span class="line"><span class="comment"># 删除多余的列</span></span><br><span class="line">df = df.drop([<span class="string">'index'</span>], axis=<span class="number">1</span> )</span><br><span class="line"><span class="comment"># 把清洗好的数据保存到 Excel ⽂件</span></span><br><span class="line">df.to_excel(<span class="string">'完成清洗的扑克牌数据.xlsx'</span>,index=<span class="literal">False</span>)</span><br><span class="line">df</span><br></pre></td></tr></table></figure><h3 id="三、操作数据"><a href="#三、操作数据" class="headerlink" title="三、操作数据"></a>三、操作数据</h3><h4 id="增加数据"><a href="#增加数据" class="headerlink" title="增加数据"></a>增加数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">"b"</span>]=[i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>)] <span class="comment">#相当于把df对象当字典用</span></span><br><span class="line">df.insert(<span class="number">1</span>, <span class="string">'a'</span>, [<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">#指定位置插入列</span></span><br><span class="line"><span class="comment">#插入一行</span></span><br><span class="line">a=pd.DataFrame(&#123;<span class="string">"a"</span>:<span class="number">1</span>,<span class="string">"b"</span>:<span class="number">2</span>&#125;)</span><br><span class="line">df2=df.append(a,ignore_index=<span class="literal">True</span>,sort=<span class="literal">False</span>)</span><br><span class="line"><span class="comment">#拼接两个数据框</span></span><br><span class="line">pd.concat([df, a],ignore_index=<span class="literal">True</span>,sort=<span class="literal">False</span>)</span><br><span class="line">还有merge()/join()函数</span><br></pre></td></tr></table></figure><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df.drop([<span class="number">0</span>,<span class="number">2</span>]) <span class="comment">#删除0/2两行数据</span></span><br><span class="line">df.drop(<span class="string">"a"</span>,axis=<span class="number">1</span>) <span class="comment">#删除"a"列的数据</span></span><br><span class="line"><span class="keyword">del</span> df2[<span class="string">"a"</span>] <span class="comment">#直接删除原数据框中的a列数据</span></span><br></pre></td></tr></table></figure><h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df.replace([<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="number">3</span>,<span class="number">4</span>],<span class="string">""</span>,regex=<span class="literal">True</span>) <span class="comment">#替换多个数据 regex--&gt;正则表达式</span></span><br><span class="line">df.loc[<span class="number">0</span>,<span class="string">"a"</span>]=<span class="string">"j"</span> <span class="comment">#修改第0行a属性的值</span></span><br><span class="line">df.columns = list(<span class="string">'AB'</span>) <span class="comment">#修改列名</span></span><br><span class="line">df.rename(&#123;<span class="string">"a"</span>:<span class="string">"b"</span>&#125;,axis=<span class="number">1</span>) <span class="comment">#修改指定列名</span></span><br><span class="line">df.rename(&#123;<span class="number">1</span>:<span class="number">3</span>,<span class="number">2</span>:<span class="number">3</span>&#125;) <span class="comment">#修改行名</span></span><br></pre></td></tr></table></figure><h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">df.head()</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">df[df.a.str.match(<span class="string">'[jk]'</span>, flags=re.IGNORECASE, na=<span class="literal">False</span>)] <span class="comment">#re.IGNORECASE--&gt;不区分大小写</span></span><br><span class="line"><span class="comment">#使用query</span></span><br><span class="line">df.query(</span><br><span class="line"> <span class="string">'1 &lt;= index &lt;= 5 \</span></span><br><span class="line"><span class="string"> and 牌⾯ not in @card '</span></span><br><span class="line">)</span><br><span class="line">df.query(</span><br><span class="line"> <span class="string">'编号 &gt; 编号.mean() \</span></span><br><span class="line"><span class="string"> and 牌⾯ == "A" '</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="四、数据转换"><a href="#四、数据转换" class="headerlink" title="四、数据转换"></a>四、数据转换</h3><h4 id="转换为时间"><a href="#转换为时间" class="headerlink" title="转换为时间"></a>转换为时间</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dateutil.parser <span class="keyword">import</span> parse</span><br><span class="line">df[<span class="string">"time"</span>]=df.Date.transform(parse).copy()</span><br><span class="line">parse(<span class="string">"10/9/2019"</span>,dayfirst=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h4 id="转换为数值"><a href="#转换为数值" class="headerlink" title="转换为数值"></a>转换为数值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pd.to_numeric(errors=<span class="string">'coerce'</span>) <span class="comment">#设置errors参数使得不能替换的值变为nan</span></span><br><span class="line">df.apply(pd.to_numeric,errors=<span class="string">'coerce'</span>) <span class="comment">#errors默认为ignore即略过不能转换的</span></span><br></pre></td></tr></table></figure><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.astype(str).dtypes</span><br><span class="line">对于时间型的数据，我们可以使⽤ strftime() 函数</span><br></pre></td></tr></table></figure><h4 id="转换为区间"><a href="#转换为区间" class="headerlink" title="转换为区间"></a>转换为区间</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pd.cut() <span class="comment">#将数值切割为指定的区间</span></span><br><span class="line">bins=[float(<span class="string">"-inf"</span>),<span class="number">280</span>,float(<span class="string">"inf"</span>)]</span><br><span class="line">pd.cut(df.a,bins=bins,right=<span class="literal">True</span>) <span class="comment">#左开右闭，默认左闭右开</span></span><br><span class="line">pd.cut(df.a,bins=<span class="number">2</span>) <span class="comment">#按照2为间隔划分</span></span><br></pre></td></tr></table></figure><h4 id="分组转换"><a href="#分组转换" class="headerlink" title="分组转换"></a>分组转换</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(<span class="string">"a"</span>)[<span class="string">"b"</span>].transform(sum) <span class="comment">#在⾏数保持不变的情况下，对某列进⾏分组求和</span></span><br><span class="line"><span class="comment">#能够⽅便地计算每个数据对应各⾃分组的占⽐</span></span><br><span class="line">df.groupby(<span class="string">"a"</span>)[<span class="string">"b"</span>].apply(sum) <span class="comment">#返回组数个结果</span></span><br><span class="line">df.groupby(<span class="string">"a"</span>)[<span class="string">"b"</span>].agg([sum,np.mean,<span class="string">"count"</span>])</span><br><span class="line">df.groupby(<span class="string">"month"</span>).agg(</span><br><span class="line">    天数=(<span class="string">"Date"</span>,count),</span><br><span class="line">平均价格=(<span class="string">"Open"</span>,np.mean)) <span class="comment">#对不同列聚合，使用不同函数</span></span><br></pre></td></tr></table></figure><h4 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#min-max标准化</span></span><br><span class="line">(df.a-df.a.min())/(df.a.max()-df.a.min())</span><br></pre></td></tr></table></figure><h3 id="五、整理数据"><a href="#五、整理数据" class="headerlink" title="五、整理数据"></a>五、整理数据</h3><h4 id="外连接-相当于并集"><a href="#外连接-相当于并集" class="headerlink" title="外连接(相当于并集)"></a>外连接(相当于并集)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.merge(df1,how=<span class="string">"outer"</span>,on=<span class="string">"用于连接的列名"</span>) <span class="comment">#缺失值用nan 得到两个表的所有⾏</span></span><br></pre></td></tr></table></figure><h4 id="内连接-相当于交集"><a href="#内连接-相当于交集" class="headerlink" title="内连接(相当于交集)"></a>内连接(相当于交集)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.merge(df1) <span class="comment">#不指定on时以两个表共同的列名为参数</span></span><br><span class="line"><span class="comment">#只返回两个表相互匹配的数据。无nan</span></span><br></pre></td></tr></table></figure><h4 id="左连接与右连接"><a href="#左连接与右连接" class="headerlink" title="左连接与右连接"></a>左连接与右连接</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.merge(df1,how=<span class="string">"left"</span>）<span class="comment">#df为左表，即使df1中某行值无也照样显示,同理右连接</span></span><br></pre></td></tr></table></figure><h4 id="交叉连接"><a href="#交叉连接" class="headerlink" title="交叉连接"></a>交叉连接</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">操作:</span><br><span class="line">（<span class="number">1</span>）⽤ assign() 函数增加 key 列；</span><br><span class="line">（<span class="number">2</span>）⽤ merge() 函数进⾏连接；</span><br><span class="line">（<span class="number">3</span>）删掉 key 列。</span><br><span class="line">df.assign(key=<span class="number">1</span>).merge(df1.assign(key=<span class="number">1</span>),on=<span class="string">"key"</span>).drop(<span class="string">"key"</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="联合拼接"><a href="#联合拼接" class="headerlink" title="联合拼接"></a>联合拼接</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.concat([df1,df2],sort=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h3 id="六、分析数据"><a href="#六、分析数据" class="headerlink" title="六、分析数据"></a>六、分析数据</h3><p>比较nb的三个数据分析库</p><p>参考文章：<a href="https://my.oschina.net/u/4581316/blog/4898542" target="_blank" rel="noopener">https://my.oschina.net/u/4581316/blog/4898542</a></p><h4 id="pandas-profiling"><a href="#pandas-profiling" class="headerlink" title="pandas_profiling"></a>pandas_profiling</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas_profiling</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.set_style(<span class="string">"whitegrid"</span>,&#123;<span class="string">"font.sans-serif"</span>:[<span class="string">"simhei"</span>,<span class="string">"Arial"</span>]&#125;)</span><br><span class="line">x=pandas_profiling.ProfileReport(df)</span><br><span class="line">x.to_file(<span class="string">"name.html"</span>)</span><br></pre></td></tr></table></figure><h4 id="Sweetviz"><a href="#Sweetviz" class="headerlink" title="Sweetviz"></a>Sweetviz</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sweetviz <span class="keyword">as</span> sv</span><br><span class="line">my_report = sv.analyze(mpg)</span><br><span class="line">my_report.show_html()</span><br></pre></td></tr></table></figure><h4 id="pandasGUI"><a href="#pandasGUI" class="headerlink" title="pandasGUI"></a>pandasGUI</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandasgui <span class="keyword">import</span> show</span><br><span class="line"><span class="comment"># 部署GUI的数据集</span></span><br><span class="line">gui = show(mpg)</span><br></pre></td></tr></table></figure><h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><h3 id="pyecharts"><a href="#pyecharts" class="headerlink" title="pyecharts"></a>pyecharts</h3><p>官网：<a href="https://pyecharts.org/#/zh-cn/intro" target="_blank" rel="noopener">https://pyecharts.org/#/zh-cn/intro</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据科学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java笔记</title>
      <link href="2021/02/01/Java-note/"/>
      <url>2021/02/01/Java-note/</url>
      
        <content type="html"><![CDATA[<p>Java学习笔记</p><a id="more"></a><h2 id="JAVA-HOW2J教程笔记"><a href="#JAVA-HOW2J教程笔记" class="headerlink" title="JAVA-HOW2J教程笔记"></a>JAVA-HOW2J教程笔记</h2><h3 id="一、JAVA基础"><a href="#一、JAVA基础" class="headerlink" title="一、JAVA基础"></a>一、JAVA基础</h3><h4 id="1-hello-world与命令行运行"><a href="#1-hello-world与命令行运行" class="headerlink" title="1.hello world与命令行运行"></a>1.hello world与命令行运行</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//code:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Helloworld</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; <span class="comment">//main--&gt;主方法，所有代码的入口</span></span><br><span class="line">    System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//run</span></span><br><span class="line">javac hello.java <span class="comment">//编译</span></span><br><span class="line">java hello <span class="comment">//运行class文件</span></span><br></pre></td></tr></table></figure><h4 id="2-面向对象"><a href="#2-面向对象" class="headerlink" title="2.面向对象"></a>2.面向对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span></span>&#123;</span><br><span class="line">    <span class="comment">//属性定义 名字一般为驼峰命名</span></span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">float</span> hp;</span><br><span class="line">    <span class="comment">//方法定义</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span></span>&#123; </span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">num=num+n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//创建</span></span><br><span class="line">Hero a= <span class="keyword">new</span> Hero(); <span class="comment">//实例化类</span></span><br><span class="line">a.num=<span class="number">12</span>;</span><br><span class="line">a.hp=<span class="number">100.0</span>;</span><br><span class="line">a.name=<span class="string">"a"</span>;</span><br></pre></td></tr></table></figure><h4 id="3-变量"><a href="#3-变量" class="headerlink" title="3.变量"></a>3.变量</h4><h5 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">a[基本类型]--&gt; b[整型:byte short int long]</span><br><span class="line">a--&gt;c[浮点型:float double]</span><br><span class="line">a--&gt;d[布尔型:boolean--true,false]</span><br><span class="line">a--&gt;e[字符型:char]</span><br><span class="line">a--&gt;f[注:String不是基本类型,Immutable-创建不可修改]</span><br></pre></td></tr></table></figure><h5 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h5><p>变量命名只能使用字母 数字 $ _，首字母不能用数字</p><h5 id="final"><a href="#final" class="headerlink" title="final"></a>final</h5><p>一个变量被final修饰的时候，该变量只有<strong>一次赋值</strong>的机会</p><h4 id="4-操作符"><a href="#4-操作符" class="headerlink" title="4.操作符"></a>4.操作符</h4><h5 id="使用Scanner类获取输入"><a href="#使用Scanner类获取输入" class="headerlink" title="使用Scanner类获取输入"></a>使用Scanner类获取输入</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> a = s.nextInt();</span><br><span class="line">        System.out.println(<span class="string">"第一个整数："</span>+a);</span><br><span class="line">        <span class="keyword">float</span> b = s.nextFloat();</span><br><span class="line">        System.out.println(<span class="string">"第二个浮点数："</span>+b);</span><br><span class="line">        String str=s.nextLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-数组"><a href="#5-数组" class="headerlink" title="5.数组"></a>5.数组</h4><h5 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//create</span></span><br><span class="line"><span class="keyword">int</span>[] a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]; </span><br><span class="line"></span><br><span class="line"><span class="comment">//3 ways to init</span></span><br><span class="line"><span class="keyword">int</span>[] c=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">int</span>[] c=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">int</span>[] c=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增强型for循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> each:values)&#123;</span><br><span class="line">    System.out.println(each);<span class="comment">//增强型for循环只能用来取值，却不能用来修改数组里的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//copy array</span></span><br><span class="line">System.arraycopy(src, srcPos, dest, destPos, length)</span><br><span class="line">    <span class="comment">//src: 源数组</span></span><br><span class="line">    <span class="comment">//srcPos: 从源数组复制数据的起始位置</span></span><br><span class="line">    <span class="comment">//dest: 目标数组</span></span><br><span class="line">    <span class="comment">//destPos: 复制到目标数组的启始位置</span></span><br><span class="line">    <span class="comment">//length: 复制的长度  </span></span><br><span class="line"><span class="keyword">int</span>[] b;</span><br><span class="line">System.arraycopy(a, <span class="number">0</span>, b, <span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//二维数组</span></span><br><span class="line"><span class="keyword">int</span> b[][] = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">   &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">   &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,</span><br><span class="line">   &#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="常见数组函数"><a href="#常见数组函数" class="headerlink" title="常见数组函数"></a>常见数组函数</h5><p>需要引入包 <code>import java.util.Arrays;</code></p><div class="table-container"><table><thead><tr><th style="text-align:center">数组函数</th><th style="text-align:center">对应操作</th></tr></thead><tbody><tr><td style="text-align:center">Arrays.copyOfRange(int[] original, int from, int to)</td><td style="text-align:center">int[] b = Arrays.copyOfRange(a, 0, 3);复制数组</td></tr><tr><td style="text-align:center">Arrays.toString(a)</td><td style="text-align:center">转换成”[1,2,3,4]”字符串形式</td></tr><tr><td style="text-align:center">Arrays.sort(a)</td><td style="text-align:center">排序</td></tr><tr><td style="text-align:center">Arrays.binarySearch(a, 62)</td><td style="text-align:center">二分查找</td></tr><tr><td style="text-align:center">Arrays.equals(a, b)</td><td style="text-align:center">判断是否相同</td></tr><tr><td style="text-align:center">Arrays.fill(a,5)</td><td style="text-align:center">使用同一个值，填充整个数组</td></tr></tbody></table></div><h4 id="6-类和对象"><a href="#6-类和对象" class="headerlink" title="6.类和对象"></a>6.类和对象</h4><h5 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h5><p>对象不是基本类型——即是引用（即指针）</p><p><code>Hero h = new Hero();</code>  h为引用，代表了右边创建的的Hero类型对象，即h指向右侧的这个对象</p><p><code>Hero h1 = h;</code> 则h1和h指向同一个对象</p><p><code>h = new Hero()</code> h指向新的对象</p><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>extends关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Weapon</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> price;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Weapon</span> <span class="keyword">extends</span> <span class="title">Item</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> damage; <span class="comment">//攻击力 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用方法attack的时候，会根据传递的参数类型以及数量，自动调用对应的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">(Hero h1)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">(Hero h1,Hero h2)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">(Hero h1,Hero h2,Hero h3)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//采用可变数量的参数,一个函数相当于上述三个函数 使用操作数组的方式处理参数heros即可</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">(Hero... heros)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heros.length; i++) &#123;</span><br><span class="line">        System.out.println(name + <span class="string">" 攻击了 "</span> + heros[i].name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p>类里不显示写构造函数时，为隐式构造，即<code>Hero a=Hero()</code>这样的形式</p><p>写了就按照写的来，且可以重载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">(String heroname)</span></span>&#123; </span><br><span class="line">name = heroname;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="this"><a href="#this" class="headerlink" title="this"></a>this</h5><p>在对象内部表示当前这个对象</p><p>在一个构造方法中，调用另一个构造方法，可以使用this()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName3</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    <span class="comment">//name代表的是参数name</span></span><br><span class="line">    <span class="comment">//this.name代表的是属性name this相当于是引用，打印this是地址</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h5><p><strong>基本类型</strong>传参：函数块内<strong>不能改变</strong>原变量值，传入的参数为函数内局部变量</p><p><strong>引用类型</strong>传参：函数块内<strong>能改变</strong>原变量值</p><h5 id="包"><a href="#包" class="headerlink" title="包"></a>包</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> character; <span class="comment">//声明包的名字</span></span><br><span class="line"><span class="keyword">import</span> person.C <span class="comment">//引用其他包</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h5><p>用于修饰类或类里面的函数</p><div class="table-container"><table><thead><tr><th style="text-align:center">修饰符</th><th style="text-align:center">对应含义</th></tr></thead><tbody><tr><td style="text-align:center">private</td><td style="text-align:center">私有的</td></tr><tr><td style="text-align:center">package/friendly/default</td><td style="text-align:center">不写修饰符，默认状态</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">受保护的</td></tr><tr><td style="text-align:center">public</td><td style="text-align:center">公共的</td></tr></tbody></table></div><h6 id="类之间关系"><a href="#类之间关系" class="headerlink" title="类之间关系"></a>类之间关系</h6><p>自身（访问）、同包子类（<strong>同包</strong>内的类<strong>继承</strong>）、不同包子类（<strong>不同包间</strong>的类<strong>继承</strong>）、同包类（<strong>同一个包</strong>内的<strong>访问</strong>）、其他类（<strong>不同包</strong>内的<strong>访问</strong>）</p><h6 id="四种修饰符及对应的访问限制"><a href="#四种修饰符及对应的访问限制" class="headerlink" title="四种修饰符及对应的访问限制"></a>四种修饰符及对应的访问限制</h6><div class="table-container"><table><thead><tr><th style="text-align:center">修饰符</th><th style="text-align:center">自身-访问</th><th style="text-align:center">同包子类-继承</th><th style="text-align:center">不同包子类-继承</th><th style="text-align:center">同包类-访问</th><th style="text-align:center">其他类-访问</th></tr></thead><tbody><tr><td style="text-align:center">private</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">package/friendly/default</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">public</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr></tbody></table></div><p>能不露就不露出来，<strong>作用范围最小</strong>原则</p><ul><li>属性用private封装</li><li>方法一般用public</li><li>会被子类继承的方法，用protected</li><li>package用的不多</li></ul><h5 id="类属性（静态属性）"><a href="#类属性（静态属性）" class="headerlink" title="类属性（静态属性）"></a>类属性（静态属性）</h5><p>static修饰时，为类属性（<strong>静态</strong>属性），与之相对的是对象属性（<strong>实例属性</strong>，<strong>非静态</strong>属性）</p><p>类属性所有对象都<strong>共享</strong>一个相同值</p><p>访问可以用<strong><code>对象.类属性</code></strong>和<strong><code>类.类属性</code></strong>两种等价方式进行访问。</p><h5 id="类方法（静态方法）"><a href="#类方法（静态方法）" class="headerlink" title="类方法（静态方法）"></a>类方法（静态方法）</h5><p>也用<code>static</code>修饰，与类属性类似，也与对象方法（实例方法，非静态方法）相对。</p><p>方法里访问了对象属性，必须用对象方法</p><p>没有访问对象属性，可以用类方法</p><h5 id="属性初始化"><a href="#属性初始化" class="headerlink" title="属性初始化"></a>属性初始化</h5><h6 id="对象属性-三种办法初始化"><a href="#对象属性-三种办法初始化" class="headerlink" title="对象属性-三种办法初始化"></a>对象属性-三种办法初始化</h6><ol><li><p>声明该属性的时候初始化 </p></li><li><p>构造方法中初始化 </p></li><li><p>初始化块 如：<code>{ x=10 }</code></p></li></ol><h6 id="类属性-两种办法"><a href="#类属性-两种办法" class="headerlink" title="类属性-两种办法"></a>类属性-两种办法</h6><ol><li>声明该属性的时候初始化</li><li>静态初始化块</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> item=<span class="number">8</span>; <span class="comment">//声明时</span></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    item=<span class="number">6</span>; <span class="comment">//静态初始化块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><h6 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h6><ul><li>只有一个，通过私有化其构造方法，使得外部无法通过new 得到新的实例。</li><li>提供了一个public static的getInstance方法，外部调用者通过该方法获取一个对象，而且每一次都是获取同一个对象。 从而达到单例的目的。</li><li>在getInstance方法外已经创建了一个实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GiantDragon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有化构造方法使得该类无法在外部通过new 进行实例化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">GiantDragon</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//准备一个类属性，指向一个实例化对象。 因为是类属性，所以只有一个</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> GiantDragon instance = <span class="keyword">new</span> GiantDragon();</span><br><span class="line">    </span><br><span class="line"><span class="comment">//public static 方法，提供给调用者获取定义的对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GiantDragon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h6><ul><li>在getInstance方法内创建了一个实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GiantDragon</span> </span>&#123;</span><br><span class="line">    <span class="comment">//私有化构造方法使得该类无法在外部通过new 进行实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">GiantDragon</span><span class="params">()</span></span>&#123;        </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//准备一个类属性，用于指向一个实例化对象，但是暂时指向null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> GiantDragon instance;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//public static 方法，返回实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GiantDragon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//第一次访问的时候，发现instance没有指向任何对象，这时实例化一个对象</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span>==instance)&#123;</span><br><span class="line">    instance = <span class="keyword">new</span> GiantDragon();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回 instance指向的对象</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="两种方式选用"><a href="#两种方式选用" class="headerlink" title="两种方式选用"></a>两种方式选用</h6><p><strong>饿汉式</strong>，是<strong>立即加载</strong>的方式，无论是否会用到这个对象，都会加载。<br>如果在构造方法里写了<strong>性能消耗较大</strong>，<strong>占时较久</strong>的代码，比如<strong>建立与数据库的连接</strong>，那么就会在启动的时候感觉稍微有些卡顿。</p><p><strong>懒汉式</strong>，是<strong>延迟加载</strong>的方式，只有使用的时候才会加载。 并且有<strong>线程安全</strong>的考量。使用懒汉式，在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化。 但是在<strong>第一次调用</strong>的时候，会进行实例化操作，感觉上就略慢。</p><p>看业务需求，如果业务上允许有比较<strong>充分的启动和初始化时间</strong>，就使用<strong>饿汉式</strong>，<strong>否则</strong>就使用<strong>懒汉式</strong></p><h6 id="单例模式三元素"><a href="#单例模式三元素" class="headerlink" title="单例模式三元素"></a>单例模式三元素</h6><ol><li>构造方法私有化</li><li>静态属性指向实例</li><li>public static的 getInstance方法，返回第二步的静态属性</li></ol><h5 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Season &#123;</span><br><span class="line">SPRING,SUMMER,AUTUMN,WINTER <span class="comment">//分别代表1，2，3，4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Season season = Season.SPRING;</span><br><span class="line"><span class="keyword">switch</span> (season) &#123;</span><br><span class="line"><span class="keyword">case</span> SPRING:</span><br><span class="line">System.out.println(<span class="string">"春天"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SUMMER:</span><br><span class="line">System.out.println(<span class="string">"夏天"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> AUTUMN:</span><br><span class="line">System.out.println(<span class="string">"秋天"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WINTER:</span><br><span class="line">System.out.println(<span class="string">"冬天"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Season s : Season.values()) &#123;  <span class="comment">//增强型for循环遍历</span></span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-接口与继承"><a href="#7-接口与继承" class="headerlink" title="7.接口与继承"></a>7.接口与继承</h4><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AD</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">physicAttack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AP</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">magicAttack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现接口 使用implements 可以同时实现多个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ADHero</span> <span class="keyword">extends</span> <span class="title">Hero</span> <span class="keyword">implements</span> <span class="title">AD</span>,<span class="title">AP</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">physicAttack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进行物理攻击"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="对象转型"><a href="#对象转型" class="headerlink" title="对象转型"></a>对象转型</h5><p>将等号右边的类型转换为等号左边的，本质上能不能转换主要是看右边的类型能不能当成左边的来用</p><h6 id="子类转父类（向上转型）"><a href="#子类转父类（向上转型）" class="headerlink" title="子类转父类（向上转型）"></a>子类转父类（向上转型）</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hero h = <span class="keyword">new</span> Hero();</span><br><span class="line">ADHero ad = <span class="keyword">new</span> ADHero();</span><br><span class="line">h = ad; <span class="comment">//直接转换即可</span></span><br></pre></td></tr></table></figure><h6 id="父类转子类（向下转型）"><a href="#父类转子类（向下转型）" class="headerlink" title="父类转子类（向下转型）"></a>父类转子类（向下转型）</h6><p>需要强制转化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ad = (ADHero) h; <span class="comment">//强制转换</span></span><br></pre></td></tr></table></figure><h6 id="没有继承关系的两个类，互相转换会失败"><a href="#没有继承关系的两个类，互相转换会失败" class="headerlink" title="没有继承关系的两个类，互相转换会失败"></a>没有继承关系的两个类，互相转换会失败</h6><h5 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h5><p>子类和父类定义名字一样的方法，调用时调用子类的，即重写</p><h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><h6 id="操作符的多态"><a href="#操作符的多态" class="headerlink" title="操作符的多态"></a>操作符的多态</h6><p>字符串相加表示拼接，数字相加表示加法</p><h6 id="类的多态"><a href="#类的多态" class="headerlink" title="类的多态"></a>类的多态</h6><p>即不同的子类，对同一个父类方法的重写</p><h5 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h5><p>子类调用父类的静态方法（类方法）</p><h5 id="super"><a href="#super" class="headerlink" title="super"></a>super</h5><p>使用<code>super对象</code>调用父类的方法和属性</p><h5 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h5><p>声明一个类的时候，默认是继承了Object </p><p><code>toString()</code>返回当前对象的<strong>字符串表达</strong></p><p><code>finalize()</code>一个对象没有任何引用指向时，满足回收条件，这个方法被<code>JVM</code>自动调用</p><p><code>equals()</code> 判断两个对象内容是否相同</p><p><code>==</code> 判断两个引用，是否指向了同一个对象</p><p><code>hashCode()</code>返回一个对象的哈希值</p><p>Object还提供<strong>线程同步</strong>相关方法</p><ul><li><code>wait()</code></li></ul><ul><li><code>notify()</code></li><li><code>notifyAll()</code></li></ul><p><code>getClass()</code> 返回一个对象的类对象</p><h5 id="final-1"><a href="#final-1" class="headerlink" title="final"></a>final</h5><p>用final修饰的类不能被继承</p><p>修饰方法则不能被重写</p><p>修饰变量，则只有一次赋值机会</p><p>修饰引用，引用只有<strong>1</strong>次指向对象的机会</p><p>常量：<code>public static final int a = 6;</code></p><h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><p>abstract修饰符来修饰</p><p>当一个类有抽象方法的时候，该类必须被声明为抽象类</p><p>抽象类可以没有抽象方法</p><p><strong>子类必须提供</strong>不一样的attack方法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">float</span> hp;</span><br><span class="line">    <span class="keyword">float</span> armor;</span><br><span class="line">    <span class="keyword">int</span> moveSpeed;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 抽象方法attack</span></span><br><span class="line">    <span class="comment">// Hero的子类会被要求实现attack方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h6><p>区别1：</p><ul><li>子类只能继承一个抽象类，不能继承多个</li><li>子类可以实现<strong>多个</strong>接口</li></ul><p>区别2：</p><ul><li><p>抽象类可以定义</p><ul><li><p>public,protected,package,private</p></li><li><p>静态和非静态属性</p></li><li><p>final和非final属性</p></li></ul></li><li><p>但是接口中声明的属性，只能是</p><ul><li><p>public</p></li><li><p>静态</p></li><li><p>final的</p></li></ul><p>即便没有显式的声明(默认转换为<code>public static final</code>)</p></li></ul><p>注:抽象类和接口都可以有实体方法。 接口中的实体方法，叫做默认方法</p><h5 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h5><p>分为四种：</p><ul><li>非静态内部类  可以直接在一个类里面定义，实例化必须建立在一个外部类对象的基础之上，即：<strong>new 外部类().new 内部类()</strong>，可以访问外部类的属性方法</li><li>静态内部类 可以直接实例化，不能访问外部类的实例属性方法，但是可以访问静态属性方法</li><li><p>匿名类 直接实例化一个抽象类，并“<strong>当场</strong>”实现其抽象方法。</p></li><li><p>本地类 有名字的匿名类</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hero h = <span class="keyword">new</span> Hero()&#123;</span><br><span class="line">            <span class="comment">//当场实现attack方法</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"新的进攻手段"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        h.attack();</span><br><span class="line">        <span class="comment">//通过打印h，可以看到h这个对象属于Hero$1这么一个系统自动分配的类名 </span></span><br><span class="line">        System.out.println(h);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//本地类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">SomeHero</span> <span class="keyword">extends</span> <span class="title">Hero</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println( name+ <span class="string">" 新的进攻手段"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        SomeHero h  =<span class="keyword">new</span> SomeHero();</span><br><span class="line">        h.name =<span class="string">"地卜师"</span>;</span><br><span class="line">        h.attack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h5><p>默认方法是JDK8新特性，指的是接口也可以提供具体方法了</p><p><code>default public void func(){}</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mortal</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">die</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">revive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"本英雄复活了"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="UML图——类之间的关系"><a href="#UML图——类之间的关系" class="headerlink" title="UML图——类之间的关系"></a>UML图——类之间的关系</h5><p>UML-Unified Module Language<br>统一建模语言，可以很方便的用于描述类的属性，方法，以及类和类之间的关系</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置环境遇到的问题和解决办法积累</title>
      <link href="2021/01/31/%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%E7%A7%AF%E7%B4%AF/"/>
      <url>2021/01/31/%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%E7%A7%AF%E7%B4%AF/</url>
      
        <content type="html"><![CDATA[<p>笔者经常花很多的时间在配置环境上，出于不想总是这样浪费时间的考虑，写篇文章积累一下踩过的坑。</p><a id="more"></a><h3 id="配置java环境"><a href="#配置java环境" class="headerlink" title="配置java环境"></a>配置java环境</h3><h4 id="命令行运行java代码时找不到或无法加载主类"><a href="#命令行运行java代码时找不到或无法加载主类" class="headerlink" title="命令行运行java代码时找不到或无法加载主类"></a>命令行运行java代码时找不到或无法加载主类</h4><p>一般是先让你在系统变量中配<code>JAVA_HOME</code>再配<code>CLASS_PATH</code>再配<code>PATH</code>。操作完之后出现这个问题，则一般都是<strong>环境配置问题</strong>，其次可能是<strong>代码本身</strong>。</p><p>我最后是把三个环境变量配置在用户变量里也加了一遍就好了。（被坑惨了，实在不知道为什么这样就行了？？）</p><p>其他的可能解决办法还有：可以试试把所有的<code>%JAVA_HOME%</code>全部换成其本身的地址；查看一下CLASS_PATH是否设置错等。</p><h4 id="Android-studio-Sync-Project-with-Gradle-Files时卡住"><a href="#Android-studio-Sync-Project-with-Gradle-Files时卡住" class="headerlink" title="Android studio Sync Project with Gradle Files时卡住"></a>Android studio Sync Project with Gradle Files时卡住</h4><p>主要要切换一下镜像源</p><p>参考这篇文章：<a href="https://blog.csdn.net/xiaoxiangsss/article/details/113136127" target="_blank" rel="noopener">https://blog.csdn.net/xiaoxiangsss/article/details/113136127</a></p><h3 id="使用npm"><a href="#使用npm" class="headerlink" title="使用npm"></a>使用npm</h3><p>常常需要切换代理才可以成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h3 id="配置Python环境"><a href="#配置Python环境" class="headerlink" title="配置Python环境"></a>配置Python环境</h3><p><code>pip install</code>遇到 <code>Read timed out</code> 修改为 <code>pip --default-timeout=100 install package-name</code></p><p>有时<code>pip</code> 和<code>conda</code>可以都试试，如果都不行可以考虑换一下镜像或者更新一下<code>pip</code> 和<code>conda</code></p><h3 id="设置右键菜单中打开xxx为xxx项目"><a href="#设置右键菜单中打开xxx为xxx项目" class="headerlink" title="设置右键菜单中打开xxx为xxx项目"></a>设置右键菜单中<code>打开xxx为xxx项目</code></h3><p><a href="https://blog.csdn.net/weixin_44653409/article/details/102808839" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44653409/article/details/102808839</a></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摄影学习</title>
      <link href="2021/01/30/%E6%91%84%E5%BD%B1%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/01/30/%E6%91%84%E5%BD%B1%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Life Note </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML+CSS笔记</title>
      <link href="2021/01/30/%E5%89%8D%E7%AB%AF-html5+css3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/01/30/%E5%89%8D%E7%AB%AF-html5+css3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>前端知识整理，以备不时之需。</p><a id="more"></a><p>写在开始：本文部分内容直接搬运自一些网站，仅用作个人和他人学习用途。</p><h2 id="资源整理"><a href="#资源整理" class="headerlink" title="资源整理"></a>资源整理</h2><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p><a href="https://www.runoob.com/html/html-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a>   <a href="https://www.w3school.com.cn/html/index.asp" target="_blank" rel="noopener">w3school</a>  </p><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p><a href="https://www.runoob.com/css/css-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a>  <a href="https://www.w3school.com.cn/css/index.asp" target="_blank" rel="noopener">w3school</a>  </p><h2 id="慕课网教程笔记"><a href="#慕课网教程笔记" class="headerlink" title="慕课网教程笔记"></a>慕课网教程笔记</h2><p><a href="https://www.imooc.com/learn/9" target="_blank" rel="noopener">慕课网入门教程</a></p><h3 id="1-HTML文档结构"><a href="#1-HTML文档结构" class="headerlink" title="1.HTML文档结构"></a>1.HTML文档结构</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span> 文档类型声明，表示该文件为 HTML5文件。<span class="meta">&lt;!DOCTYPE&gt;</span> 声明必须是 HTML 文档的第一行，位于 <span class="tag">&lt;<span class="name">html</span>&gt;</span> 标签之前</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span>  --&gt;head标签表示头部标签,通常用来嵌套meta、title、style等标签。 title:网页标题</span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>认识html文件基本结构<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>在本小节中，你将学会认识html文件基本结构<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-语义化标签"><a href="#2-语义化标签" class="headerlink" title="2.语义化标签"></a>2.语义化标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>段落文本<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>自定义文本标签<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题标签 h1-h6来表示<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>块标签<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span>网页开头<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span>网页底部<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span>区域<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span>侧边栏<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-效果标签"><a href="#3-效果标签" class="headerlink" title="3.效果标签"></a>3.效果标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span> --&gt;换行标签</span><br><span class="line"><span class="symbol">&amp;nbsp;</span> --&gt;空格</span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span> --&gt;水平分割线</span><br></pre></td></tr></table></figure><h3 id="4-列表标签"><a href="#4-列表标签" class="headerlink" title="4.列表标签"></a>4.列表标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span> <span class="tag">&lt;/<span class="name">li</span>&gt;</span> --&gt;无序列表</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>abc<span class="tag">&lt;/<span class="name">li</span>&gt;</span> --&gt;有序列表</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>def<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-图片链接和表格标签"><a href="#5-图片链接和表格标签" class="headerlink" title="5.图片链接和表格标签"></a>5.图片链接和表格标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"图片地址"</span> <span class="attr">alt</span>=<span class="string">"下载失败时的替换文本"</span> <span class="attr">title</span> = <span class="string">"鼠标滑过时的提示文本"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span>  <span class="attr">href</span>=<span class="string">"目标网址"</span>  <span class="attr">title</span>=<span class="string">"鼠标滑过显示的文本"</span> <span class="attr">target</span>=<span class="string">"_self(覆盖原网页)/_blank(打开新网页)"</span>&gt;</span>链接显示的文本<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">10</span> &gt;</span> --&gt;table表格标签 border属性为边框粗细</span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span> --&gt;tr表示行</span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>知识点<span class="tag">&lt;/<span class="name">th</span>&gt;</span> --&gt;th表示第一行加粗的表格表头单元格</span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>html<span class="tag">&lt;/<span class="name">td</span>&gt;</span> --&gt;td表示普通单元格</span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">thead</span>&gt;</span>标签定义表格头部,<span class="tag">&lt;<span class="name">tbody</span>&gt;</span>标签来定义表格的内容,<span class="tag">&lt;<span class="name">tfoot</span>&gt;</span>来定义表格的底部,当长的表格被打印时，表格的表头和页脚可被打印在包含表格数据的每张页面上。</span><br></pre></td></tr></table></figure><h3 id="6-表单标签"><a href="#6-表单标签" class="headerlink" title="6.表单标签"></a>6.表单标签</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">"save.php"</span>&gt;</span> --&gt;action:浏览者输入的数据被传送到的地方,比如一个PHP页面(save.php) </span><br><span class="line">       --&gt;method:数据传送的方式（get/post）</span><br><span class="line">    <span class="comment">&lt;!--文本输入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"username"</span>&gt;</span>用户名:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">id</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">""</span> <span class="attr">placeholder</span>=<span class="string">""</span>/&gt;</span> --&gt;普通文本输入</span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"pass"</span>&gt;</span>密码:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"pass"</span> <span class="attr">id</span>=<span class="string">"pass"</span> <span class="attr">value</span>=<span class="string">""</span> <span class="attr">placeholder</span>=<span class="string">""</span>/&gt;</span> --&gt;加密文本输入</span><br><span class="line">    --&gt;for=id完成了和input标签的联动，和相应的输入框进行绑定</span><br><span class="line">    --&gt;type="num"--只允许输入数字 type="url"--只允许输入http/https协议的网址 type="email"--&gt;邮箱</span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span>  <span class="attr">rows</span>=<span class="string">"行数"</span> <span class="attr">cols</span>=<span class="string">"列数"</span>&gt;</span>文本<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span> --&gt;大段文字输入框</span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--选择框--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio/checkbox"</span> <span class="attr">value</span>=<span class="string">"值"</span> <span class="attr">name</span>=<span class="string">"名称"</span> <span class="attr">checked</span>=<span class="string">"checked"</span>/&gt;</span></span><br><span class="line">     --&gt;当 type="radio" 时，控件为单选框</span><br><span class="line">       当 type="checkbox" 时，控件为复选框</span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--下拉菜单--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span>&gt;</span> --&gt;下拉菜单 select标签里面只能放option标签，表示下拉列表的选项。option标签放选项内容，不放置其他标签</span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"看书"</span>&gt;</span>看书<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"旅游"</span>&gt;</span>旅游<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"运动"</span> <span class="attr">selected</span>=<span class="string">"selected"</span>&gt;</span>运动<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"购物"</span>&gt;</span>购物<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--按钮--&gt;</span> --&gt;对表单其他元素做相应的操作</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"确定"</span> <span class="attr">name</span>=<span class="string">"submit"</span> /&gt;</span>  --&gt;value：按钮上显示的文字</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"reset"</span> <span class="attr">value</span>=<span class="string">"重置"</span> <span class="attr">name</span>=<span class="string">"reset"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="几个常用属性"><a href="#几个常用属性" class="headerlink" title="几个常用属性"></a>几个常用属性</h4><p>value：提交数据到服务器的值（后台程序PHP使用）</p><p>name：为控件命名，以备后台程序 ASP、PHP 使用</p><p>checked：当设置 checked=”checked” 时，该选项被默认选中</p><h3 id="7-CSS样式基本使用"><a href="#7-CSS样式基本使用" class="headerlink" title="7.CSS样式基本使用"></a>7.CSS样式基本使用</h3><p>css 样式由<strong>选择符</strong>和<strong>声明</strong>组成，而<strong>声明</strong>又由<strong>属性</strong>和<strong>值</strong>组成</p><p>注释：<code>/* */</code></p><h4 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p style="color:red;font-size:12px"&gt;这里文字是红色。&lt;/p&gt;</span><br></pre></td></tr></table></figure><h4 id="嵌入式"><a href="#嵌入式" class="headerlink" title="嵌入式"></a>嵌入式</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line">    <span class="selector-tag">span</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>:blue;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;span&gt;123&lt;/span&gt;</span><br></pre></td></tr></table></figure><h4 id="外联样式"><a href="#外联样式" class="headerlink" title="外联样式"></a>外联样式</h4><p>一般写在<code>&lt;head&gt;</code>标签内</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href="base.css" rel="stylesheet" type="text/css" /&gt;</span><br></pre></td></tr></table></figure><h4 id="三种方式优先级"><a href="#三种方式优先级" class="headerlink" title="三种方式优先级"></a>三种方式优先级</h4><p>内联式 &gt; 嵌入式 &gt; 外部式</p><p>即<strong>就近原则</strong></p><h3 id="8-CSS选择器"><a href="#8-CSS选择器" class="headerlink" title="8.CSS选择器"></a>8.CSS选择器</h3><p>声明组成：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123;</span><br><span class="line">    样式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="各种选择器"><a href="#各种选择器" class="headerlink" title="各种选择器"></a>各种选择器</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 标签选择器 */</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">font-size</span>:<span class="number">12px</span>;<span class="attribute">line-height</span>:<span class="number">1.6em</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 类选择器 .类名 */</span></span><br><span class="line">.类选器名称 &#123;css样式代码;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ID选择器 #ID */</span></span><br><span class="line">#ID名字 &#123;css样式;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*子选择器 &gt; */</span></span><br><span class="line"><span class="selector-class">.food</span>&gt;<span class="selector-tag">li</span> &#123;<span class="attribute">border</span>:<span class="number">1px</span> solid red;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*后代选择器 空格 */</span></span><br><span class="line"><span class="selector-class">.food</span> <span class="selector-tag">span</span>&#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*通用选择器 匹配html中所有标签元素*/</span></span><br><span class="line">* &#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 伪类选择器 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;<span class="attribute">color</span>:red;&#125; <span class="comment">/*给html中一个标签元素的鼠标滑过的状态来设置字体颜色*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分组选择器 */</span></span><br><span class="line"><span class="selector-tag">h1</span>,<span class="selector-tag">span</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类和ID选择器区别"><a href="#类和ID选择器区别" class="headerlink" title="类和ID选择器区别"></a>类和ID选择器区别</h4><ul><li><p><strong>ID选择器只能在文档中使用一次</strong>。与类选择器不同，在一个HTML文档中，ID选择器只能使用一次，而且仅一次。而类选择器可以使用多次。换言之，每个标签ID不能相同</p></li><li><p><strong>可以使用类选择器词列表方法为一个元素同时设置多个样式。</strong>我们可以为一个元素同时设多个样式，但只可以用类选择器的方法实现，ID选择器是不可以的（<strong>不能使用 ID 词列表</strong>）。如：</p></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.stress</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bigsize</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">25px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;p&gt;到了&lt;span class="stress bigsize"&gt;三年级&lt;/span&gt;下学期时，我们班上了一节公开课...&lt;/p&gt;</span><br></pre></td></tr></table></figure><h3 id="9-CSS继承，优先级和重要性"><a href="#9-CSS继承，优先级和重要性" class="headerlink" title="9.CSS继承，优先级和重要性"></a>9.CSS继承，优先级和重要性</h3><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>内联样式 &gt; id选择器 &gt; 类选择器 &gt; 标签选择器 &gt; 通配符选择器</p><h4 id="权值计算-特殊性"><a href="#权值计算-特殊性" class="headerlink" title="权值计算-特殊性"></a>权值计算-特殊性</h4><p>标签的权值为1，类选择符的权值为10，ID选择符的权值最高为100。继承的权值可视为0.1</p><h4 id="选择器最高层级-important"><a href="#选择器最高层级-important" class="headerlink" title="选择器最高层级!important"></a>选择器最高层级!important</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:red<span class="meta">!important</span>;&#125;</span><br></pre></td></tr></table></figure><h3 id="10-CSS字体样式"><a href="#10-CSS字体样式" class="headerlink" title="10.CSS字体样式"></a>10.CSS字体样式</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*使用font-family设置字体*/</span></span><br><span class="line"><span class="selector-tag">body</span>&#123;<span class="attribute">font-family</span>:<span class="string">"宋体"</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用font-size设置字体大小*/</span></span><br><span class="line"><span class="selector-tag">body</span>&#123;<span class="attribute">font-size</span>:<span class="number">12px</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用font-weight设置字体粗细*/</span></span><br><span class="line"><span class="selector-tag">p</span> <span class="selector-tag">span</span>&#123;<span class="attribute">font-weight</span>:bold;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用font-style设置字体样式</span></span><br><span class="line"><span class="comment">正常字体为normal,也是font-style的默认值。</span></span><br><span class="line"><span class="comment">italic为设置字体为斜体，用于字体本身就有倾斜的样式。</span></span><br><span class="line"><span class="comment">oblique为设置倾斜的字体，强制将字体倾斜。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用color设置字体颜色 三种赋值方式*/</span></span><br><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:<span class="built_in">rgb</span>(<span class="number">133</span>,<span class="number">45</span>,<span class="number">200</span>);&#125;</span><br><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:<span class="number">#00ffff</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*font样式的简写方式*/</span></span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">font-style</span>:italic;</span><br><span class="line">    <span class="attribute">font-weight</span>:bold; </span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">12px</span>; </span><br><span class="line">    <span class="attribute">line-height</span>:<span class="number">1.5em</span>; </span><br><span class="line">    <span class="attribute">font-family</span>:<span class="string">"宋体"</span>,sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">---------------</span>&gt;</span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">font</span>:italic  bold  <span class="number">12px</span>/<span class="number">1.5em</span>  <span class="string">"宋体"</span>,sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-装饰文本"><a href="#11-装饰文本" class="headerlink" title="11.装饰文本"></a>11.装饰文本</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* text-decoration添加文本修饰</span></span><br><span class="line"><span class="comment">1、text-decoration可以设置添加到文本的修饰。</span></span><br><span class="line"><span class="comment">2、text-decoration默认值为none, 定义标准的文本。</span></span><br><span class="line"><span class="comment">3、text-decoration的值为underline为定义文本下的一条线。</span></span><br><span class="line"><span class="comment">4、text-decoration的值为overline为定义文本上的一条线。</span></span><br><span class="line"><span class="comment">5、text-decoration的值为line-through为定义穿过文本下的一条线，一般用于商品折扣价。 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*text-indent为文本添加首行缩进*/</span></span><br><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">text-indent</span>:<span class="number">2em</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*line-height设置行间距*/</span></span><br><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">line-height</span>:<span class="number">1.5em</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用letter/word-spacing增加或减少字符间的空白*/</span></span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line">    <span class="attribute">letter-spacing</span>:<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用text-align设置文本对齐方式*/</span></span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line">    <span class="attribute">text-align</span>:center; <span class="comment">/*可选left right*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用到<code>px（像素）</code>、<code>em</code>、<code>% 百分比</code> 三种长度单位，这三个都是相对长度单位</p><p>1em和font-size对应</p><p>百分比也是相对于font-size设定值的比</p><h3 id="12-CSS盒模型"><a href="#12-CSS盒模型" class="headerlink" title="12.CSS盒模型"></a>12.CSS盒模型</h3><h4 id="元素分类"><a href="#元素分类" class="headerlink" title="元素分类"></a>元素分类</h4><h5 id="常用的块状元素"><a href="#常用的块状元素" class="headerlink" title="常用的块状元素"></a>常用的块状元素</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span>&gt;、&lt;<span class="selector-tag">p</span>&gt;、&lt;<span class="selector-tag">h1</span>&gt;...&lt;<span class="selector-tag">h6</span>&gt;、&lt;<span class="selector-tag">ol</span>&gt;、&lt;<span class="selector-tag">ul</span>&gt;、&lt;<span class="selector-tag">dl</span>&gt;、&lt;<span class="selector-tag">table</span>&gt;、&lt;<span class="selector-tag">address</span>&gt;、&lt;<span class="selector-tag">blockquote</span>&gt; 、&lt;<span class="selector-tag">form</span>&gt;</span><br></pre></td></tr></table></figure><h5 id="常用的内联元素"><a href="#常用的内联元素" class="headerlink" title="常用的内联元素"></a>常用的内联元素</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">a</span>&gt;、&lt;<span class="selector-tag">span</span>&gt;、&lt;<span class="selector-tag">br</span>&gt;、&lt;<span class="selector-tag">i</span>&gt;、&lt;<span class="selector-tag">em</span>&gt;、&lt;<span class="selector-tag">strong</span>&gt;、&lt;<span class="selector-tag">label</span>&gt;、&lt;<span class="selector-tag">q</span>&gt;、&lt;<span class="selector-tag">var</span>&gt;、&lt;<span class="selector-tag">cite</span>&gt;、&lt;<span class="selector-tag">code</span>&gt;</span><br></pre></td></tr></table></figure><h5 id="常用的内联块状元素"><a href="#常用的内联块状元素" class="headerlink" title="常用的内联块状元素"></a>常用的内联块状元素</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">img</span>&gt;、&lt;<span class="selector-tag">input</span>&gt;</span><br></pre></td></tr></table></figure><h5 id="几种元素转换"><a href="#几种元素转换" class="headerlink" title="几种元素转换"></a>几种元素转换</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.将<span class="selector-tag">a</span>标签转为块级标签</span><br><span class="line"><span class="selector-tag">a</span>&#123;<span class="attribute">display</span>:block;&#125;</span><br><span class="line">2.将块状元素<span class="selector-tag">div</span>转换为内联元素</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">     <span class="attribute">display</span>:inline;</span><br><span class="line">&#125;</span><br><span class="line">3.设置为内联块状</span><br><span class="line"><span class="selector-tag">display</span><span class="selector-pseudo">:inline-block</span>;</span><br><span class="line">4<span class="selector-class">.none</span>设置不显示</span><br><span class="line"><span class="selector-tag">display</span><span class="selector-pseudo">:none</span>;</span><br></pre></td></tr></table></figure><h4 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h4><p>辅助理解的视频：<a href="https://www.imooc.com/video/3225" target="_blank" rel="noopener">https://www.imooc.com/video/3225</a></p><p>内容被<code>padding</code>，<code>border</code>，<code>margin</code>三层包住，每层都有一定的宽度。</p><p>都可以设置<code>top</code>/<code>bottom</code>/<code>left</code>/<code>right</code>四个方向的属性</p><h5 id="基本设置盒子模型"><a href="#基本设置盒子模型" class="headerlink" title="基本设置盒子模型"></a>基本设置盒子模型</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">10px</span>;    </span><br><span class="line">    <span class="attribute">background-color</span>:red; <span class="comment">/*设置背景色*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/CSS3%2BHTML5/1.jpg" style="zoom:80%;" /> <img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/CSS3%2BHTML5/2.jpg" style="zoom:80%;" /></p><h4 id="设置盒子边框"><a href="#设置盒子边框" class="headerlink" title="设置盒子边框"></a>设置盒子边框</h4><p>盒子模型的边框就是围绕着内容及补白的线，这条线你可以设置它的粗细、样式和颜色(边框三个属性)。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">2px</span>  solid  red;</span><br><span class="line">&#125;</span><br><span class="line">上面是 <span class="selector-tag">border</span> 代码的缩写形式，可以分开写：</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">border-width</span>:<span class="number">2px</span>; <span class="comment">/*不常用的:thin | medium | thick*/</span></span><br><span class="line">    <span class="attribute">border-style</span>:solid; <span class="comment">/*边框样式: dashed（虚线）| dotted（点线）| solid（实线）。*/</span></span><br><span class="line">    <span class="attribute">border-color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*只加底部边框*/</span></span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">border-bottom</span>:<span class="number">2px</span> solid red; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*元素边框的圆角效果可以使用border-radius属性来设置。圆角可分为左上、右上、右下、左下。*/</span></span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">border-radius</span>: <span class="number">20px</span> <span class="number">10px</span> <span class="number">15px</span> <span class="number">30px</span>;&#125;</span><br></pre></td></tr></table></figure><h4 id="设置内边距"><a href="#设置内边距" class="headerlink" title="设置内边距"></a>设置内边距</h4><p>元素内容与边框之间是可以设置距离的，称之为“内边距（填充）”。填充也可分为上、右、下、左(顺时针)。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">padding</span>:<span class="number">20px</span> <span class="number">10px</span> <span class="number">15px</span> <span class="number">30px</span>;&#125;</span><br><span class="line"></span><br><span class="line">如果上、右、下、左的填充都为10<span class="selector-tag">px</span>;可以这么写</span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">padding</span>:<span class="number">10px</span>;&#125;</span><br><span class="line"></span><br><span class="line">如果上下填充一样为10<span class="selector-tag">px</span>，左右一样为20<span class="selector-tag">px</span>，可以这么写：</span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">padding</span>:<span class="number">10px</span> <span class="number">20px</span>;&#125;</span><br></pre></td></tr></table></figure><h4 id="设置外边距"><a href="#设置外边距" class="headerlink" title="设置外边距"></a>设置外边距</h4><p>元素与其它元素之间的距离可以使用边界（margin）来设置。边界也是可分为上、右、下、左。使用方法和内边距一样。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">margin</span>:<span class="number">20px</span> <span class="number">10px</span> <span class="number">15px</span> <span class="number">30px</span>;&#125;</span><br></pre></td></tr></table></figure><h3 id="13-CSS3布局模型"><a href="#13-CSS3布局模型" class="headerlink" title="13.CSS3布局模型"></a>13.CSS3布局模型</h3><p>在网页中，元素有三种布局模型：<br>1、流动模型（Flow）<br>2、浮动模型 (Float)<br>3、层模型（Layer）</p><h4 id="流动模型"><a href="#流动模型" class="headerlink" title="流动模型"></a>流动模型</h4><h5 id="典型特征"><a href="#典型特征" class="headerlink" title="典型特征"></a>典型特征</h5><p>第一点，<strong>块状元素</strong>都会在所处的<strong>包含元素内</strong>自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为<strong>100%</strong>。实际上，块状元素都会以行的形式占据位置。如右侧代码编辑器中三个块状元素标签(div，h1，p)宽度显示为100%。</p><p>第二点，在流动模型下，<strong>内联元素</strong>都会在所处的包含元素内从左到右水平分布显示。（内联元素可不像块状元素这么霸道独占一行）</p><h4 id="浮动模型"><a href="#浮动模型" class="headerlink" title="浮动模型"></a>浮动模型</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*让两个块状元素并排显示*/</span></span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">2px</span> red solid;</span><br><span class="line">    <span class="attribute">float</span>:left; <span class="comment">/*左对齐 right即为右对齐*/</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;div id="div1"&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id="div2"&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置div1和div2一个最左一个最右*/</span></span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">2px</span> red solid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#div1</span>&#123;<span class="attribute">float</span>:left;&#125;</span><br><span class="line"><span class="selector-id">#div2</span>&#123;<span class="attribute">float</span>:right;&#125; </span><br><span class="line"></span><br><span class="line">&lt;div id="div1"&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id="div2"&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="层模型"><a href="#层模型" class="headerlink" title="层模型"></a>层模型</h4><p>层模型有三种形式：</p><p>1、绝对定位(position: absolute)</p><p>2、相对定位(position: relative)</p><p>3、固定定位(position: fixed)</p><h5 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h5><p>如果想为元素设置层模型中的绝对定位，需要设置position:absolute(表示绝对定位)，这条语句的作用将元素<strong>从文档流中拖出来</strong>，然后使用left、right、top、bottom属性<strong>相对于</strong>其<strong>最接近的一个具有定位属性</strong>的<strong>父包含块</strong>进行绝对定位。如果不存在这样的包含块，则相对于body元素，即相对于<strong>浏览器窗口</strong>。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">实现<span class="selector-tag">div</span>元素相对于浏览器窗口向右移动100<span class="selector-tag">px</span>，向下移动50<span class="selector-tag">px</span>。</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">2px</span> red solid;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50px</span>;                                          </span><br><span class="line">&#125;</span><br><span class="line">&lt;div id="div1"&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h5 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h5><p>如果想为元素设置层模型中的相对定位，需要设置position:relative（表示相对定位），它通过left、right、top、bottom属性确定元素在<strong>正常文档流中</strong>的偏移位置。相对定位完成的过程是首先按static(float)方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于<strong>以前的位置移动，</strong>移动的方向和幅度由left、right、top、bottom属性确定，偏移前的位置保留不动。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">相对于以前位置向下移动50<span class="selector-tag">px</span>，向右移动100<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-id">#div1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">2px</span> red solid;</span><br><span class="line">    <span class="attribute">position</span>:relative;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div id="div1"&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h5 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h5><p>fixed：表示固定定位，与absolute定位类型类似，但它的相对移动的坐标是视图（屏幕内的网页窗口）本身。由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响，这与background-attachment:fixed;属性功能相同。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">实现相对于浏览器视图向右移动100<span class="selector-tag">px</span>，向下移动50<span class="selector-tag">px</span>。并且拖动滚动条时位置固定不变。</span><br><span class="line"><span class="selector-id">#div1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">2px</span> red solid;</span><br><span class="line">    <span class="attribute">position</span>:fixed;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;p&gt;文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本。&lt;/p&gt;</span><br></pre></td></tr></table></figure><h5 id="Relative与Absolute组合使用"><a href="#Relative与Absolute组合使用" class="headerlink" title="Relative与Absolute组合使用"></a>Relative与Absolute组合使用</h5><p>使用相对于某个元素的绝对定位</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1、参照定位的元素必须是相对定位元素的前辈元素：</span><br><span class="line">&lt;div id="box1"&gt;&lt;!--参照定位的元素--&gt;</span><br><span class="line">    &lt;div id="box2"&gt;相对参照元素进行定位&lt;/div&gt;&lt;!--相对定位元素--&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">从上面代码可以看出<span class="selector-tag">box1</span>是<span class="selector-tag">box2</span>的父元素（父元素当然也是前辈元素了）。</span><br><span class="line"></span><br><span class="line">2、参照定位的元素必须加入<span class="selector-tag">position</span><span class="selector-pseudo">:relative</span>;</span><br><span class="line"><span class="selector-id">#box1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">position</span>:relative;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3、定位元素加入<span class="selector-tag">position</span><span class="selector-pseudo">:absolute</span>，便可以使用<span class="selector-tag">top</span>、<span class="selector-tag">bottom</span>、<span class="selector-tag">left</span>、<span class="selector-tag">right</span>来进行偏移定位了。</span><br><span class="line"><span class="selector-id">#box2</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">30px</span>;         </span><br><span class="line">&#125;</span><br><span class="line">这样<span class="selector-tag">box2</span>就可以相对于父元素<span class="selector-tag">box1</span>定位了（这里注意参照物就可以不是浏览器了，而可以自由设置了）。</span><br></pre></td></tr></table></figure><h3 id="14-弹性盒模型"><a href="#14-弹性盒模型" class="headerlink" title="14.弹性盒模型"></a>14.弹性盒模型</h3><h4 id="设置flex"><a href="#设置flex" class="headerlink" title="设置flex"></a>设置flex</h4><p>三个块元素设置大小以及背景色，在父容器中添加flex。</p><p>技术点的解释：</p><p>1、设置display: flex属性可以把块级元素在一排显示。</p><p>2、flex需要添加在父元素上，改变子元素的排列顺序。</p><p>3、默认为从左往右依次排列,且和父元素左边没有间隙。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class="box"&gt;</span><br><span class="line">    &lt;div class="box1"&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class="box2"&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class="box3"&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line">    <span class="selector-class">.box</span> &#123;</span><br><span class="line">        <span class="attribute">background</span>: blue;</span><br><span class="line">        <span class="attribute">display</span>: flex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.box</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.box1</span> &#123;</span><br><span class="line">        <span class="attribute">background</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.box2</span> &#123;</span><br><span class="line">        <span class="attribute">background</span>: orange;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.box3</span> &#123;</span><br><span class="line">        <span class="attribute">background</span>: green;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h4 id="使用justify-content属性设置横轴排列方式"><a href="#使用justify-content属性设置横轴排列方式" class="headerlink" title="使用justify-content属性设置横轴排列方式"></a>使用justify-content属性设置横轴排列方式</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">justify-content: flex-start | flex-end | center | space-between | space-around;</span><br></pre></td></tr></table></figure><p><code>flex-start</code>：交叉轴的起点对齐</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">       <span class="attribute">background</span>: blue;</span><br><span class="line">       <span class="attribute">display</span>: flex;</span><br><span class="line">       <span class="attribute">justify-content</span>: flex-start;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><a href="https://img.mukewang.com/5e959b080001a38d25340322.jpg" target="_blank" rel="noopener"><img src="https://img.mukewang.com/5e959b080001a38d25340322.jpg" alt="img"></a></p><p><code>flex-end</code>：右对齐</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">       <span class="attribute">background</span>: blue;</span><br><span class="line">       <span class="attribute">display</span>: flex;</span><br><span class="line">       <span class="attribute">justify-content</span>: flex-end;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><a href="https://img1.mukewang.com/5e959b8b0001d43b25420308.jpg" target="_blank" rel="noopener"><img src="https://img1.mukewang.com/5e959b8b0001d43b25420308.jpg" alt="img"></a></p><p><code>center</code>： 居中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">       <span class="attribute">background</span>: blue;</span><br><span class="line">       <span class="attribute">display</span>: flex;</span><br><span class="line">       <span class="attribute">justify-content</span>: center;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><a href="https://img2.mukewang.com/5e959bdd0001ad2125300303.jpg" target="_blank" rel="noopener"><img src="https://img2.mukewang.com/5e959bdd0001ad2125300303.jpg" alt="img"></a></p><p><code>space-between</code>：两端对齐，项目之间的间隔都相等。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">       <span class="attribute">background</span>: blue;</span><br><span class="line">       <span class="attribute">display</span>: flex;</span><br><span class="line">       <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><a href="https://img2.mukewang.com/5e959c6400017b1c25530313.jpg" target="_blank" rel="noopener"><img src="https://img2.mukewang.com/5e959c6400017b1c25530313.jpg" alt="img"></a></p><p><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">        <span class="attribute">background</span>: blue;</span><br><span class="line">        <span class="attribute">display</span>: flex;</span><br><span class="line">        <span class="attribute">justify-content</span>: space-around;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><a href="https://img2.mukewang.com/5e959caf000113b125370303.jpg" target="_blank" rel="noopener"><img src="https://img2.mukewang.com/5e959caf000113b125370303.jpg" alt="img"></a></p><h4 id="使用align-items属性设置纵轴排列方式"><a href="#使用align-items属性设置纵轴排列方式" class="headerlink" title="使用align-items属性设置纵轴排列方式"></a>使用align-items属性设置纵轴排列方式</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-items: flex-start | flex-end | center | baseline | stretch;</span><br></pre></td></tr></table></figure><p><code>flex-start</code>：默认值，左对齐</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">700px</span>;</span><br><span class="line">     <span class="attribute">background</span>: blue;</span><br><span class="line">     <span class="attribute">display</span>: flex;</span><br><span class="line">     <span class="attribute">align-items</span>: flex-start;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><a href="https://img3.mukewang.com/5e95a3720001140325381051.jpg" target="_blank" rel="noopener"><img src="https://img3.mukewang.com/5e95a3720001140325381051.jpg" alt="img"></a></p><p><code>flex-end</code>：交叉轴的终点对齐</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">       <span class="attribute">height</span>: <span class="number">700px</span>;</span><br><span class="line">       <span class="attribute">background</span>: blue;</span><br><span class="line">       <span class="attribute">display</span>: flex;</span><br><span class="line">       <span class="attribute">align-items</span>: flex-end;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><a href="https://img2.mukewang.com/5e95a3ca0001550a25381056.jpg" target="_blank" rel="noopener"><img src="https://img2.mukewang.com/5e95a3ca0001550a25381056.jpg" alt="img"></a></p><p><code>center</code>： 交叉轴的中点对齐</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">700px</span>;</span><br><span class="line">        <span class="attribute">background</span>: blue;</span><br><span class="line">        <span class="attribute">display</span>: flex;</span><br><span class="line">        <span class="attribute">align-items</span>: center;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><a href="https://img3.mukewang.com/5e9667880001796c25371056.jpg" target="_blank" rel="noopener"><img src="https://img3.mukewang.com/5e9667880001796c25371056.jpg" alt="img"></a></p><p><code>baseline</code>：项目的第一行文字的基线对齐。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">700px</span>;</span><br><span class="line">        <span class="attribute">background</span>: blue;</span><br><span class="line">        <span class="attribute">display</span>: flex;</span><br><span class="line">        <span class="attribute">align-items</span>: baseline;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>三个盒子中设置不同的字体大小，可以参考右侧编辑器中的代码进行测试。</p><p>实现效果：</p><p><a href="https://img3.mukewang.com/5e9668ff0001f8f125341053.jpg" target="_blank" rel="noopener"><img src="https://img3.mukewang.com/5e9668ff0001f8f125341053.jpg" alt="img"></a></p><p><code>stretch（默认值）</code>：如果项目未设置高度或设为auto，将占满整个容器的高度。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">       <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">       <span class="attribute">background</span>: blue;</span><br><span class="line">       <span class="attribute">display</span>: flex;</span><br><span class="line">       <span class="attribute">align-items</span>: stretch;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="selector-class">.box</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">       <span class="comment">/*不设置高度，元素在垂直方向上铺满父容器*/</span></span><br><span class="line">       <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><a href="https://img2.mukewang.com/5e9669ef00017e0e25390453.jpg" target="_blank" rel="noopener"><img src="https://img2.mukewang.com/5e9669ef00017e0e25390453.jpg" alt="img"></a></p><h4 id="给子元素设置flex占比"><a href="#给子元素设置flex占比" class="headerlink" title="给子元素设置flex占比"></a>给子元素设置flex占比</h4><p><a href="https://img3.mukewang.com/5e966c3100011c5b25430450.jpg" target="_blank" rel="noopener"><img src="https://img3.mukewang.com/5e966c3100011c5b25430450.jpg" alt="img"></a></p><p><strong>技术点的解释：</strong></p><p>1、给子元素设置flex属性,可以设置子元素相对于父元素的占比。</p><p>2、flex属性的值只能是正整数,表示占比多少。其实是几个子块的比</p><p>3、给子元素设置了flex之后,其宽度属性会失效。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="selector-tag">DOCTYPE</span> <span class="selector-tag">html</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">html</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">head</span>&gt;</span><br><span class="line">    &lt;meta charset="UTF-8"&gt;</span><br><span class="line">    &lt;title&gt;flex占比&lt;/title&gt;</span><br><span class="line">    &lt;style type="text/css"&gt;</span><br><span class="line">    <span class="selector-class">.box</span> &#123;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">        <span class="attribute">background</span>: blue;</span><br><span class="line">        <span class="attribute">display</span>: flex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.box</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.box1</span> &#123;</span><br><span class="line">        <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">        <span class="attribute">background</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.box2</span> &#123;</span><br><span class="line">        <span class="attribute">flex</span>: <span class="number">3</span>;</span><br><span class="line">        <span class="attribute">background</span>: orange;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.box3</span> &#123;</span><br><span class="line">        <span class="attribute">flex</span>: <span class="number">2</span>;</span><br><span class="line">        <span class="attribute">background</span>: green;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">    &lt;div class="box"&gt;</span><br><span class="line">        &lt;div class="box1"&gt;flex:1&lt;/div&gt;</span><br><span class="line">        &lt;div class="box2"&gt;flex:3&lt;/div&gt;</span><br><span class="line">        &lt;div class="box3"&gt;flex:2&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="15-css样式设置技巧"><a href="#15-css样式设置技巧" class="headerlink" title="15.css样式设置技巧"></a>15.css样式设置技巧</h3><h4 id="水平居中设置-行内元素"><a href="#水平居中设置-行内元素" class="headerlink" title="水平居中设置-行内元素"></a>水平居中设置-行内元素</h4><p>如果被设置元素为文本、图片等行内元素时，水平居中是通过给父元素设置 <code>text-align:center</code> 来实现的。</p><h4 id="水平居中设置-定宽块状元素"><a href="#水平居中设置-定宽块状元素" class="headerlink" title="水平居中设置-定宽块状元素"></a>水平居中设置-定宽块状元素</h4><p>当被设置元素为 块状元素 时用 <code>text-align：center</code> 就不起作用了，这时也分两种情况：<strong>定宽块状元素</strong>和<strong>不定宽块状元素</strong>。</p><h5 id="定宽块状元素：块状元素的宽度width为固定值。"><a href="#定宽块状元素：块状元素的宽度width为固定值。" class="headerlink" title="定宽块状元素：块状元素的宽度width为固定值。"></a>定宽块状元素：块状元素的宽度width为固定值。</h5><p>满足定宽和块状两个条件的元素是可以通过设置“左右margin”值为“auto”来实现居中的。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">  &lt;div&gt;我是定宽块状元素，哈哈，我要水平居中显示。&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid red;<span class="comment">/*为了显示居中效果明显为 div 设置了边框*/</span></span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;<span class="comment">/*定宽*/</span></span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">20px</span> auto;<span class="comment">/* margin-left 与 margin-right 设置为 auto */</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h4 id="面试常考题之已知宽高实现盒子水平垂直居中"><a href="#面试常考题之已知宽高实现盒子水平垂直居中" class="headerlink" title="面试常考题之已知宽高实现盒子水平垂直居中"></a>面试常考题之已知宽高实现盒子水平垂直居中</h4><p>这一章节我们来学习已知宽高实现盒子水平垂直居中。通常使用定位完成，例如想要实现以下效果：</p><p><a href="https://img4.mukewang.com/5e967bb40001e35725570475.jpg" target="_blank" rel="noopener"><img src="https://img4.mukewang.com/5e967bb40001e35725570475.jpg" alt="img"></a></p><p>我们有如下两个div元素</p><p><img src="https://img3.mukewang.com/5e967a0500013c9104650162.jpg" alt="img"></p><p>要实现子元素相对于父元素垂直水平居中,我们只需要输入以下代码：</p><p><a href="https://img.mukewang.com/5e967a380001840f11050487.jpg" target="_blank" rel="noopener"><img src="https://img.mukewang.com/5e967a380001840f11050487.jpg" alt="img"></a></p><p><strong>技术点的解释：</strong></p><p>1、利用父元素设置相对定位,子元素设置绝对定位,那么子元素就是相对于父元素定位的特性。</p><p>2、子元素设置上和左偏移的值都为50%，是元素的左上角在父元素中心点的位置。效果：</p><p><a href="https://img2.mukewang.com/5e967c3d0001fbbf25600616.jpg" target="_blank" rel="noopener"><img src="https://img2.mukewang.com/5e967c3d0001fbbf25600616.jpg" alt="img"></a></p><p>3、然后再用margin给上和左都给负的自身宽高的一半,就能达到垂直水平居中的效果。</p><h4 id="面试常考题之宽高不定实现盒子水平垂直居中"><a href="#面试常考题之宽高不定实现盒子水平垂直居中" class="headerlink" title="面试常考题之宽高不定实现盒子水平垂直居中"></a>面试常考题之宽高不定实现盒子水平垂直居中</h4><p>这一章我们来学习未知宽高实现盒子水平垂直居中，通常使用定位以及translate完成。参考下面例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box1"</span>&gt;</span></span><br><span class="line">           慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网慕课网</span><br><span class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">       <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#00ee00</span>;</span><br><span class="line">       <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">       <span class="attribute">position</span>: relative;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="selector-class">.box1</span> &#123;</span><br><span class="line">       <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">       <span class="attribute">position</span>: absolute;</span><br><span class="line">       <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">       <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">       <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><a href="https://img4.mukewang.com/5e967f3b000117da25530461.jpg" target="_blank" rel="noopener"><img src="https://img4.mukewang.com/5e967f3b000117da25530461.jpg" alt="img"></a></p><p><strong>技术点的解释：</strong></p><p>1、利用父元素设置相对定位,子元素设置绝对定位,那么子元素就是相对于父元素定位的特性。</p><p>2、子元素设置上和左偏移的值都为50%。</p><p>3、然后再用css3属性translate位移,给上和左都位移-50%距离，就能达到垂直水平居中的效果。</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计组笔记-P0-logisim状态机搭建</title>
      <link href="2021/01/29/CO-P0-logisim%E7%8A%B6%E6%80%81%E6%9C%BA%E6%90%AD%E5%BB%BA/"/>
      <url>2021/01/29/CO-P0-logisim%E7%8A%B6%E6%80%81%E6%9C%BA%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>北航计算机组成原理课程设计的Project0笔记，主要是关于logisim的使用和状态机的搭建。</p><a id="more"></a><h2 id="p0复习（logisim）"><a href="#p0复习（logisim）" class="headerlink" title="p0复习（logisim）"></a>p0复习（logisim）</h2><h3 id="注意的点"><a href="#注意的点" class="headerlink" title="注意的点"></a>注意的点</h3><ul><li>输入信号一般是通过<strong>MUX，多路选择器</strong>来实现对输出结果的控制。</li><li>刚连接好电路时或者连接电路中，可能出现有一些线路<strong>莫名其妙是蓝色</strong>，这时<strong>关闭logisim后再次打开</strong>往往就好了。</li><li><strong>comparator</strong>器件默认是有符号的，要调成<strong>unsigned</strong>来避免出现无符号数比较出现错误。</li><li>一些<strong>Arithmetic</strong>模块器件使用时，由于<strong>上下两侧也有输出端</strong>，如果连在一起可能出现意外。</li><li>组合逻辑部分如果输入、输出的位数较少，可直接用<strong>combinational analysis</strong> 里的 <strong>table</strong> 傻瓜式生成电路。</li><li>出现“xxxx”或者“EEEE”往往是因为电路中有<strong>连错的电路</strong>，比如<strong>把输入当成输出元件连了；某条线没有连接在模块/元件的端口上，而是连在了空白区域</strong>。</li><li>出现“ ”、fewer than output we expected可能是时序问题，比如超出了题目给出的时间。或者期待输出非零值时输出了0。也有可能是<strong>appearance</strong>不对</li><li>DMX最好设置成 <strong>Three-state:Yes</strong>    <strong>Disabled output:Float</strong>  如果Three state勾选为yes，那么DMX输出端<strong>没有被选中的路径</strong>会<strong>保持</strong>原来的值不变</li></ul><h3 id="时序逻辑—状态机"><a href="#时序逻辑—状态机" class="headerlink" title="时序逻辑—状态机"></a>时序逻辑—状态机</h3><p><strong>参考文章</strong>：<a href="https://www.cnblogs.com/BUAA-YiFei/articles/13855136.html" target="_blank" rel="noopener">lyyf的logisim状态机博客</a></p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li><strong>状态转移、输出逻辑</strong>用<strong>真值表生成</strong>。</li><li>寄存器的Q端在<strong>时钟信号为0时</strong>的值为<strong>初态</strong>，时钟信号的<strong>上升沿</strong>更新为<strong>次态</strong>。</li><li><strong>Moore输出逻辑</strong>，只和<strong>当前状态</strong>有关。</li><li><strong>Mealy输出逻辑</strong>，除了<strong>当前状态</strong>，还必须和<strong>输入</strong>发生联系。</li><li>（<strong>当前状态值</strong>：时钟上升沿前是寄存器现有的值，上升沿时是状态转移模块的输出值s’）</li></ul><h4 id="Moore型"><a href="#Moore型" class="headerlink" title="Moore型"></a>Moore型</h4><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/moore.png" alt=""></p><h4 id="Mealy型"><a href="#Mealy型" class="headerlink" title="Mealy型"></a>Mealy型</h4><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/mealy.png" alt=""></p><h4 id="同步复位"><a href="#同步复位" class="headerlink" title="同步复位"></a>同步复位</h4><p>具体来说就是用一个多路选择器，如果复位信号<strong>为0</strong>，则<strong>正常更新状态值</strong>，<strong>如果为1</strong>，就直接赋值给寄存器<strong>常量0</strong>。</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/同步复位.png" alt=""></p><h4 id="异步复位"><a href="#异步复位" class="headerlink" title="异步复位"></a>异步复位</h4><p>直接使用寄存器自带的<strong>clear</strong>端口进行复位即可</p><p>王pb助教的logisim评测帖子：<a href="http://cscore.net.cn/courses/course-v1:Internal+B3I062410+2020_T1/discussion/forum/course/threads/5f8ab909cf9bcc0efe0000bd" target="_blank" rel="noopener">http://cscore.net.cn/courses/course-v1:Internal+B3I062410+2020_T1/discussion/forum/course/threads/5f8ab909cf9bcc0efe0000bd</a></p><h3 id="logisim命令行调试"><a href="#logisim命令行调试" class="headerlink" title="logisim命令行调试"></a>logisim命令行调试</h3><p>要用 jar 文件</p><p>我的电脑：java -jar logisim-generic-2.7.1.jar fsm.circ -tty table</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA-CO-2020 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL学习笔记</title>
      <link href="2021/01/29/sql-note/"/>
      <url>2021/01/29/sql-note/</url>
      
        <content type="html"><![CDATA[<p>最近结合廖雪峰教程学习了和sql,mysql相关的一些知识，对重要的部分做了一些梳理。<br><a id="more"></a></p><h2 id="英文教程"><a href="#英文教程" class="headerlink" title="英文教程"></a>英文教程</h2><h5 id="How-to-Load-the-Sample-Database-into-MySQL-Server"><a href="#How-to-Load-the-Sample-Database-into-MySQL-Server" class="headerlink" title="How to Load the Sample Database into MySQL Server"></a><a href="https://www.mysqltutorial.org/how-to-load-sample-database-into-mysql-database-server.aspx" target="_blank" rel="noopener">How to Load the Sample Database into MySQL Server</a></h5><h5 id="https-www-mysqltutorial-org"><a href="#https-www-mysqltutorial-org" class="headerlink" title="https://www.mysqltutorial.org/"></a><a href="https://www.mysqltutorial.org/" target="_blank" rel="noopener">https://www.mysqltutorial.org/</a></h5><h2 id="SQL教程（廖雪峰）笔记"><a href="#SQL教程（廖雪峰）笔记" class="headerlink" title="SQL教程（廖雪峰）笔记"></a>SQL教程（廖雪峰）笔记</h2><h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><p>关系数据库是建立在关系模型上的。而关系模型本质上就是若干个存储数据的<strong>二维表</strong>，可以把它们看作很多<strong>Excel表</strong>。</p><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><h4 id="脚本生成数据方式"><a href="#脚本生成数据方式" class="headerlink" title="脚本生成数据方式"></a>脚本生成数据方式</h4><p>1.打开MYSQL-command line </p><p>2.输入source 将相应的sql文件对应的地址输入（或者直接把文件拖入命令行）</p><p>廖老师的sql文件：<a href="F:\学习\工程与应用科学\CS技术学习\SQL-learn\init-test-data.sql">init-test-data.sql</a></p><p>3.<code>SHOW DATABASE</code>可以查看已有数据库</p><h4 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h4><p>使用SELECT查询的基本语句<code>SELECT * FROM &lt;表名&gt;</code>可以查询一个表的所有行和所有列的数据。</p><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &lt;表名&gt; WHERE &lt;条件表达式&gt;</span><br><span class="line">SELECT * FROM students WHERE score &gt;&#x3D; 80;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:left">条件</th><th style="text-align:left">表达式举例1</th><th style="text-align:left">表达式举例2</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">使用=判断相等</td><td style="text-align:left">score = 80</td><td style="text-align:left">name = ‘abc’</td><td style="text-align:left">字符串需要用单引号括起来</td></tr><tr><td style="text-align:left">使用&gt;判断大于</td><td style="text-align:left">score &gt; 80</td><td style="text-align:left">name &gt; ‘abc’</td><td style="text-align:left">字符串比较根据ASCII码，中文字符比较根据数据库设置</td></tr><tr><td style="text-align:left">使用&gt;=判断大于或相等</td><td style="text-align:left">score &gt;= 80</td><td style="text-align:left">name &gt;= ‘abc’</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">使用&lt;判断小于</td><td style="text-align:left">score &lt; 80</td><td style="text-align:left">name &lt;= ‘abc’</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">使用&lt;=判断小于或相等</td><td style="text-align:left">score &lt;= 80</td><td style="text-align:left">name &lt;= ‘abc’</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">使用&lt;&gt;判断不相等</td><td style="text-align:left">score &lt;&gt; 80</td><td style="text-align:left">name &lt;&gt; ‘abc’</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">使用LIKE判断相似</td><td style="text-align:left">name LIKE ‘ab%’</td><td style="text-align:left">name LIKE ‘%bc%’</td><td style="text-align:left">%表示任意字符，例如’ab%’将匹配’ab’，’abc’，’abcd’</td></tr><tr><td style="text-align:left">BETWEEN a AND b</td><td style="text-align:left">BETWEEN 60 AND 90</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">IN (a,b)</td><td style="text-align:left">是否等于a或b</td><td style="text-align:left"></td></tr></tbody></table></div><h4 id="投影查询"><a href="#投影查询" class="headerlink" title="投影查询"></a>投影查询</h4><p>基本格式：<code>SELECT 列1, 列2, 列3 FROM students</code></p><p>使用<code>SELECT 列1, 列2, 列3 FROM ...</code>时，还可以给每一列起个别名，这样，结果集的列名就可以与原表的列名不同。它的语法是<code>SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM ...</code>。</p><p>例如，以下<code>SELECT</code>语句将列名<code>score</code>重命名为<code>points</code>，而<code>id</code>和<code>name</code>列名保持不变：</p><p><code>SELECT id, score points, name FROM students;</code></p><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>查询结果集通常是按照<code>id</code>排序的，也就是根据主键排序。要根据其他条件排序——加上ORDER BY子句</p><p><strong>默认的排序规则</strong>是<code>ASC</code>：“<strong>升序</strong>”，即从小到大。ASC可以省略，即<code>ORDER BY score ASC和ORDER BY score</code>效果一样。</p><p>加上<code>DESC</code>表示“<strong>倒序</strong>”</p><p>如果score列有相同的数据，要进一步排序，可以继续添加列名。例如，使用<code>ORDER BY score DESC, gender</code>表示先按score列倒序，如果有相同分数的，再按gender列排序：</p><p>如果有<code>WHERE</code>子句，那么<code>ORDER BY</code>子句要放到WHERE子句后面。</p><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><p>使用<code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code>可以对结果集进行分页，每次查询返回结果集的一部分；</p><p>offset—从第几条记录开始查</p><p>limit—最多显示多少条数据</p><p>分页查询需要先确定每页的数量和当前页数，然后确定LIMIT和OFFSET的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, name, gender, score</span><br><span class="line">FROM students</span><br><span class="line">ORDER BY score DESC</span><br><span class="line">LIMIT 3 OFFSET 0;</span><br></pre></td></tr></table></figure><h4 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h4><p>对于统计总数、平均数这类计算，SQL提供了专门的聚合函数，使用聚合函数进行查询，就是聚合查询，它可以快速获得结果。</p><p><code>SELECT COUNT(*) FROM students;</code></p><p><code>COUNT(*)</code>表示查询所有列的行数，要注意聚合的计算结果虽然是一个数字，但查询的结果仍然是一个二维表，只是这个二维表只有一行一列，并且列名是<code>COUNT(*)</code>。通常，使用聚合查询时，我们应该给列名设置一个别名，便于处理结果：</p><p><code>SELECT COUNT(*) num FROM students;</code></p><p>聚合查询同样可以使用WHERE条件</p><p>除了COUNT()函数外，SQL还提供了如下聚合函数：</p><div class="table-container"><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">SUM</td><td style="text-align:left">计算某一列的合计值，该列必须为数值类型</td></tr><tr><td style="text-align:left">AVG</td><td style="text-align:left">计算某一列的平均值，该列必须为数值类型</td></tr><tr><td style="text-align:left">MAX</td><td style="text-align:left">计算某一列的最大值</td></tr><tr><td style="text-align:left">MIN</td><td style="text-align:left">计算某一列的最小值</td></tr></tbody></table></div><p>要特别注意：如果聚合查询的<code>WHERE</code>条件没有匹配到任何行，<code>COUNT()</code>会返回0，而<code>SUM()</code>、<code>AVG()</code>、<code>MAX()</code>和<code>MIN()</code>会返回<code>NULL</code>：</p><p>每页3条记录，如何通过聚合查询获得总页数？——<code>SELECT CEILING(COUNT(*) / 3) FROM students;</code></p><h5 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h5><p>按class_id分组: <code>SELECT COUNT(*) num FROM students GROUP BY class_id;</code></p><p><code>SELECT class_id, COUNT(*) num FROM students GROUP BY class_id;</code></p><p>请使用一条SELECT查询查出每个班级男生和女生的平均分：<code>SELECT class_id,gender,AVG(score) FROM students GROUP BY class_id,gender;</code></p><h4 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h4><p><code>SELECT * FROM &lt;表1&gt; &lt;表2&gt;</code></p><p>注意，多表查询时，要使用<code>表名.列名</code>这样的方式来引用列和设置别名，这样就避免了结果集的列名重复问题。但是，用<code>表名.列名</code>这种方式列举两个表的所有列实在是很麻烦，所以SQL还允许给表设置一个别名，让我们在投影查询中引用起来稍微简洁一点：</p><p><code>SELECT s.id sid, s.name, s.gender, s.score, c.id cid, c.name cname FROM students s, classes c;</code></p><p>注意到<code>FROM</code>子句给表设置别名的语法是<code>FROM &lt;表名1&gt; &lt;别名1&gt;, &lt;表名2&gt; &lt;别名2&gt;</code>。这样我们用别名<code>s</code>和<code>c</code>分别表示<code>students</code>表和<code>classes</code>表。</p><p>使用多表查询可以获取M x N行记录；</p><p>多表查询的结果集可能非常巨大，要小心使用。</p><h4 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h4><p>注意<strong>INNER JOIN</strong>查询的写法是：</p><ol><li>先确定主表，仍然使用<code>FROM &lt;表1&gt;</code>的语法；</li><li>再确定需要连接的表，使用<code>INNER JOIN &lt;表2&gt;</code>的语法；</li><li>然后确定连接条件，使用<code>ON &lt;条件...&gt;</code>，这里的条件是<code>s.class_id = c.id</code>，表示<code>students</code>表的<code>class_id</code>列与<code>classes</code>表的<code>id</code>列相同的行需要连接；</li><li>可选：加上<code>WHERE</code>子句、<code>ORDER BY</code>等子句。</li></ol><p>有<strong>RIGHT OUTER JOIN，就有LEFT OUTER JOIN，以及FULL OUTER JOIN</strong>。它们的区别是：</p><ul><li><p>INNER JOIN只返回同时存在于两张表的行数据，由于students表的class_id包含1，2，3，classes表的id包含1，2，3，4，所以，INNER JOIN根据条件s.class_id = c.id返回的结果集仅包含1，2，3。</p></li><li><p>RIGHT OUTER JOIN返回右表都存在的行。如果某一行仅在右表存在，那么结果集就会以NULL填充剩下的字段。</p></li><li><p>LEFT OUTER JOIN则返回左表都存在的行。如果我们给students表增加一行，并添加class_id=5，由于classes表并不存在id=5的行，所以，LEFT OUTER JOIN的结果会增加一行，对应的class_name是NULL：</p></li></ul><h4 id="查询数据方式小结"><a href="#查询数据方式小结" class="headerlink" title="查询数据方式小结"></a>查询数据方式小结</h4><p>代码形式总结知识点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT col1_name,col2_name,(COUNT(*),(AVG(col3_name)) average) #基本查询方式 聚合查询——聚合函数 投影查询</span><br><span class="line">FROM excel1_name replace1_name (,excel2_name replace2_name) #多表查询 同表名字替换</span><br><span class="line">INNER(&#x2F;FULL OUTER&#x2F;RIGHT OUTER&#x2F;LEFT OUTER)  JOIN classes c #连接查询</span><br><span class="line">(GROUP BY colx_name) #聚合查询——分组查询</span><br><span class="line">WHERE (EXPRESSION) #条件查询</span><br><span class="line">ORDER BY coly_name (ASC&#x2F;DESC) #排序</span><br><span class="line">LIMIT m OFFSET n; #分页查询</span><br></pre></td></tr></table></figure><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p>关系数据库的基本操作就是增删改查，即CRUD：Create、Retrieve、Update、Delete。</p><p>而对于增、删、改，对应的SQL语句分别是：</p><ul><li>INSERT：插入新记录；</li><li>UPDATE：更新已有记录；</li><li>DELETE：删除已有记录。</li></ul><h4 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h4><p><code>INSERT INTO &lt;表名&gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...);</code></p><p>注意到我们并没有列出<code>id</code>字段，也没有列出<code>id</code>字段对应的值，这是因为<code>id</code>字段是一个自增主键，它的值可以由数据库自己推算出来。此外，如果一个字段有默认值，那么在<code>INSERT</code>语句中也可以不出现。</p><p>还可以一次性添加多条记录，只需要在<code>VALUES</code>子句中指定多个记录值，每个记录是由<code>(...)</code>包含的一组值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO students (class_id, name, gender, score) VALUES</span><br><span class="line">  (1, &#39;大宝&#39;, &#39;M&#39;, 87),</span><br><span class="line">  (2, &#39;二宝&#39;, &#39;M&#39;, 81);</span><br><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure><h4 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h4><p><code>UPDATE &lt;表名&gt; SET 字段1=值1, 字段2=值2, ... WHERE ...;</code></p><p>可以一次更新多条记录</p><h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><p><code>DELETE FROM &lt;表名&gt; WHERE ...;</code></p><p>不带<code>WHERE</code>条件的<code>DELETE</code>语句会删除整个表的数据</p><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>查找MYSQL安装目录方法：进入mysql命令行输入：<code>show variables like &quot;%char%&quot;;</code></p><p>我的：C:\Program Files\MySQL\MySQL Server 8.0\bin</p><p><strong>加环境变量</strong>：我的计算机——属性——高级系统设置——环境变量——在用户变量和系统变量的path处加地址</p><p>打开命令提示符，输入命令<code>mysql -u root -p</code>，提示输入口令。填入MySQL的<code>root</code>口令，如果正确，就连上了MySQL Server，同时提示符变为<code>mysql&gt;</code>：</p><p>输入<code>exit</code>断开与MySQL Server的连接并返回到命令提示符。</p><p>MySQL Client的可执行程序是mysql，MySQL Server的可执行程序是mysqld。</p><p>MySQL Client和MySQL Server的关系如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──────────────┐  SQL   ┌──────────────┐</span><br><span class="line">│ MySQL Client │───────&gt;│ MySQL Server │</span><br><span class="line">└──────────────┘  TCP   └──────────────┘</span><br></pre></td></tr></table></figure><p>在MySQL Client中输入的SQL语句通过TCP连接发送到MySQL Server。默认端口号是3306，即如果发送到本机MySQL Server，地址就是<code>127.0.0.1:3306</code>。</p><p>也可以只安装MySQL Client，然后连接到远程MySQL Server。假设远程MySQL Server的IP地址是<code>10.0.1.99</code>，那么就使用<code>-h</code>指定IP或域名：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h <span class="number">10</span>.<span class="number">0</span>.<span class="number">1</span>.<span class="number">99</span> -u root -p</span><br></pre></td></tr></table></figure><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>命令行程序<code>mysql</code>实际上是MySQL客户端，真正的MySQL服务器程序是<code>mysqld</code>，在后台运行。</p><h4 id="管理MySQL"><a href="#管理MySQL" class="headerlink" title="管理MySQL"></a>管理MySQL</h4><p>要管理MySQL，可以使用可视化图形界面MySQL Workbench。</p><p>MySQL Workbench可以用可视化的方式查询、创建和修改数据库表，但是，归根到底，MySQL Workbench是一个图形客户端，它对MySQL的操作仍然是发送SQL语句并执行。因此，本质上，MySQL Workbench和MySQL Client命令行都是客户端，和MySQL交互，唯一的接口就是SQL。</p><p>因此，MySQL提供了大量的SQL语句用于管理。虽然可以使用MySQL Workbench图形界面来直接管理MySQL，但是，很多时候，通过SSH远程连接时，只能使用SQL命令，所以，了解并掌握常用的SQL管理操作是必须的。</p><h5 id="1-数据库"><a href="#1-数据库" class="headerlink" title="1.数据库"></a>1.数据库</h5><p>在一个运行MySQL的服务器上，实际上可以创建多个数据库（Database）。要列出所有数据库，使用命令：<code>SHOW DATABASES</code></p><p>其中，<code>information_schema</code>、<code>mysql</code>、<code>performance_schema</code>和<code>sys</code>是系统库，不要去改动它们。其他的是用户创建的数据库。</p><p>要<strong>创建</strong>一个新数据库，使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE test;</span><br></pre></td></tr></table></figure><p>要<strong>删除</strong>一个数据库，使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE test;</span><br></pre></td></tr></table></figure><p>注意：删除一个数据库将导致该数据库的所有表全部被删除。</p><p>对一个数据库进行操作时，要首先将其切换为当前数据库：<code>USE test;</code></p><h5 id="2-表"><a href="#2-表" class="headerlink" title="2.表"></a>2.表</h5><p>列出当前数据库的所有表，使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure><p>要查看一个表的结构，使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC students;</span><br></pre></td></tr></table></figure><p>还可以使用以下命令查看创建表的SQL语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE TABLE students;</span><br></pre></td></tr></table></figure><p>创建表使用<code>CREATE TABLE</code>语句，而删除表使用<code>DROP TABLE</code>语句：</p><p>修改表就比较复杂。如果要给<code>students</code>表新增一列<code>birth</code>，使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students ADD COLUMN birth VARCHAR(10) NOT NULL;</span><br></pre></td></tr></table></figure><p>要修改<code>birth</code>列，例如把列名改为<code>birthday</code>，类型改为<code>VARCHAR(20)</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students CHANGE COLUMN birth birthday VARCHAR(20) NOT NULL;</span><br></pre></td></tr></table></figure><p>要删除列，使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students DROP COLUMN birthday;</span><br></pre></td></tr></table></figure><h5 id="3-退出MySQL"><a href="#3-退出MySQL" class="headerlink" title="3.退出MySQL"></a>3.退出MySQL</h5><p>使用<code>EXIT</code>命令退出MySQL</p><h4 id="实用SQL语句"><a href="#实用SQL语句" class="headerlink" title="实用SQL语句"></a>实用SQL语句</h4><p>在编写SQL时，灵活运用一些技巧，可以大大简化程序逻辑。</p><h5 id="1-插入或替换"><a href="#1-插入或替换" class="headerlink" title="1.插入或替换"></a>1.插入或替换</h5><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就先删除原记录，再插入新记录。此时，可以使用<code>REPLACE</code>语句，这样就不必先查询，再决定是否先删除再插入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLACE INTO students (id, class_id, name, gender, score) VALUES (1, 1, &#39;小明&#39;, &#39;F&#39;, 99);</span><br></pre></td></tr></table></figure><p>若<code>id=1</code>的记录不存在，<code>REPLACE</code>语句将插入新记录，否则，当前<code>id=1</code>的记录将被删除，然后再插入新记录。</p><h5 id="2-插入或更新"><a href="#2-插入或更新" class="headerlink" title="2.插入或更新"></a>2.插入或更新</h5><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就更新该记录，此时，可以使用<code>INSERT INTO ... ON DUPLICATE KEY UPDATE ...</code>语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO students (id, class_id, name, gender, score) VALUES (1, 1, &#39;小明&#39;, &#39;F&#39;, 99) ON DUPLICATE KEY UPDATE name&#x3D;&#39;小明&#39;, gender&#x3D;&#39;F&#39;, score&#x3D;99;</span><br></pre></td></tr></table></figure><p>若<code>id=1</code>的记录不存在，<code>INSERT</code>语句将插入新记录，否则，当前<code>id=1</code>的记录将被更新，更新的字段由<code>UPDATE</code>指定。</p><h5 id="3-插入或忽略"><a href="#3-插入或忽略" class="headerlink" title="3.插入或忽略"></a>3.插入或忽略</h5><p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就啥事也不干直接忽略，此时，可以使用<code>INSERT IGNORE INTO ...</code>语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT IGNORE INTO students (id, class_id, name, gender, score) VALUES (1, 1, &#39;小明&#39;, &#39;F&#39;, 99);</span><br></pre></td></tr></table></figure><p>若<code>id=1</code>的记录不存在，<code>INSERT</code>语句将插入新记录，否则，不执行任何操作。</p><h5 id="4-快照"><a href="#4-快照" class="headerlink" title="4.快照"></a>4.快照</h5><p>如果想要对一个表进行快照，即复制一份当前表的数据到一个新表，可以结合<code>CREATE TABLE</code>和<code>SELECT</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 对class_id&#x3D;1的记录进行快照，并存储为新表students_of_class1:</span><br><span class="line">CREATE TABLE students_of_class1 SELECT * FROM students WHERE class_id&#x3D;1;</span><br></pre></td></tr></table></figure><p>新创建的表结构和<code>SELECT</code>使用的表结构完全一致。</p><h5 id="5-写入查询结果集"><a href="#5-写入查询结果集" class="headerlink" title="5.写入查询结果集"></a>5.写入查询结果集</h5><p>如果查询结果集需要写入到表中，可以结合<code>INSERT</code>和<code>SELECT</code>，将<code>SELECT</code>语句的结果集直接插入到指定表中。</p><p>例如，创建一个统计成绩的表<code>statistics</code>，记录各班的平均成绩：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE statistics (</span><br><span class="line">    id BIGINT NOT NULL AUTO_INCREMENT,</span><br><span class="line">    class_id BIGINT NOT NULL,</span><br><span class="line">    average DOUBLE NOT NULL,</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>然后，我们就可以用一条语句写入各班的平均成绩：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO statistics (class_id, average) SELECT class_id, AVG(score) FROM students GROUP BY class_id;</span><br></pre></td></tr></table></figure><p>确保<code>INSERT</code>语句的列和<code>SELECT</code>语句的列能一一对应，就可以在<code>statistics</code>表中直接保存查询的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT * FROM statistics;</span><br><span class="line">+----+----------+--------------+</span><br><span class="line">| id | class_id | average      |</span><br><span class="line">+----+----------+--------------+</span><br><span class="line">|  1 |        1 |         86.5 |</span><br><span class="line">|  2 |        2 | 73.666666666 |</span><br><span class="line">|  3 |        3 | 88.333333333 |</span><br><span class="line">+----+----------+--------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h5 id="6-强制使用指定索引"><a href="#6-强制使用指定索引" class="headerlink" title="6.强制使用指定索引"></a>6.强制使用指定索引</h5><p>在查询的时候，数据库系统会自动分析查询语句，并选择一个最合适的索引。但是很多时候，数据库系统的查询优化器并不一定总是能使用最优索引。如果我们知道如何选择索引，可以使用<code>FORCE INDEX</code>强制查询使用指定的索引。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT * FROM students FORCE INDEX (idx_class_id) WHERE class_id &#x3D; 1 ORDER BY id DESC;</span><br></pre></td></tr></table></figure><p>指定索引的前提是索引<code>idx_class_id</code>必须存在。</p><h2 id="Python3-MySQL-数据库连接-PyMySQL-驱动"><a href="#Python3-MySQL-数据库连接-PyMySQL-驱动" class="headerlink" title="Python3 MySQL 数据库连接 - PyMySQL 驱动"></a>Python3 MySQL 数据库连接 - PyMySQL 驱动</h2><p><code>$ pip3 install PyMySQL</code></p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>廖雪峰git课程笔记</title>
      <link href="2021/01/29/git-liaoxuefeng-note/"/>
      <url>2021/01/29/git-liaoxuefeng-note/</url>
      
        <content type="html"><![CDATA[<p>关于廖雪峰git教程的一点笔记</p><a id="more"></a><h2 id="git教程（廖雪峰）笔记"><a href="#git教程（廖雪峰）笔记" class="headerlink" title="git教程（廖雪峰）笔记"></a>git教程（廖雪峰）笔记</h2><h3 id="1-git简介"><a href="#1-git简介" class="headerlink" title="1.git简介"></a>1.git简介</h3><h4 id="git的诞生"><a href="#git的诞生" class="headerlink" title="git的诞生"></a>git的诞生</h4><p>Git是目前世界上最先进的<strong>分布式版本控制系统</strong>（没有之一）。开发Linux系统时，Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！Git迅速成为最流行的分布式版本控制系统，尤其是2008年，<strong>GitHub</strong>网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。</p><h4 id="分布式vs集中式"><a href="#分布式vs集中式" class="headerlink" title="分布式vs集中式"></a>分布式vs集中式</h4><p>CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统</p><h5 id="集中式版本控制系统"><a href="#集中式版本控制系统" class="headerlink" title="集中式版本控制系统"></a>集中式版本控制系统</h5><ul><li><p>版本库是<strong>集中存放在中央服务器的</strong>，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。</p></li><li><p>必须联网才能工作</p></li></ul><h5 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h5><ul><li><p><strong>分布式版本控制系统根本没有“中央服务器”</strong>，<strong>每个人的电脑上都是一个完整的版本库</strong>，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p></li><li><p>不用联网，且分支管理功能强大</p></li></ul><h3 id="2-git的安装"><a href="#2-git的安装" class="headerlink" title="2.git的安装"></a>2.<span id="anzhuang">git的安装</span></h3><h4 id="在windows上安装"><a href="#在windows上安装" class="headerlink" title="在windows上安装"></a>在windows上安装</h4><p>从Git官网直接<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">下载安装程序</a>，然后按默认选项安装即可。安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p><p>安装完成后，还需要最后一步设置，在命令行输入：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name "Your Name"</span><br><span class="line">$ git config --global user.email "email@example.com"</span><br></pre></td></tr></table></figure><p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：<strong>你的名字和Email地址</strong>。不用担心别人会冒充，如果有也可以查询。</p><p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><h3 id="3-创建版本库"><a href="#3-创建版本库" class="headerlink" title="3.创建版本库"></a>3.创建版本库</h3><p><strong>版本库</strong>：又名仓库，英文名<strong>repository</strong>，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p><h4 id="创建一个版本库"><a href="#创建一个版本库" class="headerlink" title="创建一个版本库"></a>创建一个版本库</h4><p>首先，选择一个合适的地方，创建一个空目录：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> learngit</span><br><span class="line">$ <span class="built_in">cd</span> learngit</span><br><span class="line">$ pwd</span><br><span class="line">/Users/michael/learngit</span><br></pre></td></tr></table></figure><ul><li><p><code>pwd</code>命令用于<strong>显示当前目录</strong>。在我的Mac上，这个仓库位于<code>/Users/michael/learngit</code>。</p></li><li><p>如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。</p></li></ul><p>第二步，通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /Users/michael/learngit/.git/</span><br></pre></td></tr></table></figure><ul><li>如果你没有看到<code>.git</code>目录，那是因为这个目录默认是隐藏的，用<code>ls -ah</code>命令就可以看见。</li></ul><h4 id="把文件添加到版本库"><a href="#把文件添加到版本库" class="headerlink" title="把文件添加到版本库"></a>把文件添加到版本库</h4><ul><li><p>所有的版本控制系统，其实只能跟踪<strong>文本文件的改动</strong>，比如<strong>TXT文件，网页，所有的程序代码</strong>等等，Git也不例外,图片、视频这些二进制文件，虽然也能由版本控制系统管理，但<strong>没法跟踪文件的变化</strong>,只能知道文件大小的变化。由于word文件是二进制文件，因此无法追踪。</p></li><li><p>建议使用标准的UTF-8编码。建议使用<strong>Notepad++</strong>而不是系统自带记事本</p></li><li><p>执行命令，没有任何显示，就对了，Unix的哲学是“没有消息就是好消息”，说明操作成功。</p></li></ul><h5 id="添加文件到Git仓库，分两步"><a href="#添加文件到Git仓库，分两步" class="headerlink" title="添加文件到Git仓库，分两步"></a>添加文件到Git仓库，分两步</h5><ol><li>使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</li><li>使用命令<code>git commit -m &lt;message&gt;</code>，完成。</li></ol><h3 id="4-版本管理"><a href="#4-版本管理" class="headerlink" title="4.版本管理"></a>4.版本管理</h3><ul><li>要随时掌握工作区的状态，使用<code>git status</code>命令。</li><li>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff &lt;file&gt;</code>可以查看修改内容。</li></ul><h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a><span id="moveback">版本回退</span></h4><ul><li><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</li></ul><p>上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，往上100个版本写成<code>HEAD~100</code>。</p><ul><li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li></ul><p><code>git log</code>命令显示从最近到最远的提交日志，如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数</p><ul><li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li></ul><h4 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h4><p><strong>工作区</strong>（Working Directory）就是你在电脑里能看到的目录</p><p><strong>版本库</strong>（Repository）:工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。Git的版本库里存了很多东西，其中最重要的就是称为<strong>stage（或者叫index）的暂存区</strong>，还有Git为我们<strong>自动创建的第一个分支</strong><code>master</code>，以及指向<code>master</code>的<strong>一个指针</strong>叫<code>HEAD</code>。</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/1.png" style="zoom:67%;" /></p><p>把文件往Git版本库里添加的时候，是分两步执行的：</p><p><strong>第一步</strong>是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p><p><strong>第二步</strong>是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p><p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p><h4 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h4><p>一个操作过程：第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code></p><p>Git管理的是修改，当你用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p><p>提交后，用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别：</p><h4 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h4><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- &lt;file&gt;</code>。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a href="#moveback">版本回退</a>一节，不过前提是没有推送到远程库。</p><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><p>命令<code>git rm &lt;file&gt;</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>。</p><h3 id="5-远程仓库"><a href="#5-远程仓库" class="headerlink" title="5.远程仓库"></a>5.远程仓库</h3><p>自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置</p><h4 id="设置流程方法"><a href="#设置流程方法" class="headerlink" title="设置流程方法"></a>设置流程方法</h4><p>第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C "youremail@example.com"</span><br></pre></td></tr></table></figure><p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><p>第2步：登陆GitHub，鼠标移到右上角头像，点击“Settings”，进入“SSH and GPG keys”页面：</p><p>然后，点“New SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容：点“Add Key”，你就应该看到已经添加的Key。</p><h4 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h4><p>创建一个新的Repository，在Repository name填入名字，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库</p><ul><li><p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</p></li><li><p>关联后，<strong>在需要提交的本地文件夹处的Git Bash</strong>使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p></li><li><p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p></li></ul><h4 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h4><p>要克隆一个仓库，首先必须知道仓库的地址，然后使用</p><p><code>git clone git@github.com:michaelliao/gitskills.git</code> (这个例子是<code>ssh</code>）命令克隆。也可以用<code>https://github.com/michaelliao/gitskills.git</code>  （<code>michaelliao</code>替换成自己的用户名，后者改为自己的项目名字）</p><p>Git支持多种协议，包括<code>https</code>，但<code>ssh</code>协议速度最快。</p><h3 id="6-分支管理"><a href="#6-分支管理" class="headerlink" title="6.分支管理"></a>6.分支管理</h3><h4 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h4><p>查看分支：<code>git branch</code></p><p>创建分支：<code>git branch &lt;name&gt;</code></p><p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code></p><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></p><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p><p>删除分支：<code>git branch -d &lt;name&gt;</code></p><h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p><p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p><p>用<code>git log --graph</code>命令可以看到分支合并图。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure><h4 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h4><p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。不能记录下来合并的过程。如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><p><code>--no-ff</code>方式的<code>git merge</code>可以禁用<code>Fast forward</code>    合并后，我们用<code>git log</code>看看分支历史：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m "merge with no-ff" dev</span><br><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure><h5 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h5><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p><ul><li><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p></li><li><p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p></li><li><p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p></li></ul><p>所以，团队合作的分支看起来如下图：</p><p><img src="https://fzc-1300590701.cos.ap-nanjing.myqcloud.com/blogImages/团队合作分支管理.png" alt=""></p><h4 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h4><ul><li><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p></li><li><p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，工作区是干净的，刚才的工作现场存到哪去了？用<code>git stash list</code>命令看看，再<code>git stash pop</code>，回到工作现场；</p></li></ul><p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p><p>一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</p><p>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了：</p><ul><li>在master分支上修复的bug，想要合并到当前dev分支，可以用<code>git cherry-pick &lt;commit&gt;</code>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</li></ul><h4 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h4><p>开发一个新feature，最好新建一个分支；</p><p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p><h4 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h4><ul><li><p>查看远程库信息，使用 <code>git remote</code> (简单信息)  <code>git remote -v</code>（详细信息）；</p></li><li><p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p></li><li><p>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</p><p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p><ul><li><code>master</code>分支是主分支，因此要时刻与远程同步；</li><li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li></ul><ul><li><p>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</p></li><li><p>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p></li></ul></li><li><p>当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的<code>master</code>分支。在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</p></li><li><p>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</p></li><li><p>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</p></li></ul><ul><li>多人协作工作模式</li></ul><ol><li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li></ol><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p><h4 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h4><ul><li>rebase操作可以把本地未push的分叉提交历史整理成直线；</li><li>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</li></ul><h3 id="7-标签管理"><a href="#7-标签管理" class="headerlink" title="7.标签管理"></a>7.标签管理</h3><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><ul><li>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id；</li><li>命令<code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；<code>-m</code>后面是说明文字</li><li>命令<code>git tag</code>可以查看所有标签。</li></ul><ul><li>用命令<code>git show &lt;tagname&gt;</code>可以看到说明文字：</li></ul><h4 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h4><ul><li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</li><li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li><li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</li><li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</li></ul><h3 id="8-使用GitHub"><a href="#8-使用GitHub" class="headerlink" title="8.使用GitHub"></a>8.使用GitHub</h3><p>我们一直用GitHub作为免费的远程仓库，如果是个人的开源项目，放到GitHub上是完全没有问题的。其实GitHub还是一个开源协作社区，通过GitHub，既可以让别人参与你的开源项目，也可以参与别人的开源项目。</p><p>如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页<a href="https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：" target="_blank" rel="noopener">https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：</a></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:michaelliao/bootstrap.git</span><br></pre></td></tr></table></figure><p>一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址<code>git@github.com:twbs/bootstrap.git</code>克隆，因为没有权限，你将不能推送修改。</p><p>Bootstrap的官方仓库<code>twbs/bootstrap</code>、你在GitHub上克隆的仓库<code>my/bootstrap</code>，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌─ GitHub ────────────────────────────────────┐</span><br><span class="line">│                                             │</span><br><span class="line">│ ┌─────────────────┐     ┌─────────────────┐ │</span><br><span class="line">│ │ twbs&#x2F;bootstrap  │────&gt;│  my&#x2F;bootstrap   │ │</span><br><span class="line">│ └─────────────────┘     └─────────────────┘ │</span><br><span class="line">│                                  ▲          │</span><br><span class="line">└──────────────────────────────────┼──────────┘</span><br><span class="line">                                   ▼</span><br><span class="line">                          ┌─────────────────┐</span><br><span class="line">                          │ local&#x2F;bootstrap │</span><br><span class="line">                          └─────────────────┘</span><br></pre></td></tr></table></figure><p>如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。</p><p>如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul><li>在GitHub上，可以任意Fork开源仓库；</li><li>自己拥有Fork后的仓库的读写权限；</li><li>可以推送pull request给官方仓库来贡献代码。</li></ul><h3 id="9-使用Gitee"><a href="#9-使用Gitee" class="headerlink" title="9.使用Gitee"></a>9.使用Gitee</h3><p>使用GitHub时，国内的用户经常遇到的问题是访问速度太慢，有时候还会出现无法连接的情况（原因你懂的）。</p><p>如果我们希望体验Git飞一般的速度，可以使用国内的Git托管服务——<a href="https://gitee.com/?utm_source=blog_lxf" target="_blank" rel="noopener">Gitee</a>（<a href="https://gitee.com/?utm_source=blog_lxf" target="_blank" rel="noopener">gitee.com</a>）。</p><p>和GitHub相比，Gitee也提供免费的Git仓库。此外，还集成了代码质量检测、项目演示等功能。对于团队协作开发，Gitee还提供了项目管理、代码托管、文档管理的服务，5人以下小团队免费。</p><p> Gitee的免费版本也提供私有库功能，只是有5人的成员上限。</p><p>使用Gitee和使用GitHub类似，我们在Gitee上注册账号并登录后，需要先上传自己的SSH公钥。选择右上角用户头像 -&gt; 菜单“修改资料”，然后选择“SSH公钥”，填写一个便于识别的标题，然后把用户主目录下的<code>.ssh/id_rsa.pub</code>文件的内容粘贴进去：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1163452910422880/l" alt="gitee-add-ssh-key"></p><p>点击“确定”即可完成并看到刚才添加的Key：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1163453163108928/l" alt="gitee-key"></p><p>如果我们已经有了一个本地的git仓库（例如，一个名为learngit的本地库），如何把它关联到Gitee的远程库上呢？</p><p>首先，我们在Gitee上创建一个新的项目，选择右上角用户头像 -&gt; 菜单“控制面板”，然后点击“创建项目”：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1163453517527296/l" alt="gitee-new-repo"></p><p>项目名称最好与本地库保持一致：</p><p>然后，我们在本地库上使用命令<code>git remote add</code>把它和Gitee的远程库关联：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@gitee.com:liaoxuefeng/learngit.git</span><br></pre></td></tr></table></figure><p>之后，就可以正常地用<code>git push</code>和<code>git pull</code>推送了！</p><p>如果在使用命令<code>git remote add</code>时报错：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@gitee.com:liaoxuefeng/learngit.git</span><br><span class="line"><span class="function">fatal: <span class="title">remote</span> <span class="title">origin</span> <span class="title">already</span> <span class="title">exists</span>.</span></span><br></pre></td></tr></table></figure><p>这说明本地库已经关联了一个名叫<code>origin</code>的远程库，此时，可以先用<code>git remote -v</code>查看远程库信息：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">origingit@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origingit@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure><p>可以看到，本地库已经关联了<code>origin</code>的远程库，并且，该远程库指向GitHub。</p><p>我们可以删除已有的GitHub远程库：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure><p>再关联Gitee的远程库（注意路径中需要填写正确的用户名）：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@gitee.com:liaoxuefeng/learngit.git</span><br></pre></td></tr></table></figure><p>此时，我们再查看远程库信息：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">origingit@gitee.com:liaoxuefeng/learngit.git (fetch)</span><br><span class="line">origingit@gitee.com:liaoxuefeng/learngit.git (push)</span><br></pre></td></tr></table></figure><p>现在可以看到，origin已经被关联到Gitee的远程库了。通过<code>git push</code>命令就可以把本地库推送到Gitee上。</p><p>有的小伙伴又要问了，一个本地库能不能既关联GitHub，又关联Gitee呢？</p><p>答案是肯定的，因为git本身是分布式版本控制系统，可以同步到另外一个远程库，当然也可以同步到另外两个远程库。</p><p>使用多个远程库时，我们要注意，git给远程库起的默认名称是<code>origin</code>，如果有多个远程库，我们需要用不同的名称来标识不同的远程库。</p><p>仍然以<code>learngit</code>本地库为例，我们先删除已关联的名为<code>origin</code>的远程库：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure><p>然后，先关联GitHub的远程库：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add github git@github.com:michaelliao/learngit.git</span><br></pre></td></tr></table></figure><p>注意，远程库的名称叫<code>github</code>，不叫<code>origin</code>了。</p><p>接着，再关联Gitee的远程库：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add gitee git@gitee.com:liaoxuefeng/learngit.git</span><br></pre></td></tr></table></figure><p>同样注意，远程库的名称叫<code>gitee</code>，不叫<code>origin</code>。</p><p>现在，我们用<code>git remote -v</code>查看远程库信息，可以看到两个远程库：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">giteegit@gitee.com:liaoxuefeng/learngit.git (fetch)</span><br><span class="line">giteegit@gitee.com:liaoxuefeng/learngit.git (push)</span><br><span class="line">githubgit@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">githubgit@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure><p>如果要推送到GitHub，使用命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push github master</span><br></pre></td></tr></table></figure><p>如果要推送到Gitee，使用命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push gitee master</span><br></pre></td></tr></table></figure><p>这样一来，我们的本地库就可以同时与多个远程库互相同步：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌─────────┐ ┌─────────┐</span><br><span class="line">│ GitHub  │ │  Gitee  │</span><br><span class="line">└─────────┘ └─────────┘</span><br><span class="line">     ▲           ▲</span><br><span class="line">     └─────┬─────┘</span><br><span class="line">           │</span><br><span class="line">    ┌─────────────┐</span><br><span class="line">    │ Local Repo  │</span><br><span class="line">    └─────────────┘</span><br></pre></td></tr></table></figure><p>Gitee也同样提供了Pull request功能，可以让其他小伙伴参与到开源项目中来。你可以通过Fork我的仓库：<a href="https://gitee.com/liaoxuefeng/learngit?utm_source=blog_lxf" target="_blank" rel="noopener">https://gitee.com/liaoxuefeng/learngit</a>，创建一个<code>your-gitee-id.txt</code>的文本文件， 写点自己学习Git的心得，然后推送一个pull request给我，这个仓库会在Gitee和GitHub做双向同步。</p><h3 id="10-自定义Git"><a href="#10-自定义Git" class="headerlink" title="10.自定义Git"></a>10.自定义Git</h3><p>在<a href="#anzhuang">安装Git</a>一节中，我们已经配置了<code>user.name</code>和<code>user.email</code>，实际上，Git还有很多可配置项。</p><p>比如，让Git显示颜色，会让命令输出看起来更醒目：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global <span class="built_in">color</span>.ui true</span><br></pre></td></tr></table></figure><h4 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h4><p>有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次<code>git status</code>都会显示<code>Untracked files ...</code>，有强迫症的童鞋心里肯定不爽。</p><p>好在Git考虑到了大家的感受，这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的<code>.gitignore</code>文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p><p>不需要从头写<code>.gitignore</code>文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：<a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a></p><p>忽略文件的原则是：</p><ol><li>忽略操作系统自动生成的文件，比如缩略图等；</li><li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的<code>.class</code>文件；</li><li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li></ol><p>举个例子：</p><p>假设你在Windows下进行Python开发，Windows会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有<code>Desktop.ini</code>文件，因此你需要忽略Windows自动生成的垃圾文件：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Windows:</span><br><span class="line">Thumbs.db</span><br><span class="line">ehthumbs.db</span><br><span class="line">Desktop.ini</span><br></pre></td></tr></table></figure><p>然后，继续忽略Python编译产生的<code>.pyc</code>、<code>.pyo</code>、<code>dist</code>等文件或目录：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Python:</span><br><span class="line">*.py[cod]</span><br><span class="line">*.so</span><br><span class="line">*.egg</span><br><span class="line">*.egg-info</span><br><span class="line">dist</span><br><span class="line">build</span><br></pre></td></tr></table></figure><p>加上你自己定义的文件，最终得到一个完整的<code>.gitignore</code>文件，内容如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Windows:</span><br><span class="line">Thumbs.db</span><br><span class="line">ehthumbs.db</span><br><span class="line">Desktop.ini</span><br><span class="line"></span><br><span class="line"># Python:</span><br><span class="line">*.py[cod]</span><br><span class="line">*.so</span><br><span class="line">*.egg</span><br><span class="line">*.egg-info</span><br><span class="line">dist</span><br><span class="line">build</span><br><span class="line"></span><br><span class="line"># My configurations:</span><br><span class="line">db.ini</span><br><span class="line">deploy_key_rsa</span><br></pre></td></tr></table></figure><p>最后一步就是把<code>.gitignore</code>也提交到Git，就完成了！当然检验<code>.gitignore</code>的标准是<code>git status</code>命令是不是说<code>working directory clean</code>。</p><p>使用Windows的童鞋注意了，如果你在资源管理器里新建一个<code>.gitignore</code>文件，它会非常弱智地提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为<code>.gitignore</code>了。</p><p>有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被<code>.gitignore</code>忽略了：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add App.class</span><br><span class="line">The following paths are ignored by one of your .gitignore files:</span><br><span class="line">App.class</span><br><span class="line">Use -f <span class="keyword">if</span> you really want to add them.</span><br></pre></td></tr></table></figure><p>如果你确实想添加该文件，可以用<code>-f</code>强制添加到Git：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add -f App.class</span><br></pre></td></tr></table></figure><p>或者你发现，可能是<code>.gitignore</code>写得有问题，需要找出来到底哪个规则写错了，可以用<code>git check-ignore</code>命令检查：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git check-ignore -v App.class</span><br><span class="line"><span class="function">.gitignore:3:*.<span class="title">class</span><span class="title">App.class</span></span></span><br></pre></td></tr></table></figure><p>Git会告诉我们，<code>.gitignore</code>的第3行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。</p><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><ul><li>忽略某些文件时，需要编写<code>.gitignore</code>；</li><li><code>.gitignore</code>文件本身要放到版本库里，并且可以对<code>.gitignore</code>做版本管理！</li></ul><h4 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h4><p>阅读: 8189585</p><hr><p>有没有经常敲错命令？比如<code>git status</code>？<code>status</code>这个单词真心不好记。</p><p>如果敲<code>git st</code>就表示<code>git status</code>那就简单多了，当然这种偷懒的办法我们是极力赞成的。</p><p>我们只需要敲一行命令，告诉Git，以后<code>st</code>就表示<code>status</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.st status</span><br></pre></td></tr></table></figure><p>好了，现在敲<code>git st</code>看看效果。</p><p>当然还有别的命令可以简写，很多人都用<code>co</code>表示<code>checkout</code>，<code>ci</code>表示<code>commit</code>，<code>br</code>表示<code>branch</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.co checkout</span><br><span class="line">$ git config --global alias.ci commit</span><br><span class="line">$ git config --global alias.br branch</span><br></pre></td></tr></table></figure><p>以后提交就可以简写成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git ci -m &quot;bala bala bala...&quot;</span><br></pre></td></tr></table></figure><p><code>--global</code>参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。</p><p>在<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897889638509536" target="_blank" rel="noopener">撤销修改</a>一节中，我们知道，命令<code>git reset HEAD file</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个<code>unstage</code>别名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.unstage &#39;reset HEAD&#39;</span><br></pre></td></tr></table></figure><p>当你敲入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git unstage test.py</span><br></pre></td></tr></table></figure><p>实际上Git执行的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD test.py</span><br></pre></td></tr></table></figure><p>配置一个<code>git last</code>，让其显示最后一次提交信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.last &#39;log -1&#39;</span><br></pre></td></tr></table></figure><p>这样，用<code>git last</code>就能显示最近一次的提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git last</span><br><span class="line">commit adca45d317e6d8a4b23f9811c3d7b7f0f180bfe2</span><br><span class="line">Merge: bd6ae48 291bea8</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Thu Aug 22 22:49:22 2013 +0800</span><br><span class="line"></span><br><span class="line">    merge &amp; fix hello.py</span><br></pre></td></tr></table></figure><p>甚至还有人丧心病狂地把<code>lg</code>配置成了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.lg &quot;log --color --graph --pretty&#x3D;format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;</span><br></pre></td></tr></table></figure><p>来看看<code>git lg</code>的效果：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919059728302912/0" alt="git-lg"></p><p>为什么不早点告诉我？别激动，咱不是为了多记几个英文单词嘛！</p><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><p>配置Git的时候，加上<code>--global</code>是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。</p><p>配置文件放哪了？每个仓库的Git配置文件都放在<code>.git/config</code>文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git&#x2F;config </span><br><span class="line">[core]</span><br><span class="line">    repositoryformatversion &#x3D; 0</span><br><span class="line">    filemode &#x3D; true</span><br><span class="line">    bare &#x3D; false</span><br><span class="line">    logallrefupdates &#x3D; true</span><br><span class="line">    ignorecase &#x3D; true</span><br><span class="line">    precomposeunicode &#x3D; true</span><br><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">    url &#x3D; git@github.com:michaelliao&#x2F;learngit.git</span><br><span class="line">    fetch &#x3D; +refs&#x2F;heads&#x2F;*:refs&#x2F;remotes&#x2F;origin&#x2F;*</span><br><span class="line">[branch &quot;master&quot;]</span><br><span class="line">    remote &#x3D; origin</span><br><span class="line">    merge &#x3D; refs&#x2F;heads&#x2F;master</span><br><span class="line">[alias]</span><br><span class="line">    last &#x3D; log -1</span><br></pre></td></tr></table></figure><p>别名就在<code>[alias]</code>后面，要删除别名，直接把对应的行删掉即可。</p><p>而当前用户的Git配置文件放在用户主目录下的一个隐藏文件<code>.gitconfig</code>中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat .gitconfig</span><br><span class="line">[alias]</span><br><span class="line">    co &#x3D; checkout</span><br><span class="line">    ci &#x3D; commit</span><br><span class="line">    br &#x3D; branch</span><br><span class="line">    st &#x3D; status</span><br><span class="line">[user]</span><br><span class="line">    name &#x3D; Your Name</span><br><span class="line">    email &#x3D; your@email.com</span><br></pre></td></tr></table></figure><p>配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。</p><h5 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h5><p>给Git配置好别名，就可以输入命令时偷个懒。我们鼓励偷懒。</p><h4 id="搭建Git服务器"><a href="#搭建Git服务器" class="headerlink" title="搭建Git服务器"></a>搭建Git服务器</h4><p>阅读: 45444012</p><hr><p>在<a href="https://www.liaoxuefeng.com/wiki/896043488029600/896954117292416" target="_blank" rel="noopener">远程仓库</a>一节中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了7x24小时开机并交换大家的修改。</p><p>GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。</p><p>搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的<code>apt</code>命令就可以完成安装。</p><p>假设你已经有<code>sudo</code>权限的用户账号，下面，正式开始安装。</p><p>第一步，安装<code>git</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install git</span><br></pre></td></tr></table></figure><p>第二步，创建一个<code>git</code>用户，用来运行<code>git</code>服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo adduser git</span><br></pre></td></tr></table></figure><p>第三步，创建证书登录：</p><p>收集所有需要登录的用户的公钥，就是他们自己的<code>id_rsa.pub</code>文件，把所有公钥导入到<code>/home/git/.ssh/authorized_keys</code>文件里，一行一个。</p><p>第四步，初始化Git仓库：</p><p>先选定一个目录作为Git仓库，假定是<code>/srv/sample.git</code>，在<code>/srv</code>目录下输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo git init --bare sample.git</span><br></pre></td></tr></table></figure><p>Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以<code>.git</code>结尾。然后，把owner改为<code>git</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown -R git:git sample.git</span><br></pre></td></tr></table></figure><p>第五步，禁用shell登录：</p><p>出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑<code>/etc/passwd</code>文件完成。找到类似下面的一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:x:1001:1001:,,,:&#x2F;home&#x2F;git:&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:x:1001:1001:,,,:&#x2F;home&#x2F;git:&#x2F;usr&#x2F;bin&#x2F;git-shell</span><br></pre></td></tr></table></figure><p>这样，<code>git</code>用户可以正常通过ssh使用git，但无法登录shell，因为我们为<code>git</code>用户指定的<code>git-shell</code>每次一登录就自动退出。</p><p>第六步，克隆远程仓库：</p><p>现在，可以通过<code>git clone</code>命令克隆远程仓库了，在各自的电脑上运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@server:&#x2F;srv&#x2F;sample.git</span><br><span class="line">Cloning into &#39;sample&#39;...</span><br><span class="line">warning: You appear to have cloned an empty repository.</span><br></pre></td></tr></table></figure><p>剩下的推送就简单了。</p><h5 id="管理公钥"><a href="#管理公钥" class="headerlink" title="管理公钥"></a>管理公钥</h5><p>如果团队很小，把每个人的公钥收集起来放到服务器的<code>/home/git/.ssh/authorized_keys</code>文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用<a href="https://github.com/res0nat0r/gitosis" target="_blank" rel="noopener">Gitosis</a>来管理公钥。</p><p>这里我们不介绍怎么玩<a href="https://github.com/res0nat0r/gitosis" target="_blank" rel="noopener">Gitosis</a>了，几百号人的团队基本都在500强了，相信找个高水平的Linux管理员问题不大。</p><h5 id="管理权限"><a href="#管理权限" class="headerlink" title="管理权限"></a>管理权限</h5><p>有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。<a href="https://github.com/sitaramc/gitolite" target="_blank" rel="noopener">Gitolite</a>就是这个工具。</p><p>这里我们也不介绍<a href="https://github.com/sitaramc/gitolite" target="_blank" rel="noopener">Gitolite</a>了，不要把有限的生命浪费到权限斗争中。</p><h5 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h5><ul><li>搭建Git服务器非常简单，通常10分钟即可完成；</li><li>要方便管理公钥，用<a href="https://github.com/res0nat0r/gitosis" target="_blank" rel="noopener">Gitosis</a>；</li><li>要像SVN那样变态地控制权限，用<a href="https://github.com/sitaramc/gitolite" target="_blank" rel="noopener">Gitolite</a>。</li></ul><h3 id="使用SourceTree"><a href="#使用SourceTree" class="headerlink" title="使用SourceTree"></a>使用SourceTree</h3><p>当我们对Git的提交、分支已经非常熟悉，可以熟练使用命令操作Git后，再使用GUI工具，就可以更高效。</p><p>Git有很多图形界面工具，这里我们推荐<a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">SourceTree</a>，它是由<a href="https://www.atlassian.com/" target="_blank" rel="noopener">Atlassian</a>开发的免费Git图形界面工具，可以操作任何Git库。</p><p>首先从<a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">官网</a>下载SourceTree并安装，然后直接运行SourceTree。</p><p>第一次运行SourceTree时，SourceTree并不知道我们的Git库在哪。如果本地已经有了Git库，直接从资源管理器把文件夹拖拽到SourceTree上，就添加了一个本地Git库：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1317162822139970/l" alt="add-local-repo"></p><p>也可以选择“New”-“Clone from URL”直接从远程克隆到本地。</p><h4 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h4><p>我们双击<code>learngit</code>这个本地库，SourceTree会打开另一个窗口，展示这个Git库的当前所有分支以及文件状态。选择左侧面板的“WORKSPACE”-“File status”，右侧会列出当前已修改的文件（Unstaged files）：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1317163279319106/l" alt="unstaged"></p><p>选中某个文件，该文件就自动添加到“Staged files”，实际上是执行了<code>git add README.md</code>命令：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1317163629543489/l" alt="add"></p><p>然后，我们在下方输入Commit描述，点击“Commit”，就完成了一个本地提交：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1317163717623874/l" alt="commit"></p><p>实际上是执行了<code>git commit -m &quot;update README.md&quot;</code>命令。</p><p>使用SourceTree进行提交就是这么简单，它的优势在于可以可视化地观察文件的修改，并以红色和绿色高亮显示。</p><h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><p>在左侧面板的“BRANCHES”下，列出了当前本地库的所有分支。当前分支会加粗并用○标记。要切换分支，我们只需要选择该分支，例如<code>master</code>，然后点击右键，在弹出菜单中选择“Checkout master”，实际上是执行命令<code>git checkout master</code>：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1317164906709058/l" alt="checkout"></p><p>要合并分支，同样选择待合并分支，例如<code>dev</code>，然后点击右键，在弹出菜单中选择“Merge dev into master”，实际上是执行命令<code>git merge dev</code>：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1317165154172993/l" alt="merge-dev-into-master"></p><h4 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h4><p>在SourceTree的工具栏上，分别有<code>Pull</code>和<code>Push</code>，分别对应命令<code>git pull</code>和<code>git push</code>，只需注意本地和远程分支的名称要对应起来，使用时十分简单。</p><p>注意到使用SourceTree时，我们只是省下了敲命令的麻烦，SourceTree本身还是通过Git命令来执行任何操作。如果操作失败，SourceTree会自动显示执行的Git命令以及错误信息，我们可以通过Git返回的错误信息知道出错的原因：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/1317166563459138/l" alt="push-error"></p><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>使用SourceTree可以以图形界面操作Git，省去了敲命令的过程，对于常用的提交、分支、推送等操作来说非常方便。</p><p>SourceTree使用Git命令执行操作，出错时，仍然需要阅读Git命令返回的错误信息。</p><p>终于到了期末总结的时刻了！</p><p>经过几天的学习，相信你对Git已经初步掌握。一开始，可能觉得Git上手比较困难，尤其是已经熟悉SVN的童鞋，没关系，多操练几次，就会越用越顺手。</p><p>Git虽然极其强大，命令繁多，但常用的就那么十来个，掌握好这十几个常用命令，你已经可以得心应手地使用Git了。</p><p>友情附赠国外网友制作的Git Cheat Sheet，建议打印出来备用：</p><p><a href="https://gitee.com/liaoxuefeng/learn-java/raw/master/teach/git-cheatsheet.pdf" target="_blank" rel="noopener">Git Cheat Sheet</a></p><p>现在告诉你Git的官方网站：<a href="http://git-scm.com/" target="_blank" rel="noopener">http://git-scm.com</a>，英文自我感觉不错的童鞋，可以经常去官网看看。什么，打不开网站？相信我，我给出的绝对是官网地址，而且，Git官网决没有那么容易宕机，可能是你的人品问题，赶紧面壁思过，好好想想原因。</p><p>如果你学了Git后，工作效率大增，有更多的空闲时间健身看电影，那我的教学目标就达到了。</p><p>谢谢观看！</p>]]></content>
      
      
      <categories>
          
          <category> Computer Science </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> git家族 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello,My personal Blog!个人博客搭建总结</title>
      <link href="2021/01/29/hello-myblog/"/>
      <url>2021/01/29/hello-myblog/</url>
      
        <content type="html"><![CDATA[<p>经过了好几天的摸索，终于大概部署好了个人博客，之后会把所学的一些CS知识技术整理成笔记记录在这里，欢迎大家时不时来踩一踩！</p><p>这篇博客主要是关于个人博客搭建和更新方法的笔记，怕之后忘了所以赶紧记一下。目前博客仅仅是实现了基本功能，之后可能会视情况设置一下评论区，点赞，社交等功能。</p><a id="more"></a><h3 id="个人博客搭建总结"><a href="#个人博客搭建总结" class="headerlink" title="个人博客搭建总结"></a>个人博客搭建总结</h3><h4 id="Jekyll"><a href="#Jekyll" class="headerlink" title="Jekyll"></a>Jekyll</h4><p>这段时间为了搭建一下自己的博客尝试了两种方式，一种是基于<code>Jekyll</code>的，这种方式比较简单，但是有时过于简单了，之前试过用一个cayman的主题，但由于本人太菜，这个模板需要配置太多，只好放弃了，改用hexo搭建。如果想用<code>Jekyll</code>的可以参考这个网站：<a href="http://jekyllcn.com/" target="_blank" rel="noopener">http://jekyllcn.com/</a> ，此站目标是<strong>成为 Jekyll 的全面指南</strong>，内容详细，值得看一看。</p><h4 id="hexo搭建大致流程"><a href="#hexo搭建大致流程" class="headerlink" title="hexo搭建大致流程"></a>hexo搭建大致流程</h4><p>大致参考了以下几篇博客</p><p><a href="https://blog.csdn.net/jinxiaonian11/article/details/82900119（这个作者有两篇这方面的博客，讲的挺详细的）" target="_blank" rel="noopener">https://blog.csdn.net/jinxiaonian11/article/details/82900119（这个作者有两篇这方面的博客，讲的挺详细的）</a></p><p><a href="https://blog.csdn.net/qq_37210523/article/details/80909983" target="_blank" rel="noopener">https://blog.csdn.net/qq_37210523/article/details/80909983</a></p><ol><li><p>选好一个空文件夹，最好不要有中文路径，之后用bash cd到这个路径下，继续下面的操作。</p></li><li><p>安装配置好node.js（node.js下载地址：<a href="https://nodejs.org/en/download/），hexo" target="_blank" rel="noopener">https://nodejs.org/en/download/），hexo</a> (<code>npm install hexo -g</code>)。</p><p>npm安装hexo时可能会出问题，更换一下镜像就好了。（如：<code>npm config set registry http://registry.npm.taobao.org</code></p></li><li><p>安装必要的组件：<code>npm install</code>，之后输入处理命令 <code>hexo g</code>   并开启服务器<code>hexo s</code> 出现了能够打开本地网页的提示（这个打开和那个线上的是一样的效果）就说明已经成功了，之后<code>ctrl+C</code>退出继续下面步骤</p></li><li><p>在github上新增仓库，命名为: username.github.io，并在本地的根目录下的 _config.yml 文件中的<strong>Deployment</strong>设置处，添加以下代码，<strong>repo</strong>和<strong>branch</strong>根据自己情况修改</p></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:BUAADreamer/BUAADreamer.github.io.git</span> </span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><ol><li><p>之后选好主题，并利用作者提供的方式git clone到本地theme文件夹下即可，并在根目录下的)_config.yml改一下theme设置，很多人推荐next，我的这个用的是ocean，也看到有同学用的黄玄大神的<a href="https://huangxuan.me/" target="_blank" rel="noopener">https://huangxuan.me/</a>  </p><p>然后创建博客：<code>hexo new blog-name</code>，之后一行代码部署到github上即可：<code>hexo d -g</code>，再打开自己的网站：username.github.io即可看到了！</p></li><li><p>后续配置，这个每个主题都有区别，去github上看作者的文档就行。可以添加很多功能。下面记录一下常用的几个tips和资源</p><ul><li><p>修改文章：直接修改之后用hexo d- g就可以完成push的操作。</p></li><li><p>设置摘要：使用<code>&lt;!--more--&gt;</code>标签设置摘要。这样在index页只会展示这行代码之前的文字</p></li><li><p>hexo官方中文文档：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></p></li></ul></li></ol><h4 id="问题和个人用法总结"><a href="#问题和个人用法总结" class="headerlink" title="问题和个人用法总结"></a>问题和个人用法总结</h4><ol><li>图片用的腾讯云对象存储</li><li>md文件配置时一定是类似<code>tags: 123</code>这样的格式。<code>tags</code>和<code>123</code>之间<strong>一定要有空格</strong>！！！</li></ol><h4 id="评论功能"><a href="#评论功能" class="headerlink" title="评论功能"></a>评论功能</h4><p>我的博客使用的<code>Utterances</code>，配置非常简单，并且也比较安全简洁。</p><p>可以参考这篇文章：<a href="https://roife.github.io/2021/02/12/use-utterances-for-comment/" target="_blank" rel="noopener">https://roife.github.io/2021/02/12/use-utterances-for-comment/</a></p><p>其他的还有<code>Gitalk</code>,<code>Valine</code>，也可以用，但是<code>Gitalk</code>配置麻烦且很容易挂，后者貌似需要花钱。</p><h4 id="更换代理"><a href="#更换代理" class="headerlink" title="更换代理"></a>更换代理</h4><p>同时参考下面这<strong>两篇</strong>文章，因为都有些不全面。记得要实名认证+获取证书+域名解析</p><p><a href="https://blog.csdn.net/obsession753/article/details/84110360" target="_blank" rel="noopener">https://blog.csdn.net/obsession753/article/details/84110360</a></p><p><a href="https://blog.csdn.net/i042416/article/details/89926005" target="_blank" rel="noopener">https://blog.csdn.net/i042416/article/details/89926005</a></p><h4 id="2021-4-24"><a href="#2021-4-24" class="headerlink" title="2021.4.24"></a>2021.4.24</h4><p>更换了主题，换成了感觉更美观的huxblog主题</p><p>更换过程很简单，只需要到<a href="https://github.com/Kaijun/hexo-theme-huxblog" target="_blank" rel="noopener">https://github.com/Kaijun/hexo-theme-huxblog</a> 这个网站下载代码，之后将themes里的huxblog文件夹copy到你自己的themes目录下，然后在根目录下的_config.xml修改themes名字为huxblog即可。</p><h4 id="2021-4-25"><a href="#2021-4-25" class="headerlink" title="2021.4.25"></a>2021.4.25</h4><p>调换过程很简单，但是由于hexo版的黄玄主题作者已经不维护了，出现了各式各样的问题，于是决定换成长得差不多的snail主题，这个主题作者给了详细的说明文档。<a href="https://github.com/dusign/hexo-theme-snail" target="_blank" rel="noopener">https://github.com/dusign/hexo-theme-snail</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hello my blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Theme-Snail</title>
      <link href="2019/11/01/Hexo-Theme-Snail/"/>
      <url>2019/11/01/Hexo-Theme-Snail/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-theme-snail"><a href="#hexo-theme-snail" class="headerlink" title="hexo-theme-snail"></a>hexo-theme-snail</h1><p><a href="https://github.com/dusign/hexo-theme-snail" target="_blank" rel="noopener">View Hexo-Theme-Snail Sources On Github &#10174; </a></p><p><a href="https://www.dusign.net" target="_blank" rel="noopener">View Live Super Snail Blog &#10174;</a></p><p><img src="snail.png" alt="hexo-theme-snail"></p><p>Hexo-theme-snail is a succinct hexo theme. It has two colors, light and star, that can be set according to your own preferences in the settings, and also has the functions of sharing and commenting. More features are under development.</p><h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ul><li>light color theme and star theme</li><li>diversified comment system</li><li>notice tips</li><li>share to other platforms (under development)</li><li>picture sharing (under development)</li></ul><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Install-Hexo"><a href="#Install-Hexo" class="headerlink" title="Install Hexo"></a>Install Hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h3 id="Setup-your-blog"><a href="#Setup-your-blog" class="headerlink" title="Setup your blog"></a>Setup your blog</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init blog</span><br></pre></td></tr></table></figure><h3 id="Installation-Theme"><a href="#Installation-Theme" class="headerlink" title="Installation Theme"></a>Installation Theme</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ rm -rf <span class="built_in">source</span></span><br><span class="line">$ rm _config.yml package.json README.md LICENSE</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/dusign/hexo-theme-snail.git</span><br><span class="line">$ mv ./hexo-theme-snail/snail ./themes</span><br><span class="line">$ mv ./hexo-theme-snail/* ./</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><h3 id="Set-Theme"><a href="#Set-Theme" class="headerlink" title="Set Theme"></a>Set Theme</h3><p>Modify the value of <code>theme:</code> in <code>_config.yml</code><br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">snail</span></span><br></pre></td></tr></table></figure></p><h3 id="Start-the-Server"><a href="#Start-the-Server" class="headerlink" title="Start the Server"></a>Start the Server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><h3 id="Site"><a href="#Site" class="headerlink" title="Site"></a>Site</h3><p>Replace the following information with your own.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> </span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">At</span> <span class="string">the</span> <span class="string">bottom</span> <span class="string">of</span> <span class="string">the</span> <span class="string">well,</span> <span class="string">it</span> <span class="string">is</span> <span class="string">destined</span> <span class="string">to</span> <span class="string">see</span> <span class="string">only</span> <span class="string">the</span> <span class="string">sky</span> <span class="string">at</span> <span class="string">the</span> <span class="string">wellhead.</span> </span><br><span class="line">          <span class="string">However,</span> <span class="string">the</span> <span class="string">starting</span> <span class="string">point</span> <span class="string">only</span> <span class="string">affects</span> <span class="string">the</span> <span class="string">process</span> <span class="string">of</span> <span class="string">reaching</span> <span class="string">your</span> <span class="string">peak</span> <span class="string">and</span> <span class="string">does</span> <span class="string">not</span> <span class="string">determine</span> <span class="string">the</span> <span class="string">height</span> <span class="string">you</span> <span class="string">reach.</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Dusign</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">en</span></span><br><span class="line"><span class="attr">timezone:</span></span><br></pre></td></tr></table></figure></p><h3 id="Site-Settings"><a href="#Site-Settings" class="headerlink" title="Site Settings"></a>Site Settings</h3><p>Put customized pictures in <code>img</code> directory.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site settings</span></span><br><span class="line"><span class="attr">SEOTitle:</span> <span class="string">Hexo-theme-snail</span></span><br><span class="line"><span class="attr">email:</span> <span class="string">hexo-theme-snail@mail.com</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">"A hexo theme"</span></span><br><span class="line"><span class="attr">keyword:</span> <span class="string">"dusign, hexo-theme-snail"</span></span><br><span class="line"><span class="attr">header-img:</span> <span class="string">img/header_img/home-bg-1-dark.jpg</span></span><br><span class="line"><span class="attr">signature:</span> <span class="literal">true</span> <span class="comment">#show signature</span></span><br><span class="line"><span class="attr">signature-img:</span> <span class="string">img/signature/Just-do-it-white.png</span></span><br></pre></td></tr></table></figure></p><h3 id="SNS-Settings"><a href="#SNS-Settings" class="headerlink" title="SNS Settings"></a>SNS Settings</h3><p>If you don’t want to display it, you can delete it directly.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SNS settings</span></span><br><span class="line"><span class="attr">github_username:</span>    <span class="string">dusign</span></span><br><span class="line"><span class="attr">twitter_username:</span>   <span class="string">dusignr</span></span><br><span class="line"><span class="attr">facebook_username:</span>  <span class="string">Gang</span> <span class="string">Du</span></span><br><span class="line"><span class="attr">zhihu_username:</span> <span class="string">dusignr</span></span><br></pre></td></tr></table></figure></p><h3 id="Sidebar-Settings"><a href="#Sidebar-Settings" class="headerlink" title="Sidebar Settings"></a>Sidebar Settings</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sidebar Settings</span></span><br><span class="line"><span class="attr">sidebar:</span> <span class="literal">true</span>                      <span class="comment"># whether or not using Sidebar.</span></span><br><span class="line"><span class="attr">sidebar-about-description:</span> <span class="string">"Welcome to visit, I'm Dusign!"</span></span><br><span class="line"><span class="attr">sidebar-avatar:</span> <span class="string">img/ironman-draw.png</span>      <span class="comment"># use absolute URL, seeing it's used in both `/` and `/about/`</span></span><br><span class="line"><span class="attr">widgets:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">featured-tags</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">short-about</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">recent-posts</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">friends-blog</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">archive</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">category</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># widget behavior</span></span><br><span class="line"><span class="comment">## Archive</span></span><br><span class="line"><span class="attr">archive_type:</span> <span class="string">'monthly'</span></span><br><span class="line"><span class="attr">show_count:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## Featured Tags</span></span><br><span class="line"><span class="attr">featured-tags:</span> <span class="literal">true</span>                     <span class="comment"># whether or not using Feature-Tags</span></span><br><span class="line"><span class="attr">featured-condition-size:</span> <span class="number">1</span>              <span class="comment"># A tag will be featured if the size of it is more than this condition value</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## Friends</span></span><br><span class="line"><span class="attr">friends:</span> <span class="string">[</span></span><br><span class="line">    <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">"Dusign's Blog"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span> <span class="string">"https://blog.csdn.net/d_Nail"</span></span><br><span class="line">    <span class="string">&#125;,&#123;</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">"Dusign's Web"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span> <span class="string">"#"</span></span><br><span class="line">    <span class="string">&#125;,&#123;</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">"Dusign's Github"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span> <span class="string">"https://github.com/dusign"</span></span><br><span class="line">    <span class="string">&#125;,&#123;</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">"Other"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span> <span class="string">"#"</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br></pre></td></tr></table></figure><h3 id="Theme"><a href="#Theme" class="headerlink" title="Theme"></a>Theme</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">snail</span></span><br></pre></td></tr></table></figure><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">      <span class="attr">github:</span> <span class="string">github.repository.address</span></span><br><span class="line">      <span class="attr">coding:</span> <span class="string">coding.repository.address</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><h3 id="Comment"><a href="#Comment" class="headerlink" title="Comment"></a>Comment</h3><p>See httpymls://github.com/imsun/gitment for detailed configuration method.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Comment</span></span><br><span class="line"><span class="comment">## This comment system is gitment</span></span><br><span class="line"><span class="comment">## gitment url: https://github.com/imsun/gitment</span></span><br><span class="line"><span class="attr">comment:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">owner:</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">  <span class="attr">client_id:</span></span><br><span class="line">  <span class="attr">client_secret:</span></span><br></pre></td></tr></table></figure></p><h3 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Tip</span></span><br><span class="line"><span class="attr">tip:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">content:</span> <span class="string">欢迎访问</span> <span class="string">&lt;a</span> <span class="string">href="https://www.dusign.net"</span> <span class="string">target="dusign"&gt;dusign&lt;/a&gt;</span> <span class="string">的博客，博客系统一键分享的功能还在完善中，请大家耐心等待。</span></span><br><span class="line">          <span class="string">若有问题或者有好的建议欢迎留言，笔者看到之后会及时回复。</span></span><br><span class="line">          <span class="string">评论点赞需要github账号登录，如果没有账号的话请点击</span> </span><br><span class="line">          <span class="string">&lt;a</span> <span class="string">href="https://github.com"</span> <span class="string">target="view_window"</span> <span class="string">&gt;</span> <span class="string">github</span> <span class="string">&lt;/a&gt;</span> <span class="string">注册，</span> <span class="string">谢谢</span> <span class="string">!</span></span><br></pre></td></tr></table></figure><h3 id="Color-Sheme"><a href="#Color-Sheme" class="headerlink" title="Color Sheme"></a>Color Sheme</h3><p>Set the <code>enable</code> value of the desired color sheme to <code>true</code>. If the value of <code>bg_effects.star.enable</code> is <code>true</code>, please modify the value of <code>highlight_theme</code> in <code>./themes/snail/_config.yml</code> to <code>night</code>.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Color Sheme</span></span><br><span class="line"><span class="comment">## If there is no effect after modification, please empty the cache and try again.</span></span><br><span class="line"><span class="comment">## ⚠️ The following special effects will take up a lot of cpu resorces, please open it carefully.</span></span><br><span class="line"><span class="attr">bg_effects:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">color:</span> <span class="number">129</span><span class="string">,200,61</span></span><br><span class="line">    <span class="attr">pointColor:</span> <span class="number">129</span><span class="string">,200,61</span></span><br><span class="line">    <span class="attr">opacity:</span> <span class="number">0.7</span></span><br><span class="line">    <span class="attr">zIndex:</span> <span class="number">-9</span></span><br><span class="line">    <span class="attr">count:</span> <span class="number">99</span></span><br><span class="line">  <span class="attr">mouse_click:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">content:</span> <span class="string">'"🌱","just do it","🌾","🍀","don'</span><span class="string">'t give up","🍂","🌻","try it again","🍃","never say die","🌵","🌿","🌴"'</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">'"rgb(121,93,179)"</span></span><br><span class="line"><span class="string">          ,"rgb(76,180,231)"</span></span><br><span class="line"><span class="string">          ,"rgb(184,90,154)"</span></span><br><span class="line"><span class="string">          ,"rgb(157,211,250)"</span></span><br><span class="line"><span class="string">          ,"rgb(255,0,0)"</span></span><br><span class="line"><span class="string">          ,"rgb(242,153,29)"</span></span><br><span class="line"><span class="string">          ,"rgb(23,204,16)"</span></span><br><span class="line"><span class="string">          ,"rgb(222,0,0)"</span></span><br><span class="line"><span class="string">          ,"rgb(22,36,92)"</span></span><br><span class="line"><span class="string">          ,"rgb(127,24,116)"</span></span><br><span class="line"><span class="string">          ,"rgb(119,195,79)"</span></span><br><span class="line"><span class="string">          ,"rgb(4,77,34)"</span></span><br><span class="line"><span class="string">          ,"rgb(122,2,60)"'</span></span><br><span class="line">  <span class="attr">star:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><h2 id="Releases"><a href="#Releases" class="headerlink" title="Releases"></a>Releases</h2><p>V1.0</p><ul><li>fix the bugs</li><li>add comment system</li><li>add notice tips</li><li>add star sheme</li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>Apache License 2.0 Copyright(c) 2018-2020 <a href="https://github.com/dusign" target="_blank" rel="noopener">Dusign</a>   </p><p><a href="https://github.com/dusign/hexo-theme-snail" target="_blank" rel="noopener">hexo-theme-snail</a> is derived from <a href="https://github.com/Huxpro/huxpro.github.io" target="_blank" rel="noopener">Huxpro</a> Apache License 2.0. Copyright (c) 2015-2020 Huxpro</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo-theme-snail </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
