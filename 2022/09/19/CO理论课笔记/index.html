<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="baidu-site-verification" content="093lY4ziMu" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="description" content="A hexo theme">
    <meta name="keyword"  content="BUAADreamer, hexo-theme-snail">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <!--<link href='http://fonts.googleapis.com/css?family=Montserrat:400,700' rel='stylesheet' type='text/css'>-->
    <title>
        
          计算机组成理论复习 - BUAADreamer&#39;s Blog
        
    </title>

    <link rel="canonical" href="https://BUAADreamer.top/2022/09/19/CO理论课笔记/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS --> 
    
        
<link rel="stylesheet" href="/css/dusign-light.css">

        
<link rel="stylesheet" href="/css/dusign-common-light.css">

        
<link rel="stylesheet" href="/css/font-awesome.css">

        
<link rel="stylesheet" href="/css/toc.css">

        <!-- background effects end -->
    
    
    <!-- Pygments Highlight CSS -->
    
<link rel="stylesheet" href="/css/highlight.css">


    
<link rel="stylesheet" href="/css/widget.css">


    
<link rel="stylesheet" href="/css/rocket.css">


    
<link rel="stylesheet" href="/css/signature.css">


    
<link rel="stylesheet" href="/css/fonts.googleapis.css">


    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <!-- photography -->
    
<link rel="stylesheet" href="/css/photography.css">


    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- background effects start -->
    
    <!-- background effects end -->

	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            
                background-image: linear-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3)), url('../../../../img/default.jpg')
                /*post*/
            
        
    }
    
    #signature{
        background-image: url('/img/signature/dusign.png');
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#BUAA-CO-2020" title="BUAA-CO-2020">BUAA-CO-2020</a>
                            
                        </div>
                        <h1>计算机组成理论复习</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by BUAADreamer on
                            2022-09-19
                        </span>

                        
                            <div class="blank_box"></div>
                            <span class="meta">
                                Words <span class="post-count">10.7k</span> and
                                Reading Time <span class="post-count">39</span> Minutes
                            </span>
                            <div class="blank_box"></div>
                            <!-- 不蒜子统计 start -->
                            <span class="meta">
                                Viewed <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span> Times
                            </span>
                            <!-- 不蒜子统计 end -->
                        

                    </div>
                

                </div>
            </div>
        </div>      
    </div>

    
    <div class="waveWrapper">
        <div class="wave wave_before" style="background-image: url('/img/wave-light.png')"></div>
        <div class="wave wave_after" style="background-image: url('/img/wave-light.png')"></div>
    </div>
    
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">BUAADreamer&#39;s Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/categories/">Categories</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/photography/">Photography</a>
                        </li>
                        
                    
                    
                    
                    <li>
                        <a href="https://www.cnblogs.com/BUAADreamer/" target="_blank">Chinese Blog</a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            
            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h1><span id="理论课学习刘旭东老师">理论课学习——刘旭东老师</span></h1>
<h2><span id="第一讲概述">第一讲：概述</span></h2>
<h3><span id="一计算机组成与结构简介">一.计算机组成与结构简介</span></h3>
<h4><span id="11-计算机的基本组成">1.1 计算机的基本组成</span></h4>
<ol>
<li>硬件（Hardware）计算机的物理部分，可以实现计算机最基本的操作行为。</li>
<li>软件（Software）使计算机实现各种功能的程序集合。包括系统软件、应用软件两大类。</li>
</ol>
<h5><span id="计算机的功能">计算机的功能</span></h5>
<ul>
<li>Data Processing (数据处理)</li>
<li>Data Storage （数据存储）</li>
<li>Data Movement （数据移动，交换）</li>
<li>Control （控制）</li>
<li>计算机的功能结构图</li>
</ul>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/计算机体系结构图.png" style="zoom:50%;">
<h5><span id="运算器实现数据处理的部件">运算器：实现数据处理的部件</span></h5>
<ul>
<li>完成最基本的算术逻辑运算</li>
<li>ALU (Arithmetic and Logic Unit） ＋ Registers</li>
<li><strong>运算器与机器字长（字的概念）的关系(电脑操作系统的位数)</strong></li>
<li>运算器与机器性能指标：MIPS：Millions of Instructuions Per Second</li>
<li>简单运算器结构图</li>
</ul>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/简单运算器结构图.png" style="zoom:50%;">
<h5><span id="存储器实现数据存储的部件">存储器：实现数据存储的部件</span></h5>
<ol>
<li>保存程序和数据（二进制信息）</li>
<li><strong>存储单元：bit, Byte, Word</strong></li>
</ol>
<p>1Byte(字节 <strong>B</strong>)=8bit(位 <strong>b</strong>)</p>
<p>1word(字)=本电脑操作系统的位数</p>
<p>$1KB=2<sup>{10}B=2</sup>{10+3}bit$</p>
<ol start="3">
<li>
<p>地址的概念：每一个字节单元拥有一个<strong>唯一的地址</strong>（索引）</p>
</li>
<li>
<p>存储器的工作方式：读、写</p>
</li>
<li>
<p>存储器结构简图</p>
</li>
</ol>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/存储器结构简图.png" style="zoom:50%;">
<h5><span id="控制器实现控制功能的部件">控制器：实现控制功能的部件</span></h5>
<ul>
<li>供各部件工作所需的控制信号，控制计算机其他部件协同工作</li>
<li>指令部件（Instruction Register ，Instruction Decoder）</li>
<li>指令顺序控制（Program Counter）</li>
<li>时序逻辑部件（Clock，Timer ，Sequencing Logic）</li>
<li>控制信号生成部件（Control Signal Generator or Control Memory）</li>
<li>Datapath ＋Control ＝CPU（Central Process Unit）or Processor</li>
<li>控制器结构简图</li>
</ul>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/控制器结构简图.png" style="zoom:50%;">
<h5><span id="输入输出实现数据交换的部件">输入输出：实现数据交换的部件</span></h5>
<ul>
<li>实现计算机内部与外界（其他系统或人类）的信息交换</li>
<li>实现数据交换的设备：输入设备、输出设备</li>
<li>接口标准与接口部件</li>
<li>计算机结构简图</li>
</ul>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/计算机结构简图.png" style="zoom:67%;">
<h5><span id="冯诺依曼体系ias该机结构被公认为随后发展起来的通用计算机的原型">冯·诺依曼体系——IAS——该机结构被公认为随后发展起来的通用计算机的原型</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/IAS.png" style="zoom:50%;">
<h5><span id="普通pcpentium的内部结构多总线结构">普通PC（Pentium）的内部结构（多总线结构）</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/普通PC（Pentium）的内部结构（多总线结构）.png" style="zoom:50%;">
<h4><span id="12-计算机系统层次结构">1.2 计算机系统层次结构</span></h4>
<h5><span id="计算机的层次结构的演变">计算机的层次结构的演变</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/计算机的层次结构的演变.png" style="zoom:50%;">
<p><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/1.png" style="zoom:50%;"><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.png" style="zoom:50%;"></p>
<h5><span id="isa">ISA</span></h5>
<p>指令集体系架构，一种规约（Specification），规定了软件如何使用硬件，是对硬件结构和功能的最底层抽象，解决了最基本的软件兼容性问题。每一种广泛采用的指令集背后都有一个强大的生态系统，比如<strong>X86指令集架构</strong>和<strong>ARM指令集架构</strong>。</p>
<h3><span id="二计算机中数的表示的基本问题">二.计算机中数的表示的基本问题</span></h3>
<h4><span id="无符号数和有符号数">无符号数和有符号数</span></h4>
<h5><span id="无符号数">无符号数</span></h5>
<ul>
<li>数的编码中所有位均为数值位，<strong>没有符号位</strong></li>
<li>只能表示 &gt;=0 的正整数</li>
<li>N位无符号数的表示范围： $0-2^{n-1}$</li>
<li>一般在全部是正数运算且不出现负值结果的场合下，可使用无符号数表示，例如<strong>地址运算</strong>。</li>
</ul>
<h5><span id="有符号数">有符号数</span></h5>
<h6><span id="机器数表示">机器数表示</span></h6>
<ul>
<li>
<p>数的正负问题：设符号位，<strong>“0”表示“正”，“1”表示“负”</strong>，固定为编码的最高位</p>
</li>
<li>
<p>真值0怎么办：正零，负零</p>
</li>
<li>
<p>小数点怎么办：隐含，<strong>小数点位置固定</strong> （即<strong>定点数</strong>）</p>
<ul>
<li>
<p>定点小数：小数点在最高位数值位前，绝对值小于1</p>
</li>
<li>
<p>定点整数：小数点在最低位数值位后，没有小数部分</p>
</li>
</ul>
</li>
<li>
<p>带有整数和小数部分的数怎么办：<strong>浮点数</strong>，按<strong>2为基</strong>的<strong>科学表示方法</strong>表示</p>
</li>
</ul>
<h4><span id="定点数-浮点数表示">定点数、浮点数表示</span></h4>
<h5><span id="定点数表示">定点数表示</span></h5>
<h6><span id="机器数表示及其表示范围">机器数表示及其表示范围</span></h6>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/机器数表示范围.png" style="zoom:50%;">
<h6><span id="原码">原码</span></h6>
<ul>
<li>容易理解</li>
<li>“0”的表示不唯一，不利于程序员编程</li>
<li>机器实现加、减运算的方法不统一，需对符号位进行单独处理，不利于硬件设计</li>
</ul>
<h6><span id="反码较少使用">反码——较少使用</span></h6>
<h6><span id="补码">补码</span></h6>
<ul>
<li>“0”的表示唯一</li>
<li>机器实现加、减运算的方法统一（模运算）</li>
<li>符号位参加运算，不需要单独处理</li>
</ul>
<h6><span id="模运算">模运算</span></h6>
<ol>
<li><strong>模</strong>：指一个计数系统<strong>所能表示的数据个数</strong>。有模运算是指运算结果超过模时，模（或模的整数倍）将溢出而只剩下余数。8位二进制的模为$2^8=256$</li>
<li>假设M为模，若数a，b满足<strong>a + b = M</strong>，则称a，b<strong>互为补数</strong>。</li>
<li>在有模运算中，<strong>减去一个数</strong>等于<strong>加上这个数对模的补数</strong>。</li>
</ol>
<h5><span id="浮点数表示">浮点数表示</span></h5>
<h6><span id="浮点数的一般表示法">浮点数的一般表示法</span></h6>
<p>分为<strong>阶码和尾数</strong>两个部分	<strong>阶码</strong>：采用<strong>定点整数</strong>表示	<strong>尾数</strong>：采用<strong>定点小数</strong>表示</p>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/阶符数符.png" style="zoom:50%;">
<h6><span id="ieee-754标准">IEEE 754标准</span></h6>
<p>分为符号（<strong>S</strong>ign）、阶码（<strong>E</strong>xponent）和尾数（<strong>M</strong>antissa）。</p>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.3.1.png" style="zoom:50%;">
<ul>
<li><strong>数符 S</strong>： 1位，0表示正数，1表示负数</li>
<li><strong>阶码 E</strong>：移码表示，n 位阶码偏移量为 $2^{n-1}-1$。如<strong>8位阶码偏移量</strong>为 7FH（ 即<strong>127</strong>），<strong>11位阶码偏移量</strong>3FFH（即<strong>1023</strong>）</li>
<li><strong>尾数 M</strong>： 原码表示，尾数必须<strong>规格化成小数点左侧一定为1</strong>，并且小数点前面这个1作为隐含位被省略。这样<strong>单精度浮点数尾数实际上为24位。</strong></li>
<li><strong>规格化数（尾数）形式</strong>：M=<strong>1.m</strong></li>
</ul>
<h6><span id="浮点数精度">浮点数精度</span></h6>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.3.2.png" style="zoom:50%;">
<h6><span id="ieee-754关于浮点数表示的约定单精度为例">IEEE 754关于浮点数表示的约定（单精度为例）</span></h6>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.3.3.png" style="zoom: 50%;">
<h6><span id="单精度浮点数表示范围">单精度浮点数表示范围</span></h6>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.3.4.png" style="zoom:50%;">
<h4><span id="非数值数据的表示">非数值数据的表示</span></h4>
<h3><span id="三-计算机的基本工作过程">三． 计算机的基本工作过程</span></h3>
<h4><span id="指令的含义">指令的含义</span></h4>
<p><strong>机器指令</strong>：计算机硬件可以执行的表示一种基本操作的<strong>二进制代码</strong>。</p>
<p><strong>指令格式</strong>：操作码 ＋ 操作数（操作数地址）
操作码：指明指令的操作性质
操作数（地址）：指令操作数的位置（或操作数本身）</p>
<p><strong>程序</strong>：在此特指一段<strong>机器指令序列</strong>。</p>
<p>完成一定的功能，采用某种算法，具备一定的流程；
计算机按照程序所规定的流程和指令顺序，一条一条地执行指令，达到完成程序所规定的功能的目的。
计算机采用**程序计算器（Program Counter）**来决定指令执行的顺序。</p>
<h4><span id="程序的执行">程序的执行</span></h4>
<h2><span id="第二讲组合逻辑">第二讲：组合逻辑</span></h2>
<h3><span id="一-逻辑代数基础">一． 逻辑代数基础</span></h3>
<h4><span id="1逻辑代数的基本概念">1.逻辑代数的基本概念</span></h4>
<p><strong>逻辑代数</strong>:逻辑代数L是一个封闭的代数系统，它由一个<strong>逻辑变量集K</strong>，常量0和1以及“或”、“与”、“非”三种基本运算所构成，记为 <strong>L={ K,∨,∧,￢,0 ,1 }</strong>。</p>
<p><strong>“或”运算</strong>：$a\bigwedge b=ab$</p>
<p><strong>“与”运算</strong>：$a\bigvee b=ab+\overline{a}b+a\overline{b}$</p>
<p><strong>“异或”运算</strong>：$a\bigoplus b= \overline{a}b+a\overline{b}$</p>
<p><strong>“同或”运算</strong>：$a⊙b=\overline{a}\overline{b}+ab$</p>
<h5><span id="逻辑运算顺序">逻辑运算顺序</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.1逻辑运算顺序.png" style="zoom:50%;">
<h5><span id="逻辑电路符号表示">逻辑电路符号表示</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.2.png" style="zoom:50%;">
<h4><span id="2逻辑代数的公理-定理与规则">2.逻辑代数的公理、定理与规则</span></h4>
<h5><span id="21逻辑代数的基本公理">2.1逻辑代数的基本公理</span></h5>
<ol>
<li>
<p>交换律：𝑨 + 𝑩 = 𝑩 + 𝑨, 𝑨 ∙ 𝑩 = 𝑩 ∙ 𝑨</p>
</li>
<li>
<p>结合律： 𝑨 + 𝑩 + 𝑪 = 𝑨 + 𝑩 + 𝑪</p>
</li>
</ol>
<p>(𝑨 ∙ 𝑩) ∙ 𝑪 = 𝑨 ∙ (𝑩 ∙ 𝑪)</p>
<ol start="3">
<li><strong>分配律</strong>：𝐀 ∙ (𝑩 + 𝑪) = 𝑨 ∙ 𝑩 + 𝑨 ∙ 𝑪</li>
</ol>
<p><strong>𝑨 + 𝑩 ∙ 𝑪 = (𝑨 + 𝑩) ∙ (𝑨 + 𝑪)</strong></p>
<ol start="4">
<li>0-1律 ：</li>
</ol>
<p>𝑨 + 𝟎 = 𝑨, 𝑨 ∙ 𝟏 = 𝑨</p>
<p>𝐀 + 𝟏 = 𝟏, 𝐀 ∙ 𝟎 = 𝟎</p>
<ol start="5">
<li>互补律</li>
</ol>
<p>$A+\overline{A}=1$</p>
<p>$A\overline{A}=0$</p>
<h5><span id="22逻辑代数的基本定理">2.2逻辑代数的基本定理</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.3.png" style="zoom:50%;">
<p>另一种吸收律：$A+\overline A B=A+B$</p>
<p>包含律第五点推广</p>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.4.png" style="zoom:50%;">
<h5><span id="23逻辑代数的规则">2.3逻辑代数的规则</span></h5>
<h6><span id="代入规则">代入规则</span></h6>
<h6><span id="反演规则">反演规则</span></h6>
<p>将原函数F中的全部 <strong>“•” 换成 “+”，“+” 换成 “•” ，“0” 换 成 “1”，“1” 换成 “0”，原变量换成反变量，反变量换成原变量</strong>，所得到的新函数就是<strong>原函数的反函数</strong>，记作 $\overline{F}$ 。----<strong>用途</strong>：直接求已知逻辑函数的反函数，可用于公式的化简</p>
<h6><span id="对偶规则">对偶规则</span></h6>
<p>将原函数F中的<strong>全部 “•” 换成 “+”，“+” 换成 “•”，“0”换成 “1”，“1” 换成 “0”</strong>，所得的新函数就是<strong>原函数的对偶式</strong>，<strong>记作F’或F</strong>* 。-----<strong>用途</strong>：已知<strong>某公式成立</strong>，则可以得到<strong>其对偶公式仍成立</strong>。若两个逻辑函数表达式F和G相等，则其对偶式F’和G’也相等</p>
<h4><span id="3逻辑函数的表达式">3.逻辑函数的表达式</span></h4>
<h5><span id="逻辑函数的常用表达式">逻辑函数的常用表达式</span></h5>
<p>常用表达式包括：与或式、或与式、与或非式</p>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.5.png" style="zoom: 50%;">
<h5><span id="逻辑函数的标准表达式">逻辑函数的标准表达式</span></h5>
<p>逻辑函数的标准表达式建立在<strong>最小项</strong>和<strong>最大项</strong>概念基础上（最小项可以巧记为<strong>占用字符数少</strong>比如:$AB$）</p>
<p>最小项表达式：全部由最小项构成的<strong>与或式</strong>（积之和式）</p>
<p>最大项表达式：全部由最大项构成的<strong>或与式</strong>（和之积式）</p>
<h5><span id="最小项">最小项</span></h5>
<h6><span id="编号">编号</span></h6>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.6.png" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.8.png" style="zoom:50%;">
<h5><span id="最大项">最大项</span></h5>
<h6><span id="编号">编号</span></h6>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.7.png" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.9.png" style="zoom:50%;">
<h4><span id="4逻辑函数化简卡诺图">4.逻辑函数化简（卡诺图）</span></h4>
<h5><span id="设计优化">设计优化</span></h5>
<ul>
<li>面积优化——使设计的电路或系统占用的逻辑资源尽量少</li>
<li>时间优化——使设计的电路或系统的输入信号到达输出的路程尽量短</li>
</ul>
<h5><span id="逻辑函数化简代数法">逻辑函数化简—代数法</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.10.png" style="zoom: 67%;">
<h5><span id="卡诺图化简基本规则">卡诺图化简基本规则</span></h5>
<ul>
<li>2个相邻项合并为一项，消去1个取值不同的变量</li>
<li>4个相邻项合并为一项，消去2个取值不同的变量</li>
<li>8个相邻项合并为一项，消去3个取值不同的变量</li>
</ul>
<h3><span id="二-逻辑门电路">二． 逻辑门电路</span></h3>
<h4><span id="1晶体管和mos管">1.晶体管和MOS管</span></h4>
<h5><span id="二极管">二极管</span></h5>
<p>PN结单向导通</p>
<h5><span id="三极管npn常用">三极管（NPN常用）</span></h5>
<p>NPN型：集电极加&gt;0.7V的电压，发射结和集电极就导通，否则就截止</p>
<p>PNP型：与上面相反</p>
<h5><span id="mos管nmos常用">MOS管（NMOS常用）</span></h5>
<h6><span id="nmos">NMOS</span></h6>
<p>类似NPN型三极管</p>
<h6><span id="pmos">PMOS</span></h6>
<p>类似PNP型三极管</p>
<h6><span id="cmosnmos和pmos的集合">CMOS——NMOS和PMOS的集合</span></h6>
<h5><span id="晶体管与mos管开关特性">晶体管与MOS管开关特性</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.11.png" style="zoom:50%;">
<h4><span id="2逻辑门电路实现">2.逻辑门电路实现</span></h4>
<h5><span id="1门电路">1.门电路</span></h5>
<h6><span id="与门二极管实现">与门——二极管实现</span></h6>
<h6><span id="或门二极管实现">或门——二极管实现</span></h6>
<h6><span id="非门三极管实现cmos实现">非门——三极管实现/CMOS实现</span></h6>
<h6><span id="或非门电路cmos实现">或非门电路——CMOS实现</span></h6>
<h6><span id="与非门电路cmos实现">与非门电路——CMOS实现</span></h6>
<h5><span id="2各种集成门电路性能比较">2.各种集成门电路性能比较</span></h5>
<p><strong>CMOS</strong>和<strong>TTL</strong>是两个常用集成电路。</p>
<ul>
<li>CMOS<strong>功耗相对低、抗干扰能力相对强、带载能力相对强</strong>。</li>
<li>TTL<strong>功耗相对高，速度相对快、抗干扰能力相对弱</strong>。</li>
<li>与TTL门电路相比，传统的CMOS门电路特点是集成度高、功耗低，但工作速度较慢、抗静电能力差。不过目前新型的CMOS门电路工作速度已经有了很大提高、抗静电能力也大为改善，基本能够与TTL门电路相媲了。</li>
<li>CMOS门电路获得了更为广泛的应用，尤其在<strong>大规模集成电路</strong>和<strong>微处理器</strong>中已占据了重要地位。</li>
</ul>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.12.png" style="zoom:50%;">
<h3><span id="三-基本组合逻辑部件设计">三． 基本组合逻辑部件设计</span></h3>
<h4><span id="组合逻辑设计概述">组合逻辑设计概述</span></h4>
<p>数字电路分类：<strong>组合逻辑电路</strong>和<strong>时序逻辑电路</strong></p>
<h5><span id="组合逻辑电路的设计方法">组合逻辑电路的设计方法</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.13.png" style="zoom:50%;">
<h4><span id="运算单元电路">运算单元电路</span></h4>
<h5><span id="1加法运算电路">1.加法运算电路</span></h5>
<p>半加器（<strong>不考虑来自低位的进位</strong>） 全加器（<strong>考虑来自低位的进位</strong>）</p>
<h5><span id="2全加器">2.全加器</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.14.png" style="zoom:50%;">
<h5><span id="3verilog模块结构">3.Verilog模块结构</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.15.png" style="zoom:50%;">
<h5><span id="4全加器的verilog-hdl">4.全加器的Verilog HDL</span></h5>
<h6><span id="方法一根据逻辑表达式用assign语句建模算法级描述">方法一：根据逻辑表达式，用assign语句建模（算法级描述）</span></h6>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1位全加器Verilog HDL源程序</span></span><br><span class="line"><span class="keyword">module</span> adder_1(A,B,CI,SO,CO);</span><br><span class="line">	<span class="keyword">input</span> A,B,CI;</span><br><span class="line">	<span class="keyword">output</span> SO,CO;</span><br><span class="line">	<span class="keyword">assign</span> SO = (!A&amp;&amp;!B&amp;&amp;CI)||(!A&amp;&amp;B&amp;&amp;!CI)||</span><br><span class="line">				(A&amp;&amp;!B&amp;&amp;!CI)||(A&amp;&amp;B&amp;&amp;CI);</span><br><span class="line">    <span class="keyword">assign</span> CO = (!A&amp;&amp;B&amp;&amp;CI)||(A&amp;&amp;!B&amp;&amp;CI)||</span><br><span class="line">    			(A&amp;&amp;B&amp;&amp;!CI)||(A&amp;&amp;B&amp;&amp;CI); <span class="comment">//assign 语句描述组合逻辑</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h6><span id="方法二根据逻辑功能定义直接描述采用行为描述方式的系统级抽象程序更简洁">方法二：根据逻辑功能定义直接描述，采用行为描述方式的系统级抽象，程序更简洁</span></h6>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> adder_2(A,B,CI,SO,CO);</span><br><span class="line">	<span class="keyword">input</span> A,B,CI;</span><br><span class="line">	<span class="keyword">output</span> SO,CO;</span><br><span class="line">	<span class="keyword">assign</span> &#123;CO,SO&#125; = A+B+CI;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"><span class="comment">//这里用位拼接运算符 “&#123; &#125;”将进位与算术和拼接在一起成为一个2位数</span></span><br></pre></td></tr></table></figure>
<h5><span id="5加法运算电路多位加法器">5.加法运算电路—多位加法器</span></h5>
<h6><span id="并行加法器串行进位">并行加法器—串行进位</span></h6>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.17.png" style="zoom:50%;">
<h6><span id="并行加法器并行进位或先行进位">并行加法器—并行进位（或先行进位）</span></h6>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.18.png" style="zoom:50%;">
<h5><span id="68位加法器的verilog-hdl">6.8位加法器的Verilog HDL</span></h5>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> adder_8(a,b,cin,sum,cout);</span><br><span class="line">    <span class="keyword">parameter</span> width=<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">input</span> [width-<span class="number">1</span>:<span class="number">0</span>] a,b;</span><br><span class="line">    <span class="keyword">input</span> cin;</span><br><span class="line">    <span class="keyword">output</span> [width-<span class="number">1</span>:<span class="number">0</span>] sum;</span><br><span class="line">    <span class="keyword">output</span> cout;</span><br><span class="line">    <span class="keyword">assign</span> &#123;cout,sum&#125; = a+b+cin;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"><span class="comment">//用parameter常量width表示加法器的位数，通过修改width，可以方便地实现不同位宽的加法器。</span></span><br></pre></td></tr></table></figure>
<h5><span id="7加法运算电路减法运算">7.加法运算电路—减法运算</span></h5>
<h6><span id="运算原则">运算原则</span></h6>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/2.19.png" style="zoom:50%;">
<h6><span id="溢出的判断">溢出的判断</span></h6>
<p>采用双符号位，“00”表示正，“11”表示负，如果运算结果符号位出现“01”或“10”表示出现溢出。</p>
<h5><span id="8乘法运算电路阵列乘法器">8.乘法运算电路：阵列乘法器</span></h5>
<p>原理类似十进制乘法</p>
<h5><span id="94位比较器的verilog-hdl设计">9.4位比较器的Verilog HDL设计</span></h5>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> CT7485(A3, A2, A1, A0, B3, B2, B1, B0, ALBI, AEBI,</span><br><span class="line">              AGBI, ALBO, AEBO, AGBO);</span><br><span class="line">    <span class="keyword">input</span> A3, A2, A1, A0, B3, B2, B1, B0, ALBI, AEBI, AGBI;</span><br><span class="line">    <span class="keyword">output</span> ALBO, AEBO, AGBO;</span><br><span class="line">    <span class="keyword">reg</span> ALBO, AEBO, AGBO;</span><br><span class="line">    <span class="keyword">wire</span>[<span class="number">3</span>:<span class="number">0</span>] A_SIGNAL, B_SIGNAL;</span><br><span class="line">    <span class="keyword">assign</span> A_SIGNAL = &#123;A3,A2,A1,A0&#125;; <span class="comment">//拼接成4位wire型向量</span></span><br><span class="line">    <span class="keyword">assign</span> B_SIGNAL = &#123;B3,B2,B1,B0&#125;; <span class="comment">//拼接成4位wire型向量</span></span><br><span class="line">  <span class="keyword">always</span></span><br><span class="line">    <span class="keyword">begin</span> </span><br><span class="line">        <span class="keyword">if</span> (A_SIGNAL &gt; B_SIGNAL)</span><br><span class="line">            <span class="keyword">begin</span> ALBO = <span class="number">0</span>; AEBO = <span class="number">0</span>; AGBO = <span class="number">1</span>; <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (A_SIGNAL &lt; B_SIGNAL)</span><br><span class="line">            <span class="keyword">begin</span> ALBO = <span class="number">1</span>; AEBO = <span class="number">0</span>; AGBO = <span class="number">0</span>; <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// if(A_SIGNAL == B_SIGNAL)可省略</span></span><br><span class="line">            <span class="keyword">begin</span> ALBO = ALBI; AEBO = AEBI; AGBO = AGBI; <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h5><span id="10alu1位alu-32位alu">10.ALU–1位ALU、32位ALU</span></h5>
<h4><span id="编码器译码器">编码器/译码器</span></h4>
<h4><span id="多路选择器">多路选择器</span></h4>
<h4><span id="组合逻辑电路的竞争冒险">组合逻辑电路的竞争冒险</span></h4>
<h2><span id="第三讲时序逻辑">第三讲：时序逻辑</span></h2>
<h3><span id="概述">概述</span></h3>
<h4><span id="时序逻辑电路的特点">时序逻辑电路的特点</span></h4>
<ul>
<li>当前输出由当前输入与电路原来状态共同决定（具有记忆功能）</li>
<li>电路的状态与时间顺序有关</li>
<li>结构特点：由组合逻辑电路和存储电路构成</li>
</ul>
<h4><span id="触发器flip-flopff">触发器(Flip-Flop，FF)</span></h4>
<p>一种有记忆功能的器件，是时序逻辑电路的基本器件。记忆电路特征：状态可预置（置0，置1），状态可保持</p>
<h4><span id="双稳态触发器两个稳定的状态">双稳态触发器(两个稳定的状态)</span></h4>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.2.png" style="zoom:50%;">
<h3><span id="一-锁存器和触发器">一． 锁存器和触发器</span></h3>
<h4><span id="1srd锁存器">1.SR/D锁存器</span></h4>
<h5><span id="11基本rs锁存器">1.1基本RS锁存器</span></h5>
<p>具有两个稳定状态，可自行保持输出状态，是各种触发器的基本构成。<strong>双稳态</strong></p>
<p><strong>原理</strong></p>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.png" style="zoom:50%;">
<h6><span id="真值表">真值表</span></h6>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.4.png" style="zoom:50%;">
<h6><span id="特性方程锁存器次态与原态及输入之间的逻辑函数表达式">特性方程：锁存器次态与原态及输入之间的逻辑函数表达式</span></h6>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.5.png" style="zoom:50%;">
<h5><span id="verilog-hdl描述-sr锁存器">Verilog HDL描述 SR锁存器</span></h5>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> RS_FF(Q,QN,SDN,RDN);</span><br><span class="line">    <span class="keyword">input</span> SDN,RDN;</span><br><span class="line">    <span class="keyword">output</span> Q,QN;</span><br><span class="line">    <span class="keyword">assign</span> Q = !(SDN &amp;&amp; QN);</span><br><span class="line">    <span class="keyword">assign</span> QN= !(RDN &amp;&amp; Q);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h5><span id="12钟控rs锁存器">1.2钟控RS锁存器</span></h5>
<h6><span id="钟控锁存器">钟控锁存器</span></h6>
<ul>
<li>数字系统中，为协调各部分电路同步运行，常要求某些锁存器在<strong>时钟信号的控制下</strong>同时动作，需要增加一个<strong>控制端</strong>（时钟信号），只有在<strong>控制端作用脉冲到达时</strong>锁存器才能动作，这种有时钟控制端的锁存器叫做钟控锁存器。</li>
<li>由于这里时钟信号为高电位（或低电位）时锁存器的状态随输入变化，所以钟控锁存器是<strong>电位触发方式</strong>的锁存器。钟控锁存器在时钟控制下同步工作，所以也称为<strong>同步锁存器。</strong></li>
</ul>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.6.png" style="zoom:50%;">
<h6><span id="原理">原理</span></h6>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.7.png" style="zoom: 50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.7.1.png" style="zoom:50%;">
<h5><span id="13-钟控d锁存器">1.3 钟控D锁存器</span></h5>
<p>将钟控RS锁存器输入由R、S双端输入改为单端输入（D），即将其S端改为D输入端，D经过非门接R端（S、R总是互反）！</p>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.7.2.png" style="zoom:50%;">
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> D_FF_1(CP,D,Q,QN);</span><br><span class="line">    <span class="keyword">input</span> CP,D;</span><br><span class="line">    <span class="keyword">output</span> Q,QN;</span><br><span class="line">    <span class="keyword">reg</span> Q,QN;</span><br><span class="line">    <span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (CP == <span class="number">1</span>)<span class="keyword">begin</span> Q = D;QN = ~Q; <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span> Q = Q;QN = QN; <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h4><span id="2d触发器">2.D触发器</span></h4>
<p>D触发器：两个反相的D锁存器构成。</p>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.8.1.png" style="zoom:50%;">
<h5><span id="d锁存器与d触发器的区别">D锁存器与D触发器的区别</span></h5>
<ul>
<li>D锁存器是电位（电平）触发的，只有在时钟CP有效电平（高电平CP=1或者低电平CP＝0）期间，触发器的状态才有可能发生变化。</li>
<li>D触发器的状态变化只发生在时钟CP的有效沿（上升沿或者下降沿）期间，CP＝1、CP=0时触发器的状态不会发生变化。</li>
</ul>
<h5><span id="带使能端的d触发器">带使能端的D触发器</span></h5>
<p>增加输入使能信号EN（ENable），用于确定在时钟沿是否能够载入数据。</p>
<ul>
<li>EN＝1时，D触发器正常工作</li>
<li>EN＝0时， D触发器状态不变</li>
<li>在时钟信号上一般不要设置逻辑，否则可能因延迟导致时序错误</li>
</ul>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.8.2.png" style="zoom:50%;">
<h5><span id="带复位功能的d触发器">带复位功能的D触发器</span></h5>
<p>增加输入复位信号RESET。 RESET 有效时（＝1），D触发器复位（Q=0） RESET 无效时（＝0）， D触发器正常工作</p>
<ul>
<li>
<p>复位方式</p>
<ul>
<li>
<p>同步复位：复位信号有效和时钟有效沿同时有效才能复位（置0）</p>
</li>
<li>
<p>异步复位：只要复位信号有效就能复位</p>
</li>
</ul>
</li>
<li>
<p>有的触发器还带有置位（SET）功能（Q=1）</p>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.8.3.png" style="zoom:50%;">
</li>
</ul>
<h5><span id="由d触发器构成寄存器">由D触发器构成寄存器</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.8.4.png" style="zoom:50%;">
<h4><span id="3钟控jk触发器">3.钟控JK触发器</span></h4>
<h5><span id="原理">原理</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.8.5.png" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.8.6.png" style="zoom:50%;">
<h5><span id="verilog-code">verilog code</span></h5>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> JK_FF(CP,J, K,Q,QN);</span><br><span class="line">    <span class="keyword">input</span> CP, J, K;</span><br><span class="line">    <span class="keyword">output</span> Q,QN;</span><br><span class="line">    <span class="keyword">reg</span> Q,QN; </span><br><span class="line">    <span class="keyword">always</span> @(CP <span class="keyword">or</span> J <span class="keyword">or</span> K)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (CP==<span class="number">0</span>) <span class="comment">//保持</span></span><br><span class="line">        <span class="keyword">begin</span> Q = Q; QN = QN; <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (CP==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">case</span> (&#123;J,K&#125;)</span><br><span class="line">                <span class="number">2</span>’b00: <span class="keyword">begin</span> Q = Q; QN = QN; <span class="keyword">end</span> <span class="comment">//保持</span></span><br><span class="line">                <span class="number">2</span>’b01: <span class="keyword">begin</span> Q = <span class="number">1</span>’b0; QN = <span class="number">1</span>’b1; <span class="keyword">end</span> <span class="comment">//置0</span></span><br><span class="line">                <span class="number">2</span>’b10: <span class="keyword">begin</span> Q = <span class="number">1</span>’b1; QN = <span class="number">1</span>’b0; <span class="keyword">end</span> <span class="comment">//置1</span></span><br><span class="line">                <span class="number">2</span>’b11: <span class="keyword">begin</span> Q = !Q; QN = !QN; <span class="keyword">end</span> <span class="comment">//翻转</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h5><span id="钟控jk触发器比d锁存器新增的功能">钟控JK触发器比D锁存器新增的功能：</span></h5>
<p>当JK=11时，输出的波形翻转（可用于计数）； 当JK=00时，触发器保持原来的状态。</p>
<h5><span id="钟控jk触发器的空翻现象分析初态q0j1k1">钟控JK触发器的空翻现象分析（初态Q=0，J=1，K=1）</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.8.7.png" style="zoom: 50%;">
<h4><span id="4-负边沿触发的jk触发器">4 负边沿触发的JK触发器</span></h4>
<h5><span id="电路结构">电路结构</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.8.8.png" style="zoom:50%;">
<h5><span id="工作原理">工作原理</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.8.9.png" style="zoom:50%;">
<h4><span id="小结">小结</span></h4>
<ul>
<li>基本RS锁存器：具有保持、置0、置1功能，其输入信号可以直接控制锁存器的输出；</li>
<li>钟控RS锁存器：时钟信号CP有效时锁存器的状态随输入变化（约束条件R、S不能同时为1）；</li>
<li>钟控D锁存器：为消除钟控RS触发器的不定状态，将钟控RS锁存器双端输入改为单端输入（D），即D锁存器；</li>
<li>D触发器：两个反向钟控D锁存器构成D触发器。时钟信号CP的边沿（上升沿或下降沿）触发。</li>
<li>D锁存器是电平敏感的，D触发器是边沿触发的；</li>
<li>寄存器有共享时钟信号CLK的多个D触发器构成。</li>
</ul>
<h4><span id="触发器应用举例">触发器应用举例</span></h4>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.8.10.png" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.8.11.png" alt="3.8.11" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.8.12.png" alt="3.8.12" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.8.13.png" alt="3.8.13" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.8.14.png" alt="3.8.14" style="zoom:50%;">
<h3><span id="二-有限状态机">二． 有限状态机</span></h3>
<h4><span id="时序电路特点">时序电路特点</span></h4>
<p>将<strong>异步时序电路</strong>转换为<strong>同步时序电路</strong>，避免竞争和冒险</p>
<h5><span id="时序电路实例分析">时序电路实例分析</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.9.1.png" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.9.2.png" style="zoom:50%;">
<h5><span id="有限状态机基本介绍">有限状态机基本介绍</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.9.3.png" style="zoom: 67%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.1.png" style="zoom: 67%;">
<h4><span id="1moore型有限状态机">1.Moore型有限状态机</span></h4>
<h5><span id="设计方法和流程图">设计方法和流程图</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.9.4.png" style="zoom:50%;">
<h5><span id="moore型fsm的表示方法">Moore型FSM的表示方法</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.9.5.png" style="zoom:50%;">
<h5><span id="例交通信号灯控制器">【例】交通信号灯控制器</span></h5>
<p>南北Academic大道，信号灯LA；东西Bravado大道，信号灯LB。信号灯红、绿、黄三色。</p>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.9.8.png" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.9.9.png" alt="3.9.9" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.9.10.png" alt="3.9.10" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.9.11.png" alt="3.9.11" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.9.12.png" alt="3.9.12" style="zoom:50%;">
<h4><span id="2mealy型有限状态机">2.Mealy型有限状态机</span></h4>
<h5><span id="设计方法和流程图">设计方法和流程图</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.9.6.png" style="zoom:50%;">
<h5><span id="mealy型fsm的表示方法">Mealy型FSM的表示方法</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.9.7.png" style="zoom:50%;">
<h5><span id="例二进制序列检测器">【例】二进制序列检测器</span></h5>
<p>检测器接收到二进制序列“1101”时，输出检测标志为1，否则输出检测标志为0。不重复检测，即收到1101输出1后，下一次从下一个输入信号开始检测。</p>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.9.13.png" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.9.14.png" alt="3.9.14" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.9.15.png" alt="3.9.15" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.9.16.png" alt="3.9.16" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.9.17.png" alt="3.9.17" style="zoom:50%;">
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> monitor2_good(clk,clr,data,zo,state);</span><br><span class="line">    <span class="keyword">parameter</span> S0=<span class="number">3</span>’b000, S1=<span class="number">3</span>’b001,</span><br><span class="line">    S2=<span class="number">3</span>’b010, S3=<span class="number">3</span>’b011, S4=<span class="number">3</span>’b100;</span><br><span class="line">    <span class="keyword">input</span> clk,clr,data;</span><br><span class="line">    <span class="keyword">output</span> zo;</span><br><span class="line">    <span class="keyword">output</span>[<span class="number">2</span>:<span class="number">0</span>] state;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] state;</span><br><span class="line">    <span class="keyword">reg</span> zo;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> clr)</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span> (clr) state=S0; <span class="comment">// 复位时回到初始状态</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">case</span> (state) <span class="comment">// 状态的转移</span></span><br><span class="line">                    S0: <span class="keyword">if</span> (data==<span class="number">1</span>’b1) state=S1; <span class="keyword">else</span> state=S0; </span><br><span class="line">                    S1: <span class="keyword">if</span> (data==<span class="number">1</span>’b1) state=S2; <span class="keyword">else</span> state=S0;</span><br><span class="line">                    S2: <span class="keyword">if</span> (data==<span class="number">1</span>’b0) state=S3; <span class="keyword">else</span> state=S2;</span><br><span class="line">                    S3: <span class="keyword">if</span> (data==<span class="number">1</span>’b1) state=S4; <span class="keyword">else</span> state=S0; </span><br><span class="line">                    S4: <span class="keyword">if</span> (data==<span class="number">1</span>’b1) state=S1; <span class="keyword">else</span> state=S0; </span><br><span class="line">                    <span class="keyword">default</span>: state=S0;</span><br><span class="line">                <span class="keyword">endcase</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">    	<span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span> @(state) <span class="comment">// 状态机的输出 输出是内部状态和外部输入的函数</span></span><br><span class="line">        <span class="keyword">begin</span>       </span><br><span class="line">            <span class="keyword">case</span> (state) </span><br><span class="line">                S0: zo=<span class="number">1'b0</span>; </span><br><span class="line">                S1: zo=<span class="number">1'b0</span>; </span><br><span class="line">                S2: zo=<span class="number">1'b0</span>; </span><br><span class="line">                S3: <span class="keyword">if</span> (data==<span class="number">1'b1</span>) zo=<span class="number">1'b1</span>;</span><br><span class="line">                <span class="comment">//在S3时若输入data=1， 则zo置1：</span></span><br><span class="line">                <span class="keyword">else</span> zo=<span class="number">1'b0</span>; </span><br><span class="line">                S4: zo=<span class="number">1'b0</span>; </span><br><span class="line">                <span class="keyword">default</span>: zo=<span class="number">1'b0</span>;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h4><span id="有限状态机的状态编码问题">有限状态机的状态编码问题</span></h4>
<h5><span id="起始状态的选择">起始状态的选择</span></h5>
<p>起始状态指电路复位后所处的初态，选择合适的起始状态将使设计简捷高效。FSM必须有<strong>时钟信号</strong>和<strong>复位信号</strong>。</p>
<h5><span id="状态编码方式的选择假定fsm有n个状态">状态编码方式的选择（假定FSM有N个状态）</span></h5>
<p><strong>二进制编码</strong>：采用<strong>log2N个触发器</strong>来表示这N个状态，按二进制顺序编码，节省逻辑资源，但<strong>可能产生输出毛刺</strong>。</p>
<p><strong>格雷编码</strong>：采用<strong>log2N个触发器</strong>来表示这N个状态，但<strong>相邻状态只有一个比特位不同</strong>。节省逻辑资源，降低了输出毛刺的可能，状态转换中，相邻状态只有一个比特位产生变化。</p>
<p><strong>一位热码状态机编码</strong>（One-Hot State Machine Encoding）：采用<strong>N个触发器来表示这N个状态</strong>。逻辑资源消耗最大，但可以<strong>避免状态机产生错误的输出</strong>，并且有时可简化输出逻辑。</p>
<h5><span id="8个状态三种编码方式的对比">8个状态三种编码方式的对比</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.9.18.png" style="zoom:50%;">
<h4><span id="有限状态机设计小结">有限状态机设计小结</span></h4>
<ol>
<li>确定输入、输出，以及状态总数</li>
<li>画出状态转换图</li>
<li>对于Moore型FSM
① 写出状态转换表
② 写出输出真值表</li>
<li>对于Mealy型FSM
① 写出组合的状态转换表和输出真值表</li>
<li>选择状态编码——这个选择将影响硬件设计</li>
<li>写出次态逻辑和输出逻辑的逻辑表达式</li>
<li>画出电路图</li>
<li>进行Verilog HDL设计并仿真测试</li>
</ol>
<h3><span id="三-时序逻辑电路设计分析">三． 时序逻辑电路设计分析</span></h3>
<h4><span id="时序电路的分类">时序电路的分类</span></h4>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.1.png" style="zoom:50%;">
<h5><span id="同步时序电路的分析方法">同步时序电路的分析方法</span></h5>
<ol>
<li>写出各触发器的<strong>激励方程(<strong>excitation equation) （也称</strong>驱动方程</strong>）</li>
<li>把得到的激励方程代入到触发器的<strong>特性方程(<strong>characteristic equation) ，得到</strong>次态方程</strong>(next-state equation)</li>
<li>按照电路图得到<strong>输出方程</strong>(output equation)</li>
<li>根据<strong>次态方程</strong>和<strong>输出方程</strong>得到<strong>状态表</strong></li>
<li>得到时序电路的<strong>状态图</strong></li>
<li>画出时序图</li>
<li>确定电路行为</li>
</ol>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.2.png" style="zoom:50%;">
<h4><span id="寄存器的分类">寄存器的分类</span></h4>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.3.png" style="zoom:50%;">
<h4><span id="1数据寄存器">1.数据寄存器</span></h4>
<h5><span id="数据寄存器">数据寄存器</span></h5>
<p>由多位边沿触发器组成的用于保存一组二进制代码的寄存单元。当时钟信号的上升沿或下降沿到来时，将输入端数据打入寄存器，即此时输出信号等于输入信号；在时钟信号的其它时刻，输出端保持刚才输入的数据，即为寄存状态，而不管此时输入信号是否变化。</p>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.4.png" style="zoom:50%;">
<p><strong>4位D型寄存器结构</strong>
$D_0D_1D_2D_3$：并行数据输入
$Q_0Q_1Q_2Q_3$：并行数据输出工作原理： （1）清除（复位）当$\overline {R_D}$ = 0 ， $Q_0Q_1Q_2Q_3$=0000; （2）置数（复位端无效时）当CP上跳沿到达时，$Q_0Q_1Q_2Q_3$= $D_0D_1D_2D_3$</p>
<h5><span id="用always块语句描述的8位数据寄存器">用always块语句描述的8位数据寄存器</span></h5>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> reg_8bit(qout,data,clk,clr);</span><br><span class="line">    <span class="keyword">output</span>[<span class="number">7</span>:<span class="number">0</span>] qout;</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] data;</span><br><span class="line">    <span class="keyword">input</span> clk,clr;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] qout;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> clr) <span class="comment">//沿触发</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(clr) qout=<span class="number">0</span>; <span class="comment">//异步清零</span></span><br><span class="line">            <span class="keyword">else</span> qout= data;</span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h5><span id="数据锁存器">数据锁存器</span></h5>
<ul>
<li>由多位电位锁存器组成的用于保存一组二进制代码的寄存单元。</li>
<li>功能：当输入控制信号（如时钟）为高电平时，门是打开的，输出信号等于输入信号；当输入控制信号为低电平时，门是关闭的，输出端保持刚才输入的数据，即为锁存状态，而不管此时输入信号是否变化。</li>
<li>通常由电平信号来控制，属于<strong>电平敏感型</strong>，适于<strong>数据有效滞后于控制信号</strong>有效的场合。</li>
</ul>
<h5><span id="数据寄存器和数据锁存器的区别">数据寄存器和数据锁存器的区别</span></h5>
<ul>
<li>数据寄存器：由边沿触发的触发器组成。通常由同步时钟信号来控制，属于脉冲敏感型，适于数据有效提前于控制信号（一般为时钟信号）有效、并要求同步操作的场合。</li>
<li>数据锁存器：由电位触发器（即D锁存器）组成。一般由电平信号来控制，属于电平敏感型，适于数据有效滞后于控制信号有效的场合。</li>
</ul>
<h5><span id="数据锁存器的verilog-hdl设计">数据锁存器的Verilog HDL设计</span></h5>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通的的1位数据锁存器的Verilog HDL</span></span><br><span class="line"><span class="keyword">module</span> latch_1(q,d,clk);</span><br><span class="line">    <span class="keyword">output</span> q;</span><br><span class="line">    <span class="keyword">input</span> d,clk ;</span><br><span class="line">    <span class="keyword">assign</span> q=clk?d:q; <span class="comment">/* 时钟信号为高电平，打入数据，否则锁存原数*/</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//带置位和复位端的1位数据锁存器的Verilog HDL</span></span><br><span class="line"><span class="keyword">module</span> latch_2(q,d,clk,set,reset);</span><br><span class="line">    <span class="keyword">output</span> q;</span><br><span class="line">    <span class="keyword">input</span> d,clk ,set,reset;</span><br><span class="line">    <span class="keyword">assign</span> q= reset ? <span class="number">0</span>: (set ? <span class="number">1</span>:(clk ? d:q)); </span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//8位数据锁存器的Verilog HDL设计</span></span><br><span class="line"><span class="keyword">module</span> latch_8bit(qout,data,clk);</span><br><span class="line">    <span class="keyword">output</span>[<span class="number">7</span>:<span class="number">0</span>] qout;</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] data;</span><br><span class="line">    <span class="keyword">input</span> clk;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] qout;</span><br><span class="line">    <span class="keyword">always</span> @(clk <span class="keyword">or</span> data) <span class="comment">//电平敏感</span></span><br><span class="line">    <span class="keyword">if</span>(clk) qout=data;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h4><span id="2移位寄存器">2.移位寄存器</span></h4>
<p>具有移位功能的寄存器称为移位寄存器，每来一个时钟脉冲，寄存器中数据就依次向左或向右移一位。</p>
<p>计算机中经常需要用到移位操作，如乘法运算中的<strong>右移</strong>，除法运算中的<strong>左移</strong>，数据输入输出方式中的<strong>串行并行转换</strong>等。</p>
<h5><span id="移位寄存器分类">移位寄存器分类</span></h5>
<p>左移移位寄存器、右移移位寄存器、双向移位寄存器、循环移位寄存器</p>
<h5><span id="4位右移移位寄存器">4位右移移位寄存器</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.5.png" style="zoom:50%;">
<h5><span id="4位右移移位寄存器的工作方式">4位右移移位寄存器的工作方式</span></h5>
<h6><span id="串入并出">串入并出</span></h6>
<p>串并转换（需要N个CP周期），经过4个CP，串行输入的4位数据全部移入移位寄存器中，并从Q3Q2Q1Q0并行输出1011</p>
<h6><span id="串入串出">串入串出</span></h6>
<p>把最右边的触发器的输出作为电路的输出。经过4个CP后， Q3 输出的是最先串行输入的数据。从每个触发器Q端输出的波形相同，但后级触发器Q端输出波形比前级触发器Q端输出波形滞后一个时钟周期。 把工作于串入串出方式的移位寄存器称为“延迟线” （第N级FF延迟N个CP周期）</p>
<h5><span id="4位串行输入-串并行输出双向移位寄存器">4位串行输入、串/并行输出双向移位寄存器</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.6.png" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.7.png" style="zoom:50%;">
<h4><span id="3计数器">3.计数器</span></h4>
<h5><span id="定义用途分类">定义，用途，分类</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.8.png" style="zoom:50%;">
<h5><span id="例题1同步十进制加法计数器">例题1：同步十进制加法计数器</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.9.png" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.10.png" alt="3.3.10" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.11.png" alt="3.3.11" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.12.png" alt="3.3.12" style="zoom:50%;">
<h5><span id="同步计数器的特点">同步计数器的特点</span></h5>
<ul>
<li>所有触发器的时钟端并联在一起，作为计数器的时钟端</li>
<li>各触发器同时翻转，不存在时钟到各触发器输出的传输延迟的积累</li>
<li>由于其工作频率只与一个触发器的时钟到输出的传输延迟有关，所以它的工作频率比异步计数器高。</li>
<li>由于计数器各触发器几乎是同时翻转的，因此，各触发器输出波形的偏移为各触发器时钟到输出的延迟之差，同步计数器输出经译码后所产生的尖峰信号宽度比较小。</li>
<li>缺点：结构比较复杂（<strong>各触发器的输入由多个Q输出相与得到</strong>），所用元件较多。</li>
<li>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.13.png" style="zoom:50%;">
</li>
</ul>
<h5><span id="例题2同步十六进制数加法计数器">例题2：同步十六进制数加法计数器</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.14.png" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.15.png" alt="3.3.15" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.16.png" alt="3.3.16" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.17.png" alt="3.3.17" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.18.png" alt="3.3.18" style="zoom:50%;">
<h5><span id="异步计数器">异步计数器</span></h5>
<p>异步计数器也有<strong>二进制、十进制、任意进制</strong>等类型</p>
<h6><span id="异步计数器的特点">异步计数器的特点</span></h6>
<ul>
<li>输入系统时钟脉冲只作用于最低位触发器，高位触发器的时钟信号往往是由低一位触发器的输出提供的，高位触发器的翻转有待低一位触发器翻转后才能进行。</li>
<li>由于每一级触发器都存在传输延迟，因此计数器工作速度慢，而且，位数越多计数越慢。在大型数字设备中较少采用。</li>
<li>对计数器状态进行译码时，由于触发器不同步，译码器输出会出现尖峰脉冲（位数越多，尖峰信号也就越宽），使仪器设备产生误动作。</li>
<li>优点：结构比较简单，所用元件较少。</li>
</ul>
<h5><span id="例题3分析下图异步二进制m16加法计数器电路n4">例题3：分析下图异步二进制（M=16）加法计数器电路（N=4）</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.19.png" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.20.png" alt="3.3.20" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.21.png" alt="3.3.21" style="zoom:50%;">
<h5><span id="异步计数器其他类型计数器">异步计数器——其他类型计数器</span></h5>
<h6><span id="1-分析异步二进制模16减法计数器">1. 分析异步二进制（模16）减法计数器</span></h6>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.22.png" style="zoom:50%;">
<h6><span id="2d触发器上跳沿触发构成的异步二进制模8加法计数器">2.D触发器（上跳沿触发）构成的异步二进制（模8）加法计数器</span></h6>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.23.png" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.24.png" alt="3.3.24" style="zoom:50%;">
<h5><span id="异步计数器小结">异步计数器小结</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.3.25.png" style="zoom:50%;">
<h4><span id="4时序电路的时序">4.时序电路的时序</span></h4>
<h5><span id="寄存器的时序">寄存器的时序</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.4.1.png" style="zoom:50%;">
<h5><span id="同步时序电路时钟周期">同步时序电路时钟周期</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.4.2.png" style="zoom: 50%;">
<h5><span id="保持时间约束">保持时间约束</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.4.3.png" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/3.4.4.png" style="zoom:50%;">
<h2><span id="第四讲主存储器">第四讲：主存储器</span></h2>
<h3><span id="一-存储系统概述">一． 存储系统概述</span></h3>
<h4><span id="11存储器分类">1.1存储器分类</span></h4>
<h5><span id="按介质分类">按介质分类：</span></h5>
<ul>
<li>半导体存储器</li>
<li>磁介质存储器</li>
<li>光盘存储器</li>
</ul>
<h5><span id="按访问方式分类">按访问方式分类：</span></h5>
<ul>
<li>随机访问存储器 （Random Access Memory—<strong>RAM</strong>）</li>
<li>只读存储器 （Read Only Memory—<strong>ROM</strong>）</li>
<li>顺序访问存储器 （Tape）</li>
<li>直接访问存储器 （Disk）</li>
</ul>
<h5><span id="按功能分类">按功能分类：</span></h5>
<ul>
<li>高速缓冲存储器</li>
<li>主存储器</li>
<li>辅助存储器</li>
<li>控制存储器</li>
</ul>
<h4><span id="存储器的层次结构">存储器的层次结构</span></h4>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/4.1.15.png" style="zoom:50%;">
<p>二级存储系统指：<strong>高速缓冲存储器</strong>（<strong>Cache</strong>）＋<strong>主存储器</strong></p>
<h4><span id="12半导体存储器">1.2半导体存储器</span></h4>
<h5><span id="静态随机访问存储器sramstatic-ram">静态随机访问存储器SRAM（Static RAM）</span></h5>
<ul>
<li>SRAM：静态存储器，相对动态而言，<strong>集成度低</strong>，<strong>但不必刷新</strong>。</li>
</ul>
<h5><span id="动态随机访问存储器dramdynamic-ram">动态随机访问存储器DRAM（Dynamic RAM）</span></h5>
<ul>
<li>DRAM：动态存储器，<strong>需要刷新</strong>，相对而言，<strong>集成度高</strong>。</li>
</ul>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/4.1.16.png" style="zoom:50%;">
<h3><span id="二-存储单元电路">二． 存储单元电路</span></h3>
<h4><span id="存储单元的符号表示">存储单元的符号表示</span></h4>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/4.1.1.png" style="zoom:50%;">
<h3><span id="三-存储器芯片结构">三． 存储器芯片结构</span></h3>
<h4><span id="存储芯片结构一维地址结构">存储芯片结构（一维地址结构）</span></h4>
<ul>
<li>1024×2 ：1024 个字单元，每个字单元 2 个二进制位 需要1024个不同的标示。</li>
<li>地址编码：译码电路使得字选择线 Wi 处于工作状态的输入信号（二进制信号），称为Wi 所选中字单元的地址编码（简称地址）。</li>
<li>对于每一个字单元，地址是唯一的。</li>
<li><strong>计组课中，地址往往都和译码器相连</strong>。</li>
<li>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/4.1.2.png" style="zoom:50%;">
</li>
</ul>
<h4><span id="二维地址结构sram">二维地址结构（SRAM）</span></h4>
<ul>
<li>一维地址需要的分支太多，不方便光刻</li>
<li>芯片示例：4096 × 4（4096 个字，每个字 4 位）	4096×4 = $2^{14}$ 个位单元</li>
<li>存储矩阵： $2<sup>7×2</sup>7$ (128行×128列)</li>
<li>行、列译码：行地址 7位，一行含32个字共128位，任一时刻只有1个字（4位数据线）被选中。一行包括32个字，要进行<strong>32选1</strong>的译码（Y译码），列地址5位</li>
<li>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/4.1.3.png" style="zoom:50%;">
</li>
</ul>
<h4><span id="dram芯片结构">DRAM芯片结构</span></h4>
<p>要求体积较小，采用行列译码器复用，时空转换</p>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/4.1.4.png" style="zoom:50%;">
<h4><span id="存储芯片结构示例">存储芯片结构示例</span></h4>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/4.1.5.png" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/4.1.6.png" alt="4.1.6" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/4.1.7.png" alt="4.1.7" style="zoom:50%;">
<h3><span id="四-存储器扩展">四． 存储器扩展</span></h3>
<h4><span id="41-存储器芯片的扩展位扩展">4.1 存储器芯片的扩展（位扩展）</span></h4>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/4.1.8.png" style="zoom: 200%;">
<h4><span id="42-存储器芯片的扩展字扩展">4.2 存储器芯片的扩展（字扩展）</span></h4>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/4.1.10.png" alt="4.1.9" style="zoom:50%;">
<h6><span id="43-存储器芯片的扩展混合扩展">4.3 存储器芯片的扩展（混合扩展）</span></h6>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/4.1.11.png" alt="4.1.9" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/4.1.12.png" alt="4.1.9" style="zoom:50%;">
<h4><span id="cpu与主存的连接示例">CPU与主存的连接（示例）</span></h4>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/4.1.13.png" style="zoom:200%;">
<h4><span id="存储器的符号表示">存储器的符号表示</span></h4>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/4.1.14.png" style="zoom:50%;">
<h3><span id="五-dram的刷新">五． DRAM的刷新</span></h3>
<h4><span id="51-dram存储单元电路的刷新">5.1 DRAM存储单元电路的刷新</span></h4>
<h4><span id="52-dram存储芯片的刷新">5.2 DRAM存储芯片的刷新</span></h4>
<p>简单来讲，就是让0变纯0，1变纯1</p>
<h4><span id="53-dram的刷新方式">5.3 DRAM的刷新方式</span></h4>
<h5><span id="集中刷新方式">集中刷新方式</span></h5>
<p>集中刷新间隔 = 刷新周期</p>
<h5><span id="分散刷新方式">分散刷新方式</span></h5>
<h5><span id="异步刷新方式一般使用">异步刷新方式（一般使用）</span></h5>
<ul>
<li>结合前两种方式，保证在一个刷新周期内将存储芯片内的所有行刷新一遍，且只刷新一遍。</li>
<li>异步刷新间隔 = 刷新周期</li>
<li>以128行为例，在2ms时间内必须轮流对每一行刷新一次，即每隔2ms/128=15.5μs刷新一行。这时假定读/写与刷新操作时间都为0.5μs，则可用前15μs进行正常读/写操作，最后0.5μs完成刷新操作。</li>
</ul>
<h4><span id="非易失性内存">非易失性内存</span></h4>
<ul>
<li>铁电存储器：FRAM</li>
<li>电阻式存储器：ReRAM</li>
<li>磁阻存储器：MRAM，SRAM的告诉读写性能，DRAM的集成度，ROM的非易失性特征，功耗低</li>
</ul>
<h2><span id="第五讲指令系统与mips汇编语言">第五讲：指令系统与MIPS汇编语言</span></h2>
<h3><span id="一-指令格式">一、指令格式</span></h3>
<h4><span id="11指令系统概述">1.1指令系统概述</span></h4>
<h5><span id="执行指令是cpu的主要工作">执行指令是CPU的主要工作</span></h5>
<h5><span id="不同的cpu有不同的指令集">不同的CPU有不同的指令集</span></h5>
<p><strong>指令集架构Instruction Set Architecture (ISA)</strong>：Intel 80x86 (Pentium 4), IBM/Motorola PowerPC (Macintosh), MIPS, Intel IA64, …</p>
<p>(ARM架构从英国卖到了美国，之后国内的芯片生态问题需要注意)</p>
<h5><span id="指令系统的基本问题">指令系统的基本问题</span></h5>
<h6><span id="操作类型应该提供哪些多少操作">操作类型：应该提供哪些（多少）操作？</span></h6>
<p>用LD/ST/INC/BRN已经足够编写任何计算程序，但不实用，程序太长。</p>
<h6><span id="操作对象如何表示可以表示多少">操作对象：如何表示？可以表示多少？</span></h6>
<p>大多数是双值运算（如A&lt;-B+C)
存在单值运算（如A&lt;- ~B)</p>
<h6><span id="指令格式如何将这些内容编码成一致的格式">指令格式：如何将这些内容编码成一致的格式？</span></h6>
<p>指令长度、字段、编码等问题</p>
<h4><span id="12指令格式">1.2指令格式</span></h4>
<h4><span id="13寻址方式">1.3寻址方式</span></h4>
<h3><span id="二-mips指令与汇编语言">二、MIPS指令与汇编语言</span></h3>
<h4><span id="21mips指令系统">2.1MIPS指令系统</span></h4>
<h5><span id="mips-r2000r3000-寄存器结构">MIPS R2000/R3000 寄存器结构</span></h5>
<h4><span id="22mips汇编语言">2.2MIPS汇编语言</span></h4>
<h4><span id="23mips汇编编程">2.3MIPS汇编编程</span></h4>
<h3><span id="三-80868088指令系统">三、8086/8088指令系统</span></h3>
<h3><span id="四-risc与cisc">四、RISC与CISC</span></h3>
<h2><span id="第六讲mips处理器设计">第六讲：MIPS处理器设计</span></h2>
<h3><span id="一处理器设计概述">一.处理器设计概述</span></h3>
<h4><span id="cpu的功能与组成">CPU的功能与组成</span></h4>
<h3><span id="二mips模型机">二.MIPS模型机</span></h3>
<h3><span id="三mips单周期处理器设计">三.MIPS单周期处理器设计</span></h3>
<h3><span id="四mips多周期处理器设计简介">四.MIPS多周期处理器设计简介</span></h3>
<h3><span id="五mips流水线处理器设计">五.MIPS流水线处理器设计</span></h3>
<h2><span id="第七讲高速缓冲存储器">第七讲：高速缓冲存储器</span></h2>
<h3><span id="一cache的原理">一．Cache的原理</span></h3>
<h4><span id="cache产生的动因">Cache产生的动因</span></h4>
<ul>
<li>单级存储系统中,主存的存储速度与CPU的速度不匹配，造成CPU资源的浪费；</li>
<li>程序运行时访问内存存在明显的<strong>局部性特征</strong>；</li>
<li>存在比主存普遍采用的DRAM速度更快的存储单元电路（SRAM）；</li>
</ul>
<h4><span id="cache的工作原理">Cache的工作原理</span></h4>
<ul>
<li>
<p>在CPU和主存间设置一个小容量<strong>访问速度更快</strong>的高速缓存，其中总是保存当前<strong>最活跃（被频繁访问）的程序和数据</strong>，大多数情况下，CPU能直接从这个高速缓存中取得指令和数据，而不必访问主存。这个高速缓存就是<strong>Cache</strong>。（Cache对用户完全透明）</p>
</li>
<li>
<p>Cache与主存之间按照数据块（Block）为单位进行数据交换(块大小一般为16/32/64/128 B)。</p>
</li>
</ul>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/701.png" style="zoom:50%;">
<h5><span id="cache要解决的问题">Cache要解决的问题</span></h5>
<p>① <strong>快速访问</strong>：具备快速访问的能力（采用<strong>SRAM</strong>）；</p>
<p>② <strong>数据交换</strong>：与主存交换数据的能力，将主存<strong>最活跃单元所在数据</strong>（或指令）块复制到Cache中；</p>
<p>③ <strong>地址判断</strong>：由于CPU总是以主存地址访问存储器，所以Cache应具备有判断CPU当前要访问的内容是否在Cache中的能力，并具有根据主存地址在Cache中访问相应单元的能力；</p>
<p>④ <strong>替换决策</strong>：具备在Cache容量不够时替换Cache中某些内容的决策能力。</p>
<h5><span id="cache的基本结构">Cache的基本结构</span></h5>
<ul>
<li>存储机构：保存数据，存取数据，一般采用SRAM构成。以Block（若干字）为单位；</li>
<li>地址机构：地址比较机制，地址映射机制，地址标记（Tag），一个Block具有一个Tag；</li>
<li>替换机构：记录Block的使用情况，有效位（v）记录对应数据块中的数据是否有效；替换策略。</li>
</ul>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/702.png" style="zoom:50%;">
<h5><span id="cache的有关术语">Cache的有关术语</span></h5>
<ul>
<li>数据块（block）：Cache与主存的基本划分单位，也是主存与Cache一次交换数据的最小单位，由多个字节（字）组成，取决与主存一次读写操作所能完成的数据字节数。也表明主存于Cache之间局部总线的宽度。</li>
<li>标记（tag）：Cache每一数据块有一个标记字段，用来保存该数据块对应的主存数据块的地址信息。</li>
<li>有效位（valid bit）：Cache中每一Block有一个有效位，用于指示相应数据块中是否包含有效数据。</li>
<li>行（line )：Cache中 一个block及其 tag、valid bit构成1行。</li>
<li>组（set）：若干块(Block)构成一个组，地址比较一般能在组内各块间同时进行。</li>
<li>路（way）：Cache相关联的等级，每一路具有独立的地址比较机构，各路地址比较能同时进行（一般与组结合），路数即指一组内的块数。</li>
<li>命中率（hit rate）：目标数据在Cache中的存储访问的比例。</li>
<li>缺失率（miss rate）：目标数据不在Cache中的存储访问的比例。</li>
</ul>
<h5><span id="cache结构示意">Cache结构示意</span></h5>
<ul>
<li>分S组</li>
<li>每组E行（相当于Block）</li>
<li>每数据块包含B个字节</li>
</ul>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/703.png" style="zoom:50%;">
<h5><span id="cache的读操作过程">Cache的读操作过程</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/704.png" style="zoom:50%;">
<h3><span id="二cache的映射机制">二．Cache的映射机制</span></h3>
<ul>
<li>主存按Cache块大小分成若干块（主存块）</li>
<li>Cache中存放主存块数据的对应单位也称为块（Cache块）或行（line）</li>
<li>主存块和Cache块的映射方式：
<ul>
<li><strong>全相联</strong>（Full Associate）：每个主存块都可以映射到任一Cache块</li>
<li><strong>组相联</strong>（Set Associate）：每个主存块只能映射到Cache中某一固定组中的任一Cache块</li>
<li><strong>直接映射</strong>（Direct）：每个主存块只能映射到某一固定的Cache块</li>
</ul>
</li>
</ul>
<h4><span id="1全相联映射">1.全相联映射</span></h4>
<ul>
<li>Cache包含 M 块，主存也按Cache块大小分块，共 N 块，显然 N&gt;&gt;M。</li>
<li>主存中的某一主存块可以映射到Cache中的任一Cache块。</li>
<li>主存块到Cache块的映射是 <strong>1:M映射</strong>。</li>
</ul>
<h5><span id="全相联cache组织">全相联Cache组织</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/706.png" style="zoom:50%;">
<h5><span id="全相联映射的地址">全相联映射的地址</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/705.png" style="zoom:50%;">
<h4><span id="2组相联映射">2.组相联映射</span></h4>
<ul>
<li>Cache包含M块，分 K 组，每组包含 L 块，M=K*L；</li>
<li>主存块 J 按 I = J mod K 的规则映射到 Cache 组 I 中的任意块；</li>
<li>主存可以视为逻辑上也分成 K 组，主存组M内的一个主存块只能映射到Cache组M内，但可以是组M内任意Cache块。</li>
</ul>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/707.png" style="zoom:50%;">
<h4><span id="3直接映射">3.直接映射</span></h4>
<ul>
<li>主存按Cache块大小也分成若干块，Cache包含M块</li>
<li>主存块 J 按 I = J mod M 的规则映射到 Cache块I 。</li>
<li>主存可以视为按Cache容量大小分成了若干区，一个区内的主存块分别与对应的Cache块构成映射。</li>
</ul>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/708.png" style="zoom:50%;">
<h4><span id="cache包含m块主存块-j-的映射">Cache包含M块，主存块 J 的映射</span></h4>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/709.png" style="zoom:50%;">
<h3><span id="三cache的替换策略">三．Cache的替换策略</span></h3>
<p>CPU访问Cache缺失时，CPU必须等待数据装入Cache后才能访问Cache，这期间的时间损失称为缺失损失。</p>
<p>取出块的时间：第一个字的延迟时间（存储器访问）+ 块的剩余部分的传送时间。</p>
<p>Cache的存储组织对缺失损失具有很大的影响。</p>
<h4><span id="缺失损失示例">缺失损失示例</span></h4>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/710.png" style="zoom:50%;">
<h4><span id="cache块的替换">Cache块的替换</span></h4>
<h5><span id="替换块的选择">替换块的选择</span></h5>
<ul>
<li>直接映射Cache：访问缺失时，被请求数据所在的块只能进入Cache的一个位置，占用该位置的数据块必须被替换掉；</li>
<li>组相联Cache：访问缺失时，被请求数据所在块可以进入Cache某一组的任何位置，因此应在Cache对应组内选择一个数据块进行替换；</li>
<li>全相联Cache：访问缺失时，被请求数据所在块可以进入Cache的任何位置，因此应在Cache中选择一个数据块进行替换。</li>
</ul>
<h4><span id="cache的替换策略">Cache的替换策略</span></h4>
<ul>
<li>最近最少使用法（<strong>LRU</strong>，Least-Recently Used）：记录每一个数据块的相对使用情况，最近没有被使用的块被替换。</li>
<li>先进先出法（<strong>FIFO</strong>，First-In-First-Out）：最先装入数据的块被替换；</li>
<li>最小使用频率法 （<strong>LFU</strong>，Least-Frequently Used）：记录每一个数据块的使用频率，使用次数最少的被替换。</li>
<li>随机法（<strong>RAND</strong>，Random）：随机选择一个数据块进行替换。</li>
</ul>
<h4><span id="替换算法的实现">替换算法的实现</span></h4>
<ul>
<li>LRU的实现（计数器法）
<ul>
<li>缓存的每一块都设置一个计数器；</li>
<li>被调入或者被替换的块， 其计数器清 0，而其它的计数器则加 1；</li>
<li>访问命中时，所有块的计数值与命中块的计数值进行比较，如果计数值小于命中块的计数值， 则该块的计数值加 1；如果块的计数值大于命中块的计数值，则数值不变。最后将命中块的计数器清为0。</li>
<li>需要替换时，则选择计数值最大的块被替换。</li>
</ul>
</li>
<li>FIFO的实现（计数器法）
<ul>
<li>例如Solar－16/65机Cache采用组相联方式，每组4块，每块都设定一个两位的计数器，当某块被装入或被替换时该块的计数器清为0，而同组的其它各块的计数器均加1，当需要替换时就选择计数值最大的块被替换掉。</li>
</ul>
</li>
</ul>
<h3><span id="四cache性能分析">四．Cache性能分析</span></h3>
<h4><span id="cache的容量">Cache的容量</span></h4>
<ul>
<li>不作特殊申明时，Cache的容量指Cache数据块的容量；</li>
<li>Cache实际总的存储容量实际上还包含tag和valid bit的位数。</li>
</ul>
<h4><span id="cache的性能计算">Cache的性能计算</span></h4>
<p>假设：CPU访问Cache失效时，直接访问主存直接获得数据，读取主存块并保存到Cache中的时间忽略不计。</p>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/711.png" style="zoom:50%;">
<h4><span id="命中率对存储器性能的影响">命中率对存储器性能的影响</span></h4>
<p>命中率与平均访问时间关系密切！假设：CPU访问Cache失效时，先读取主存块并保存到Cache中，再从Cache读取所需数据。</p>
<h4><span id="cache与主存的数据一致性">Cache与主存的数据一致性</span></h4>
<p><img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/712.png" style="zoom:50%;"> <img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/713.png" style="zoom:50%;"></p>
<h4><span id="cache命中率问题">Cache命中率问题</span></h4>
<p>命中率与Cache大小和Way的关系</p>
<ul>
<li>Cache越大，命中率越高</li>
<li>Way的数量与命中率成正比</li>
</ul>
<p>块的大小与命中率：比较复杂。</p>
<ul>
<li>一般而言，增加块大小将降低缺失率（因为空间局部性），但块大小达到一定程度时，缺失率会随块大小的继续增加而上升（因为块数量下降带来块替换的增加）；</li>
<li>单纯增加块大小带来缺失代价（缺失损失）的增大。</li>
</ul>
<h2><span id="第八讲外部存储与虚拟存储">第八讲：外部存储与虚拟存储</span></h2>
<h3><span id="一外部存储设备">一．外部存储设备</span></h3>
<h4><span id="1磁表面存储器">1.磁表面存储器</span></h4>
<h5><span id="磁表面存储原理">磁表面存储原理</span></h5>
<h6><span id="磁表面存储器">磁表面存储器</span></h6>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/801.png" style="zoom:50%;">
<h6><span id="记录原理">记录原理</span></h6>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/802.png" style="zoom: 50%;">
<h5><span id="硬磁盘基本结构">硬磁盘基本结构</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/803.png" style="zoom:50%;">
<h5><span id="磁盘存储结构恒定角速度cav">磁盘存储结构（恒定角速度，CAV）</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/804.png" style="zoom:50%;">
<h5><span id="扇区的地址表示">扇区的地址表示</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/805.png" style="zoom:50%;">
<h5><span id="磁盘存储结构多重区域纪录multiple-zone-recording">磁盘存储结构（多重区域纪录，multiple zone recording）</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/806.png" style="zoom: 50%;">
<h5><span id="扇区数据格式示例segate-st506-磁盘扇区格式">扇区数据格式示例（Segate ST506 磁盘扇区格式）</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/807.png" style="zoom:50%;">
<h5><span id="磁盘的性能参数">磁盘的性能参数</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/808.png" style="zoom:50%;">
<h4><span id="2光盘存储器">2.光盘存储器</span></h4>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/809.png" style="zoom:50%;">
<h5><span id="cd-rom的数据格式">CD-ROM的数据格式</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/8010.png" style="zoom:50%;">
<h5><span id="cd-rrecordables">CD-R（Recordables）</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/8011.png" style="zoom:50%;">
<h5><span id="dvddigital-video-disk">DVD（Digital Video Disk）</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/8012.png" style="zoom:40%;">
<h3><span id="二虚拟存储系统">二．虚拟存储系统</span></h3>
<h4><span id="程序员的程序空间">程序员的程序空间</span></h4>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/810.png" style="zoom:50%;">
<h4><span id="1概述">1.概述</span></h4>
<h4><span id="2页式虚拟存储系统">2.页式虚拟存储系统</span></h4>
<h5><span id="基本概念">基本概念</span></h5>
<h6><span id="基本思想">基本思想</span></h6>
<ul>
<li>内存按照固定的大小分页（存储页，实页），每个进程也按相同大小分页（程序页，虚页）；</li>
<li>内存按页顺序编号（实页号），每个独立编址的程序（进程）空间有自己的页号顺序（虚页号）；</li>
<li>操作系统将辅助存储器中进程的虚页装入到内存中的实页中；</li>
<li>进程运行无需占用连续的实页，也无需把所有的虚页都装入内存；</li>
<li>操作系统为每一个进程维护一个页表（page table），通过页表实现逻辑地址到物理地址的转换。地址转换由CPU中的MMU实现。</li>
</ul>
<p><strong>逻辑地址</strong>：程序中指令所使用的地址，也称虚拟地址或虚地址</p>
<p><strong>物理地址</strong>：内存中存放指令或数据的实际地址，也称实际地址或实地址</p>
<h6><span id="页式调度按页交换">页式调度：按页交换</span></h6>
<p>优点：页内零头小，页表对程序员来说是透明的，地址变换快，调入操作简单；</p>
<p>缺点：各页不是程序的独立模块，不便于实现程序和数据保护。</p>
<h5><span id="页表">页表</span></h5>
<p><strong>页表</strong>：记录虚页与实页的映射关系，实现虚实地址的转换，页表建立在内存中，操作系统为每道程序建立一个页表。页表用虚页号作为索引，页表项包括虚页对应的实页号和有效位。</p>
<p><strong>页表寄存器</strong>：保存页表在内存中的首地址。</p>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/811.png" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/812.png" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/813.png" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/814.png" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/815.png" style="zoom:50%;">
<h5><span id="加快地址转换采用快表tlbtranslation-lookaside-buffer转换后备缓冲器">加快地址转换，采用快表TLB（Translation Lookaside Buffer，转换后备缓冲器）</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/816.png" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/817.png" style="zoom:50%;">
<h5><span id="完整流程">完整流程</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/818.png" style="zoom:50%;">
<h5><span id="cpu通过tlb和cache访问的全过程">CPU通过TLB和Cache访问的全过程</span></h5>
<ul>
<li>TLB和Cache都采用组相联</li>
<li>以虚拟页号为依据访问TLB获取物理页号</li>
<li>以物理地址为依据访问Cache获取最终数据</li>
</ul>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/819.png" style="zoom:70%;">
<h5><span id="tlb页表cache三种缺失的可能性">TLB，页表，Cache三种缺失的可能性</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/8110.png" style="zoom:50%;">
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/8111.png" style="zoom:50%;">
<h5><span id="举例">举例</span></h5>
<img src="/2022/09/19/CO%E7%90%86%E8%AE%BA%E8%AF%BE%E7%AC%94%E8%AE%B0/8112.png" style="zoom:50%;">

                
                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2022/09/19/编译技术理论课笔记/" data-toggle="tooltip" data-placement="top" title="编译技术理论课笔记">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2022/09/19/离散数学2/" data-toggle="tooltip" data-placement="top" title="离散数学2">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                <!-- tip start -->
                

                
                <!-- tip end -->

                <!-- Music start-->
                
                <!-- Music end -->

                <!-- Sharing -->
                
                <div class="social-share"  data-wechat-qrcode-helper="" align="center"></div>
                <!--  css & js -->
                <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
                <script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
                
                <!-- Sharing -->

                <!-- gitment start -->
                
                <!-- gitment end -->

                <!-- 来必力City版安装代码 -->
                
                <!-- City版安装代码已完成 -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

    
      
        <aside id="sidebar">
          <div id="toc" class="toc-article">
          <strong class="toc-title">Contents</strong>
          
            
              <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#"><span class="toc-nav-text">理论课学习——刘旭东老师</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#"><span class="toc-nav-text">第一讲：概述</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">一.计算机组成与结构简介</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">1.1 计算机的基本组成</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">计算机的功能</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">运算器：实现数据处理的部件</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">存储器：实现数据存储的部件</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">控制器：实现控制功能的部件</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">输入输出：实现数据交换的部件</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">冯·诺依曼体系——IAS——该机结构被公认为随后发展起来的通用计算机的原型</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">普通PC（Pentium）的内部结构（多总线结构）</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">1.2 计算机系统层次结构</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">计算机的层次结构的演变</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">ISA</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">二.计算机中数的表示的基本问题</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">无符号数和有符号数</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">无符号数</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">有符号数</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">机器数表示</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">定点数、浮点数表示</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">定点数表示</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">机器数表示及其表示范围</span></a></li><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">原码</span></a></li><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">反码——较少使用</span></a></li><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">补码</span></a></li><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">模运算</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">浮点数表示</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">浮点数的一般表示法</span></a></li><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">IEEE 754标准</span></a></li><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">浮点数精度</span></a></li><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">IEEE 754关于浮点数表示的约定（单精度为例）</span></a></li><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">单精度浮点数表示范围</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">非数值数据的表示</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">三． 计算机的基本工作过程</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">指令的含义</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">程序的执行</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#"><span class="toc-nav-text">第二讲：组合逻辑</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">一． 逻辑代数基础</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">1.逻辑代数的基本概念</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">逻辑运算顺序</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">逻辑电路符号表示</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">2.逻辑代数的公理、定理与规则</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">2.1逻辑代数的基本公理</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">2.2逻辑代数的基本定理</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">2.3逻辑代数的规则</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">代入规则</span></a></li><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">反演规则</span></a></li><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">对偶规则</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">3.逻辑函数的表达式</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">逻辑函数的常用表达式</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">逻辑函数的标准表达式</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">最小项</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">编号</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">最大项</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">编号</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">4.逻辑函数化简（卡诺图）</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">设计优化</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">逻辑函数化简—代数法</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">卡诺图化简基本规则</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">二． 逻辑门电路</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">1.晶体管和MOS管</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">二极管</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">三极管（NPN常用）</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">MOS管（NMOS常用）</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">NMOS</span></a></li><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">PMOS</span></a></li><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">CMOS——NMOS和PMOS的集合</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">晶体管与MOS管开关特性</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">2.逻辑门电路实现</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">1.门电路</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">与门——二极管实现</span></a></li><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">或门——二极管实现</span></a></li><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">非门——三极管实现&#x2F;CMOS实现</span></a></li><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">或非门电路——CMOS实现</span></a></li><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">与非门电路——CMOS实现</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">2.各种集成门电路性能比较</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">三． 基本组合逻辑部件设计</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">组合逻辑设计概述</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">组合逻辑电路的设计方法</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">运算单元电路</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">1.加法运算电路</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">2.全加器</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">3.Verilog模块结构</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">4.全加器的Verilog HDL</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">方法一：根据逻辑表达式，用assign语句建模（算法级描述）</span></a></li><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">方法二：根据逻辑功能定义直接描述，采用行为描述方式的系统级抽象，程序更简洁</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">5.加法运算电路—多位加法器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">并行加法器—串行进位</span></a></li><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">并行加法器—并行进位（或先行进位）</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">6.8位加法器的Verilog HDL</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">7.加法运算电路—减法运算</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">运算原则</span></a></li><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">溢出的判断</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">8.乘法运算电路：阵列乘法器</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">9.4位比较器的Verilog HDL设计</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">10.ALU–1位ALU、32位ALU</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">编码器&#x2F;译码器</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">多路选择器</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">组合逻辑电路的竞争冒险</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#"><span class="toc-nav-text">第三讲：时序逻辑</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">概述</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">时序逻辑电路的特点</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">触发器(Flip-Flop，FF)</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">双稳态触发器(两个稳定的状态)</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">一． 锁存器和触发器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">1.SR&#x2F;D锁存器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">1.1基本RS锁存器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">真值表</span></a></li><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">特性方程：锁存器次态与原态及输入之间的逻辑函数表达式</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">Verilog HDL描述 SR锁存器</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">1.2钟控RS锁存器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">钟控锁存器</span></a></li><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">原理</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">1.3 钟控D锁存器</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">2.D触发器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">D锁存器与D触发器的区别</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">带使能端的D触发器</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">带复位功能的D触发器</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">由D触发器构成寄存器</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">3.钟控JK触发器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">原理</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">verilog code</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">钟控JK触发器比D锁存器新增的功能：</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">钟控JK触发器的空翻现象分析（初态Q&#x3D;0，J&#x3D;1，K&#x3D;1）</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">4 负边沿触发的JK触发器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">电路结构</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">工作原理</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">小结</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">触发器应用举例</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">二． 有限状态机</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">时序电路特点</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">时序电路实例分析</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">有限状态机基本介绍</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">1.Moore型有限状态机</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">设计方法和流程图</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">Moore型FSM的表示方法</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">【例】交通信号灯控制器</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">2.Mealy型有限状态机</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">设计方法和流程图</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">Mealy型FSM的表示方法</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">【例】二进制序列检测器</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">有限状态机的状态编码问题</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">起始状态的选择</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">状态编码方式的选择（假定FSM有N个状态）</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">8个状态三种编码方式的对比</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">有限状态机设计小结</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">三． 时序逻辑电路设计分析</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">时序电路的分类</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">同步时序电路的分析方法</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">寄存器的分类</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">1.数据寄存器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">数据寄存器</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">用always块语句描述的8位数据寄存器</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">数据锁存器</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">数据寄存器和数据锁存器的区别</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">数据锁存器的Verilog HDL设计</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">2.移位寄存器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">移位寄存器分类</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">4位右移移位寄存器</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">4位右移移位寄存器的工作方式</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">串入并出</span></a></li><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">串入串出</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">4位串行输入、串&#x2F;并行输出双向移位寄存器</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">3.计数器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">定义，用途，分类</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">例题1：同步十进制加法计数器</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">同步计数器的特点</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">例题2：同步十六进制数加法计数器</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">异步计数器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">异步计数器的特点</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">例题3：分析下图异步二进制（M&#x3D;16）加法计数器电路（N&#x3D;4）</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">异步计数器——其他类型计数器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">1. 分析异步二进制（模16）减法计数器</span></a></li><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">2.D触发器（上跳沿触发）构成的异步二进制（模8）加法计数器</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">异步计数器小结</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">4.时序电路的时序</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">寄存器的时序</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">同步时序电路时钟周期</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">保持时间约束</span></a></li></ol></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#"><span class="toc-nav-text">第四讲：主存储器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">一． 存储系统概述</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">1.1存储器分类</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">按介质分类：</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">按访问方式分类：</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">按功能分类：</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">存储器的层次结构</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">1.2半导体存储器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">静态随机访问存储器SRAM（Static RAM）</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">动态随机访问存储器DRAM（Dynamic RAM）</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">二． 存储单元电路</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">存储单元的符号表示</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">三． 存储器芯片结构</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">存储芯片结构（一维地址结构）</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">二维地址结构（SRAM）</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">DRAM芯片结构</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">存储芯片结构示例</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">四． 存储器扩展</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">4.1 存储器芯片的扩展（位扩展）</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">4.2 存储器芯片的扩展（字扩展）</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">4.3 存储器芯片的扩展（混合扩展）</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">CPU与主存的连接（示例）</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">存储器的符号表示</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">五． DRAM的刷新</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">5.1 DRAM存储单元电路的刷新</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">5.2 DRAM存储芯片的刷新</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">5.3 DRAM的刷新方式</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">集中刷新方式</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">分散刷新方式</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">异步刷新方式（一般使用）</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">非易失性内存</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#"><span class="toc-nav-text">第五讲：指令系统与MIPS汇编语言</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">一、指令格式</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">1.1指令系统概述</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">执行指令是CPU的主要工作</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">不同的CPU有不同的指令集</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">指令系统的基本问题</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">操作类型：应该提供哪些（多少）操作？</span></a></li><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">操作对象：如何表示？可以表示多少？</span></a></li><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">指令格式：如何将这些内容编码成一致的格式？</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">1.2指令格式</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">1.3寻址方式</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">二、MIPS指令与汇编语言</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">2.1MIPS指令系统</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">MIPS R2000&#x2F;R3000 寄存器结构</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">2.2MIPS汇编语言</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">2.3MIPS汇编编程</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">三、8086&#x2F;8088指令系统</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">四、RISC与CISC</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#"><span class="toc-nav-text">第六讲：MIPS处理器设计</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">一.处理器设计概述</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">CPU的功能与组成</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">二.MIPS模型机</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">三.MIPS单周期处理器设计</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">四.MIPS多周期处理器设计简介</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">五.MIPS流水线处理器设计</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#"><span class="toc-nav-text">第七讲：高速缓冲存储器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">一．Cache的原理</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">Cache产生的动因</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">Cache的工作原理</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">Cache要解决的问题</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">Cache的基本结构</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">Cache的有关术语</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">Cache结构示意</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">Cache的读操作过程</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">二．Cache的映射机制</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">1.全相联映射</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">全相联Cache组织</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">全相联映射的地址</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">2.组相联映射</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">3.直接映射</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">Cache包含M块，主存块 J 的映射</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">三．Cache的替换策略</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">缺失损失示例</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">Cache块的替换</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">替换块的选择</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">Cache的替换策略</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">替换算法的实现</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">四．Cache性能分析</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">Cache的容量</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">Cache的性能计算</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">命中率对存储器性能的影响</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">Cache与主存的数据一致性</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">Cache命中率问题</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#"><span class="toc-nav-text">第八讲：外部存储与虚拟存储</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">一．外部存储设备</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">1.磁表面存储器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">磁表面存储原理</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">磁表面存储器</span></a></li><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">记录原理</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">硬磁盘基本结构</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">磁盘存储结构（恒定角速度，CAV）</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">扇区的地址表示</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">磁盘存储结构（多重区域纪录，multiple zone recording）</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">扇区数据格式示例（Segate ST506 磁盘扇区格式）</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">磁盘的性能参数</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">2.光盘存储器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">CD-ROM的数据格式</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">CD-R（Recordables）</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">DVD（Digital Video Disk）</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">二．虚拟存储系统</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">程序员的程序空间</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">1.概述</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#"><span class="toc-nav-text">2.页式虚拟存储系统</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">基本概念</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">基本思想</span></a></li><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#"><span class="toc-nav-text">页式调度：按页交换</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">页表</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">加快地址转换，采用快表TLB（Translation Lookaside Buffer，转换后备缓冲器）</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">完整流程</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">CPU通过TLB和Cache访问的全过程</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">TLB，页表，Cache三种缺失的可能性</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#"><span class="toc-nav-text">举例</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>
            
          
          </div>
        </aside>
      
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#BUAA-CO-2020" title="BUAA-CO-2020">BUAA-CO-2020</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="https://roife.github.io" target="_blank">Roife</a></li>
                    
                        <li><a href="https://coekjan.cn" target="_blank">Coekjan</a></li>
                    
                        <li><a href="https://www.dusign.net/" target="_blank">Dusign</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>
<script src="https://utteranc.es/client.js"
        repo="buaadreamer/buaadreamer.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>



<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>


<style  type="text/css">
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">

                
                    <li>
                        <a target="_blank"  href="https://github.com/BUAADreamer">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                

                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; BUAADreamer 2024 
                    <br>
                    Powered by 
                    <a href="https://github.com/dusign/hexo-theme-snail" target="_blank" rel="noopener">
                        <i>hexo-theme-snail</i>
                    </a> | 
                    <iframe name="star" style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0"
                        width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=dusign&repo=hexo-theme-snail&type=star&count=true">
                    </iframe>
                </p>
            </div>
        </div>
    </div>

</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/hux-blog.min.js"></script>


<!-- Search -->

<script src="/js/search.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://BUAADreamer.top/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->


<!-- Search -->

    <script type="text/javascript">      
        var search_path = "search.xml";
        if (search_path.length == 0) {
            search_path = "search.xml";
        }
    var path = "/" + search_path;
    searchFunc(path, 'local-search-input', 'local-search-result');
    </script>


<!-- busuanzi -->
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>








	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>

    
        <!-- background effects line -->
        

        
            <script type="text/javascript" src="/js/mouse-click.js" content='[&quot;🌱&quot;,&quot;just do it&quot;,&quot;🍀&quot;]' color='[&quot;rgb(121,93,179)&quot; ,&quot;rgb(76,180,231)&quot; ,&quot;rgb(184,90,154)&quot;]'></script>
        

        <!-- background effects end -->
    

    <!--<script size="50" alpha='0.3' zIndex="-999" src="/js/ribbonStatic.js"></script>-->
    
        <script src="/js/ribbonDynamic.js"></script>
    
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>

</html>
